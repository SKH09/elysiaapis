// @bun
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};

// node_modules/.pnpm/cookie@1.0.2/node_modules/cookie/dist/index.js
var require_dist = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parse = parse2;
  exports.serialize = serialize;
  var cookieNameRegExp = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/;
  var cookieValueRegExp = /^[\u0021-\u003A\u003C-\u007E]*$/;
  var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
  var pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
  var __toString = Object.prototype.toString;
  var NullObject = /* @__PURE__ */ (() => {
    const C = function() {
    };
    C.prototype = Object.create(null);
    return C;
  })();
  function parse2(str, options) {
    const obj = new NullObject;
    const len = str.length;
    if (len < 2)
      return obj;
    const dec = options?.decode || decode2;
    let index = 0;
    do {
      const eqIdx = str.indexOf("=", index);
      if (eqIdx === -1)
        break;
      const colonIdx = str.indexOf(";", index);
      const endIdx = colonIdx === -1 ? len : colonIdx;
      if (eqIdx > endIdx) {
        index = str.lastIndexOf(";", eqIdx - 1) + 1;
        continue;
      }
      const keyStartIdx = startIndex(str, index, eqIdx);
      const keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
      const key = str.slice(keyStartIdx, keyEndIdx);
      if (obj[key] === undefined) {
        let valStartIdx = startIndex(str, eqIdx + 1, endIdx);
        let valEndIdx = endIndex(str, endIdx, valStartIdx);
        const value = dec(str.slice(valStartIdx, valEndIdx));
        obj[key] = value;
      }
      index = endIdx + 1;
    } while (index < len);
    return obj;
  }
  function startIndex(str, index, max) {
    do {
      const code = str.charCodeAt(index);
      if (code !== 32 && code !== 9)
        return index;
    } while (++index < max);
    return max;
  }
  function endIndex(str, index, min) {
    while (index > min) {
      const code = str.charCodeAt(--index);
      if (code !== 32 && code !== 9)
        return index + 1;
    }
    return min;
  }
  function serialize(name, val, options) {
    const enc = options?.encode || encodeURIComponent;
    if (!cookieNameRegExp.test(name)) {
      throw new TypeError(`argument name is invalid: ${name}`);
    }
    const value = enc(val);
    if (!cookieValueRegExp.test(value)) {
      throw new TypeError(`argument val is invalid: ${val}`);
    }
    let str = name + "=" + value;
    if (!options)
      return str;
    if (options.maxAge !== undefined) {
      if (!Number.isInteger(options.maxAge)) {
        throw new TypeError(`option maxAge is invalid: ${options.maxAge}`);
      }
      str += "; Max-Age=" + options.maxAge;
    }
    if (options.domain) {
      if (!domainValueRegExp.test(options.domain)) {
        throw new TypeError(`option domain is invalid: ${options.domain}`);
      }
      str += "; Domain=" + options.domain;
    }
    if (options.path) {
      if (!pathValueRegExp.test(options.path)) {
        throw new TypeError(`option path is invalid: ${options.path}`);
      }
      str += "; Path=" + options.path;
    }
    if (options.expires) {
      if (!isDate(options.expires) || !Number.isFinite(options.expires.valueOf())) {
        throw new TypeError(`option expires is invalid: ${options.expires}`);
      }
      str += "; Expires=" + options.expires.toUTCString();
    }
    if (options.httpOnly) {
      str += "; HttpOnly";
    }
    if (options.secure) {
      str += "; Secure";
    }
    if (options.partitioned) {
      str += "; Partitioned";
    }
    if (options.priority) {
      const priority = typeof options.priority === "string" ? options.priority.toLowerCase() : undefined;
      switch (priority) {
        case "low":
          str += "; Priority=Low";
          break;
        case "medium":
          str += "; Priority=Medium";
          break;
        case "high":
          str += "; Priority=High";
          break;
        default:
          throw new TypeError(`option priority is invalid: ${options.priority}`);
      }
    }
    if (options.sameSite) {
      const sameSite = typeof options.sameSite === "string" ? options.sameSite.toLowerCase() : options.sameSite;
      switch (sameSite) {
        case true:
        case "strict":
          str += "; SameSite=Strict";
          break;
        case "lax":
          str += "; SameSite=Lax";
          break;
        case "none":
          str += "; SameSite=None";
          break;
        default:
          throw new TypeError(`option sameSite is invalid: ${options.sameSite}`);
      }
    }
    return str;
  }
  function decode2(str) {
    if (str.indexOf("%") === -1)
      return str;
    try {
      return decodeURIComponent(str);
    } catch (e) {
      return str;
    }
  }
  function isDate(val) {
    return __toString.call(val) === "[object Date]";
  }
});

// node_modules/.pnpm/fast-decode-uri-component@1.0.1/node_modules/fast-decode-uri-component/index.js
var require_fast_decode_uri_component = __commonJS((exports, module) => {
  var UTF8_ACCEPT = 12;
  var UTF8_REJECT = 0;
  var UTF8_DATA = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    4,
    4,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    6,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    8,
    7,
    7,
    10,
    9,
    9,
    9,
    11,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    12,
    0,
    0,
    0,
    0,
    24,
    36,
    48,
    60,
    72,
    84,
    96,
    0,
    12,
    12,
    12,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    127,
    63,
    63,
    63,
    0,
    31,
    15,
    15,
    15,
    7,
    7,
    7
  ];
  function decodeURIComponent2(uri) {
    var percentPosition = uri.indexOf("%");
    if (percentPosition === -1)
      return uri;
    var length = uri.length;
    var decoded = "";
    var last = 0;
    var codepoint = 0;
    var startOfOctets = percentPosition;
    var state = UTF8_ACCEPT;
    while (percentPosition > -1 && percentPosition < length) {
      var high = hexCodeToInt(uri[percentPosition + 1], 4);
      var low = hexCodeToInt(uri[percentPosition + 2], 0);
      var byte = high | low;
      var type = UTF8_DATA[byte];
      state = UTF8_DATA[256 + state + type];
      codepoint = codepoint << 6 | byte & UTF8_DATA[364 + type];
      if (state === UTF8_ACCEPT) {
        decoded += uri.slice(last, startOfOctets);
        decoded += codepoint <= 65535 ? String.fromCharCode(codepoint) : String.fromCharCode(55232 + (codepoint >> 10), 56320 + (codepoint & 1023));
        codepoint = 0;
        last = percentPosition + 3;
        percentPosition = startOfOctets = uri.indexOf("%", last);
      } else if (state === UTF8_REJECT) {
        return null;
      } else {
        percentPosition += 3;
        if (percentPosition < length && uri.charCodeAt(percentPosition) === 37)
          continue;
        return null;
      }
    }
    return decoded + uri.slice(last);
  }
  var HEX = {
    "0": 0,
    "1": 1,
    "2": 2,
    "3": 3,
    "4": 4,
    "5": 5,
    "6": 6,
    "7": 7,
    "8": 8,
    "9": 9,
    a: 10,
    A: 10,
    b: 11,
    B: 11,
    c: 12,
    C: 12,
    d: 13,
    D: 13,
    e: 14,
    E: 14,
    f: 15,
    F: 15
  };
  function hexCodeToInt(c, shift) {
    var i = HEX[c];
    return i === undefined ? 255 : i << shift;
  }
  module.exports = decodeURIComponent2;
});

// node_modules/cookie/dist/index.js
var require_dist2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parse = parse4;
  exports.serialize = serialize2;
  var cookieNameRegExp = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/;
  var cookieValueRegExp = /^[\u0021-\u003A\u003C-\u007E]*$/;
  var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
  var pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
  var __toString = Object.prototype.toString;
  var NullObject = /* @__PURE__ */ (() => {
    const C = function() {
    };
    C.prototype = Object.create(null);
    return C;
  })();
  function parse4(str, options) {
    const obj = new NullObject;
    const len = str.length;
    if (len < 2)
      return obj;
    const dec = options?.decode || decode3;
    let index = 0;
    do {
      const eqIdx = str.indexOf("=", index);
      if (eqIdx === -1)
        break;
      const colonIdx = str.indexOf(";", index);
      const endIdx = colonIdx === -1 ? len : colonIdx;
      if (eqIdx > endIdx) {
        index = str.lastIndexOf(";", eqIdx - 1) + 1;
        continue;
      }
      const keyStartIdx = startIndex(str, index, eqIdx);
      const keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
      const key = str.slice(keyStartIdx, keyEndIdx);
      if (obj[key] === undefined) {
        let valStartIdx = startIndex(str, eqIdx + 1, endIdx);
        let valEndIdx = endIndex(str, endIdx, valStartIdx);
        const value = dec(str.slice(valStartIdx, valEndIdx));
        obj[key] = value;
      }
      index = endIdx + 1;
    } while (index < len);
    return obj;
  }
  function startIndex(str, index, max) {
    do {
      const code = str.charCodeAt(index);
      if (code !== 32 && code !== 9)
        return index;
    } while (++index < max);
    return max;
  }
  function endIndex(str, index, min) {
    while (index > min) {
      const code = str.charCodeAt(--index);
      if (code !== 32 && code !== 9)
        return index + 1;
    }
    return min;
  }
  function serialize2(name, val, options) {
    const enc = options?.encode || encodeURIComponent;
    if (!cookieNameRegExp.test(name)) {
      throw new TypeError(`argument name is invalid: ${name}`);
    }
    const value = enc(val);
    if (!cookieValueRegExp.test(value)) {
      throw new TypeError(`argument val is invalid: ${val}`);
    }
    let str = name + "=" + value;
    if (!options)
      return str;
    if (options.maxAge !== undefined) {
      if (!Number.isInteger(options.maxAge)) {
        throw new TypeError(`option maxAge is invalid: ${options.maxAge}`);
      }
      str += "; Max-Age=" + options.maxAge;
    }
    if (options.domain) {
      if (!domainValueRegExp.test(options.domain)) {
        throw new TypeError(`option domain is invalid: ${options.domain}`);
      }
      str += "; Domain=" + options.domain;
    }
    if (options.path) {
      if (!pathValueRegExp.test(options.path)) {
        throw new TypeError(`option path is invalid: ${options.path}`);
      }
      str += "; Path=" + options.path;
    }
    if (options.expires) {
      if (!isDate(options.expires) || !Number.isFinite(options.expires.valueOf())) {
        throw new TypeError(`option expires is invalid: ${options.expires}`);
      }
      str += "; Expires=" + options.expires.toUTCString();
    }
    if (options.httpOnly) {
      str += "; HttpOnly";
    }
    if (options.secure) {
      str += "; Secure";
    }
    if (options.partitioned) {
      str += "; Partitioned";
    }
    if (options.priority) {
      const priority = typeof options.priority === "string" ? options.priority.toLowerCase() : undefined;
      switch (priority) {
        case "low":
          str += "; Priority=Low";
          break;
        case "medium":
          str += "; Priority=Medium";
          break;
        case "high":
          str += "; Priority=High";
          break;
        default:
          throw new TypeError(`option priority is invalid: ${options.priority}`);
      }
    }
    if (options.sameSite) {
      const sameSite = typeof options.sameSite === "string" ? options.sameSite.toLowerCase() : options.sameSite;
      switch (sameSite) {
        case true:
        case "strict":
          str += "; SameSite=Strict";
          break;
        case "lax":
          str += "; SameSite=Lax";
          break;
        case "none":
          str += "; SameSite=None";
          break;
        default:
          throw new TypeError(`option sameSite is invalid: ${options.sameSite}`);
      }
    }
    return str;
  }
  function decode3(str) {
    if (str.indexOf("%") === -1)
      return str;
    try {
      return decodeURIComponent(str);
    } catch (e) {
      return str;
    }
  }
  function isDate(val) {
    return __toString.call(val) === "[object Date]";
  }
});

// node_modules/fast-decode-uri-component/index.js
var require_fast_decode_uri_component2 = __commonJS((exports, module) => {
  var UTF8_ACCEPT = 12;
  var UTF8_REJECT = 0;
  var UTF8_DATA = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    4,
    4,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    6,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    8,
    7,
    7,
    10,
    9,
    9,
    9,
    11,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    12,
    0,
    0,
    0,
    0,
    24,
    36,
    48,
    60,
    72,
    84,
    96,
    0,
    12,
    12,
    12,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    127,
    63,
    63,
    63,
    0,
    31,
    15,
    15,
    15,
    7,
    7,
    7
  ];
  function decodeURIComponent3(uri2) {
    var percentPosition = uri2.indexOf("%");
    if (percentPosition === -1)
      return uri2;
    var length = uri2.length;
    var decoded = "";
    var last = 0;
    var codepoint = 0;
    var startOfOctets = percentPosition;
    var state = UTF8_ACCEPT;
    while (percentPosition > -1 && percentPosition < length) {
      var high = hexCodeToInt(uri2[percentPosition + 1], 4);
      var low = hexCodeToInt(uri2[percentPosition + 2], 0);
      var byte2 = high | low;
      var type = UTF8_DATA[byte2];
      state = UTF8_DATA[256 + state + type];
      codepoint = codepoint << 6 | byte2 & UTF8_DATA[364 + type];
      if (state === UTF8_ACCEPT) {
        decoded += uri2.slice(last, startOfOctets);
        decoded += codepoint <= 65535 ? String.fromCharCode(codepoint) : String.fromCharCode(55232 + (codepoint >> 10), 56320 + (codepoint & 1023));
        codepoint = 0;
        last = percentPosition + 3;
        percentPosition = startOfOctets = uri2.indexOf("%", last);
      } else if (state === UTF8_REJECT) {
        return null;
      } else {
        percentPosition += 3;
        if (percentPosition < length && uri2.charCodeAt(percentPosition) === 37)
          continue;
        return null;
      }
    }
    return decoded + uri2.slice(last);
  }
  var HEX = {
    "0": 0,
    "1": 1,
    "2": 2,
    "3": 3,
    "4": 4,
    "5": 5,
    "6": 6,
    "7": 7,
    "8": 8,
    "9": 9,
    a: 10,
    A: 10,
    b: 11,
    B: 11,
    c: 12,
    C: 12,
    d: 13,
    D: 13,
    e: 14,
    E: 14,
    f: 15,
    F: 15
  };
  function hexCodeToInt(c, shift) {
    var i = HEX[c];
    return i === undefined ? 255 : i << shift;
  }
  module.exports = decodeURIComponent3;
});

// node_modules/.pnpm/@prisma+client@6.1.0_prisma@6.1.0/node_modules/@prisma/client/runtime/library.js
var require_library = __commonJS((exports, module) => {
  var __dirname = "/home/hussain/React Native/New-Cart-Task/elysiaApis/apisEly/node_modules/.pnpm/@prisma+client@6.1.0_prisma@6.1.0/node_modules/@prisma/client/runtime", __filename = "/home/hussain/React Native/New-Cart-Task/elysiaApis/apisEly/node_modules/.pnpm/@prisma+client@6.1.0_prisma@6.1.0/node_modules/@prisma/client/runtime/library.js";
  var ru = Object.create;
  var Fr = Object.defineProperty;
  var nu = Object.getOwnPropertyDescriptor;
  var iu = Object.getOwnPropertyNames;
  var ou = Object.getPrototypeOf;
  var su = Object.prototype.hasOwnProperty;
  var z = (e, t3) => () => (t3 || e((t3 = { exports: {} }).exports, t3), t3.exports);
  var Bt = (e, t3) => {
    for (var r2 in t3)
      Fr(e, r2, { get: t3[r2], enumerable: true });
  };
  var bo = (e, t3, r2, n2) => {
    if (t3 && typeof t3 == "object" || typeof t3 == "function")
      for (let i of iu(t3))
        !su.call(e, i) && i !== r2 && Fr(e, i, { get: () => t3[i], enumerable: !(n2 = nu(t3, i)) || n2.enumerable });
    return e;
  };
  var k = (e, t3, r2) => (r2 = e != null ? ru(ou(e)) : {}, bo(t3 || !e || !e.__esModule ? Fr(r2, "default", { value: e, enumerable: true }) : r2, e));
  var au = (e) => bo(Fr({}, "__esModule", { value: true }), e);
  var Uo = z((yf, ei) => {
    var P = ei.exports;
    ei.exports.default = P;
    var D = "\x1B[", Ht = "\x1B]", mt = "\x07", Jr = ";", Bo = process.env.TERM_PROGRAM === "Apple_Terminal";
    P.cursorTo = (e, t3) => {
      if (typeof e != "number")
        throw new TypeError("The `x` argument is required");
      return typeof t3 != "number" ? D + (e + 1) + "G" : D + (t3 + 1) + ";" + (e + 1) + "H";
    };
    P.cursorMove = (e, t3) => {
      if (typeof e != "number")
        throw new TypeError("The `x` argument is required");
      let r2 = "";
      return e < 0 ? r2 += D + -e + "D" : e > 0 && (r2 += D + e + "C"), t3 < 0 ? r2 += D + -t3 + "A" : t3 > 0 && (r2 += D + t3 + "B"), r2;
    };
    P.cursorUp = (e = 1) => D + e + "A";
    P.cursorDown = (e = 1) => D + e + "B";
    P.cursorForward = (e = 1) => D + e + "C";
    P.cursorBackward = (e = 1) => D + e + "D";
    P.cursorLeft = D + "G";
    P.cursorSavePosition = Bo ? "\x1B7" : D + "s";
    P.cursorRestorePosition = Bo ? "\x1B8" : D + "u";
    P.cursorGetPosition = D + "6n";
    P.cursorNextLine = D + "E";
    P.cursorPrevLine = D + "F";
    P.cursorHide = D + "?25l";
    P.cursorShow = D + "?25h";
    P.eraseLines = (e) => {
      let t3 = "";
      for (let r2 = 0;r2 < e; r2++)
        t3 += P.eraseLine + (r2 < e - 1 ? P.cursorUp() : "");
      return e && (t3 += P.cursorLeft), t3;
    };
    P.eraseEndLine = D + "K";
    P.eraseStartLine = D + "1K";
    P.eraseLine = D + "2K";
    P.eraseDown = D + "J";
    P.eraseUp = D + "1J";
    P.eraseScreen = D + "2J";
    P.scrollUp = D + "S";
    P.scrollDown = D + "T";
    P.clearScreen = "\x1Bc";
    P.clearTerminal = process.platform === "win32" ? `${P.eraseScreen}${D}0f` : `${P.eraseScreen}${D}3J${D}H`;
    P.beep = mt;
    P.link = (e, t3) => [Ht, "8", Jr, Jr, t3, mt, e, Ht, "8", Jr, Jr, mt].join("");
    P.image = (e, t3 = {}) => {
      let r2 = `${Ht}1337;File=inline=1`;
      return t3.width && (r2 += `;width=${t3.width}`), t3.height && (r2 += `;height=${t3.height}`), t3.preserveAspectRatio === false && (r2 += ";preserveAspectRatio=0"), r2 + ":" + e.toString("base64") + mt;
    };
    P.iTerm = { setCwd: (e = process.cwd()) => `${Ht}50;CurrentDir=${e}${mt}`, annotation: (e, t3 = {}) => {
      let r2 = `${Ht}1337;`, n2 = typeof t3.x < "u", i = typeof t3.y < "u";
      if ((n2 || i) && !(n2 && i && typeof t3.length < "u"))
        throw new Error("`x`, `y` and `length` must be defined when `x` or `y` is defined");
      return e = e.replace(/\|/g, ""), r2 += t3.isHidden ? "AddHiddenAnnotation=" : "AddAnnotation=", t3.length > 0 ? r2 += (n2 ? [e, t3.length, t3.x, t3.y] : [t3.length, e]).join("|") : r2 += e, r2 + mt;
    } };
  });
  var ti = z((Ef, Qo) => {
    Qo.exports = (e, t3 = process.argv) => {
      let r2 = e.startsWith("-") ? "" : e.length === 1 ? "-" : "--", n2 = t3.indexOf(r2 + e), i = t3.indexOf("--");
      return n2 !== -1 && (i === -1 || n2 < i);
    };
  });
  var Ho = z((bf, Jo) => {
    var Ju = import.meta.require("os"), Go = import.meta.require("tty"), me = ti(), { env: G } = process, Je;
    me("no-color") || me("no-colors") || me("color=false") || me("color=never") ? Je = 0 : (me("color") || me("colors") || me("color=true") || me("color=always")) && (Je = 1);
    "FORCE_COLOR" in G && (G.FORCE_COLOR === "true" ? Je = 1 : G.FORCE_COLOR === "false" ? Je = 0 : Je = G.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(G.FORCE_COLOR, 10), 3));
    function ri(e) {
      return e === 0 ? false : { level: e, hasBasic: true, has256: e >= 2, has16m: e >= 3 };
    }
    function ni(e, t3) {
      if (Je === 0)
        return 0;
      if (me("color=16m") || me("color=full") || me("color=truecolor"))
        return 3;
      if (me("color=256"))
        return 2;
      if (e && !t3 && Je === undefined)
        return 0;
      let r2 = Je || 0;
      if (G.TERM === "dumb")
        return r2;
      if (process.platform === "win32") {
        let n2 = Ju.release().split(".");
        return Number(n2[0]) >= 10 && Number(n2[2]) >= 10586 ? Number(n2[2]) >= 14931 ? 3 : 2 : 1;
      }
      if ("CI" in G)
        return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((n2) => (n2 in G)) || G.CI_NAME === "codeship" ? 1 : r2;
      if ("TEAMCITY_VERSION" in G)
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(G.TEAMCITY_VERSION) ? 1 : 0;
      if (G.COLORTERM === "truecolor")
        return 3;
      if ("TERM_PROGRAM" in G) {
        let n2 = parseInt((G.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (G.TERM_PROGRAM) {
          case "iTerm.app":
            return n2 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      return /-256(color)?$/i.test(G.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(G.TERM) || ("COLORTERM" in G) ? 1 : r2;
    }
    function Hu(e) {
      let t3 = ni(e, e && e.isTTY);
      return ri(t3);
    }
    Jo.exports = { supportsColor: Hu, stdout: ri(ni(true, Go.isatty(1))), stderr: ri(ni(true, Go.isatty(2))) };
  });
  var Yo = z((wf, Ko) => {
    var Wu = Ho(), ft = ti();
    function Wo(e) {
      if (/^\d{3,4}$/.test(e)) {
        let r2 = /(\d{1,2})(\d{2})/.exec(e);
        return { major: 0, minor: parseInt(r2[1], 10), patch: parseInt(r2[2], 10) };
      }
      let t3 = (e || "").split(".").map((r2) => parseInt(r2, 10));
      return { major: t3[0], minor: t3[1], patch: t3[2] };
    }
    function ii(e) {
      let { env: t3 } = process;
      if ("FORCE_HYPERLINK" in t3)
        return !(t3.FORCE_HYPERLINK.length > 0 && parseInt(t3.FORCE_HYPERLINK, 10) === 0);
      if (ft("no-hyperlink") || ft("no-hyperlinks") || ft("hyperlink=false") || ft("hyperlink=never"))
        return false;
      if (ft("hyperlink=true") || ft("hyperlink=always") || "NETLIFY" in t3)
        return true;
      if (!Wu.supportsColor(e) || e && !e.isTTY || process.platform === "win32" || "CI" in t3 || "TEAMCITY_VERSION" in t3)
        return false;
      if ("TERM_PROGRAM" in t3) {
        let r2 = Wo(t3.TERM_PROGRAM_VERSION);
        switch (t3.TERM_PROGRAM) {
          case "iTerm.app":
            return r2.major === 3 ? r2.minor >= 1 : r2.major > 3;
          case "WezTerm":
            return r2.major >= 20200620;
          case "vscode":
            return r2.major > 1 || r2.major === 1 && r2.minor >= 72;
        }
      }
      if ("VTE_VERSION" in t3) {
        if (t3.VTE_VERSION === "0.50.0")
          return false;
        let r2 = Wo(t3.VTE_VERSION);
        return r2.major > 0 || r2.minor >= 50;
      }
      return false;
    }
    Ko.exports = { supportsHyperlink: ii, stdout: ii(process.stdout), stderr: ii(process.stderr) };
  });
  var Zo = z((xf, Wt) => {
    var Ku = Uo(), oi = Yo(), zo = (e, t3, { target: r2 = "stdout", ...n2 } = {}) => oi[r2] ? Ku.link(e, t3) : n2.fallback === false ? e : typeof n2.fallback == "function" ? n2.fallback(e, t3) : `${e} (\u200B${t3}\u200B)`;
    Wt.exports = (e, t3, r2 = {}) => zo(e, t3, r2);
    Wt.exports.stderr = (e, t3, r2 = {}) => zo(e, t3, { target: "stderr", ...r2 });
    Wt.exports.isSupported = oi.stdout;
    Wt.exports.stderr.isSupported = oi.stderr;
  });
  var ai = z((kf, Yu) => {
    Yu.exports = { name: "@prisma/engines-version", version: "6.1.0-21.11f085a2012c0f4778414c8db2651556ee0ef959", main: "index.js", types: "index.d.ts", license: "Apache-2.0", author: "Tim Suchanek <suchanek@prisma.io>", prisma: { enginesVersion: "11f085a2012c0f4778414c8db2651556ee0ef959" }, repository: { type: "git", url: "https://github.com/prisma/engines-wrapper.git", directory: "packages/engines-version" }, devDependencies: { "@types/node": "18.19.67", typescript: "4.9.5" }, files: ["index.js", "index.d.ts"], scripts: { build: "tsc -d" } };
  });
  var li = z((Hr) => {
    Object.defineProperty(Hr, "__esModule", { value: true });
    Hr.enginesVersion = undefined;
    Hr.enginesVersion = ai().prisma.enginesVersion;
  });
  var rs = z((Yf, Xu) => {
    Xu.exports = { name: "dotenv", version: "16.4.7", description: "Loads environment variables from .env file", main: "lib/main.js", types: "lib/main.d.ts", exports: { ".": { types: "./lib/main.d.ts", require: "./lib/main.js", default: "./lib/main.js" }, "./config": "./config.js", "./config.js": "./config.js", "./lib/env-options": "./lib/env-options.js", "./lib/env-options.js": "./lib/env-options.js", "./lib/cli-options": "./lib/cli-options.js", "./lib/cli-options.js": "./lib/cli-options.js", "./package.json": "./package.json" }, scripts: { "dts-check": "tsc --project tests/types/tsconfig.json", lint: "standard", pretest: "npm run lint && npm run dts-check", test: "tap run --allow-empty-coverage --disable-coverage --timeout=60000", "test:coverage": "tap run --show-full-coverage --timeout=60000 --coverage-report=lcov", prerelease: "npm test", release: "standard-version" }, repository: { type: "git", url: "git://github.com/motdotla/dotenv.git" }, funding: "https://dotenvx.com", keywords: ["dotenv", "env", ".env", "environment", "variables", "config", "settings"], readmeFilename: "README.md", license: "BSD-2-Clause", devDependencies: { "@types/node": "^18.11.3", decache: "^4.6.2", sinon: "^14.0.1", standard: "^17.0.0", "standard-version": "^9.5.0", tap: "^19.2.0", typescript: "^4.8.4" }, engines: { node: ">=12" }, browser: { fs: false } };
  });
  var ss = z((zf, Le) => {
    var di = import.meta.require("fs"), mi = import.meta.require("path"), ec = import.meta.require("os"), tc = import.meta.require("crypto"), rc = rs(), fi = rc.version, nc = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
    function ic(e) {
      let t3 = {}, r2 = e.toString();
      r2 = r2.replace(/\r\n?/mg, `
`);
      let n2;
      for (;(n2 = nc.exec(r2)) != null; ) {
        let i = n2[1], o2 = n2[2] || "";
        o2 = o2.trim();
        let s = o2[0];
        o2 = o2.replace(/^(['"`])([\s\S]*)\1$/mg, "$2"), s === '"' && (o2 = o2.replace(/\\n/g, `
`), o2 = o2.replace(/\\r/g, "\r")), t3[i] = o2;
      }
      return t3;
    }
    function oc(e) {
      let t3 = os(e), r2 = U3.configDotenv({ path: t3 });
      if (!r2.parsed) {
        let s = new Error(`MISSING_DATA: Cannot parse ${t3} for an unknown reason`);
        throw s.code = "MISSING_DATA", s;
      }
      let n2 = is(e).split(","), i = n2.length, o2;
      for (let s = 0;s < i; s++)
        try {
          let a13 = n2[s].trim(), l2 = lc(r2, a13);
          o2 = U3.decrypt(l2.ciphertext, l2.key);
          break;
        } catch (a13) {
          if (s + 1 >= i)
            throw a13;
        }
      return U3.parse(o2);
    }
    function sc(e) {
      console.log(`[dotenv@${fi}][INFO] ${e}`);
    }
    function ac(e) {
      console.log(`[dotenv@${fi}][WARN] ${e}`);
    }
    function Wr(e) {
      console.log(`[dotenv@${fi}][DEBUG] ${e}`);
    }
    function is(e) {
      return e && e.DOTENV_KEY && e.DOTENV_KEY.length > 0 ? e.DOTENV_KEY : process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0 ? process.env.DOTENV_KEY : "";
    }
    function lc(e, t3) {
      let r2;
      try {
        r2 = new URL(t3);
      } catch (a13) {
        if (a13.code === "ERR_INVALID_URL") {
          let l2 = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
          throw l2.code = "INVALID_DOTENV_KEY", l2;
        }
        throw a13;
      }
      let n2 = r2.password;
      if (!n2) {
        let a13 = new Error("INVALID_DOTENV_KEY: Missing key part");
        throw a13.code = "INVALID_DOTENV_KEY", a13;
      }
      let i = r2.searchParams.get("environment");
      if (!i) {
        let a13 = new Error("INVALID_DOTENV_KEY: Missing environment part");
        throw a13.code = "INVALID_DOTENV_KEY", a13;
      }
      let o2 = `DOTENV_VAULT_${i.toUpperCase()}`, s = e.parsed[o2];
      if (!s) {
        let a13 = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${o2} in your .env.vault file.`);
        throw a13.code = "NOT_FOUND_DOTENV_ENVIRONMENT", a13;
      }
      return { ciphertext: s, key: n2 };
    }
    function os(e) {
      let t3 = null;
      if (e && e.path && e.path.length > 0)
        if (Array.isArray(e.path))
          for (let r2 of e.path)
            di.existsSync(r2) && (t3 = r2.endsWith(".vault") ? r2 : `${r2}.vault`);
        else
          t3 = e.path.endsWith(".vault") ? e.path : `${e.path}.vault`;
      else
        t3 = mi.resolve(process.cwd(), ".env.vault");
      return di.existsSync(t3) ? t3 : null;
    }
    function ns(e) {
      return e[0] === "~" ? mi.join(ec.homedir(), e.slice(1)) : e;
    }
    function uc(e) {
      sc("Loading env from encrypted .env.vault");
      let t3 = U3._parseVault(e), r2 = process.env;
      return e && e.processEnv != null && (r2 = e.processEnv), U3.populate(r2, t3, e), { parsed: t3 };
    }
    function cc(e) {
      let t3 = mi.resolve(process.cwd(), ".env"), r2 = "utf8", n2 = !!(e && e.debug);
      e && e.encoding ? r2 = e.encoding : n2 && Wr("No encoding is specified. UTF-8 is used by default");
      let i = [t3];
      if (e && e.path)
        if (!Array.isArray(e.path))
          i = [ns(e.path)];
        else {
          i = [];
          for (let l2 of e.path)
            i.push(ns(l2));
        }
      let o2, s = {};
      for (let l2 of i)
        try {
          let u = U3.parse(di.readFileSync(l2, { encoding: r2 }));
          U3.populate(s, u, e);
        } catch (u) {
          n2 && Wr(`Failed to load ${l2} ${u.message}`), o2 = u;
        }
      let a13 = process.env;
      return e && e.processEnv != null && (a13 = e.processEnv), U3.populate(a13, s, e), o2 ? { parsed: s, error: o2 } : { parsed: s };
    }
    function pc(e) {
      if (is(e).length === 0)
        return U3.configDotenv(e);
      let t3 = os(e);
      return t3 ? U3._configVault(e) : (ac(`You set DOTENV_KEY but you are missing a .env.vault file at ${t3}. Did you forget to build it?`), U3.configDotenv(e));
    }
    function dc(e, t3) {
      let r2 = Buffer.from(t3.slice(-64), "hex"), n2 = Buffer.from(e, "base64"), i = n2.subarray(0, 12), o2 = n2.subarray(-16);
      n2 = n2.subarray(12, -16);
      try {
        let s = tc.createDecipheriv("aes-256-gcm", r2, i);
        return s.setAuthTag(o2), `${s.update(n2)}${s.final()}`;
      } catch (s) {
        let a13 = s instanceof RangeError, l2 = s.message === "Invalid key length", u = s.message === "Unsupported state or unable to authenticate data";
        if (a13 || l2) {
          let c2 = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
          throw c2.code = "INVALID_DOTENV_KEY", c2;
        } else if (u) {
          let c2 = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
          throw c2.code = "DECRYPTION_FAILED", c2;
        } else
          throw s;
      }
    }
    function mc(e, t3, r2 = {}) {
      let n2 = !!(r2 && r2.debug), i = !!(r2 && r2.override);
      if (typeof t3 != "object") {
        let o2 = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
        throw o2.code = "OBJECT_REQUIRED", o2;
      }
      for (let o2 of Object.keys(t3))
        Object.prototype.hasOwnProperty.call(e, o2) ? (i === true && (e[o2] = t3[o2]), n2 && Wr(i === true ? `"${o2}" is already defined and WAS overwritten` : `"${o2}" is already defined and was NOT overwritten`)) : e[o2] = t3[o2];
    }
    var U3 = { configDotenv: cc, _configVault: uc, _parseVault: oc, config: pc, decrypt: dc, parse: ic, populate: mc };
    Le.exports.configDotenv = U3.configDotenv;
    Le.exports._configVault = U3._configVault;
    Le.exports._parseVault = U3._parseVault;
    Le.exports.config = U3.config;
    Le.exports.decrypt = U3.decrypt;
    Le.exports.parse = U3.parse;
    Le.exports.populate = U3.populate;
    Le.exports = U3;
  });
  var ds = z((ig, ps) => {
    ps.exports = (e) => {
      let t3 = e.match(/^[ \t]*(?=\S)/gm);
      return t3 ? t3.reduce((r2, n2) => Math.min(r2, n2.length), 1 / 0) : 0;
    };
  });
  var fs = z((og, ms) => {
    var yc = ds();
    ms.exports = (e) => {
      let t3 = yc(e);
      if (t3 === 0)
        return e;
      let r2 = new RegExp(`^[ \\t]{${t3}}`, "gm");
      return e.replace(r2, "");
    };
  });
  var Ei = z((pg, gs) => {
    gs.exports = (e, t3 = 1, r2) => {
      if (r2 = { indent: " ", includeEmptyLines: false, ...r2 }, typeof e != "string")
        throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof e}\``);
      if (typeof t3 != "number")
        throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof t3}\``);
      if (typeof r2.indent != "string")
        throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof r2.indent}\``);
      if (t3 === 0)
        return e;
      let n2 = r2.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
      return e.replace(n2, r2.indent.repeat(t3));
    };
  });
  var bs = z((fg, Es) => {
    Es.exports = ({ onlyFirst: e = false } = {}) => {
      let t3 = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
      return new RegExp(t3, e ? undefined : "g");
    };
  });
  var vi = z((gg, ws) => {
    var Rc = bs();
    ws.exports = (e) => typeof e == "string" ? e.replace(Rc(), "") : e;
  });
  var xs = z((Eg, zr) => {
    zr.exports = (e = {}) => {
      let t3;
      if (e.repoUrl)
        t3 = e.repoUrl;
      else if (e.user && e.repo)
        t3 = `https://github.com/${e.user}/${e.repo}`;
      else
        throw new Error("You need to specify either the `repoUrl` option or both the `user` and `repo` options");
      let r2 = new URL(`${t3}/issues/new`), n2 = ["body", "title", "labels", "template", "milestone", "assignee", "projects"];
      for (let i of n2) {
        let o2 = e[i];
        if (o2 !== undefined) {
          if (i === "labels" || i === "projects") {
            if (!Array.isArray(o2))
              throw new TypeError(`The \`${i}\` option should be an array`);
            o2 = o2.join(",");
          }
          r2.searchParams.set(i, o2);
        }
      }
      return r2.toString();
    };
    zr.exports.default = zr.exports;
  });
  var Di = z((Sh, Us) => {
    Us.exports = function() {
      function e(t3, r2, n2, i, o2) {
        return t3 < r2 || n2 < r2 ? t3 > n2 ? n2 + 1 : t3 + 1 : i === o2 ? r2 : r2 + 1;
      }
      return function(t3, r2) {
        if (t3 === r2)
          return 0;
        if (t3.length > r2.length) {
          var n2 = t3;
          t3 = r2, r2 = n2;
        }
        for (var i = t3.length, o2 = r2.length;i > 0 && t3.charCodeAt(i - 1) === r2.charCodeAt(o2 - 1); )
          i--, o2--;
        for (var s = 0;s < i && t3.charCodeAt(s) === r2.charCodeAt(s); )
          s++;
        if (i -= s, o2 -= s, i === 0 || o2 < 3)
          return o2;
        var a13 = 0, l2, u, c2, p, d, f, g, h, O, T, S, C, b = [];
        for (l2 = 0;l2 < i; l2++)
          b.push(l2 + 1), b.push(t3.charCodeAt(s + l2));
        for (var fe = b.length - 1;a13 < o2 - 3; )
          for (O = r2.charCodeAt(s + (u = a13)), T = r2.charCodeAt(s + (c2 = a13 + 1)), S = r2.charCodeAt(s + (p = a13 + 2)), C = r2.charCodeAt(s + (d = a13 + 3)), f = a13 += 4, l2 = 0;l2 < fe; l2 += 2)
            g = b[l2], h = b[l2 + 1], u = e(g, u, c2, O, h), c2 = e(u, c2, p, T, h), p = e(c2, p, d, S, h), f = e(p, d, f, C, h), b[l2] = f, d = p, p = c2, c2 = u, u = g;
        for (;a13 < o2; )
          for (O = r2.charCodeAt(s + (u = a13)), f = ++a13, l2 = 0;l2 < fe; l2 += 2)
            g = b[l2], b[l2] = f = e(g, u, f, O, b[l2 + 1]), u = g;
        return f;
      };
    }();
  });
  var Bm = {};
  Bt(Bm, { Debug: () => Gn, Decimal: () => ve, Extensions: () => jn, MetricsClient: () => Ot, PrismaClientInitializationError: () => R, PrismaClientKnownRequestError: () => X, PrismaClientRustPanicError: () => ue, PrismaClientUnknownRequestError: () => j, PrismaClientValidationError: () => ee, Public: () => Bn, Sql: () => se, defineDmmfProperty: () => fa, deserializeJsonResponse: () => bt, dmmfToRuntimeDataModel: () => ma, empty: () => Ea, getPrismaClient: () => Xl, getRuntime: () => In, join: () => ya, makeStrictEnum: () => eu, makeTypedQueryFactory: () => ga, objectEnumValues: () => yn, raw: () => Qi, serializeJsonQuery: () => Pn, skip: () => vn, sqltag: () => Gi, warnEnvConflicts: () => tu, warnOnce: () => tr });
  module.exports = au(Bm);
  var jn = {};
  Bt(jn, { defineExtension: () => wo, getExtensionContext: () => xo });
  function wo(e) {
    return typeof e == "function" ? e : (t3) => t3.$extends(e);
  }
  function xo(e) {
    return e;
  }
  var Bn = {};
  Bt(Bn, { validator: () => vo });
  function vo(...e) {
    return (t3) => t3;
  }
  var Mr = {};
  Bt(Mr, { $: () => So, bgBlack: () => yu, bgBlue: () => xu, bgCyan: () => Pu, bgGreen: () => bu, bgMagenta: () => vu, bgRed: () => Eu, bgWhite: () => Tu, bgYellow: () => wu, black: () => mu, blue: () => rt, bold: () => H, cyan: () => _e, dim: () => ke, gray: () => Ut, green: () => Ve, grey: () => hu, hidden: () => pu, inverse: () => cu, italic: () => uu, magenta: () => fu, red: () => pe, reset: () => lu, strikethrough: () => du, underline: () => Z3, white: () => gu, yellow: () => De });
  var Un;
  var Po;
  var To;
  var Ro;
  var Co = true;
  typeof process < "u" && ({ FORCE_COLOR: Un, NODE_DISABLE_COLORS: Po, NO_COLOR: To, TERM: Ro } = process.env || {}, Co = process.stdout && process.stdout.isTTY);
  var So = { enabled: !Po && To == null && Ro !== "dumb" && (Un != null && Un !== "0" || Co) };
  function M(e, t3) {
    let r2 = new RegExp(`\\x1b\\[${t3}m`, "g"), n2 = `\x1B[${e}m`, i = `\x1B[${t3}m`;
    return function(o2) {
      return !So.enabled || o2 == null ? o2 : n2 + (~("" + o2).indexOf(i) ? o2.replace(r2, i + n2) : o2) + i;
    };
  }
  var lu = M(0, 0);
  var H = M(1, 22);
  var ke = M(2, 22);
  var uu = M(3, 23);
  var Z3 = M(4, 24);
  var cu = M(7, 27);
  var pu = M(8, 28);
  var du = M(9, 29);
  var mu = M(30, 39);
  var pe = M(31, 39);
  var Ve = M(32, 39);
  var De = M(33, 39);
  var rt = M(34, 39);
  var fu = M(35, 39);
  var _e = M(36, 39);
  var gu = M(37, 39);
  var Ut = M(90, 39);
  var hu = M(90, 39);
  var yu = M(40, 49);
  var Eu = M(41, 49);
  var bu = M(42, 49);
  var wu = M(43, 49);
  var xu = M(44, 49);
  var vu = M(45, 49);
  var Pu = M(46, 49);
  var Tu = M(47, 49);
  var Ru = 100;
  var Ao = ["green", "yellow", "blue", "magenta", "cyan", "red"];
  var Qt = [];
  var Io = Date.now();
  var Cu = 0;
  var Qn = typeof process < "u" ? process.env : {};
  globalThis.DEBUG ??= Qn.DEBUG ?? "";
  globalThis.DEBUG_COLORS ??= Qn.DEBUG_COLORS ? Qn.DEBUG_COLORS === "true" : true;
  var Gt = { enable(e) {
    typeof e == "string" && (globalThis.DEBUG = e);
  }, disable() {
    let e = globalThis.DEBUG;
    return globalThis.DEBUG = "", e;
  }, enabled(e) {
    let t3 = globalThis.DEBUG.split(",").map((i) => i.replace(/[.+?^${}()|[\]\\]/g, "\\$&")), r2 = t3.some((i) => i === "" || i[0] === "-" ? false : e.match(RegExp(i.split("*").join(".*") + "$"))), n2 = t3.some((i) => i === "" || i[0] !== "-" ? false : e.match(RegExp(i.slice(1).split("*").join(".*") + "$")));
    return r2 && !n2;
  }, log: (...e) => {
    let [t3, r2, ...n2] = e;
    (console.warn ?? console.log)(`${t3} ${r2}`, ...n2);
  }, formatters: {} };
  function Su(e) {
    let t3 = { color: Ao[Cu++ % Ao.length], enabled: Gt.enabled(e), namespace: e, log: Gt.log, extend: () => {
    } }, r2 = (...n2) => {
      let { enabled: i, namespace: o2, color: s, log: a13 } = t3;
      if (n2.length !== 0 && Qt.push([o2, ...n2]), Qt.length > Ru && Qt.shift(), Gt.enabled(o2) || i) {
        let l2 = n2.map((c2) => typeof c2 == "string" ? c2 : Au(c2)), u = `+${Date.now() - Io}ms`;
        Io = Date.now(), globalThis.DEBUG_COLORS ? a13(Mr[s](H(o2)), ...l2, Mr[s](u)) : a13(o2, ...l2, u);
      }
    };
    return new Proxy(r2, { get: (n2, i) => t3[i], set: (n2, i, o2) => t3[i] = o2 });
  }
  var Gn = new Proxy(Su, { get: (e, t3) => Gt[t3], set: (e, t3, r2) => Gt[t3] = r2 });
  function Au(e, t3 = 2) {
    let r2 = new Set;
    return JSON.stringify(e, (n2, i) => {
      if (typeof i == "object" && i !== null) {
        if (r2.has(i))
          return "[Circular *]";
        r2.add(i);
      } else if (typeof i == "bigint")
        return i.toString();
      return i;
    }, t3);
  }
  function Oo(e = 7500) {
    let t3 = Qt.map(([r2, ...n2]) => `${r2} ${n2.map((i) => typeof i == "string" ? i : JSON.stringify(i)).join(" ")}`).join(`
`);
    return t3.length < e ? t3 : t3.slice(-e);
  }
  function ko() {
    Qt.length = 0;
  }
  var L = Gn;
  var Do = k(import.meta.require("fs"));
  function Jn() {
    let e = process.env.PRISMA_QUERY_ENGINE_LIBRARY;
    if (!(e && Do.default.existsSync(e)) && process.arch === "ia32")
      throw new Error('The default query engine type (Node-API, "library") is currently not supported for 32bit Node. Please set `engineType = "binary"` in the "generator" block of your "schema.prisma" file (or use the environment variables "PRISMA_CLIENT_ENGINE_TYPE=binary" and/or "PRISMA_CLI_QUERY_ENGINE_TYPE=binary".)');
  }
  var Hn = ["darwin", "darwin-arm64", "debian-openssl-1.0.x", "debian-openssl-1.1.x", "debian-openssl-3.0.x", "rhel-openssl-1.0.x", "rhel-openssl-1.1.x", "rhel-openssl-3.0.x", "linux-arm64-openssl-1.1.x", "linux-arm64-openssl-1.0.x", "linux-arm64-openssl-3.0.x", "linux-arm-openssl-1.1.x", "linux-arm-openssl-1.0.x", "linux-arm-openssl-3.0.x", "linux-musl", "linux-musl-openssl-3.0.x", "linux-musl-arm64-openssl-1.1.x", "linux-musl-arm64-openssl-3.0.x", "linux-nixos", "linux-static-x64", "linux-static-arm64", "windows", "freebsd11", "freebsd12", "freebsd13", "freebsd14", "freebsd15", "openbsd", "netbsd", "arm"];
  var $r = "libquery_engine";
  function qr(e, t3) {
    let r2 = t3 === "url";
    return e.includes("windows") ? r2 ? "query_engine.dll.node" : `query_engine-${e}.dll.node` : e.includes("darwin") ? r2 ? `${$r}.dylib.node` : `${$r}-${e}.dylib.node` : r2 ? `${$r}.so.node` : `${$r}-${e}.so.node`;
  }
  var Fo = k(import.meta.require("child_process"));
  var Zn = k(import.meta.require("fs/promises"));
  var Qr = k(import.meta.require("os"));
  var Ne = Symbol.for("@ts-pattern/matcher");
  var Iu = Symbol.for("@ts-pattern/isVariadic");
  var jr = "@ts-pattern/anonymous-select-key";
  var Wn = (e) => !!(e && typeof e == "object");
  var Vr = (e) => e && !!e[Ne];
  var we = (e, t3, r2) => {
    if (Vr(e)) {
      let n2 = e[Ne](), { matched: i, selections: o2 } = n2.match(t3);
      return i && o2 && Object.keys(o2).forEach((s) => r2(s, o2[s])), i;
    }
    if (Wn(e)) {
      if (!Wn(t3))
        return false;
      if (Array.isArray(e)) {
        if (!Array.isArray(t3))
          return false;
        let n2 = [], i = [], o2 = [];
        for (let s of e.keys()) {
          let a13 = e[s];
          Vr(a13) && a13[Iu] ? o2.push(a13) : o2.length ? i.push(a13) : n2.push(a13);
        }
        if (o2.length) {
          if (o2.length > 1)
            throw new Error("Pattern error: Using `...P.array(...)` several times in a single pattern is not allowed.");
          if (t3.length < n2.length + i.length)
            return false;
          let s = t3.slice(0, n2.length), a13 = i.length === 0 ? [] : t3.slice(-i.length), l2 = t3.slice(n2.length, i.length === 0 ? 1 / 0 : -i.length);
          return n2.every((u, c2) => we(u, s[c2], r2)) && i.every((u, c2) => we(u, a13[c2], r2)) && (o2.length === 0 || we(o2[0], l2, r2));
        }
        return e.length === t3.length && e.every((s, a13) => we(s, t3[a13], r2));
      }
      return Reflect.ownKeys(e).every((n2) => {
        let i = e[n2];
        return ((n2 in t3) || Vr(o2 = i) && o2[Ne]().matcherType === "optional") && we(i, t3[n2], r2);
        var o2;
      });
    }
    return Object.is(t3, e);
  };
  var Ge = (e) => {
    var t3, r2, n2;
    return Wn(e) ? Vr(e) ? (t3 = (r2 = (n2 = e[Ne]()).getSelectionKeys) == null ? undefined : r2.call(n2)) != null ? t3 : [] : Array.isArray(e) ? Jt(e, Ge) : Jt(Object.values(e), Ge) : [];
  };
  var Jt = (e, t3) => e.reduce((r2, n2) => r2.concat(t3(n2)), []);
  function de(e) {
    return Object.assign(e, { optional: () => Ou(e), and: (t3) => V(e, t3), or: (t3) => ku(e, t3), select: (t3) => t3 === undefined ? _o(e) : _o(t3, e) });
  }
  function Ou(e) {
    return de({ [Ne]: () => ({ match: (t3) => {
      let r2 = {}, n2 = (i, o2) => {
        r2[i] = o2;
      };
      return t3 === undefined ? (Ge(e).forEach((i) => n2(i, undefined)), { matched: true, selections: r2 }) : { matched: we(e, t3, n2), selections: r2 };
    }, getSelectionKeys: () => Ge(e), matcherType: "optional" }) });
  }
  function V(...e) {
    return de({ [Ne]: () => ({ match: (t3) => {
      let r2 = {}, n2 = (i, o2) => {
        r2[i] = o2;
      };
      return { matched: e.every((i) => we(i, t3, n2)), selections: r2 };
    }, getSelectionKeys: () => Jt(e, Ge), matcherType: "and" }) });
  }
  function ku(...e) {
    return de({ [Ne]: () => ({ match: (t3) => {
      let r2 = {}, n2 = (i, o2) => {
        r2[i] = o2;
      };
      return Jt(e, Ge).forEach((i) => n2(i, undefined)), { matched: e.some((i) => we(i, t3, n2)), selections: r2 };
    }, getSelectionKeys: () => Jt(e, Ge), matcherType: "or" }) });
  }
  function I(e) {
    return { [Ne]: () => ({ match: (t3) => ({ matched: !!e(t3) }) }) };
  }
  function _o(...e) {
    let t3 = typeof e[0] == "string" ? e[0] : undefined, r2 = e.length === 2 ? e[1] : typeof e[0] == "string" ? undefined : e[0];
    return de({ [Ne]: () => ({ match: (n2) => {
      let i = { [t3 ?? jr]: n2 };
      return { matched: r2 === undefined || we(r2, n2, (o2, s) => {
        i[o2] = s;
      }), selections: i };
    }, getSelectionKeys: () => [t3 ?? jr].concat(r2 === undefined ? [] : Ge(r2)) }) });
  }
  function Ee(e) {
    return typeof e == "number";
  }
  function je(e) {
    return typeof e == "string";
  }
  function Be(e) {
    return typeof e == "bigint";
  }
  var tf = de(I(function(e) {
    return true;
  }));
  var Ue = (e) => Object.assign(de(e), { startsWith: (t3) => {
    return Ue(V(e, (r2 = t3, I((n2) => je(n2) && n2.startsWith(r2)))));
    var r2;
  }, endsWith: (t3) => {
    return Ue(V(e, (r2 = t3, I((n2) => je(n2) && n2.endsWith(r2)))));
    var r2;
  }, minLength: (t3) => Ue(V(e, ((r2) => I((n2) => je(n2) && n2.length >= r2))(t3))), length: (t3) => Ue(V(e, ((r2) => I((n2) => je(n2) && n2.length === r2))(t3))), maxLength: (t3) => Ue(V(e, ((r2) => I((n2) => je(n2) && n2.length <= r2))(t3))), includes: (t3) => {
    return Ue(V(e, (r2 = t3, I((n2) => je(n2) && n2.includes(r2)))));
    var r2;
  }, regex: (t3) => {
    return Ue(V(e, (r2 = t3, I((n2) => je(n2) && !!n2.match(r2)))));
    var r2;
  } });
  var rf = Ue(I(je));
  var be = (e) => Object.assign(de(e), { between: (t3, r2) => be(V(e, ((n2, i) => I((o2) => Ee(o2) && n2 <= o2 && i >= o2))(t3, r2))), lt: (t3) => be(V(e, ((r2) => I((n2) => Ee(n2) && n2 < r2))(t3))), gt: (t3) => be(V(e, ((r2) => I((n2) => Ee(n2) && n2 > r2))(t3))), lte: (t3) => be(V(e, ((r2) => I((n2) => Ee(n2) && n2 <= r2))(t3))), gte: (t3) => be(V(e, ((r2) => I((n2) => Ee(n2) && n2 >= r2))(t3))), int: () => be(V(e, I((t3) => Ee(t3) && Number.isInteger(t3)))), finite: () => be(V(e, I((t3) => Ee(t3) && Number.isFinite(t3)))), positive: () => be(V(e, I((t3) => Ee(t3) && t3 > 0))), negative: () => be(V(e, I((t3) => Ee(t3) && t3 < 0))) });
  var nf = be(I(Ee));
  var Qe = (e) => Object.assign(de(e), { between: (t3, r2) => Qe(V(e, ((n2, i) => I((o2) => Be(o2) && n2 <= o2 && i >= o2))(t3, r2))), lt: (t3) => Qe(V(e, ((r2) => I((n2) => Be(n2) && n2 < r2))(t3))), gt: (t3) => Qe(V(e, ((r2) => I((n2) => Be(n2) && n2 > r2))(t3))), lte: (t3) => Qe(V(e, ((r2) => I((n2) => Be(n2) && n2 <= r2))(t3))), gte: (t3) => Qe(V(e, ((r2) => I((n2) => Be(n2) && n2 >= r2))(t3))), positive: () => Qe(V(e, I((t3) => Be(t3) && t3 > 0))), negative: () => Qe(V(e, I((t3) => Be(t3) && t3 < 0))) });
  var of = Qe(I(Be));
  var sf = de(I(function(e) {
    return typeof e == "boolean";
  }));
  var af = de(I(function(e) {
    return typeof e == "symbol";
  }));
  var lf = de(I(function(e) {
    return e == null;
  }));
  var uf = de(I(function(e) {
    return e != null;
  }));
  var Kn = class extends Error {
    constructor(t3) {
      let r2;
      try {
        r2 = JSON.stringify(t3);
      } catch {
        r2 = t3;
      }
      super(`Pattern matching error: no pattern matches value ${r2}`), this.input = undefined, this.input = t3;
    }
  };
  var Yn = { matched: false, value: undefined };
  function dt(e) {
    return new zn(e, Yn);
  }
  var zn = class e {
    constructor(t3, r2) {
      this.input = undefined, this.state = undefined, this.input = t3, this.state = r2;
    }
    with(...t3) {
      if (this.state.matched)
        return this;
      let r2 = t3[t3.length - 1], n2 = [t3[0]], i;
      t3.length === 3 && typeof t3[1] == "function" ? i = t3[1] : t3.length > 2 && n2.push(...t3.slice(1, t3.length - 1));
      let o2 = false, s = {}, a13 = (u, c2) => {
        o2 = true, s[u] = c2;
      }, l2 = !n2.some((u) => we(u, this.input, a13)) || i && !i(this.input) ? Yn : { matched: true, value: r2(o2 ? jr in s ? s[jr] : s : this.input, this.input) };
      return new e(this.input, l2);
    }
    when(t3, r2) {
      if (this.state.matched)
        return this;
      let n2 = !!t3(this.input);
      return new e(this.input, n2 ? { matched: true, value: r2(this.input, this.input) } : Yn);
    }
    otherwise(t3) {
      return this.state.matched ? this.state.value : t3(this.input);
    }
    exhaustive() {
      if (this.state.matched)
        return this.state.value;
      throw new Kn(this.input);
    }
    run() {
      return this.exhaustive();
    }
    returnType() {
      return this;
    }
  };
  var Mo = import.meta.require("util");
  var Du = { warn: De("prisma:warn") };
  var _u = { warn: () => !process.env.PRISMA_DISABLE_WARNINGS };
  function Br(e, ...t3) {
    _u.warn() && console.warn(`${Du.warn} ${e}`, ...t3);
  }
  var Nu = (0, Mo.promisify)(Fo.default.exec);
  var re = L("prisma:get-platform");
  var Lu = ["1.0.x", "1.1.x", "3.0.x"];
  async function $o() {
    let e = Qr.default.platform(), t3 = process.arch;
    if (e === "freebsd") {
      let s = await Gr("freebsd-version");
      if (s && s.trim().length > 0) {
        let l2 = /^(\d+)\.?/.exec(s);
        if (l2)
          return { platform: "freebsd", targetDistro: `freebsd${l2[1]}`, arch: t3 };
      }
    }
    if (e !== "linux")
      return { platform: e, arch: t3 };
    let r2 = await Mu(), n2 = await Gu(), i = qu({ arch: t3, archFromUname: n2, familyDistro: r2.familyDistro }), { libssl: o2 } = await Vu(i);
    return { platform: "linux", libssl: o2, arch: t3, archFromUname: n2, ...r2 };
  }
  function Fu(e) {
    let t3 = /^ID="?([^"\n]*)"?$/im, r2 = /^ID_LIKE="?([^"\n]*)"?$/im, n2 = t3.exec(e), i = n2 && n2[1] && n2[1].toLowerCase() || "", o2 = r2.exec(e), s = o2 && o2[1] && o2[1].toLowerCase() || "", a13 = dt({ id: i, idLike: s }).with({ id: "alpine" }, ({ id: l2 }) => ({ targetDistro: "musl", familyDistro: l2, originalDistro: l2 })).with({ id: "raspbian" }, ({ id: l2 }) => ({ targetDistro: "arm", familyDistro: "debian", originalDistro: l2 })).with({ id: "nixos" }, ({ id: l2 }) => ({ targetDistro: "nixos", originalDistro: l2, familyDistro: "nixos" })).with({ id: "debian" }, { id: "ubuntu" }, ({ id: l2 }) => ({ targetDistro: "debian", familyDistro: "debian", originalDistro: l2 })).with({ id: "rhel" }, { id: "centos" }, { id: "fedora" }, ({ id: l2 }) => ({ targetDistro: "rhel", familyDistro: "rhel", originalDistro: l2 })).when(({ idLike: l2 }) => l2.includes("debian") || l2.includes("ubuntu"), ({ id: l2 }) => ({ targetDistro: "debian", familyDistro: "debian", originalDistro: l2 })).when(({ idLike: l2 }) => i === "arch" || l2.includes("arch"), ({ id: l2 }) => ({ targetDistro: "debian", familyDistro: "arch", originalDistro: l2 })).when(({ idLike: l2 }) => l2.includes("centos") || l2.includes("fedora") || l2.includes("rhel") || l2.includes("suse"), ({ id: l2 }) => ({ targetDistro: "rhel", familyDistro: "rhel", originalDistro: l2 })).otherwise(({ id: l2 }) => ({ targetDistro: undefined, familyDistro: undefined, originalDistro: l2 }));
    return re(`Found distro info:
${JSON.stringify(a13, null, 2)}`), a13;
  }
  async function Mu() {
    let e = "/etc/os-release";
    try {
      let t3 = await Zn.default.readFile(e, { encoding: "utf-8" });
      return Fu(t3);
    } catch {
      return { targetDistro: undefined, familyDistro: undefined, originalDistro: undefined };
    }
  }
  function $u(e) {
    let t3 = /^OpenSSL\s(\d+\.\d+)\.\d+/.exec(e);
    if (t3) {
      let r2 = `${t3[1]}.x`;
      return qo(r2);
    }
  }
  function No(e) {
    let t3 = /libssl\.so\.(\d)(\.\d)?/.exec(e);
    if (t3) {
      let r2 = `${t3[1]}${t3[2] ?? ".0"}.x`;
      return qo(r2);
    }
  }
  function qo(e) {
    let t3 = (() => {
      if (jo(e))
        return e;
      let r2 = e.split(".");
      return r2[1] = "0", r2.join(".");
    })();
    if (Lu.includes(t3))
      return t3;
  }
  function qu(e) {
    return dt(e).with({ familyDistro: "musl" }, () => (re('Trying platform-specific paths for "alpine"'), ["/lib", "/usr/lib"])).with({ familyDistro: "debian" }, ({ archFromUname: t3 }) => (re('Trying platform-specific paths for "debian" (and "ubuntu")'), [`/usr/lib/${t3}-linux-gnu`, `/lib/${t3}-linux-gnu`])).with({ familyDistro: "rhel" }, () => (re('Trying platform-specific paths for "rhel"'), ["/lib64", "/usr/lib64"])).otherwise(({ familyDistro: t3, arch: r2, archFromUname: n2 }) => (re(`Don't know any platform-specific paths for "${t3}" on ${r2} (${n2})`), []));
  }
  async function Vu(e) {
    let t3 = 'grep -v "libssl.so.0"', r2 = await Lo(e);
    if (r2) {
      re(`Found libssl.so file using platform-specific paths: ${r2}`);
      let o2 = No(r2);
      if (re(`The parsed libssl version is: ${o2}`), o2)
        return { libssl: o2, strategy: "libssl-specific-path" };
    }
    re('Falling back to "ldconfig" and other generic paths');
    let n2 = await Gr(`ldconfig -p | sed "s/.*=>s*//" | sed "s|.*/||" | grep libssl | sort | ${t3}`);
    if (n2 || (n2 = await Lo(["/lib64", "/usr/lib64", "/lib", "/usr/lib"])), n2) {
      re(`Found libssl.so file using "ldconfig" or other generic paths: ${n2}`);
      let o2 = No(n2);
      if (re(`The parsed libssl version is: ${o2}`), o2)
        return { libssl: o2, strategy: "ldconfig" };
    }
    let i = await Gr("openssl version -v");
    if (i) {
      re(`Found openssl binary with version: ${i}`);
      let o2 = $u(i);
      if (re(`The parsed openssl version is: ${o2}`), o2)
        return { libssl: o2, strategy: "openssl-binary" };
    }
    return re("Couldn't find any version of libssl or OpenSSL in the system"), {};
  }
  async function Lo(e) {
    for (let t3 of e) {
      let r2 = await ju(t3);
      if (r2)
        return r2;
    }
  }
  async function ju(e) {
    try {
      return (await Zn.default.readdir(e)).find((r2) => r2.startsWith("libssl.so.") && !r2.startsWith("libssl.so.0"));
    } catch (t3) {
      if (t3.code === "ENOENT")
        return;
      throw t3;
    }
  }
  async function nt() {
    let { binaryTarget: e } = await Vo();
    return e;
  }
  function Bu(e) {
    return e.binaryTarget !== undefined;
  }
  async function Xn() {
    let { memoized: e, ...t3 } = await Vo();
    return t3;
  }
  var Ur = {};
  async function Vo() {
    if (Bu(Ur))
      return Promise.resolve({ ...Ur, memoized: true });
    let e = await $o(), t3 = Uu(e);
    return Ur = { ...e, binaryTarget: t3 }, { ...Ur, memoized: false };
  }
  function Uu(e) {
    let { platform: t3, arch: r2, archFromUname: n2, libssl: i, targetDistro: o2, familyDistro: s, originalDistro: a13 } = e;
    t3 === "linux" && !["x64", "arm64"].includes(r2) && Br(`Prisma only officially supports Linux on amd64 (x86_64) and arm64 (aarch64) system architectures (detected "${r2}" instead). If you are using your own custom Prisma engines, you can ignore this warning, as long as you've compiled the engines for your system architecture "${n2}".`);
    let l2 = "1.1.x";
    if (t3 === "linux" && i === undefined) {
      let c2 = dt({ familyDistro: s }).with({ familyDistro: "debian" }, () => "Please manually install OpenSSL via `apt-get update -y && apt-get install -y openssl` and try installing Prisma again. If you're running Prisma on Docker, add this command to your Dockerfile, or switch to an image that already has OpenSSL installed.").otherwise(() => "Please manually install OpenSSL and try installing Prisma again.");
      Br(`Prisma failed to detect the libssl/openssl version to use, and may not work as expected. Defaulting to "openssl-${l2}".
${c2}`);
    }
    let u = "debian";
    if (t3 === "linux" && o2 === undefined && re(`Distro is "${a13}". Falling back to Prisma engines built for "${u}".`), t3 === "darwin" && r2 === "arm64")
      return "darwin-arm64";
    if (t3 === "darwin")
      return "darwin";
    if (t3 === "win32")
      return "windows";
    if (t3 === "freebsd")
      return o2;
    if (t3 === "openbsd")
      return "openbsd";
    if (t3 === "netbsd")
      return "netbsd";
    if (t3 === "linux" && o2 === "nixos")
      return "linux-nixos";
    if (t3 === "linux" && r2 === "arm64")
      return `${o2 === "musl" ? "linux-musl-arm64" : "linux-arm64"}-openssl-${i || l2}`;
    if (t3 === "linux" && r2 === "arm")
      return `linux-arm-openssl-${i || l2}`;
    if (t3 === "linux" && o2 === "musl") {
      let c2 = "linux-musl";
      return !i || jo(i) ? c2 : `${c2}-openssl-${i}`;
    }
    return t3 === "linux" && o2 && i ? `${o2}-openssl-${i}` : (t3 !== "linux" && Br(`Prisma detected unknown OS "${t3}" and may not work as expected. Defaulting to "linux".`), i ? `${u}-openssl-${i}` : o2 ? `${o2}-openssl-${l2}` : `${u}-openssl-${l2}`);
  }
  async function Qu(e) {
    try {
      return await e();
    } catch {
      return;
    }
  }
  function Gr(e) {
    return Qu(async () => {
      let t3 = await Nu(e);
      return re(`Command "${e}" successfully returned "${t3.stdout}"`), t3.stdout;
    });
  }
  async function Gu() {
    return typeof Qr.default.machine == "function" ? Qr.default.machine() : (await Gr("uname -m"))?.trim();
  }
  function jo(e) {
    return e.startsWith("1.");
  }
  var Xo = k(Zo());
  function si(e) {
    return (0, Xo.default)(e, e, { fallback: Z3 });
  }
  var zu = k(li());
  var $3 = k(import.meta.require("path"));
  var Zu = k(li());
  var jf = L("prisma:engines");
  function es() {
    return $3.default.join(__dirname, "../");
  }
  var Bf = "libquery-engine";
  $3.default.join(__dirname, "../query-engine-darwin");
  $3.default.join(__dirname, "../query-engine-darwin-arm64");
  $3.default.join(__dirname, "../query-engine-debian-openssl-1.0.x");
  $3.default.join(__dirname, "../query-engine-debian-openssl-1.1.x");
  $3.default.join(__dirname, "../query-engine-debian-openssl-3.0.x");
  $3.default.join(__dirname, "../query-engine-linux-static-x64");
  $3.default.join(__dirname, "../query-engine-linux-static-arm64");
  $3.default.join(__dirname, "../query-engine-rhel-openssl-1.0.x");
  $3.default.join(__dirname, "../query-engine-rhel-openssl-1.1.x");
  $3.default.join(__dirname, "../query-engine-rhel-openssl-3.0.x");
  $3.default.join(__dirname, "../libquery_engine-darwin.dylib.node");
  $3.default.join(__dirname, "../libquery_engine-darwin-arm64.dylib.node");
  $3.default.join(__dirname, "../libquery_engine-debian-openssl-1.0.x.so.node");
  $3.default.join(__dirname, "../libquery_engine-debian-openssl-1.1.x.so.node");
  $3.default.join(__dirname, "../libquery_engine-debian-openssl-3.0.x.so.node");
  $3.default.join(__dirname, "../libquery_engine-linux-arm64-openssl-1.0.x.so.node");
  $3.default.join(__dirname, "../libquery_engine-linux-arm64-openssl-1.1.x.so.node");
  $3.default.join(__dirname, "../libquery_engine-linux-arm64-openssl-3.0.x.so.node");
  $3.default.join(__dirname, "../libquery_engine-linux-musl.so.node");
  $3.default.join(__dirname, "../libquery_engine-linux-musl-openssl-3.0.x.so.node");
  $3.default.join(__dirname, "../libquery_engine-rhel-openssl-1.0.x.so.node");
  $3.default.join(__dirname, "../libquery_engine-rhel-openssl-1.1.x.so.node");
  $3.default.join(__dirname, "../libquery_engine-rhel-openssl-3.0.x.so.node");
  $3.default.join(__dirname, "../query_engine-windows.dll.node");
  var ui = k(import.meta.require("fs"));
  var ts = L("chmodPlusX");
  function ci(e) {
    if (process.platform === "win32")
      return;
    let t3 = ui.default.statSync(e), r2 = t3.mode | 64 | 8 | 1;
    if (t3.mode === r2) {
      ts(`Execution permissions of ${e} are fine`);
      return;
    }
    let n2 = r2.toString(8).slice(-3);
    ts(`Have to call chmodPlusX on ${e}`), ui.default.chmodSync(e, n2);
  }
  function pi(e) {
    let t3 = e.e, r2 = (a13) => `Prisma cannot find the required \`${a13}\` system library in your system`, n2 = t3.message.includes("cannot open shared object file"), i = `Please refer to the documentation about Prisma's system requirements: ${si("https://pris.ly/d/system-requirements")}`, o2 = `Unable to require(\`${ke(e.id)}\`).`, s = dt({ message: t3.message, code: t3.code }).with({ code: "ENOENT" }, () => "File does not exist.").when(({ message: a13 }) => n2 && a13.includes("libz"), () => `${r2("libz")}. Please install it and try again.`).when(({ message: a13 }) => n2 && a13.includes("libgcc_s"), () => `${r2("libgcc_s")}. Please install it and try again.`).when(({ message: a13 }) => n2 && a13.includes("libssl"), () => {
      let a13 = e.platformInfo.libssl ? `openssl-${e.platformInfo.libssl}` : "openssl";
      return `${r2("libssl")}. Please install ${a13} and try again.`;
    }).when(({ message: a13 }) => a13.includes("GLIBC"), () => `Prisma has detected an incompatible version of the \`glibc\` C standard library installed in your system. This probably means your system may be too old to run Prisma. ${i}`).when(({ message: a13 }) => e.platformInfo.platform === "linux" && a13.includes("symbol not found"), () => `The Prisma engines are not compatible with your system ${e.platformInfo.originalDistro} on (${e.platformInfo.archFromUname}) which uses the \`${e.platformInfo.binaryTarget}\` binaryTarget by default. ${i}`).otherwise(() => `The Prisma engines do not seem to be compatible with your system. ${i}`);
    return `${o2}
${s}

Details: ${t3.message}`;
  }
  var hi = k(ss());
  var Kr = k(import.meta.require("fs"));
  var gt = k(import.meta.require("path"));
  function as(e) {
    let t3 = e.ignoreProcessEnv ? {} : process.env, r2 = (n2) => n2.match(/(.?\${(?:[a-zA-Z0-9_]+)?})/g)?.reduce(function(o2, s) {
      let a13 = /(.?)\${([a-zA-Z0-9_]+)?}/g.exec(s);
      if (!a13)
        return o2;
      let l2 = a13[1], u, c2;
      if (l2 === "\\")
        c2 = a13[0], u = c2.replace("\\$", "$");
      else {
        let p = a13[2];
        c2 = a13[0].substring(l2.length), u = Object.hasOwnProperty.call(t3, p) ? t3[p] : e.parsed[p] || "", u = r2(u);
      }
      return o2.replace(c2, u);
    }, n2) ?? n2;
    for (let n2 in e.parsed) {
      let i = Object.hasOwnProperty.call(t3, n2) ? t3[n2] : e.parsed[n2];
      e.parsed[n2] = r2(i);
    }
    for (let n2 in e.parsed)
      t3[n2] = e.parsed[n2];
    return e;
  }
  var gi = L("prisma:tryLoadEnv");
  function Kt({ rootEnvPath: e, schemaEnvPath: t3 }, r2 = { conflictCheck: "none" }) {
    let n2 = ls(e);
    r2.conflictCheck !== "none" && fc(n2, t3, r2.conflictCheck);
    let i = null;
    return us(n2?.path, t3) || (i = ls(t3)), !n2 && !i && gi("No Environment variables loaded"), i?.dotenvResult.error ? console.error(pe(H("Schema Env Error: ")) + i.dotenvResult.error) : { message: [n2?.message, i?.message].filter(Boolean).join(`
`), parsed: { ...n2?.dotenvResult?.parsed, ...i?.dotenvResult?.parsed } };
  }
  function fc(e, t3, r2) {
    let n2 = e?.dotenvResult.parsed, i = !us(e?.path, t3);
    if (n2 && t3 && i && Kr.default.existsSync(t3)) {
      let o2 = hi.default.parse(Kr.default.readFileSync(t3)), s = [];
      for (let a13 in o2)
        n2[a13] === o2[a13] && s.push(a13);
      if (s.length > 0) {
        let a13 = gt.default.relative(process.cwd(), e.path), l2 = gt.default.relative(process.cwd(), t3);
        if (r2 === "error") {
          let u = `There is a conflict between env var${s.length > 1 ? "s" : ""} in ${Z3(a13)} and ${Z3(l2)}
Conflicting env vars:
${s.map((c2) => `  ${H(c2)}`).join(`
`)}

We suggest to move the contents of ${Z3(l2)} to ${Z3(a13)} to consolidate your env vars.
`;
          throw new Error(u);
        } else if (r2 === "warn") {
          let u = `Conflict for env var${s.length > 1 ? "s" : ""} ${s.map((c2) => H(c2)).join(", ")} in ${Z3(a13)} and ${Z3(l2)}
Env vars from ${Z3(l2)} overwrite the ones from ${Z3(a13)}
      `;
          console.warn(`${De("warn(prisma)")} ${u}`);
        }
      }
    }
  }
  function ls(e) {
    if (gc(e)) {
      gi(`Environment variables loaded from ${e}`);
      let t3 = hi.default.config({ path: e, debug: process.env.DOTENV_CONFIG_DEBUG ? true : undefined });
      return { dotenvResult: as(t3), message: ke(`Environment variables loaded from ${gt.default.relative(process.cwd(), e)}`), path: e };
    } else
      gi(`Environment variables not found at ${e}`);
    return null;
  }
  function us(e, t3) {
    return e && t3 && gt.default.resolve(e) === gt.default.resolve(t3);
  }
  function gc(e) {
    return !!(e && Kr.default.existsSync(e));
  }
  var cs = "library";
  function Yt(e) {
    let t3 = hc();
    return t3 || (e?.config.engineType === "library" ? "library" : e?.config.engineType === "binary" ? "binary" : cs);
  }
  function hc() {
    let e = process.env.PRISMA_CLIENT_ENGINE_TYPE;
    return e === "library" ? "library" : e === "binary" ? "binary" : undefined;
  }
  var zt;
  ((t3) => {
    let e;
    ((b) => (b.findUnique = "findUnique", b.findUniqueOrThrow = "findUniqueOrThrow", b.findFirst = "findFirst", b.findFirstOrThrow = "findFirstOrThrow", b.findMany = "findMany", b.create = "create", b.createMany = "createMany", b.createManyAndReturn = "createManyAndReturn", b.update = "update", b.updateMany = "updateMany", b.upsert = "upsert", b.delete = "delete", b.deleteMany = "deleteMany", b.groupBy = "groupBy", b.count = "count", b.aggregate = "aggregate", b.findRaw = "findRaw", b.aggregateRaw = "aggregateRaw"))(e = t3.ModelAction ||= {});
  })(zt ||= {});
  var Zt = k(import.meta.require("path"));
  function yi(e) {
    return Zt.default.sep === Zt.default.posix.sep ? e : e.split(Zt.default.sep).join(Zt.default.posix.sep);
  }
  var hs = k(Ei());
  function wi(e) {
    return String(new bi(e));
  }
  var bi = class {
    constructor(t3) {
      this.config = t3;
    }
    toString() {
      let { config: t3 } = this, r2 = t3.provider.fromEnvVar ? `env("${t3.provider.fromEnvVar}")` : t3.provider.value, n2 = JSON.parse(JSON.stringify({ provider: r2, binaryTargets: Ec(t3.binaryTargets) }));
      return `generator ${t3.name} {
${(0, hs.default)(bc(n2), 2)}
}`;
    }
  };
  function Ec(e) {
    let t3;
    if (e.length > 0) {
      let r2 = e.find((n2) => n2.fromEnvVar !== null);
      r2 ? t3 = `env("${r2.fromEnvVar}")` : t3 = e.map((n2) => n2.native ? "native" : n2.value);
    } else
      t3 = undefined;
    return t3;
  }
  function bc(e) {
    let t3 = Object.keys(e).reduce((r2, n2) => Math.max(r2, n2.length), 0);
    return Object.entries(e).map(([r2, n2]) => `${r2.padEnd(t3)} = ${wc(n2)}`).join(`
`);
  }
  function wc(e) {
    return JSON.parse(JSON.stringify(e, (t3, r2) => Array.isArray(r2) ? `[${r2.map((n2) => JSON.stringify(n2)).join(", ")}]` : JSON.stringify(r2)));
  }
  var er = {};
  Bt(er, { error: () => Pc, info: () => vc, log: () => xc, query: () => Tc, should: () => ys, tags: () => Xt, warn: () => xi });
  var Xt = { error: pe("prisma:error"), warn: De("prisma:warn"), info: _e("prisma:info"), query: rt("prisma:query") };
  var ys = { warn: () => !process.env.PRISMA_DISABLE_WARNINGS };
  function xc(...e) {
    console.log(...e);
  }
  function xi(e, ...t3) {
    ys.warn() && console.warn(`${Xt.warn} ${e}`, ...t3);
  }
  function vc(e, ...t3) {
    console.info(`${Xt.info} ${e}`, ...t3);
  }
  function Pc(e, ...t3) {
    console.error(`${Xt.error} ${e}`, ...t3);
  }
  function Tc(e, ...t3) {
    console.log(`${Xt.query} ${e}`, ...t3);
  }
  function Yr(e, t3) {
    if (!e)
      throw new Error(`${t3}. This should never happen. If you see this error, please, open an issue at https://pris.ly/prisma-prisma-bug-report`);
  }
  function Fe(e, t3) {
    throw new Error(t3);
  }
  function Pi(e, t3) {
    return Object.prototype.hasOwnProperty.call(e, t3);
  }
  var Ti = (e, t3) => e.reduce((r2, n2) => (r2[t3(n2)] = n2, r2), {});
  function ht(e, t3) {
    let r2 = {};
    for (let n2 of Object.keys(e))
      r2[n2] = t3(e[n2], n2);
    return r2;
  }
  function Ri(e, t3) {
    if (e.length === 0)
      return;
    let r2 = e[0];
    for (let n2 = 1;n2 < e.length; n2++)
      t3(r2, e[n2]) < 0 && (r2 = e[n2]);
    return r2;
  }
  function x(e, t3) {
    Object.defineProperty(e, "name", { value: t3, configurable: true });
  }
  var vs = new Set;
  var tr = (e, t3, ...r2) => {
    vs.has(e) || (vs.add(e), xi(t3, ...r2));
  };
  var R = class e extends Error {
    constructor(t3, r2, n2) {
      super(t3), this.name = "PrismaClientInitializationError", this.clientVersion = r2, this.errorCode = n2, Error.captureStackTrace(e);
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientInitializationError";
    }
  };
  x(R, "PrismaClientInitializationError");
  var X = class extends Error {
    constructor(t3, { code: r2, clientVersion: n2, meta: i, batchRequestIdx: o2 }) {
      super(t3), this.name = "PrismaClientKnownRequestError", this.code = r2, this.clientVersion = n2, this.meta = i, Object.defineProperty(this, "batchRequestIdx", { value: o2, enumerable: false, writable: true });
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientKnownRequestError";
    }
  };
  x(X, "PrismaClientKnownRequestError");
  var ue = class extends Error {
    constructor(t3, r2) {
      super(t3), this.name = "PrismaClientRustPanicError", this.clientVersion = r2;
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientRustPanicError";
    }
  };
  x(ue, "PrismaClientRustPanicError");
  var j = class extends Error {
    constructor(t3, { clientVersion: r2, batchRequestIdx: n2 }) {
      super(t3), this.name = "PrismaClientUnknownRequestError", this.clientVersion = r2, Object.defineProperty(this, "batchRequestIdx", { value: n2, writable: true, enumerable: false });
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientUnknownRequestError";
    }
  };
  x(j, "PrismaClientUnknownRequestError");
  var ee = class extends Error {
    constructor(r2, { clientVersion: n2 }) {
      super(r2);
      this.name = "PrismaClientValidationError";
      this.clientVersion = n2;
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientValidationError";
    }
  };
  x(ee, "PrismaClientValidationError");
  var yt = 9000000000000000;
  var Ye = 1e9;
  var Ci = "0123456789abcdef";
  var en = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
  var tn = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
  var Si = { precision: 20, rounding: 4, modulo: 1, toExpNeg: -7, toExpPos: 21, minE: -yt, maxE: yt, crypto: false };
  var Cs;
  var Me;
  var w = true;
  var nn = "[DecimalError] ";
  var Ke = nn + "Invalid argument: ";
  var Ss = nn + "Precision limit exceeded";
  var As = nn + "crypto unavailable";
  var Is = "[object Decimal]";
  var te = Math.floor;
  var Q = Math.pow;
  var Cc = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
  var Sc = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
  var Ac = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
  var Os = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
  var he = 1e7;
  var E = 7;
  var Ic = 9007199254740991;
  var Oc = en.length - 1;
  var Ai = tn.length - 1;
  var m2 = { toStringTag: Is };
  m2.absoluteValue = m2.abs = function() {
    var e = new this.constructor(this);
    return e.s < 0 && (e.s = 1), y(e);
  };
  m2.ceil = function() {
    return y(new this.constructor(this), this.e + 1, 2);
  };
  m2.clampedTo = m2.clamp = function(e, t3) {
    var r2, n2 = this, i = n2.constructor;
    if (e = new i(e), t3 = new i(t3), !e.s || !t3.s)
      return new i(NaN);
    if (e.gt(t3))
      throw Error(Ke + t3);
    return r2 = n2.cmp(e), r2 < 0 ? e : n2.cmp(t3) > 0 ? t3 : new i(n2);
  };
  m2.comparedTo = m2.cmp = function(e) {
    var t3, r2, n2, i, o2 = this, s = o2.d, a13 = (e = new o2.constructor(e)).d, l2 = o2.s, u = e.s;
    if (!s || !a13)
      return !l2 || !u ? NaN : l2 !== u ? l2 : s === a13 ? 0 : !s ^ l2 < 0 ? 1 : -1;
    if (!s[0] || !a13[0])
      return s[0] ? l2 : a13[0] ? -u : 0;
    if (l2 !== u)
      return l2;
    if (o2.e !== e.e)
      return o2.e > e.e ^ l2 < 0 ? 1 : -1;
    for (n2 = s.length, i = a13.length, t3 = 0, r2 = n2 < i ? n2 : i;t3 < r2; ++t3)
      if (s[t3] !== a13[t3])
        return s[t3] > a13[t3] ^ l2 < 0 ? 1 : -1;
    return n2 === i ? 0 : n2 > i ^ l2 < 0 ? 1 : -1;
  };
  m2.cosine = m2.cos = function() {
    var e, t3, r2 = this, n2 = r2.constructor;
    return r2.d ? r2.d[0] ? (e = n2.precision, t3 = n2.rounding, n2.precision = e + Math.max(r2.e, r2.sd()) + E, n2.rounding = 1, r2 = kc(n2, Ls(n2, r2)), n2.precision = e, n2.rounding = t3, y(Me == 2 || Me == 3 ? r2.neg() : r2, e, t3, true)) : new n2(1) : new n2(NaN);
  };
  m2.cubeRoot = m2.cbrt = function() {
    var e, t3, r2, n2, i, o2, s, a13, l2, u, c2 = this, p = c2.constructor;
    if (!c2.isFinite() || c2.isZero())
      return new p(c2);
    for (w = false, o2 = c2.s * Q(c2.s * c2, 1 / 3), !o2 || Math.abs(o2) == 1 / 0 ? (r2 = W(c2.d), e = c2.e, (o2 = (e - r2.length + 1) % 3) && (r2 += o2 == 1 || o2 == -2 ? "0" : "00"), o2 = Q(r2, 1 / 3), e = te((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2)), o2 == 1 / 0 ? r2 = "5e" + e : (r2 = o2.toExponential(), r2 = r2.slice(0, r2.indexOf("e") + 1) + e), n2 = new p(r2), n2.s = c2.s) : n2 = new p(o2.toString()), s = (e = p.precision) + 3;; )
      if (a13 = n2, l2 = a13.times(a13).times(a13), u = l2.plus(c2), n2 = F(u.plus(c2).times(a13), u.plus(l2), s + 2, 1), W(a13.d).slice(0, s) === (r2 = W(n2.d)).slice(0, s))
        if (r2 = r2.slice(s - 3, s + 1), r2 == "9999" || !i && r2 == "4999") {
          if (!i && (y(a13, e + 1, 0), a13.times(a13).times(a13).eq(c2))) {
            n2 = a13;
            break;
          }
          s += 4, i = 1;
        } else {
          (!+r2 || !+r2.slice(1) && r2.charAt(0) == "5") && (y(n2, e + 1, 1), t3 = !n2.times(n2).times(n2).eq(c2));
          break;
        }
    return w = true, y(n2, e, p.rounding, t3);
  };
  m2.decimalPlaces = m2.dp = function() {
    var e, t3 = this.d, r2 = NaN;
    if (t3) {
      if (e = t3.length - 1, r2 = (e - te(this.e / E)) * E, e = t3[e], e)
        for (;e % 10 == 0; e /= 10)
          r2--;
      r2 < 0 && (r2 = 0);
    }
    return r2;
  };
  m2.dividedBy = m2.div = function(e) {
    return F(this, new this.constructor(e));
  };
  m2.dividedToIntegerBy = m2.divToInt = function(e) {
    var t3 = this, r2 = t3.constructor;
    return y(F(t3, new r2(e), 0, 1, 1), r2.precision, r2.rounding);
  };
  m2.equals = m2.eq = function(e) {
    return this.cmp(e) === 0;
  };
  m2.floor = function() {
    return y(new this.constructor(this), this.e + 1, 3);
  };
  m2.greaterThan = m2.gt = function(e) {
    return this.cmp(e) > 0;
  };
  m2.greaterThanOrEqualTo = m2.gte = function(e) {
    var t3 = this.cmp(e);
    return t3 == 1 || t3 === 0;
  };
  m2.hyperbolicCosine = m2.cosh = function() {
    var e, t3, r2, n2, i, o2 = this, s = o2.constructor, a13 = new s(1);
    if (!o2.isFinite())
      return new s(o2.s ? 1 / 0 : NaN);
    if (o2.isZero())
      return a13;
    r2 = s.precision, n2 = s.rounding, s.precision = r2 + Math.max(o2.e, o2.sd()) + 4, s.rounding = 1, i = o2.d.length, i < 32 ? (e = Math.ceil(i / 3), t3 = (1 / sn(4, e)).toString()) : (e = 16, t3 = "2.3283064365386962890625e-10"), o2 = Et(s, 1, o2.times(t3), new s(1), true);
    for (var l2, u = e, c2 = new s(8);u--; )
      l2 = o2.times(o2), o2 = a13.minus(l2.times(c2.minus(l2.times(c2))));
    return y(o2, s.precision = r2, s.rounding = n2, true);
  };
  m2.hyperbolicSine = m2.sinh = function() {
    var e, t3, r2, n2, i = this, o2 = i.constructor;
    if (!i.isFinite() || i.isZero())
      return new o2(i);
    if (t3 = o2.precision, r2 = o2.rounding, o2.precision = t3 + Math.max(i.e, i.sd()) + 4, o2.rounding = 1, n2 = i.d.length, n2 < 3)
      i = Et(o2, 2, i, i, true);
    else {
      e = 1.4 * Math.sqrt(n2), e = e > 16 ? 16 : e | 0, i = i.times(1 / sn(5, e)), i = Et(o2, 2, i, i, true);
      for (var s, a13 = new o2(5), l2 = new o2(16), u = new o2(20);e--; )
        s = i.times(i), i = i.times(a13.plus(s.times(l2.times(s).plus(u))));
    }
    return o2.precision = t3, o2.rounding = r2, y(i, t3, r2, true);
  };
  m2.hyperbolicTangent = m2.tanh = function() {
    var e, t3, r2 = this, n2 = r2.constructor;
    return r2.isFinite() ? r2.isZero() ? new n2(r2) : (e = n2.precision, t3 = n2.rounding, n2.precision = e + 7, n2.rounding = 1, F(r2.sinh(), r2.cosh(), n2.precision = e, n2.rounding = t3)) : new n2(r2.s);
  };
  m2.inverseCosine = m2.acos = function() {
    var e, t3 = this, r2 = t3.constructor, n2 = t3.abs().cmp(1), i = r2.precision, o2 = r2.rounding;
    return n2 !== -1 ? n2 === 0 ? t3.isNeg() ? ge(r2, i, o2) : new r2(0) : new r2(NaN) : t3.isZero() ? ge(r2, i + 4, o2).times(0.5) : (r2.precision = i + 6, r2.rounding = 1, t3 = t3.asin(), e = ge(r2, i + 4, o2).times(0.5), r2.precision = i, r2.rounding = o2, e.minus(t3));
  };
  m2.inverseHyperbolicCosine = m2.acosh = function() {
    var e, t3, r2 = this, n2 = r2.constructor;
    return r2.lte(1) ? new n2(r2.eq(1) ? 0 : NaN) : r2.isFinite() ? (e = n2.precision, t3 = n2.rounding, n2.precision = e + Math.max(Math.abs(r2.e), r2.sd()) + 4, n2.rounding = 1, w = false, r2 = r2.times(r2).minus(1).sqrt().plus(r2), w = true, n2.precision = e, n2.rounding = t3, r2.ln()) : new n2(r2);
  };
  m2.inverseHyperbolicSine = m2.asinh = function() {
    var e, t3, r2 = this, n2 = r2.constructor;
    return !r2.isFinite() || r2.isZero() ? new n2(r2) : (e = n2.precision, t3 = n2.rounding, n2.precision = e + 2 * Math.max(Math.abs(r2.e), r2.sd()) + 6, n2.rounding = 1, w = false, r2 = r2.times(r2).plus(1).sqrt().plus(r2), w = true, n2.precision = e, n2.rounding = t3, r2.ln());
  };
  m2.inverseHyperbolicTangent = m2.atanh = function() {
    var e, t3, r2, n2, i = this, o2 = i.constructor;
    return i.isFinite() ? i.e >= 0 ? new o2(i.abs().eq(1) ? i.s / 0 : i.isZero() ? i : NaN) : (e = o2.precision, t3 = o2.rounding, n2 = i.sd(), Math.max(n2, e) < 2 * -i.e - 1 ? y(new o2(i), e, t3, true) : (o2.precision = r2 = n2 - i.e, i = F(i.plus(1), new o2(1).minus(i), r2 + e, 1), o2.precision = e + 4, o2.rounding = 1, i = i.ln(), o2.precision = e, o2.rounding = t3, i.times(0.5))) : new o2(NaN);
  };
  m2.inverseSine = m2.asin = function() {
    var e, t3, r2, n2, i = this, o2 = i.constructor;
    return i.isZero() ? new o2(i) : (t3 = i.abs().cmp(1), r2 = o2.precision, n2 = o2.rounding, t3 !== -1 ? t3 === 0 ? (e = ge(o2, r2 + 4, n2).times(0.5), e.s = i.s, e) : new o2(NaN) : (o2.precision = r2 + 6, o2.rounding = 1, i = i.div(new o2(1).minus(i.times(i)).sqrt().plus(1)).atan(), o2.precision = r2, o2.rounding = n2, i.times(2)));
  };
  m2.inverseTangent = m2.atan = function() {
    var e, t3, r2, n2, i, o2, s, a13, l2, u = this, c2 = u.constructor, p = c2.precision, d = c2.rounding;
    if (u.isFinite()) {
      if (u.isZero())
        return new c2(u);
      if (u.abs().eq(1) && p + 4 <= Ai)
        return s = ge(c2, p + 4, d).times(0.25), s.s = u.s, s;
    } else {
      if (!u.s)
        return new c2(NaN);
      if (p + 4 <= Ai)
        return s = ge(c2, p + 4, d).times(0.5), s.s = u.s, s;
    }
    for (c2.precision = a13 = p + 10, c2.rounding = 1, r2 = Math.min(28, a13 / E + 2 | 0), e = r2;e; --e)
      u = u.div(u.times(u).plus(1).sqrt().plus(1));
    for (w = false, t3 = Math.ceil(a13 / E), n2 = 1, l2 = u.times(u), s = new c2(u), i = u;e !== -1; )
      if (i = i.times(l2), o2 = s.minus(i.div(n2 += 2)), i = i.times(l2), s = o2.plus(i.div(n2 += 2)), s.d[t3] !== undefined)
        for (e = t3;s.d[e] === o2.d[e] && e--; )
          ;
    return r2 && (s = s.times(2 << r2 - 1)), w = true, y(s, c2.precision = p, c2.rounding = d, true);
  };
  m2.isFinite = function() {
    return !!this.d;
  };
  m2.isInteger = m2.isInt = function() {
    return !!this.d && te(this.e / E) > this.d.length - 2;
  };
  m2.isNaN = function() {
    return !this.s;
  };
  m2.isNegative = m2.isNeg = function() {
    return this.s < 0;
  };
  m2.isPositive = m2.isPos = function() {
    return this.s > 0;
  };
  m2.isZero = function() {
    return !!this.d && this.d[0] === 0;
  };
  m2.lessThan = m2.lt = function(e) {
    return this.cmp(e) < 0;
  };
  m2.lessThanOrEqualTo = m2.lte = function(e) {
    return this.cmp(e) < 1;
  };
  m2.logarithm = m2.log = function(e) {
    var t3, r2, n2, i, o2, s, a13, l2, u = this, c2 = u.constructor, p = c2.precision, d = c2.rounding, f = 5;
    if (e == null)
      e = new c2(10), t3 = true;
    else {
      if (e = new c2(e), r2 = e.d, e.s < 0 || !r2 || !r2[0] || e.eq(1))
        return new c2(NaN);
      t3 = e.eq(10);
    }
    if (r2 = u.d, u.s < 0 || !r2 || !r2[0] || u.eq(1))
      return new c2(r2 && !r2[0] ? -1 / 0 : u.s != 1 ? NaN : r2 ? 0 : 1 / 0);
    if (t3)
      if (r2.length > 1)
        o2 = true;
      else {
        for (i = r2[0];i % 10 === 0; )
          i /= 10;
        o2 = i !== 1;
      }
    if (w = false, a13 = p + f, s = We(u, a13), n2 = t3 ? rn(c2, a13 + 10) : We(e, a13), l2 = F(s, n2, a13, 1), rr(l2.d, i = p, d))
      do
        if (a13 += 10, s = We(u, a13), n2 = t3 ? rn(c2, a13 + 10) : We(e, a13), l2 = F(s, n2, a13, 1), !o2) {
          +W(l2.d).slice(i + 1, i + 15) + 1 == 100000000000000 && (l2 = y(l2, p + 1, 0));
          break;
        }
      while (rr(l2.d, i += 10, d));
    return w = true, y(l2, p, d);
  };
  m2.minus = m2.sub = function(e) {
    var t3, r2, n2, i, o2, s, a13, l2, u, c2, p, d, f = this, g = f.constructor;
    if (e = new g(e), !f.d || !e.d)
      return !f.s || !e.s ? e = new g(NaN) : f.d ? e.s = -e.s : e = new g(e.d || f.s !== e.s ? f : NaN), e;
    if (f.s != e.s)
      return e.s = -e.s, f.plus(e);
    if (u = f.d, d = e.d, a13 = g.precision, l2 = g.rounding, !u[0] || !d[0]) {
      if (d[0])
        e.s = -e.s;
      else if (u[0])
        e = new g(f);
      else
        return new g(l2 === 3 ? -0 : 0);
      return w ? y(e, a13, l2) : e;
    }
    if (r2 = te(e.e / E), c2 = te(f.e / E), u = u.slice(), o2 = c2 - r2, o2) {
      for (p = o2 < 0, p ? (t3 = u, o2 = -o2, s = d.length) : (t3 = d, r2 = c2, s = u.length), n2 = Math.max(Math.ceil(a13 / E), s) + 2, o2 > n2 && (o2 = n2, t3.length = 1), t3.reverse(), n2 = o2;n2--; )
        t3.push(0);
      t3.reverse();
    } else {
      for (n2 = u.length, s = d.length, p = n2 < s, p && (s = n2), n2 = 0;n2 < s; n2++)
        if (u[n2] != d[n2]) {
          p = u[n2] < d[n2];
          break;
        }
      o2 = 0;
    }
    for (p && (t3 = u, u = d, d = t3, e.s = -e.s), s = u.length, n2 = d.length - s;n2 > 0; --n2)
      u[s++] = 0;
    for (n2 = d.length;n2 > o2; ) {
      if (u[--n2] < d[n2]) {
        for (i = n2;i && u[--i] === 0; )
          u[i] = he - 1;
        --u[i], u[n2] += he;
      }
      u[n2] -= d[n2];
    }
    for (;u[--s] === 0; )
      u.pop();
    for (;u[0] === 0; u.shift())
      --r2;
    return u[0] ? (e.d = u, e.e = on(u, r2), w ? y(e, a13, l2) : e) : new g(l2 === 3 ? -0 : 0);
  };
  m2.modulo = m2.mod = function(e) {
    var t3, r2 = this, n2 = r2.constructor;
    return e = new n2(e), !r2.d || !e.s || e.d && !e.d[0] ? new n2(NaN) : !e.d || r2.d && !r2.d[0] ? y(new n2(r2), n2.precision, n2.rounding) : (w = false, n2.modulo == 9 ? (t3 = F(r2, e.abs(), 0, 3, 1), t3.s *= e.s) : t3 = F(r2, e, 0, n2.modulo, 1), t3 = t3.times(e), w = true, r2.minus(t3));
  };
  m2.naturalExponential = m2.exp = function() {
    return Ii(this);
  };
  m2.naturalLogarithm = m2.ln = function() {
    return We(this);
  };
  m2.negated = m2.neg = function() {
    var e = new this.constructor(this);
    return e.s = -e.s, y(e);
  };
  m2.plus = m2.add = function(e) {
    var t3, r2, n2, i, o2, s, a13, l2, u, c2, p = this, d = p.constructor;
    if (e = new d(e), !p.d || !e.d)
      return !p.s || !e.s ? e = new d(NaN) : p.d || (e = new d(e.d || p.s === e.s ? p : NaN)), e;
    if (p.s != e.s)
      return e.s = -e.s, p.minus(e);
    if (u = p.d, c2 = e.d, a13 = d.precision, l2 = d.rounding, !u[0] || !c2[0])
      return c2[0] || (e = new d(p)), w ? y(e, a13, l2) : e;
    if (o2 = te(p.e / E), n2 = te(e.e / E), u = u.slice(), i = o2 - n2, i) {
      for (i < 0 ? (r2 = u, i = -i, s = c2.length) : (r2 = c2, n2 = o2, s = u.length), o2 = Math.ceil(a13 / E), s = o2 > s ? o2 + 1 : s + 1, i > s && (i = s, r2.length = 1), r2.reverse();i--; )
        r2.push(0);
      r2.reverse();
    }
    for (s = u.length, i = c2.length, s - i < 0 && (i = s, r2 = c2, c2 = u, u = r2), t3 = 0;i; )
      t3 = (u[--i] = u[i] + c2[i] + t3) / he | 0, u[i] %= he;
    for (t3 && (u.unshift(t3), ++n2), s = u.length;u[--s] == 0; )
      u.pop();
    return e.d = u, e.e = on(u, n2), w ? y(e, a13, l2) : e;
  };
  m2.precision = m2.sd = function(e) {
    var t3, r2 = this;
    if (e !== undefined && e !== !!e && e !== 1 && e !== 0)
      throw Error(Ke + e);
    return r2.d ? (t3 = ks(r2.d), e && r2.e + 1 > t3 && (t3 = r2.e + 1)) : t3 = NaN, t3;
  };
  m2.round = function() {
    var e = this, t3 = e.constructor;
    return y(new t3(e), e.e + 1, t3.rounding);
  };
  m2.sine = m2.sin = function() {
    var e, t3, r2 = this, n2 = r2.constructor;
    return r2.isFinite() ? r2.isZero() ? new n2(r2) : (e = n2.precision, t3 = n2.rounding, n2.precision = e + Math.max(r2.e, r2.sd()) + E, n2.rounding = 1, r2 = _c(n2, Ls(n2, r2)), n2.precision = e, n2.rounding = t3, y(Me > 2 ? r2.neg() : r2, e, t3, true)) : new n2(NaN);
  };
  m2.squareRoot = m2.sqrt = function() {
    var e, t3, r2, n2, i, o2, s = this, a13 = s.d, l2 = s.e, u = s.s, c2 = s.constructor;
    if (u !== 1 || !a13 || !a13[0])
      return new c2(!u || u < 0 && (!a13 || a13[0]) ? NaN : a13 ? s : 1 / 0);
    for (w = false, u = Math.sqrt(+s), u == 0 || u == 1 / 0 ? (t3 = W(a13), (t3.length + l2) % 2 == 0 && (t3 += "0"), u = Math.sqrt(t3), l2 = te((l2 + 1) / 2) - (l2 < 0 || l2 % 2), u == 1 / 0 ? t3 = "5e" + l2 : (t3 = u.toExponential(), t3 = t3.slice(0, t3.indexOf("e") + 1) + l2), n2 = new c2(t3)) : n2 = new c2(u.toString()), r2 = (l2 = c2.precision) + 3;; )
      if (o2 = n2, n2 = o2.plus(F(s, o2, r2 + 2, 1)).times(0.5), W(o2.d).slice(0, r2) === (t3 = W(n2.d)).slice(0, r2))
        if (t3 = t3.slice(r2 - 3, r2 + 1), t3 == "9999" || !i && t3 == "4999") {
          if (!i && (y(o2, l2 + 1, 0), o2.times(o2).eq(s))) {
            n2 = o2;
            break;
          }
          r2 += 4, i = 1;
        } else {
          (!+t3 || !+t3.slice(1) && t3.charAt(0) == "5") && (y(n2, l2 + 1, 1), e = !n2.times(n2).eq(s));
          break;
        }
    return w = true, y(n2, l2, c2.rounding, e);
  };
  m2.tangent = m2.tan = function() {
    var e, t3, r2 = this, n2 = r2.constructor;
    return r2.isFinite() ? r2.isZero() ? new n2(r2) : (e = n2.precision, t3 = n2.rounding, n2.precision = e + 10, n2.rounding = 1, r2 = r2.sin(), r2.s = 1, r2 = F(r2, new n2(1).minus(r2.times(r2)).sqrt(), e + 10, 0), n2.precision = e, n2.rounding = t3, y(Me == 2 || Me == 4 ? r2.neg() : r2, e, t3, true)) : new n2(NaN);
  };
  m2.times = m2.mul = function(e) {
    var t3, r2, n2, i, o2, s, a13, l2, u, c2 = this, p = c2.constructor, d = c2.d, f = (e = new p(e)).d;
    if (e.s *= c2.s, !d || !d[0] || !f || !f[0])
      return new p(!e.s || d && !d[0] && !f || f && !f[0] && !d ? NaN : !d || !f ? e.s / 0 : e.s * 0);
    for (r2 = te(c2.e / E) + te(e.e / E), l2 = d.length, u = f.length, l2 < u && (o2 = d, d = f, f = o2, s = l2, l2 = u, u = s), o2 = [], s = l2 + u, n2 = s;n2--; )
      o2.push(0);
    for (n2 = u;--n2 >= 0; ) {
      for (t3 = 0, i = l2 + n2;i > n2; )
        a13 = o2[i] + f[n2] * d[i - n2 - 1] + t3, o2[i--] = a13 % he | 0, t3 = a13 / he | 0;
      o2[i] = (o2[i] + t3) % he | 0;
    }
    for (;!o2[--s]; )
      o2.pop();
    return t3 ? ++r2 : o2.shift(), e.d = o2, e.e = on(o2, r2), w ? y(e, p.precision, p.rounding) : e;
  };
  m2.toBinary = function(e, t3) {
    return ki(this, 2, e, t3);
  };
  m2.toDecimalPlaces = m2.toDP = function(e, t3) {
    var r2 = this, n2 = r2.constructor;
    return r2 = new n2(r2), e === undefined ? r2 : (oe(e, 0, Ye), t3 === undefined ? t3 = n2.rounding : oe(t3, 0, 8), y(r2, e + r2.e + 1, t3));
  };
  m2.toExponential = function(e, t3) {
    var r2, n2 = this, i = n2.constructor;
    return e === undefined ? r2 = xe(n2, true) : (oe(e, 0, Ye), t3 === undefined ? t3 = i.rounding : oe(t3, 0, 8), n2 = y(new i(n2), e + 1, t3), r2 = xe(n2, true, e + 1)), n2.isNeg() && !n2.isZero() ? "-" + r2 : r2;
  };
  m2.toFixed = function(e, t3) {
    var r2, n2, i = this, o2 = i.constructor;
    return e === undefined ? r2 = xe(i) : (oe(e, 0, Ye), t3 === undefined ? t3 = o2.rounding : oe(t3, 0, 8), n2 = y(new o2(i), e + i.e + 1, t3), r2 = xe(n2, false, e + n2.e + 1)), i.isNeg() && !i.isZero() ? "-" + r2 : r2;
  };
  m2.toFraction = function(e) {
    var t3, r2, n2, i, o2, s, a13, l2, u, c2, p, d, f = this, g = f.d, h = f.constructor;
    if (!g)
      return new h(f);
    if (u = r2 = new h(1), n2 = l2 = new h(0), t3 = new h(n2), o2 = t3.e = ks(g) - f.e - 1, s = o2 % E, t3.d[0] = Q(10, s < 0 ? E + s : s), e == null)
      e = o2 > 0 ? t3 : u;
    else {
      if (a13 = new h(e), !a13.isInt() || a13.lt(u))
        throw Error(Ke + a13);
      e = a13.gt(t3) ? o2 > 0 ? t3 : u : a13;
    }
    for (w = false, a13 = new h(W(g)), c2 = h.precision, h.precision = o2 = g.length * E * 2;p = F(a13, t3, 0, 1, 1), i = r2.plus(p.times(n2)), i.cmp(e) != 1; )
      r2 = n2, n2 = i, i = u, u = l2.plus(p.times(i)), l2 = i, i = t3, t3 = a13.minus(p.times(i)), a13 = i;
    return i = F(e.minus(r2), n2, 0, 1, 1), l2 = l2.plus(i.times(u)), r2 = r2.plus(i.times(n2)), l2.s = u.s = f.s, d = F(u, n2, o2, 1).minus(f).abs().cmp(F(l2, r2, o2, 1).minus(f).abs()) < 1 ? [u, n2] : [l2, r2], h.precision = c2, w = true, d;
  };
  m2.toHexadecimal = m2.toHex = function(e, t3) {
    return ki(this, 16, e, t3);
  };
  m2.toNearest = function(e, t3) {
    var r2 = this, n2 = r2.constructor;
    if (r2 = new n2(r2), e == null) {
      if (!r2.d)
        return r2;
      e = new n2(1), t3 = n2.rounding;
    } else {
      if (e = new n2(e), t3 === undefined ? t3 = n2.rounding : oe(t3, 0, 8), !r2.d)
        return e.s ? r2 : e;
      if (!e.d)
        return e.s && (e.s = r2.s), e;
    }
    return e.d[0] ? (w = false, r2 = F(r2, e, 0, t3, 1).times(e), w = true, y(r2)) : (e.s = r2.s, r2 = e), r2;
  };
  m2.toNumber = function() {
    return +this;
  };
  m2.toOctal = function(e, t3) {
    return ki(this, 8, e, t3);
  };
  m2.toPower = m2.pow = function(e) {
    var t3, r2, n2, i, o2, s, a13 = this, l2 = a13.constructor, u = +(e = new l2(e));
    if (!a13.d || !e.d || !a13.d[0] || !e.d[0])
      return new l2(Q(+a13, u));
    if (a13 = new l2(a13), a13.eq(1))
      return a13;
    if (n2 = l2.precision, o2 = l2.rounding, e.eq(1))
      return y(a13, n2, o2);
    if (t3 = te(e.e / E), t3 >= e.d.length - 1 && (r2 = u < 0 ? -u : u) <= Ic)
      return i = Ds(l2, a13, r2, n2), e.s < 0 ? new l2(1).div(i) : y(i, n2, o2);
    if (s = a13.s, s < 0) {
      if (t3 < e.d.length - 1)
        return new l2(NaN);
      if (e.d[t3] & 1 || (s = 1), a13.e == 0 && a13.d[0] == 1 && a13.d.length == 1)
        return a13.s = s, a13;
    }
    return r2 = Q(+a13, u), t3 = r2 == 0 || !isFinite(r2) ? te(u * (Math.log("0." + W(a13.d)) / Math.LN10 + a13.e + 1)) : new l2(r2 + "").e, t3 > l2.maxE + 1 || t3 < l2.minE - 1 ? new l2(t3 > 0 ? s / 0 : 0) : (w = false, l2.rounding = a13.s = 1, r2 = Math.min(12, (t3 + "").length), i = Ii(e.times(We(a13, n2 + r2)), n2), i.d && (i = y(i, n2 + 5, 1), rr(i.d, n2, o2) && (t3 = n2 + 10, i = y(Ii(e.times(We(a13, t3 + r2)), t3), t3 + 5, 1), +W(i.d).slice(n2 + 1, n2 + 15) + 1 == 100000000000000 && (i = y(i, n2 + 1, 0)))), i.s = s, w = true, l2.rounding = o2, y(i, n2, o2));
  };
  m2.toPrecision = function(e, t3) {
    var r2, n2 = this, i = n2.constructor;
    return e === undefined ? r2 = xe(n2, n2.e <= i.toExpNeg || n2.e >= i.toExpPos) : (oe(e, 1, Ye), t3 === undefined ? t3 = i.rounding : oe(t3, 0, 8), n2 = y(new i(n2), e, t3), r2 = xe(n2, e <= n2.e || n2.e <= i.toExpNeg, e)), n2.isNeg() && !n2.isZero() ? "-" + r2 : r2;
  };
  m2.toSignificantDigits = m2.toSD = function(e, t3) {
    var r2 = this, n2 = r2.constructor;
    return e === undefined ? (e = n2.precision, t3 = n2.rounding) : (oe(e, 1, Ye), t3 === undefined ? t3 = n2.rounding : oe(t3, 0, 8)), y(new n2(r2), e, t3);
  };
  m2.toString = function() {
    var e = this, t3 = e.constructor, r2 = xe(e, e.e <= t3.toExpNeg || e.e >= t3.toExpPos);
    return e.isNeg() && !e.isZero() ? "-" + r2 : r2;
  };
  m2.truncated = m2.trunc = function() {
    return y(new this.constructor(this), this.e + 1, 1);
  };
  m2.valueOf = m2.toJSON = function() {
    var e = this, t3 = e.constructor, r2 = xe(e, e.e <= t3.toExpNeg || e.e >= t3.toExpPos);
    return e.isNeg() ? "-" + r2 : r2;
  };
  function W(e) {
    var t3, r2, n2, i = e.length - 1, o2 = "", s = e[0];
    if (i > 0) {
      for (o2 += s, t3 = 1;t3 < i; t3++)
        n2 = e[t3] + "", r2 = E - n2.length, r2 && (o2 += He(r2)), o2 += n2;
      s = e[t3], n2 = s + "", r2 = E - n2.length, r2 && (o2 += He(r2));
    } else if (s === 0)
      return "0";
    for (;s % 10 === 0; )
      s /= 10;
    return o2 + s;
  }
  function oe(e, t3, r2) {
    if (e !== ~~e || e < t3 || e > r2)
      throw Error(Ke + e);
  }
  function rr(e, t3, r2, n2) {
    var i, o2, s, a13;
    for (o2 = e[0];o2 >= 10; o2 /= 10)
      --t3;
    return --t3 < 0 ? (t3 += E, i = 0) : (i = Math.ceil((t3 + 1) / E), t3 %= E), o2 = Q(10, E - t3), a13 = e[i] % o2 | 0, n2 == null ? t3 < 3 ? (t3 == 0 ? a13 = a13 / 100 | 0 : t3 == 1 && (a13 = a13 / 10 | 0), s = r2 < 4 && a13 == 99999 || r2 > 3 && a13 == 49999 || a13 == 50000 || a13 == 0) : s = (r2 < 4 && a13 + 1 == o2 || r2 > 3 && a13 + 1 == o2 / 2) && (e[i + 1] / o2 / 100 | 0) == Q(10, t3 - 2) - 1 || (a13 == o2 / 2 || a13 == 0) && (e[i + 1] / o2 / 100 | 0) == 0 : t3 < 4 ? (t3 == 0 ? a13 = a13 / 1000 | 0 : t3 == 1 ? a13 = a13 / 100 | 0 : t3 == 2 && (a13 = a13 / 10 | 0), s = (n2 || r2 < 4) && a13 == 9999 || !n2 && r2 > 3 && a13 == 4999) : s = ((n2 || r2 < 4) && a13 + 1 == o2 || !n2 && r2 > 3 && a13 + 1 == o2 / 2) && (e[i + 1] / o2 / 1000 | 0) == Q(10, t3 - 3) - 1, s;
  }
  function Xr(e, t3, r2) {
    for (var n2, i = [0], o2, s = 0, a13 = e.length;s < a13; ) {
      for (o2 = i.length;o2--; )
        i[o2] *= t3;
      for (i[0] += Ci.indexOf(e.charAt(s++)), n2 = 0;n2 < i.length; n2++)
        i[n2] > r2 - 1 && (i[n2 + 1] === undefined && (i[n2 + 1] = 0), i[n2 + 1] += i[n2] / r2 | 0, i[n2] %= r2);
    }
    return i.reverse();
  }
  function kc(e, t3) {
    var r2, n2, i;
    if (t3.isZero())
      return t3;
    n2 = t3.d.length, n2 < 32 ? (r2 = Math.ceil(n2 / 3), i = (1 / sn(4, r2)).toString()) : (r2 = 16, i = "2.3283064365386962890625e-10"), e.precision += r2, t3 = Et(e, 1, t3.times(i), new e(1));
    for (var o2 = r2;o2--; ) {
      var s = t3.times(t3);
      t3 = s.times(s).minus(s).times(8).plus(1);
    }
    return e.precision -= r2, t3;
  }
  var F = function() {
    function e(n2, i, o2) {
      var s, a13 = 0, l2 = n2.length;
      for (n2 = n2.slice();l2--; )
        s = n2[l2] * i + a13, n2[l2] = s % o2 | 0, a13 = s / o2 | 0;
      return a13 && n2.unshift(a13), n2;
    }
    function t3(n2, i, o2, s) {
      var a13, l2;
      if (o2 != s)
        l2 = o2 > s ? 1 : -1;
      else
        for (a13 = l2 = 0;a13 < o2; a13++)
          if (n2[a13] != i[a13]) {
            l2 = n2[a13] > i[a13] ? 1 : -1;
            break;
          }
      return l2;
    }
    function r2(n2, i, o2, s) {
      for (var a13 = 0;o2--; )
        n2[o2] -= a13, a13 = n2[o2] < i[o2] ? 1 : 0, n2[o2] = a13 * s + n2[o2] - i[o2];
      for (;!n2[0] && n2.length > 1; )
        n2.shift();
    }
    return function(n2, i, o2, s, a13, l2) {
      var u, c2, p, d, f, g, h, O, T, S, C, b, fe, le, jt, B, ie, Oe, K2, pt, Lr = n2.constructor, Vn = n2.s == i.s ? 1 : -1, Y3 = n2.d, _3 = i.d;
      if (!Y3 || !Y3[0] || !_3 || !_3[0])
        return new Lr(!n2.s || !i.s || (Y3 ? _3 && Y3[0] == _3[0] : !_3) ? NaN : Y3 && Y3[0] == 0 || !_3 ? Vn * 0 : Vn / 0);
      for (l2 ? (f = 1, c2 = n2.e - i.e) : (l2 = he, f = E, c2 = te(n2.e / f) - te(i.e / f)), K2 = _3.length, ie = Y3.length, T = new Lr(Vn), S = T.d = [], p = 0;_3[p] == (Y3[p] || 0); p++)
        ;
      if (_3[p] > (Y3[p] || 0) && c2--, o2 == null ? (le = o2 = Lr.precision, s = Lr.rounding) : a13 ? le = o2 + (n2.e - i.e) + 1 : le = o2, le < 0)
        S.push(1), g = true;
      else {
        if (le = le / f + 2 | 0, p = 0, K2 == 1) {
          for (d = 0, _3 = _3[0], le++;(p < ie || d) && le--; p++)
            jt = d * l2 + (Y3[p] || 0), S[p] = jt / _3 | 0, d = jt % _3 | 0;
          g = d || p < ie;
        } else {
          for (d = l2 / (_3[0] + 1) | 0, d > 1 && (_3 = e(_3, d, l2), Y3 = e(Y3, d, l2), K2 = _3.length, ie = Y3.length), B = K2, C = Y3.slice(0, K2), b = C.length;b < K2; )
            C[b++] = 0;
          pt = _3.slice(), pt.unshift(0), Oe = _3[0], _3[1] >= l2 / 2 && ++Oe;
          do
            d = 0, u = t3(_3, C, K2, b), u < 0 ? (fe = C[0], K2 != b && (fe = fe * l2 + (C[1] || 0)), d = fe / Oe | 0, d > 1 ? (d >= l2 && (d = l2 - 1), h = e(_3, d, l2), O = h.length, b = C.length, u = t3(h, C, O, b), u == 1 && (d--, r2(h, K2 < O ? pt : _3, O, l2))) : (d == 0 && (u = d = 1), h = _3.slice()), O = h.length, O < b && h.unshift(0), r2(C, h, b, l2), u == -1 && (b = C.length, u = t3(_3, C, K2, b), u < 1 && (d++, r2(C, K2 < b ? pt : _3, b, l2))), b = C.length) : u === 0 && (d++, C = [0]), S[p++] = d, u && C[0] ? C[b++] = Y3[B] || 0 : (C = [Y3[B]], b = 1);
          while ((B++ < ie || C[0] !== undefined) && le--);
          g = C[0] !== undefined;
        }
        S[0] || S.shift();
      }
      if (f == 1)
        T.e = c2, Cs = g;
      else {
        for (p = 1, d = S[0];d >= 10; d /= 10)
          p++;
        T.e = p + c2 * f - 1, y(T, a13 ? o2 + T.e + 1 : o2, s, g);
      }
      return T;
    };
  }();
  function y(e, t3, r2, n2) {
    var i, o2, s, a13, l2, u, c2, p, d, f = e.constructor;
    e:
      if (t3 != null) {
        if (p = e.d, !p)
          return e;
        for (i = 1, a13 = p[0];a13 >= 10; a13 /= 10)
          i++;
        if (o2 = t3 - i, o2 < 0)
          o2 += E, s = t3, c2 = p[d = 0], l2 = c2 / Q(10, i - s - 1) % 10 | 0;
        else if (d = Math.ceil((o2 + 1) / E), a13 = p.length, d >= a13)
          if (n2) {
            for (;a13++ <= d; )
              p.push(0);
            c2 = l2 = 0, i = 1, o2 %= E, s = o2 - E + 1;
          } else
            break e;
        else {
          for (c2 = a13 = p[d], i = 1;a13 >= 10; a13 /= 10)
            i++;
          o2 %= E, s = o2 - E + i, l2 = s < 0 ? 0 : c2 / Q(10, i - s - 1) % 10 | 0;
        }
        if (n2 = n2 || t3 < 0 || p[d + 1] !== undefined || (s < 0 ? c2 : c2 % Q(10, i - s - 1)), u = r2 < 4 ? (l2 || n2) && (r2 == 0 || r2 == (e.s < 0 ? 3 : 2)) : l2 > 5 || l2 == 5 && (r2 == 4 || n2 || r2 == 6 && (o2 > 0 ? s > 0 ? c2 / Q(10, i - s) : 0 : p[d - 1]) % 10 & 1 || r2 == (e.s < 0 ? 8 : 7)), t3 < 1 || !p[0])
          return p.length = 0, u ? (t3 -= e.e + 1, p[0] = Q(10, (E - t3 % E) % E), e.e = -t3 || 0) : p[0] = e.e = 0, e;
        if (o2 == 0 ? (p.length = d, a13 = 1, d--) : (p.length = d + 1, a13 = Q(10, E - o2), p[d] = s > 0 ? (c2 / Q(10, i - s) % Q(10, s) | 0) * a13 : 0), u)
          for (;; )
            if (d == 0) {
              for (o2 = 1, s = p[0];s >= 10; s /= 10)
                o2++;
              for (s = p[0] += a13, a13 = 1;s >= 10; s /= 10)
                a13++;
              o2 != a13 && (e.e++, p[0] == he && (p[0] = 1));
              break;
            } else {
              if (p[d] += a13, p[d] != he)
                break;
              p[d--] = 0, a13 = 1;
            }
        for (o2 = p.length;p[--o2] === 0; )
          p.pop();
      }
    return w && (e.e > f.maxE ? (e.d = null, e.e = NaN) : e.e < f.minE && (e.e = 0, e.d = [0])), e;
  }
  function xe(e, t3, r2) {
    if (!e.isFinite())
      return Ns(e);
    var n2, i = e.e, o2 = W(e.d), s = o2.length;
    return t3 ? (r2 && (n2 = r2 - s) > 0 ? o2 = o2.charAt(0) + "." + o2.slice(1) + He(n2) : s > 1 && (o2 = o2.charAt(0) + "." + o2.slice(1)), o2 = o2 + (e.e < 0 ? "e" : "e+") + e.e) : i < 0 ? (o2 = "0." + He(-i - 1) + o2, r2 && (n2 = r2 - s) > 0 && (o2 += He(n2))) : i >= s ? (o2 += He(i + 1 - s), r2 && (n2 = r2 - i - 1) > 0 && (o2 = o2 + "." + He(n2))) : ((n2 = i + 1) < s && (o2 = o2.slice(0, n2) + "." + o2.slice(n2)), r2 && (n2 = r2 - s) > 0 && (i + 1 === s && (o2 += "."), o2 += He(n2))), o2;
  }
  function on(e, t3) {
    var r2 = e[0];
    for (t3 *= E;r2 >= 10; r2 /= 10)
      t3++;
    return t3;
  }
  function rn(e, t3, r2) {
    if (t3 > Oc)
      throw w = true, r2 && (e.precision = r2), Error(Ss);
    return y(new e(en), t3, 1, true);
  }
  function ge(e, t3, r2) {
    if (t3 > Ai)
      throw Error(Ss);
    return y(new e(tn), t3, r2, true);
  }
  function ks(e) {
    var t3 = e.length - 1, r2 = t3 * E + 1;
    if (t3 = e[t3], t3) {
      for (;t3 % 10 == 0; t3 /= 10)
        r2--;
      for (t3 = e[0];t3 >= 10; t3 /= 10)
        r2++;
    }
    return r2;
  }
  function He(e) {
    for (var t3 = "";e--; )
      t3 += "0";
    return t3;
  }
  function Ds(e, t3, r2, n2) {
    var i, o2 = new e(1), s = Math.ceil(n2 / E + 4);
    for (w = false;; ) {
      if (r2 % 2 && (o2 = o2.times(t3), Ts(o2.d, s) && (i = true)), r2 = te(r2 / 2), r2 === 0) {
        r2 = o2.d.length - 1, i && o2.d[r2] === 0 && ++o2.d[r2];
        break;
      }
      t3 = t3.times(t3), Ts(t3.d, s);
    }
    return w = true, o2;
  }
  function Ps(e) {
    return e.d[e.d.length - 1] & 1;
  }
  function _s(e, t3, r2) {
    for (var n2, i = new e(t3[0]), o2 = 0;++o2 < t3.length; )
      if (n2 = new e(t3[o2]), n2.s)
        i[r2](n2) && (i = n2);
      else {
        i = n2;
        break;
      }
    return i;
  }
  function Ii(e, t3) {
    var r2, n2, i, o2, s, a13, l2, u = 0, c2 = 0, p = 0, d = e.constructor, f = d.rounding, g = d.precision;
    if (!e.d || !e.d[0] || e.e > 17)
      return new d(e.d ? e.d[0] ? e.s < 0 ? 0 : 1 / 0 : 1 : e.s ? e.s < 0 ? 0 : e : NaN);
    for (t3 == null ? (w = false, l2 = g) : l2 = t3, a13 = new d(0.03125);e.e > -2; )
      e = e.times(a13), p += 5;
    for (n2 = Math.log(Q(2, p)) / Math.LN10 * 2 + 5 | 0, l2 += n2, r2 = o2 = s = new d(1), d.precision = l2;; ) {
      if (o2 = y(o2.times(e), l2, 1), r2 = r2.times(++c2), a13 = s.plus(F(o2, r2, l2, 1)), W(a13.d).slice(0, l2) === W(s.d).slice(0, l2)) {
        for (i = p;i--; )
          s = y(s.times(s), l2, 1);
        if (t3 == null)
          if (u < 3 && rr(s.d, l2 - n2, f, u))
            d.precision = l2 += 10, r2 = o2 = a13 = new d(1), c2 = 0, u++;
          else
            return y(s, d.precision = g, f, w = true);
        else
          return d.precision = g, s;
      }
      s = a13;
    }
  }
  function We(e, t3) {
    var r2, n2, i, o2, s, a13, l2, u, c2, p, d, f = 1, g = 10, h = e, O = h.d, T = h.constructor, S = T.rounding, C = T.precision;
    if (h.s < 0 || !O || !O[0] || !h.e && O[0] == 1 && O.length == 1)
      return new T(O && !O[0] ? -1 / 0 : h.s != 1 ? NaN : O ? 0 : h);
    if (t3 == null ? (w = false, c2 = C) : c2 = t3, T.precision = c2 += g, r2 = W(O), n2 = r2.charAt(0), Math.abs(o2 = h.e) < 1500000000000000) {
      for (;n2 < 7 && n2 != 1 || n2 == 1 && r2.charAt(1) > 3; )
        h = h.times(e), r2 = W(h.d), n2 = r2.charAt(0), f++;
      o2 = h.e, n2 > 1 ? (h = new T("0." + r2), o2++) : h = new T(n2 + "." + r2.slice(1));
    } else
      return u = rn(T, c2 + 2, C).times(o2 + ""), h = We(new T(n2 + "." + r2.slice(1)), c2 - g).plus(u), T.precision = C, t3 == null ? y(h, C, S, w = true) : h;
    for (p = h, l2 = s = h = F(h.minus(1), h.plus(1), c2, 1), d = y(h.times(h), c2, 1), i = 3;; ) {
      if (s = y(s.times(d), c2, 1), u = l2.plus(F(s, new T(i), c2, 1)), W(u.d).slice(0, c2) === W(l2.d).slice(0, c2))
        if (l2 = l2.times(2), o2 !== 0 && (l2 = l2.plus(rn(T, c2 + 2, C).times(o2 + ""))), l2 = F(l2, new T(f), c2, 1), t3 == null)
          if (rr(l2.d, c2 - g, S, a13))
            T.precision = c2 += g, u = s = h = F(p.minus(1), p.plus(1), c2, 1), d = y(h.times(h), c2, 1), i = a13 = 1;
          else
            return y(l2, T.precision = C, S, w = true);
        else
          return T.precision = C, l2;
      l2 = u, i += 2;
    }
  }
  function Ns(e) {
    return String(e.s * e.s / 0);
  }
  function Oi(e, t3) {
    var r2, n2, i;
    for ((r2 = t3.indexOf(".")) > -1 && (t3 = t3.replace(".", "")), (n2 = t3.search(/e/i)) > 0 ? (r2 < 0 && (r2 = n2), r2 += +t3.slice(n2 + 1), t3 = t3.substring(0, n2)) : r2 < 0 && (r2 = t3.length), n2 = 0;t3.charCodeAt(n2) === 48; n2++)
      ;
    for (i = t3.length;t3.charCodeAt(i - 1) === 48; --i)
      ;
    if (t3 = t3.slice(n2, i), t3) {
      if (i -= n2, e.e = r2 = r2 - n2 - 1, e.d = [], n2 = (r2 + 1) % E, r2 < 0 && (n2 += E), n2 < i) {
        for (n2 && e.d.push(+t3.slice(0, n2)), i -= E;n2 < i; )
          e.d.push(+t3.slice(n2, n2 += E));
        t3 = t3.slice(n2), n2 = E - t3.length;
      } else
        n2 -= i;
      for (;n2--; )
        t3 += "0";
      e.d.push(+t3), w && (e.e > e.constructor.maxE ? (e.d = null, e.e = NaN) : e.e < e.constructor.minE && (e.e = 0, e.d = [0]));
    } else
      e.e = 0, e.d = [0];
    return e;
  }
  function Dc(e, t3) {
    var r2, n2, i, o2, s, a13, l2, u, c2;
    if (t3.indexOf("_") > -1) {
      if (t3 = t3.replace(/(\d)_(?=\d)/g, "$1"), Os.test(t3))
        return Oi(e, t3);
    } else if (t3 === "Infinity" || t3 === "NaN")
      return +t3 || (e.s = NaN), e.e = NaN, e.d = null, e;
    if (Sc.test(t3))
      r2 = 16, t3 = t3.toLowerCase();
    else if (Cc.test(t3))
      r2 = 2;
    else if (Ac.test(t3))
      r2 = 8;
    else
      throw Error(Ke + t3);
    for (o2 = t3.search(/p/i), o2 > 0 ? (l2 = +t3.slice(o2 + 1), t3 = t3.substring(2, o2)) : t3 = t3.slice(2), o2 = t3.indexOf("."), s = o2 >= 0, n2 = e.constructor, s && (t3 = t3.replace(".", ""), a13 = t3.length, o2 = a13 - o2, i = Ds(n2, new n2(r2), o2, o2 * 2)), u = Xr(t3, r2, he), c2 = u.length - 1, o2 = c2;u[o2] === 0; --o2)
      u.pop();
    return o2 < 0 ? new n2(e.s * 0) : (e.e = on(u, c2), e.d = u, w = false, s && (e = F(e, i, a13 * 4)), l2 && (e = e.times(Math.abs(l2) < 54 ? Q(2, l2) : it.pow(2, l2))), w = true, e);
  }
  function _c(e, t3) {
    var r2, n2 = t3.d.length;
    if (n2 < 3)
      return t3.isZero() ? t3 : Et(e, 2, t3, t3);
    r2 = 1.4 * Math.sqrt(n2), r2 = r2 > 16 ? 16 : r2 | 0, t3 = t3.times(1 / sn(5, r2)), t3 = Et(e, 2, t3, t3);
    for (var i, o2 = new e(5), s = new e(16), a13 = new e(20);r2--; )
      i = t3.times(t3), t3 = t3.times(o2.plus(i.times(s.times(i).minus(a13))));
    return t3;
  }
  function Et(e, t3, r2, n2, i) {
    var o2, s, a13, l2, u = 1, c2 = e.precision, p = Math.ceil(c2 / E);
    for (w = false, l2 = r2.times(r2), a13 = new e(n2);; ) {
      if (s = F(a13.times(l2), new e(t3++ * t3++), c2, 1), a13 = i ? n2.plus(s) : n2.minus(s), n2 = F(s.times(l2), new e(t3++ * t3++), c2, 1), s = a13.plus(n2), s.d[p] !== undefined) {
        for (o2 = p;s.d[o2] === a13.d[o2] && o2--; )
          ;
        if (o2 == -1)
          break;
      }
      o2 = a13, a13 = n2, n2 = s, s = o2, u++;
    }
    return w = true, s.d.length = p + 1, s;
  }
  function sn(e, t3) {
    for (var r2 = e;--t3; )
      r2 *= e;
    return r2;
  }
  function Ls(e, t3) {
    var r2, n2 = t3.s < 0, i = ge(e, e.precision, 1), o2 = i.times(0.5);
    if (t3 = t3.abs(), t3.lte(o2))
      return Me = n2 ? 4 : 1, t3;
    if (r2 = t3.divToInt(i), r2.isZero())
      Me = n2 ? 3 : 2;
    else {
      if (t3 = t3.minus(r2.times(i)), t3.lte(o2))
        return Me = Ps(r2) ? n2 ? 2 : 3 : n2 ? 4 : 1, t3;
      Me = Ps(r2) ? n2 ? 1 : 4 : n2 ? 3 : 2;
    }
    return t3.minus(i).abs();
  }
  function ki(e, t3, r2, n2) {
    var i, o2, s, a13, l2, u, c2, p, d, f = e.constructor, g = r2 !== undefined;
    if (g ? (oe(r2, 1, Ye), n2 === undefined ? n2 = f.rounding : oe(n2, 0, 8)) : (r2 = f.precision, n2 = f.rounding), !e.isFinite())
      c2 = Ns(e);
    else {
      for (c2 = xe(e), s = c2.indexOf("."), g ? (i = 2, t3 == 16 ? r2 = r2 * 4 - 3 : t3 == 8 && (r2 = r2 * 3 - 2)) : i = t3, s >= 0 && (c2 = c2.replace(".", ""), d = new f(1), d.e = c2.length - s, d.d = Xr(xe(d), 10, i), d.e = d.d.length), p = Xr(c2, 10, i), o2 = l2 = p.length;p[--l2] == 0; )
        p.pop();
      if (!p[0])
        c2 = g ? "0p+0" : "0";
      else {
        if (s < 0 ? o2-- : (e = new f(e), e.d = p, e.e = o2, e = F(e, d, r2, n2, 0, i), p = e.d, o2 = e.e, u = Cs), s = p[r2], a13 = i / 2, u = u || p[r2 + 1] !== undefined, u = n2 < 4 ? (s !== undefined || u) && (n2 === 0 || n2 === (e.s < 0 ? 3 : 2)) : s > a13 || s === a13 && (n2 === 4 || u || n2 === 6 && p[r2 - 1] & 1 || n2 === (e.s < 0 ? 8 : 7)), p.length = r2, u)
          for (;++p[--r2] > i - 1; )
            p[r2] = 0, r2 || (++o2, p.unshift(1));
        for (l2 = p.length;!p[l2 - 1]; --l2)
          ;
        for (s = 0, c2 = "";s < l2; s++)
          c2 += Ci.charAt(p[s]);
        if (g) {
          if (l2 > 1)
            if (t3 == 16 || t3 == 8) {
              for (s = t3 == 16 ? 4 : 3, --l2;l2 % s; l2++)
                c2 += "0";
              for (p = Xr(c2, i, t3), l2 = p.length;!p[l2 - 1]; --l2)
                ;
              for (s = 1, c2 = "1.";s < l2; s++)
                c2 += Ci.charAt(p[s]);
            } else
              c2 = c2.charAt(0) + "." + c2.slice(1);
          c2 = c2 + (o2 < 0 ? "p" : "p+") + o2;
        } else if (o2 < 0) {
          for (;++o2; )
            c2 = "0" + c2;
          c2 = "0." + c2;
        } else if (++o2 > l2)
          for (o2 -= l2;o2--; )
            c2 += "0";
        else
          o2 < l2 && (c2 = c2.slice(0, o2) + "." + c2.slice(o2));
      }
      c2 = (t3 == 16 ? "0x" : t3 == 2 ? "0b" : t3 == 8 ? "0o" : "") + c2;
    }
    return e.s < 0 ? "-" + c2 : c2;
  }
  function Ts(e, t3) {
    if (e.length > t3)
      return e.length = t3, true;
  }
  function Nc(e) {
    return new this(e).abs();
  }
  function Lc(e) {
    return new this(e).acos();
  }
  function Fc(e) {
    return new this(e).acosh();
  }
  function Mc(e, t3) {
    return new this(e).plus(t3);
  }
  function $c(e) {
    return new this(e).asin();
  }
  function qc(e) {
    return new this(e).asinh();
  }
  function Vc(e) {
    return new this(e).atan();
  }
  function jc(e) {
    return new this(e).atanh();
  }
  function Bc(e, t3) {
    e = new this(e), t3 = new this(t3);
    var r2, n2 = this.precision, i = this.rounding, o2 = n2 + 4;
    return !e.s || !t3.s ? r2 = new this(NaN) : !e.d && !t3.d ? (r2 = ge(this, o2, 1).times(t3.s > 0 ? 0.25 : 0.75), r2.s = e.s) : !t3.d || e.isZero() ? (r2 = t3.s < 0 ? ge(this, n2, i) : new this(0), r2.s = e.s) : !e.d || t3.isZero() ? (r2 = ge(this, o2, 1).times(0.5), r2.s = e.s) : t3.s < 0 ? (this.precision = o2, this.rounding = 1, r2 = this.atan(F(e, t3, o2, 1)), t3 = ge(this, o2, 1), this.precision = n2, this.rounding = i, r2 = e.s < 0 ? r2.minus(t3) : r2.plus(t3)) : r2 = this.atan(F(e, t3, o2, 1)), r2;
  }
  function Uc(e) {
    return new this(e).cbrt();
  }
  function Qc(e) {
    return y(e = new this(e), e.e + 1, 2);
  }
  function Gc(e, t3, r2) {
    return new this(e).clamp(t3, r2);
  }
  function Jc(e) {
    if (!e || typeof e != "object")
      throw Error(nn + "Object expected");
    var t3, r2, n2, i = e.defaults === true, o2 = ["precision", 1, Ye, "rounding", 0, 8, "toExpNeg", -yt, 0, "toExpPos", 0, yt, "maxE", 0, yt, "minE", -yt, 0, "modulo", 0, 9];
    for (t3 = 0;t3 < o2.length; t3 += 3)
      if (r2 = o2[t3], i && (this[r2] = Si[r2]), (n2 = e[r2]) !== undefined)
        if (te(n2) === n2 && n2 >= o2[t3 + 1] && n2 <= o2[t3 + 2])
          this[r2] = n2;
        else
          throw Error(Ke + r2 + ": " + n2);
    if (r2 = "crypto", i && (this[r2] = Si[r2]), (n2 = e[r2]) !== undefined)
      if (n2 === true || n2 === false || n2 === 0 || n2 === 1)
        if (n2)
          if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
            this[r2] = true;
          else
            throw Error(As);
        else
          this[r2] = false;
      else
        throw Error(Ke + r2 + ": " + n2);
    return this;
  }
  function Hc(e) {
    return new this(e).cos();
  }
  function Wc(e) {
    return new this(e).cosh();
  }
  function Fs(e) {
    var t3, r2, n2;
    function i(o2) {
      var s, a13, l2, u = this;
      if (!(u instanceof i))
        return new i(o2);
      if (u.constructor = i, Rs(o2)) {
        u.s = o2.s, w ? !o2.d || o2.e > i.maxE ? (u.e = NaN, u.d = null) : o2.e < i.minE ? (u.e = 0, u.d = [0]) : (u.e = o2.e, u.d = o2.d.slice()) : (u.e = o2.e, u.d = o2.d ? o2.d.slice() : o2.d);
        return;
      }
      if (l2 = typeof o2, l2 === "number") {
        if (o2 === 0) {
          u.s = 1 / o2 < 0 ? -1 : 1, u.e = 0, u.d = [0];
          return;
        }
        if (o2 < 0 ? (o2 = -o2, u.s = -1) : u.s = 1, o2 === ~~o2 && o2 < 1e7) {
          for (s = 0, a13 = o2;a13 >= 10; a13 /= 10)
            s++;
          w ? s > i.maxE ? (u.e = NaN, u.d = null) : s < i.minE ? (u.e = 0, u.d = [0]) : (u.e = s, u.d = [o2]) : (u.e = s, u.d = [o2]);
          return;
        } else if (o2 * 0 !== 0) {
          o2 || (u.s = NaN), u.e = NaN, u.d = null;
          return;
        }
        return Oi(u, o2.toString());
      } else if (l2 !== "string")
        throw Error(Ke + o2);
      return (a13 = o2.charCodeAt(0)) === 45 ? (o2 = o2.slice(1), u.s = -1) : (a13 === 43 && (o2 = o2.slice(1)), u.s = 1), Os.test(o2) ? Oi(u, o2) : Dc(u, o2);
    }
    if (i.prototype = m2, i.ROUND_UP = 0, i.ROUND_DOWN = 1, i.ROUND_CEIL = 2, i.ROUND_FLOOR = 3, i.ROUND_HALF_UP = 4, i.ROUND_HALF_DOWN = 5, i.ROUND_HALF_EVEN = 6, i.ROUND_HALF_CEIL = 7, i.ROUND_HALF_FLOOR = 8, i.EUCLID = 9, i.config = i.set = Jc, i.clone = Fs, i.isDecimal = Rs, i.abs = Nc, i.acos = Lc, i.acosh = Fc, i.add = Mc, i.asin = $c, i.asinh = qc, i.atan = Vc, i.atanh = jc, i.atan2 = Bc, i.cbrt = Uc, i.ceil = Qc, i.clamp = Gc, i.cos = Hc, i.cosh = Wc, i.div = Kc, i.exp = Yc, i.floor = zc, i.hypot = Zc, i.ln = Xc, i.log = ep, i.log10 = rp, i.log2 = tp, i.max = np, i.min = ip, i.mod = op, i.mul = sp, i.pow = ap, i.random = lp, i.round = up, i.sign = cp, i.sin = pp, i.sinh = dp, i.sqrt = mp, i.sub = fp, i.sum = gp, i.tan = hp, i.tanh = yp, i.trunc = Ep, e === undefined && (e = {}), e && e.defaults !== true)
      for (n2 = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], t3 = 0;t3 < n2.length; )
        e.hasOwnProperty(r2 = n2[t3++]) || (e[r2] = this[r2]);
    return i.config(e), i;
  }
  function Kc(e, t3) {
    return new this(e).div(t3);
  }
  function Yc(e) {
    return new this(e).exp();
  }
  function zc(e) {
    return y(e = new this(e), e.e + 1, 3);
  }
  function Zc() {
    var e, t3, r2 = new this(0);
    for (w = false, e = 0;e < arguments.length; )
      if (t3 = new this(arguments[e++]), t3.d)
        r2.d && (r2 = r2.plus(t3.times(t3)));
      else {
        if (t3.s)
          return w = true, new this(1 / 0);
        r2 = t3;
      }
    return w = true, r2.sqrt();
  }
  function Rs(e) {
    return e instanceof it || e && e.toStringTag === Is || false;
  }
  function Xc(e) {
    return new this(e).ln();
  }
  function ep(e, t3) {
    return new this(e).log(t3);
  }
  function tp(e) {
    return new this(e).log(2);
  }
  function rp(e) {
    return new this(e).log(10);
  }
  function np() {
    return _s(this, arguments, "lt");
  }
  function ip() {
    return _s(this, arguments, "gt");
  }
  function op(e, t3) {
    return new this(e).mod(t3);
  }
  function sp(e, t3) {
    return new this(e).mul(t3);
  }
  function ap(e, t3) {
    return new this(e).pow(t3);
  }
  function lp(e) {
    var t3, r2, n2, i, o2 = 0, s = new this(1), a13 = [];
    if (e === undefined ? e = this.precision : oe(e, 1, Ye), n2 = Math.ceil(e / E), this.crypto)
      if (crypto.getRandomValues)
        for (t3 = crypto.getRandomValues(new Uint32Array(n2));o2 < n2; )
          i = t3[o2], i >= 4290000000 ? t3[o2] = crypto.getRandomValues(new Uint32Array(1))[0] : a13[o2++] = i % 1e7;
      else if (crypto.randomBytes) {
        for (t3 = crypto.randomBytes(n2 *= 4);o2 < n2; )
          i = t3[o2] + (t3[o2 + 1] << 8) + (t3[o2 + 2] << 16) + ((t3[o2 + 3] & 127) << 24), i >= 2140000000 ? crypto.randomBytes(4).copy(t3, o2) : (a13.push(i % 1e7), o2 += 4);
        o2 = n2 / 4;
      } else
        throw Error(As);
    else
      for (;o2 < n2; )
        a13[o2++] = Math.random() * 1e7 | 0;
    for (n2 = a13[--o2], e %= E, n2 && e && (i = Q(10, E - e), a13[o2] = (n2 / i | 0) * i);a13[o2] === 0; o2--)
      a13.pop();
    if (o2 < 0)
      r2 = 0, a13 = [0];
    else {
      for (r2 = -1;a13[0] === 0; r2 -= E)
        a13.shift();
      for (n2 = 1, i = a13[0];i >= 10; i /= 10)
        n2++;
      n2 < E && (r2 -= E - n2);
    }
    return s.e = r2, s.d = a13, s;
  }
  function up(e) {
    return y(e = new this(e), e.e + 1, this.rounding);
  }
  function cp(e) {
    return e = new this(e), e.d ? e.d[0] ? e.s : 0 * e.s : e.s || NaN;
  }
  function pp(e) {
    return new this(e).sin();
  }
  function dp(e) {
    return new this(e).sinh();
  }
  function mp(e) {
    return new this(e).sqrt();
  }
  function fp(e, t3) {
    return new this(e).sub(t3);
  }
  function gp() {
    var e = 0, t3 = arguments, r2 = new this(t3[e]);
    for (w = false;r2.s && ++e < t3.length; )
      r2 = r2.plus(t3[e]);
    return w = true, y(r2, this.precision, this.rounding);
  }
  function hp(e) {
    return new this(e).tan();
  }
  function yp(e) {
    return new this(e).tanh();
  }
  function Ep(e) {
    return y(e = new this(e), e.e + 1, 1);
  }
  m2[Symbol.for("nodejs.util.inspect.custom")] = m2.toString;
  m2[Symbol.toStringTag] = "Decimal";
  var it = m2.constructor = Fs(Si);
  en = new it(en);
  tn = new it(tn);
  var ve = it;
  function bt(e) {
    return e === null ? e : Array.isArray(e) ? e.map(bt) : typeof e == "object" ? bp(e) ? wp(e) : ht(e, bt) : e;
  }
  function bp(e) {
    return e !== null && typeof e == "object" && typeof e.$type == "string";
  }
  function wp({ $type: e, value: t3 }) {
    switch (e) {
      case "BigInt":
        return BigInt(t3);
      case "Bytes": {
        let { buffer: r2, byteOffset: n2, byteLength: i } = Buffer.from(t3, "base64");
        return new Uint8Array(r2, n2, i);
      }
      case "DateTime":
        return new Date(t3);
      case "Decimal":
        return new ve(t3);
      case "Json":
        return JSON.parse(t3);
      default:
        Fe(t3, "Unknown tagged value");
    }
  }
  function wt(e) {
    return e.substring(0, 1).toLowerCase() + e.substring(1);
  }
  function xt(e) {
    return e instanceof Date || Object.prototype.toString.call(e) === "[object Date]";
  }
  function an(e) {
    return e.toString() !== "Invalid Date";
  }
  function vt(e) {
    return it.isDecimal(e) ? true : e !== null && typeof e == "object" && typeof e.s == "number" && typeof e.e == "number" && typeof e.toFixed == "function" && Array.isArray(e.d);
  }
  var Bs = k(Ei());
  var js = k(import.meta.require("fs"));
  var Ms = { keyword: _e, entity: _e, value: (e) => H(rt(e)), punctuation: rt, directive: _e, function: _e, variable: (e) => H(rt(e)), string: (e) => H(Ve(e)), boolean: De, number: _e, comment: Ut };
  var xp = (e) => e;
  var ln = {};
  var vp = 0;
  var v = { manual: ln.Prism && ln.Prism.manual, disableWorkerMessageHandler: ln.Prism && ln.Prism.disableWorkerMessageHandler, util: { encode: function(e) {
    if (e instanceof ye) {
      let t3 = e;
      return new ye(t3.type, v.util.encode(t3.content), t3.alias);
    } else
      return Array.isArray(e) ? e.map(v.util.encode) : e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
  }, type: function(e) {
    return Object.prototype.toString.call(e).slice(8, -1);
  }, objId: function(e) {
    return e.__id || Object.defineProperty(e, "__id", { value: ++vp }), e.__id;
  }, clone: function e(t3, r2) {
    let n2, i, o2 = v.util.type(t3);
    switch (r2 = r2 || {}, o2) {
      case "Object":
        if (i = v.util.objId(t3), r2[i])
          return r2[i];
        n2 = {}, r2[i] = n2;
        for (let s in t3)
          t3.hasOwnProperty(s) && (n2[s] = e(t3[s], r2));
        return n2;
      case "Array":
        return i = v.util.objId(t3), r2[i] ? r2[i] : (n2 = [], r2[i] = n2, t3.forEach(function(s, a13) {
          n2[a13] = e(s, r2);
        }), n2);
      default:
        return t3;
    }
  } }, languages: { extend: function(e, t3) {
    let r2 = v.util.clone(v.languages[e]);
    for (let n2 in t3)
      r2[n2] = t3[n2];
    return r2;
  }, insertBefore: function(e, t3, r2, n2) {
    n2 = n2 || v.languages;
    let i = n2[e], o2 = {};
    for (let a13 in i)
      if (i.hasOwnProperty(a13)) {
        if (a13 == t3)
          for (let l2 in r2)
            r2.hasOwnProperty(l2) && (o2[l2] = r2[l2]);
        r2.hasOwnProperty(a13) || (o2[a13] = i[a13]);
      }
    let s = n2[e];
    return n2[e] = o2, v.languages.DFS(v.languages, function(a13, l2) {
      l2 === s && a13 != e && (this[a13] = o2);
    }), o2;
  }, DFS: function e(t3, r2, n2, i) {
    i = i || {};
    let o2 = v.util.objId;
    for (let s in t3)
      if (t3.hasOwnProperty(s)) {
        r2.call(t3, s, t3[s], n2 || s);
        let a13 = t3[s], l2 = v.util.type(a13);
        l2 === "Object" && !i[o2(a13)] ? (i[o2(a13)] = true, e(a13, r2, null, i)) : l2 === "Array" && !i[o2(a13)] && (i[o2(a13)] = true, e(a13, r2, s, i));
      }
  } }, plugins: {}, highlight: function(e, t3, r2) {
    let n2 = { code: e, grammar: t3, language: r2 };
    return v.hooks.run("before-tokenize", n2), n2.tokens = v.tokenize(n2.code, n2.grammar), v.hooks.run("after-tokenize", n2), ye.stringify(v.util.encode(n2.tokens), n2.language);
  }, matchGrammar: function(e, t3, r2, n2, i, o2, s) {
    for (let h in r2) {
      if (!r2.hasOwnProperty(h) || !r2[h])
        continue;
      if (h == s)
        return;
      let O = r2[h];
      O = v.util.type(O) === "Array" ? O : [O];
      for (let T = 0;T < O.length; ++T) {
        let S = O[T], C = S.inside, b = !!S.lookbehind, fe = !!S.greedy, le = 0, jt = S.alias;
        if (fe && !S.pattern.global) {
          let B = S.pattern.toString().match(/[imuy]*$/)[0];
          S.pattern = RegExp(S.pattern.source, B + "g");
        }
        S = S.pattern || S;
        for (let B = n2, ie = i;B < t3.length; ie += t3[B].length, ++B) {
          let Oe = t3[B];
          if (t3.length > e.length)
            return;
          if (Oe instanceof ye)
            continue;
          if (fe && B != t3.length - 1) {
            S.lastIndex = ie;
            var p = S.exec(e);
            if (!p)
              break;
            var c2 = p.index + (b ? p[1].length : 0), d = p.index + p[0].length, a13 = B, l2 = ie;
            for (let _3 = t3.length;a13 < _3 && (l2 < d || !t3[a13].type && !t3[a13 - 1].greedy); ++a13)
              l2 += t3[a13].length, c2 >= l2 && (++B, ie = l2);
            if (t3[B] instanceof ye)
              continue;
            u = a13 - B, Oe = e.slice(ie, l2), p.index -= ie;
          } else {
            S.lastIndex = 0;
            var p = S.exec(Oe), u = 1;
          }
          if (!p) {
            if (o2)
              break;
            continue;
          }
          b && (le = p[1] ? p[1].length : 0);
          var c2 = p.index + le, p = p[0].slice(le), d = c2 + p.length, f = Oe.slice(0, c2), g = Oe.slice(d);
          let K2 = [B, u];
          f && (++B, ie += f.length, K2.push(f));
          let pt = new ye(h, C ? v.tokenize(p, C) : p, jt, p, fe);
          if (K2.push(pt), g && K2.push(g), Array.prototype.splice.apply(t3, K2), u != 1 && v.matchGrammar(e, t3, r2, B, ie, true, h), o2)
            break;
        }
      }
    }
  }, tokenize: function(e, t3) {
    let r2 = [e], n2 = t3.rest;
    if (n2) {
      for (let i in n2)
        t3[i] = n2[i];
      delete t3.rest;
    }
    return v.matchGrammar(e, r2, t3, 0, 0, false), r2;
  }, hooks: { all: {}, add: function(e, t3) {
    let r2 = v.hooks.all;
    r2[e] = r2[e] || [], r2[e].push(t3);
  }, run: function(e, t3) {
    let r2 = v.hooks.all[e];
    if (!(!r2 || !r2.length))
      for (var n2 = 0, i;i = r2[n2++]; )
        i(t3);
  } }, Token: ye };
  v.languages.clike = { comment: [{ pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/, lookbehind: true }, { pattern: /(^|[^\\:])\/\/.*/, lookbehind: true, greedy: true }], string: { pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, greedy: true }, "class-name": { pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i, lookbehind: true, inside: { punctuation: /[.\\]/ } }, keyword: /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/, boolean: /\b(?:true|false)\b/, function: /\w+(?=\()/, number: /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i, operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/, punctuation: /[{}[\];(),.:]/ };
  v.languages.javascript = v.languages.extend("clike", { "class-name": [v.languages.clike["class-name"], { pattern: /(^|[^$\w\xA0-\uFFFF])[_$A-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\.(?:prototype|constructor))/, lookbehind: true }], keyword: [{ pattern: /((?:^|})\s*)(?:catch|finally)\b/, lookbehind: true }, { pattern: /(^|[^.])\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/, lookbehind: true }], number: /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/, function: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/, operator: /-[-=]?|\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/ });
  v.languages.javascript["class-name"][0].pattern = /(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/;
  v.languages.insertBefore("javascript", "keyword", { regex: { pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)\/(\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^/\\\[\r\n])+\/[gimyus]{0,6}(?=\s*($|[\r\n,.;})\]]))/, lookbehind: true, greedy: true }, "function-variable": { pattern: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/, alias: "function" }, parameter: [{ pattern: /(function(?:\s+[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)?\s*\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\))/, lookbehind: true, inside: v.languages.javascript }, { pattern: /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=>)/i, inside: v.languages.javascript }, { pattern: /(\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*=>)/, lookbehind: true, inside: v.languages.javascript }, { pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\s*)\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*\{)/, lookbehind: true, inside: v.languages.javascript }], constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/ });
  v.languages.markup && v.languages.markup.tag.addInlined("script", "javascript");
  v.languages.js = v.languages.javascript;
  v.languages.typescript = v.languages.extend("javascript", { keyword: /\b(?:abstract|as|async|await|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|is|keyof|let|module|namespace|new|null|of|package|private|protected|public|readonly|return|require|set|static|super|switch|this|throw|try|type|typeof|var|void|while|with|yield)\b/, builtin: /\b(?:string|Function|any|number|boolean|Array|symbol|console|Promise|unknown|never)\b/ });
  v.languages.ts = v.languages.typescript;
  function ye(e, t3, r2, n2, i) {
    this.type = e, this.content = t3, this.alias = r2, this.length = (n2 || "").length | 0, this.greedy = !!i;
  }
  ye.stringify = function(e, t3) {
    return typeof e == "string" ? e : Array.isArray(e) ? e.map(function(r2) {
      return ye.stringify(r2, t3);
    }).join("") : Pp(e.type)(e.content);
  };
  function Pp(e) {
    return Ms[e] || xp;
  }
  function $s(e) {
    return Tp(e, v.languages.javascript);
  }
  function Tp(e, t3) {
    return v.tokenize(e, t3).map((n2) => ye.stringify(n2)).join("");
  }
  var qs = k(fs());
  function Vs(e) {
    return (0, qs.default)(e);
  }
  var un = class e {
    static read(t3) {
      let r2;
      try {
        r2 = js.default.readFileSync(t3, "utf-8");
      } catch {
        return null;
      }
      return e.fromContent(r2);
    }
    static fromContent(t3) {
      let r2 = t3.split(/\r?\n/);
      return new e(1, r2);
    }
    constructor(t3, r2) {
      this.firstLineNumber = t3, this.lines = r2;
    }
    get lastLineNumber() {
      return this.firstLineNumber + this.lines.length - 1;
    }
    mapLineAt(t3, r2) {
      if (t3 < this.firstLineNumber || t3 > this.lines.length + this.firstLineNumber)
        return this;
      let n2 = t3 - this.firstLineNumber, i = [...this.lines];
      return i[n2] = r2(i[n2]), new e(this.firstLineNumber, i);
    }
    mapLines(t3) {
      return new e(this.firstLineNumber, this.lines.map((r2, n2) => t3(r2, this.firstLineNumber + n2)));
    }
    lineAt(t3) {
      return this.lines[t3 - this.firstLineNumber];
    }
    prependSymbolAt(t3, r2) {
      return this.mapLines((n2, i) => i === t3 ? `${r2} ${n2}` : `  ${n2}`);
    }
    slice(t3, r2) {
      let n2 = this.lines.slice(t3 - 1, r2).join(`
`);
      return new e(t3, Vs(n2).split(`
`));
    }
    highlight() {
      let t3 = $s(this.toString());
      return new e(this.firstLineNumber, t3.split(`
`));
    }
    toString() {
      return this.lines.join(`
`);
    }
  };
  var Rp = { red: pe, gray: Ut, dim: ke, bold: H, underline: Z3, highlightSource: (e) => e.highlight() };
  var Cp = { red: (e) => e, gray: (e) => e, dim: (e) => e, bold: (e) => e, underline: (e) => e, highlightSource: (e) => e };
  function Sp({ message: e, originalMethod: t3, isPanic: r2, callArguments: n2 }) {
    return { functionName: `prisma.${t3}()`, message: e, isPanic: r2 ?? false, callArguments: n2 };
  }
  function Ap({ callsite: e, message: t3, originalMethod: r2, isPanic: n2, callArguments: i }, o2) {
    let s = Sp({ message: t3, originalMethod: r2, isPanic: n2, callArguments: i });
    if (!e || typeof window < "u" || false)
      return s;
    let a13 = e.getLocation();
    if (!a13 || !a13.lineNumber || !a13.columnNumber)
      return s;
    let l2 = Math.max(1, a13.lineNumber - 3), u = un.read(a13.fileName)?.slice(l2, a13.lineNumber), c2 = u?.lineAt(a13.lineNumber);
    if (u && c2) {
      let p = Op(c2), d = Ip(c2);
      if (!d)
        return s;
      s.functionName = `${d.code})`, s.location = a13, n2 || (u = u.mapLineAt(a13.lineNumber, (g) => g.slice(0, d.openingBraceIndex))), u = o2.highlightSource(u);
      let f = String(u.lastLineNumber).length;
      if (s.contextLines = u.mapLines((g, h) => o2.gray(String(h).padStart(f)) + " " + g).mapLines((g) => o2.dim(g)).prependSymbolAt(a13.lineNumber, o2.bold(o2.red("\u2192"))), i) {
        let g = p + f + 1;
        g += 2, s.callArguments = (0, Bs.default)(i, g).slice(g);
      }
    }
    return s;
  }
  function Ip(e) {
    let t3 = Object.keys(zt.ModelAction).join("|"), n2 = new RegExp(String.raw`\.(${t3})\(`).exec(e);
    if (n2) {
      let i = n2.index + n2[0].length, o2 = e.lastIndexOf(" ", n2.index) + 1;
      return { code: e.slice(o2, i), openingBraceIndex: i };
    }
    return null;
  }
  function Op(e) {
    let t3 = 0;
    for (let r2 = 0;r2 < e.length; r2++) {
      if (e.charAt(r2) !== " ")
        return t3;
      t3++;
    }
    return t3;
  }
  function kp({ functionName: e, location: t3, message: r2, isPanic: n2, contextLines: i, callArguments: o2 }, s) {
    let a13 = [""], l2 = t3 ? " in" : ":";
    if (n2 ? (a13.push(s.red(`Oops, an unknown error occurred! This is ${s.bold("on us")}, you did nothing wrong.`)), a13.push(s.red(`It occurred in the ${s.bold(`\`${e}\``)} invocation${l2}`))) : a13.push(s.red(`Invalid ${s.bold(`\`${e}\``)} invocation${l2}`)), t3 && a13.push(s.underline(Dp(t3))), i) {
      a13.push("");
      let u = [i.toString()];
      o2 && (u.push(o2), u.push(s.dim(")"))), a13.push(u.join("")), o2 && a13.push("");
    } else
      a13.push(""), o2 && a13.push(o2), a13.push("");
    return a13.push(r2), a13.join(`
`);
  }
  function Dp(e) {
    let t3 = [e.fileName];
    return e.lineNumber && t3.push(String(e.lineNumber)), e.columnNumber && t3.push(String(e.columnNumber)), t3.join(":");
  }
  function cn(e) {
    let t3 = e.showColors ? Rp : Cp, r2;
    return r2 = Ap(e, t3), kp(r2, t3);
  }
  var Ks = k(Di());
  function Js(e, t3, r2) {
    let n2 = Hs(e), i = _p(n2), o2 = Lp(i);
    o2 ? pn(o2, t3, r2) : t3.addErrorMessage(() => "Unknown error");
  }
  function Hs(e) {
    return e.errors.flatMap((t3) => t3.kind === "Union" ? Hs(t3) : [t3]);
  }
  function _p(e) {
    let t3 = new Map, r2 = [];
    for (let n2 of e) {
      if (n2.kind !== "InvalidArgumentType") {
        r2.push(n2);
        continue;
      }
      let i = `${n2.selectionPath.join(".")}:${n2.argumentPath.join(".")}`, o2 = t3.get(i);
      o2 ? t3.set(i, { ...n2, argument: { ...n2.argument, typeNames: Np(o2.argument.typeNames, n2.argument.typeNames) } }) : t3.set(i, n2);
    }
    return r2.push(...t3.values()), r2;
  }
  function Np(e, t3) {
    return [...new Set(e.concat(t3))];
  }
  function Lp(e) {
    return Ri(e, (t3, r2) => {
      let n2 = Qs(t3), i = Qs(r2);
      return n2 !== i ? n2 - i : Gs(t3) - Gs(r2);
    });
  }
  function Qs(e) {
    let t3 = 0;
    return Array.isArray(e.selectionPath) && (t3 += e.selectionPath.length), Array.isArray(e.argumentPath) && (t3 += e.argumentPath.length), t3;
  }
  function Gs(e) {
    switch (e.kind) {
      case "InvalidArgumentValue":
      case "ValueTooLarge":
        return 20;
      case "InvalidArgumentType":
        return 10;
      case "RequiredArgumentMissing":
        return -10;
      default:
        return 0;
    }
  }
  var ce = class {
    constructor(t3, r2) {
      this.name = t3;
      this.value = r2;
      this.isRequired = false;
    }
    makeRequired() {
      return this.isRequired = true, this;
    }
    write(t3) {
      let { colors: { green: r2 } } = t3.context;
      t3.addMarginSymbol(r2(this.isRequired ? "+" : "?")), t3.write(r2(this.name)), this.isRequired || t3.write(r2("?")), t3.write(r2(": ")), typeof this.value == "string" ? t3.write(r2(this.value)) : t3.write(this.value);
    }
  };
  var Pt = class {
    constructor(t3 = 0, r2) {
      this.context = r2;
      this.lines = [];
      this.currentLine = "";
      this.currentIndent = 0;
      this.currentIndent = t3;
    }
    write(t3) {
      return typeof t3 == "string" ? this.currentLine += t3 : t3.write(this), this;
    }
    writeJoined(t3, r2, n2 = (i, o2) => o2.write(i)) {
      let i = r2.length - 1;
      for (let o2 = 0;o2 < r2.length; o2++)
        n2(r2[o2], this), o2 !== i && this.write(t3);
      return this;
    }
    writeLine(t3) {
      return this.write(t3).newLine();
    }
    newLine() {
      this.lines.push(this.indentedCurrentLine()), this.currentLine = "", this.marginSymbol = undefined;
      let t3 = this.afterNextNewLineCallback;
      return this.afterNextNewLineCallback = undefined, t3?.(), this;
    }
    withIndent(t3) {
      return this.indent(), t3(this), this.unindent(), this;
    }
    afterNextNewline(t3) {
      return this.afterNextNewLineCallback = t3, this;
    }
    indent() {
      return this.currentIndent++, this;
    }
    unindent() {
      return this.currentIndent > 0 && this.currentIndent--, this;
    }
    addMarginSymbol(t3) {
      return this.marginSymbol = t3, this;
    }
    toString() {
      return this.lines.concat(this.indentedCurrentLine()).join(`
`);
    }
    getCurrentLineLength() {
      return this.currentLine.length;
    }
    indentedCurrentLine() {
      let t3 = this.currentLine.padStart(this.currentLine.length + 2 * this.currentIndent);
      return this.marginSymbol ? this.marginSymbol + t3.slice(1) : t3;
    }
  };
  var dn = class {
    constructor(t3) {
      this.value = t3;
    }
    write(t3) {
      t3.write(this.value);
    }
    markAsError() {
      this.value.markAsError();
    }
  };
  var mn = (e) => e;
  var fn = { bold: mn, red: mn, green: mn, dim: mn, enabled: false };
  var Ws = { bold: H, red: pe, green: Ve, dim: ke, enabled: true };
  var Tt = { write(e) {
    e.writeLine(",");
  } };
  var Pe = class {
    constructor(t3) {
      this.contents = t3;
      this.isUnderlined = false;
      this.color = (t4) => t4;
    }
    underline() {
      return this.isUnderlined = true, this;
    }
    setColor(t3) {
      return this.color = t3, this;
    }
    write(t3) {
      let r2 = t3.getCurrentLineLength();
      t3.write(this.color(this.contents)), this.isUnderlined && t3.afterNextNewline(() => {
        t3.write(" ".repeat(r2)).writeLine(this.color("~".repeat(this.contents.length)));
      });
    }
  };
  var ze = class {
    constructor() {
      this.hasError = false;
    }
    markAsError() {
      return this.hasError = true, this;
    }
  };
  var Rt = class extends ze {
    constructor() {
      super(...arguments);
      this.items = [];
    }
    addItem(r2) {
      return this.items.push(new dn(r2)), this;
    }
    getField(r2) {
      return this.items[r2];
    }
    getPrintWidth() {
      return this.items.length === 0 ? 2 : Math.max(...this.items.map((n2) => n2.value.getPrintWidth())) + 2;
    }
    write(r2) {
      if (this.items.length === 0) {
        this.writeEmpty(r2);
        return;
      }
      this.writeWithItems(r2);
    }
    writeEmpty(r2) {
      let n2 = new Pe("[]");
      this.hasError && n2.setColor(r2.context.colors.red).underline(), r2.write(n2);
    }
    writeWithItems(r2) {
      let { colors: n2 } = r2.context;
      r2.writeLine("[").withIndent(() => r2.writeJoined(Tt, this.items).newLine()).write("]"), this.hasError && r2.afterNextNewline(() => {
        r2.writeLine(n2.red("~".repeat(this.getPrintWidth())));
      });
    }
    asObject() {
    }
  };
  var Ct = class e extends ze {
    constructor() {
      super(...arguments);
      this.fields = {};
      this.suggestions = [];
    }
    addField(r2) {
      this.fields[r2.name] = r2;
    }
    addSuggestion(r2) {
      this.suggestions.push(r2);
    }
    getField(r2) {
      return this.fields[r2];
    }
    getDeepField(r2) {
      let [n2, ...i] = r2, o2 = this.getField(n2);
      if (!o2)
        return;
      let s = o2;
      for (let a13 of i) {
        let l2;
        if (s.value instanceof e ? l2 = s.value.getField(a13) : s.value instanceof Rt && (l2 = s.value.getField(Number(a13))), !l2)
          return;
        s = l2;
      }
      return s;
    }
    getDeepFieldValue(r2) {
      return r2.length === 0 ? this : this.getDeepField(r2)?.value;
    }
    hasField(r2) {
      return !!this.getField(r2);
    }
    removeAllFields() {
      this.fields = {};
    }
    removeField(r2) {
      delete this.fields[r2];
    }
    getFields() {
      return this.fields;
    }
    isEmpty() {
      return Object.keys(this.fields).length === 0;
    }
    getFieldValue(r2) {
      return this.getField(r2)?.value;
    }
    getDeepSubSelectionValue(r2) {
      let n2 = this;
      for (let i of r2) {
        if (!(n2 instanceof e))
          return;
        let o2 = n2.getSubSelectionValue(i);
        if (!o2)
          return;
        n2 = o2;
      }
      return n2;
    }
    getDeepSelectionParent(r2) {
      let n2 = this.getSelectionParent();
      if (!n2)
        return;
      let i = n2;
      for (let o2 of r2) {
        let s = i.value.getFieldValue(o2);
        if (!s || !(s instanceof e))
          return;
        let a13 = s.getSelectionParent();
        if (!a13)
          return;
        i = a13;
      }
      return i;
    }
    getSelectionParent() {
      let r2 = this.getField("select")?.value.asObject();
      if (r2)
        return { kind: "select", value: r2 };
      let n2 = this.getField("include")?.value.asObject();
      if (n2)
        return { kind: "include", value: n2 };
    }
    getSubSelectionValue(r2) {
      return this.getSelectionParent()?.value.fields[r2].value;
    }
    getPrintWidth() {
      let r2 = Object.values(this.fields);
      return r2.length == 0 ? 2 : Math.max(...r2.map((i) => i.getPrintWidth())) + 2;
    }
    write(r2) {
      let n2 = Object.values(this.fields);
      if (n2.length === 0 && this.suggestions.length === 0) {
        this.writeEmpty(r2);
        return;
      }
      this.writeWithContents(r2, n2);
    }
    asObject() {
      return this;
    }
    writeEmpty(r2) {
      let n2 = new Pe("{}");
      this.hasError && n2.setColor(r2.context.colors.red).underline(), r2.write(n2);
    }
    writeWithContents(r2, n2) {
      r2.writeLine("{").withIndent(() => {
        r2.writeJoined(Tt, [...n2, ...this.suggestions]).newLine();
      }), r2.write("}"), this.hasError && r2.afterNextNewline(() => {
        r2.writeLine(r2.context.colors.red("~".repeat(this.getPrintWidth())));
      });
    }
  };
  var J = class extends ze {
    constructor(r2) {
      super();
      this.text = r2;
    }
    getPrintWidth() {
      return this.text.length;
    }
    write(r2) {
      let n2 = new Pe(this.text);
      this.hasError && n2.underline().setColor(r2.context.colors.red), r2.write(n2);
    }
    asObject() {
    }
  };
  var nr = class {
    constructor() {
      this.fields = [];
    }
    addField(t3, r2) {
      return this.fields.push({ write(n2) {
        let { green: i, dim: o2 } = n2.context.colors;
        n2.write(i(o2(`${t3}: ${r2}`))).addMarginSymbol(i(o2("+")));
      } }), this;
    }
    write(t3) {
      let { colors: { green: r2 } } = t3.context;
      t3.writeLine(r2("{")).withIndent(() => {
        t3.writeJoined(Tt, this.fields).newLine();
      }).write(r2("}")).addMarginSymbol(r2("+"));
    }
  };
  function pn(e, t3, r2) {
    switch (e.kind) {
      case "MutuallyExclusiveFields":
        Mp(e, t3);
        break;
      case "IncludeOnScalar":
        $p(e, t3);
        break;
      case "EmptySelection":
        qp(e, t3, r2);
        break;
      case "UnknownSelectionField":
        Up(e, t3);
        break;
      case "InvalidSelectionValue":
        Qp(e, t3);
        break;
      case "UnknownArgument":
        Gp(e, t3);
        break;
      case "UnknownInputField":
        Jp(e, t3);
        break;
      case "RequiredArgumentMissing":
        Hp(e, t3);
        break;
      case "InvalidArgumentType":
        Wp(e, t3);
        break;
      case "InvalidArgumentValue":
        Kp(e, t3);
        break;
      case "ValueTooLarge":
        Yp(e, t3);
        break;
      case "SomeFieldsMissing":
        zp(e, t3);
        break;
      case "TooManyFieldsGiven":
        Zp(e, t3);
        break;
      case "Union":
        Js(e, t3, r2);
        break;
      default:
        throw new Error("not implemented: " + e.kind);
    }
  }
  function Mp(e, t3) {
    let r2 = t3.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();
    r2 && (r2.getField(e.firstField)?.markAsError(), r2.getField(e.secondField)?.markAsError()), t3.addErrorMessage((n2) => `Please ${n2.bold("either")} use ${n2.green(`\`${e.firstField}\``)} or ${n2.green(`\`${e.secondField}\``)}, but ${n2.red("not both")} at the same time.`);
  }
  function $p(e, t3) {
    let [r2, n2] = ir(e.selectionPath), i = e.outputType, o2 = t3.arguments.getDeepSelectionParent(r2)?.value;
    if (o2 && (o2.getField(n2)?.markAsError(), i))
      for (let s of i.fields)
        s.isRelation && o2.addSuggestion(new ce(s.name, "true"));
    t3.addErrorMessage((s) => {
      let a13 = `Invalid scalar field ${s.red(`\`${n2}\``)} for ${s.bold("include")} statement`;
      return i ? a13 += ` on model ${s.bold(i.name)}. ${or(s)}` : a13 += ".", a13 += `
Note that ${s.bold("include")} statements only accept relation fields.`, a13;
    });
  }
  function qp(e, t3, r2) {
    let n2 = t3.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();
    if (n2) {
      let i = n2.getField("omit")?.value.asObject();
      if (i) {
        Vp(e, t3, i);
        return;
      }
      if (n2.hasField("select")) {
        jp(e, t3);
        return;
      }
    }
    if (r2?.[wt(e.outputType.name)]) {
      Bp(e, t3);
      return;
    }
    t3.addErrorMessage(() => `Unknown field at "${e.selectionPath.join(".")} selection"`);
  }
  function Vp(e, t3, r2) {
    r2.removeAllFields();
    for (let n2 of e.outputType.fields)
      r2.addSuggestion(new ce(n2.name, "false"));
    t3.addErrorMessage((n2) => `The ${n2.red("omit")} statement includes every field of the model ${n2.bold(e.outputType.name)}. At least one field must be included in the result`);
  }
  function jp(e, t3) {
    let r2 = e.outputType, n2 = t3.arguments.getDeepSelectionParent(e.selectionPath)?.value, i = n2?.isEmpty() ?? false;
    n2 && (n2.removeAllFields(), Zs(n2, r2)), t3.addErrorMessage((o2) => i ? `The ${o2.red("`select`")} statement for type ${o2.bold(r2.name)} must not be empty. ${or(o2)}` : `The ${o2.red("`select`")} statement for type ${o2.bold(r2.name)} needs ${o2.bold("at least one truthy value")}.`);
  }
  function Bp(e, t3) {
    let r2 = new nr;
    for (let i of e.outputType.fields)
      i.isRelation || r2.addField(i.name, "false");
    let n2 = new ce("omit", r2).makeRequired();
    if (e.selectionPath.length === 0)
      t3.arguments.addSuggestion(n2);
    else {
      let [i, o2] = ir(e.selectionPath), a13 = t3.arguments.getDeepSelectionParent(i)?.value.asObject()?.getField(o2);
      if (a13) {
        let l2 = a13?.value.asObject() ?? new Ct;
        l2.addSuggestion(n2), a13.value = l2;
      }
    }
    t3.addErrorMessage((i) => `The global ${i.red("omit")} configuration excludes every field of the model ${i.bold(e.outputType.name)}. At least one field must be included in the result`);
  }
  function Up(e, t3) {
    let r2 = Xs(e.selectionPath, t3);
    if (r2.parentKind !== "unknown") {
      r2.field.markAsError();
      let n2 = r2.parent;
      switch (r2.parentKind) {
        case "select":
          Zs(n2, e.outputType);
          break;
        case "include":
          Xp(n2, e.outputType);
          break;
        case "omit":
          ed(n2, e.outputType);
          break;
      }
    }
    t3.addErrorMessage((n2) => {
      let i = [`Unknown field ${n2.red(`\`${r2.fieldName}\``)}`];
      return r2.parentKind !== "unknown" && i.push(`for ${n2.bold(r2.parentKind)} statement`), i.push(`on model ${n2.bold(`\`${e.outputType.name}\``)}.`), i.push(or(n2)), i.join(" ");
    });
  }
  function Qp(e, t3) {
    let r2 = Xs(e.selectionPath, t3);
    r2.parentKind !== "unknown" && r2.field.value.markAsError(), t3.addErrorMessage((n2) => `Invalid value for selection field \`${n2.red(r2.fieldName)}\`: ${e.underlyingError}`);
  }
  function Gp(e, t3) {
    let r2 = e.argumentPath[0], n2 = t3.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();
    n2 && (n2.getField(r2)?.markAsError(), td(n2, e.arguments)), t3.addErrorMessage((i) => Ys(i, r2, e.arguments.map((o2) => o2.name)));
  }
  function Jp(e, t3) {
    let [r2, n2] = ir(e.argumentPath), i = t3.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();
    if (i) {
      i.getDeepField(e.argumentPath)?.markAsError();
      let o2 = i.getDeepFieldValue(r2)?.asObject();
      o2 && ea(o2, e.inputType);
    }
    t3.addErrorMessage((o2) => Ys(o2, n2, e.inputType.fields.map((s) => s.name)));
  }
  function Ys(e, t3, r2) {
    let n2 = [`Unknown argument \`${e.red(t3)}\`.`], i = nd(t3, r2);
    return i && n2.push(`Did you mean \`${e.green(i)}\`?`), r2.length > 0 && n2.push(or(e)), n2.join(" ");
  }
  function Hp(e, t3) {
    let r2;
    t3.addErrorMessage((l2) => r2?.value instanceof J && r2.value.text === "null" ? `Argument \`${l2.green(o2)}\` must not be ${l2.red("null")}.` : `Argument \`${l2.green(o2)}\` is missing.`);
    let n2 = t3.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();
    if (!n2)
      return;
    let [i, o2] = ir(e.argumentPath), s = new nr, a13 = n2.getDeepFieldValue(i)?.asObject();
    if (a13)
      if (r2 = a13.getField(o2), r2 && a13.removeField(o2), e.inputTypes.length === 1 && e.inputTypes[0].kind === "object") {
        for (let l2 of e.inputTypes[0].fields)
          s.addField(l2.name, l2.typeNames.join(" | "));
        a13.addSuggestion(new ce(o2, s).makeRequired());
      } else {
        let l2 = e.inputTypes.map(zs).join(" | ");
        a13.addSuggestion(new ce(o2, l2).makeRequired());
      }
  }
  function zs(e) {
    return e.kind === "list" ? `${zs(e.elementType)}[]` : e.name;
  }
  function Wp(e, t3) {
    let r2 = e.argument.name, n2 = t3.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();
    n2 && n2.getDeepFieldValue(e.argumentPath)?.markAsError(), t3.addErrorMessage((i) => {
      let o2 = gn("or", e.argument.typeNames.map((s) => i.green(s)));
      return `Argument \`${i.bold(r2)}\`: Invalid value provided. Expected ${o2}, provided ${i.red(e.inferredType)}.`;
    });
  }
  function Kp(e, t3) {
    let r2 = e.argument.name, n2 = t3.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();
    n2 && n2.getDeepFieldValue(e.argumentPath)?.markAsError(), t3.addErrorMessage((i) => {
      let o2 = [`Invalid value for argument \`${i.bold(r2)}\``];
      if (e.underlyingError && o2.push(`: ${e.underlyingError}`), o2.push("."), e.argument.typeNames.length > 0) {
        let s = gn("or", e.argument.typeNames.map((a13) => i.green(a13)));
        o2.push(` Expected ${s}.`);
      }
      return o2.join("");
    });
  }
  function Yp(e, t3) {
    let r2 = e.argument.name, n2 = t3.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject(), i;
    if (n2) {
      let s = n2.getDeepField(e.argumentPath)?.value;
      s?.markAsError(), s instanceof J && (i = s.text);
    }
    t3.addErrorMessage((o2) => {
      let s = ["Unable to fit value"];
      return i && s.push(o2.red(i)), s.push(`into a 64-bit signed integer for field \`${o2.bold(r2)}\``), s.join(" ");
    });
  }
  function zp(e, t3) {
    let r2 = e.argumentPath[e.argumentPath.length - 1], n2 = t3.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();
    if (n2) {
      let i = n2.getDeepFieldValue(e.argumentPath)?.asObject();
      i && ea(i, e.inputType);
    }
    t3.addErrorMessage((i) => {
      let o2 = [`Argument \`${i.bold(r2)}\` of type ${i.bold(e.inputType.name)} needs`];
      return e.constraints.minFieldCount === 1 ? e.constraints.requiredFields ? o2.push(`${i.green("at least one of")} ${gn("or", e.constraints.requiredFields.map((s) => `\`${i.bold(s)}\``))} arguments.`) : o2.push(`${i.green("at least one")} argument.`) : o2.push(`${i.green(`at least ${e.constraints.minFieldCount}`)} arguments.`), o2.push(or(i)), o2.join(" ");
    });
  }
  function Zp(e, t3) {
    let r2 = e.argumentPath[e.argumentPath.length - 1], n2 = t3.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject(), i = [];
    if (n2) {
      let o2 = n2.getDeepFieldValue(e.argumentPath)?.asObject();
      o2 && (o2.markAsError(), i = Object.keys(o2.getFields()));
    }
    t3.addErrorMessage((o2) => {
      let s = [`Argument \`${o2.bold(r2)}\` of type ${o2.bold(e.inputType.name)} needs`];
      return e.constraints.minFieldCount === 1 && e.constraints.maxFieldCount == 1 ? s.push(`${o2.green("exactly one")} argument,`) : e.constraints.maxFieldCount == 1 ? s.push(`${o2.green("at most one")} argument,`) : s.push(`${o2.green(`at most ${e.constraints.maxFieldCount}`)} arguments,`), s.push(`but you provided ${gn("and", i.map((a13) => o2.red(a13)))}. Please choose`), e.constraints.maxFieldCount === 1 ? s.push("one.") : s.push(`${e.constraints.maxFieldCount}.`), s.join(" ");
    });
  }
  function Zs(e, t3) {
    for (let r2 of t3.fields)
      e.hasField(r2.name) || e.addSuggestion(new ce(r2.name, "true"));
  }
  function Xp(e, t3) {
    for (let r2 of t3.fields)
      r2.isRelation && !e.hasField(r2.name) && e.addSuggestion(new ce(r2.name, "true"));
  }
  function ed(e, t3) {
    for (let r2 of t3.fields)
      !e.hasField(r2.name) && !r2.isRelation && e.addSuggestion(new ce(r2.name, "true"));
  }
  function td(e, t3) {
    for (let r2 of t3)
      e.hasField(r2.name) || e.addSuggestion(new ce(r2.name, r2.typeNames.join(" | ")));
  }
  function Xs(e, t3) {
    let [r2, n2] = ir(e), i = t3.arguments.getDeepSubSelectionValue(r2)?.asObject();
    if (!i)
      return { parentKind: "unknown", fieldName: n2 };
    let o2 = i.getFieldValue("select")?.asObject(), s = i.getFieldValue("include")?.asObject(), a13 = i.getFieldValue("omit")?.asObject(), l2 = o2?.getField(n2);
    return o2 && l2 ? { parentKind: "select", parent: o2, field: l2, fieldName: n2 } : (l2 = s?.getField(n2), s && l2 ? { parentKind: "include", field: l2, parent: s, fieldName: n2 } : (l2 = a13?.getField(n2), a13 && l2 ? { parentKind: "omit", field: l2, parent: a13, fieldName: n2 } : { parentKind: "unknown", fieldName: n2 }));
  }
  function ea(e, t3) {
    if (t3.kind === "object")
      for (let r2 of t3.fields)
        e.hasField(r2.name) || e.addSuggestion(new ce(r2.name, r2.typeNames.join(" | ")));
  }
  function ir(e) {
    let t3 = [...e], r2 = t3.pop();
    if (!r2)
      throw new Error("unexpected empty path");
    return [t3, r2];
  }
  function or({ green: e, enabled: t3 }) {
    return "Available options are " + (t3 ? `listed in ${e("green")}` : "marked with ?") + ".";
  }
  function gn(e, t3) {
    if (t3.length === 1)
      return t3[0];
    let r2 = [...t3], n2 = r2.pop();
    return `${r2.join(", ")} ${e} ${n2}`;
  }
  var rd = 3;
  function nd(e, t3) {
    let r2 = 1 / 0, n2;
    for (let i of t3) {
      let o2 = (0, Ks.default)(e, i);
      o2 > rd || o2 < r2 && (r2 = o2, n2 = i);
    }
    return n2;
  }
  function ta(e) {
    return e.substring(0, 1).toLowerCase() + e.substring(1);
  }
  var sr = class {
    constructor(t3, r2, n2, i, o2) {
      this.modelName = t3, this.name = r2, this.typeName = n2, this.isList = i, this.isEnum = o2;
    }
    _toGraphQLInputType() {
      let t3 = this.isList ? "List" : "", r2 = this.isEnum ? "Enum" : "";
      return `${t3}${r2}${this.typeName}FieldRefInput<${this.modelName}>`;
    }
  };
  function St(e) {
    return e instanceof sr;
  }
  var hn = Symbol();
  var _i = new WeakMap;
  var $e = class {
    constructor(t3) {
      t3 === hn ? _i.set(this, `Prisma.${this._getName()}`) : _i.set(this, `new Prisma.${this._getNamespace()}.${this._getName()}()`);
    }
    _getName() {
      return this.constructor.name;
    }
    toString() {
      return _i.get(this);
    }
  };
  var ar = class extends $e {
    _getNamespace() {
      return "NullTypes";
    }
  };
  var lr = class extends ar {
  };
  Ni(lr, "DbNull");
  var ur = class extends ar {
  };
  Ni(ur, "JsonNull");
  var cr = class extends ar {
  };
  Ni(cr, "AnyNull");
  var yn = { classes: { DbNull: lr, JsonNull: ur, AnyNull: cr }, instances: { DbNull: new lr(hn), JsonNull: new ur(hn), AnyNull: new cr(hn) } };
  function Ni(e, t3) {
    Object.defineProperty(e, "name", { value: t3, configurable: true });
  }
  var ra = ": ";
  var En = class {
    constructor(t3, r2) {
      this.name = t3;
      this.value = r2;
      this.hasError = false;
    }
    markAsError() {
      this.hasError = true;
    }
    getPrintWidth() {
      return this.name.length + this.value.getPrintWidth() + ra.length;
    }
    write(t3) {
      let r2 = new Pe(this.name);
      this.hasError && r2.underline().setColor(t3.context.colors.red), t3.write(r2).write(ra).write(this.value);
    }
  };
  var Li = class {
    constructor(t3) {
      this.errorMessages = [];
      this.arguments = t3;
    }
    write(t3) {
      t3.write(this.arguments);
    }
    addErrorMessage(t3) {
      this.errorMessages.push(t3);
    }
    renderAllMessages(t3) {
      return this.errorMessages.map((r2) => r2(t3)).join(`
`);
    }
  };
  function At(e) {
    return new Li(na(e));
  }
  function na(e) {
    let t3 = new Ct;
    for (let [r2, n2] of Object.entries(e)) {
      let i = new En(r2, ia(n2));
      t3.addField(i);
    }
    return t3;
  }
  function ia(e) {
    if (typeof e == "string")
      return new J(JSON.stringify(e));
    if (typeof e == "number" || typeof e == "boolean")
      return new J(String(e));
    if (typeof e == "bigint")
      return new J(`${e}n`);
    if (e === null)
      return new J("null");
    if (e === undefined)
      return new J("undefined");
    if (vt(e))
      return new J(`new Prisma.Decimal("${e.toFixed()}")`);
    if (e instanceof Uint8Array)
      return Buffer.isBuffer(e) ? new J(`Buffer.alloc(${e.byteLength})`) : new J(`new Uint8Array(${e.byteLength})`);
    if (e instanceof Date) {
      let t3 = an(e) ? e.toISOString() : "Invalid Date";
      return new J(`new Date("${t3}")`);
    }
    return e instanceof $e ? new J(`Prisma.${e._getName()}`) : St(e) ? new J(`prisma.${ta(e.modelName)}.$fields.${e.name}`) : Array.isArray(e) ? id(e) : typeof e == "object" ? na(e) : new J(Object.prototype.toString.call(e));
  }
  function id(e) {
    let t3 = new Rt;
    for (let r2 of e)
      t3.addItem(ia(r2));
    return t3;
  }
  function bn(e, t3) {
    let r2 = t3 === "pretty" ? Ws : fn, n2 = e.renderAllMessages(r2), i = new Pt(0, { colors: r2 }).write(e).toString();
    return { message: n2, args: i };
  }
  function wn({ args: e, errors: t3, errorFormat: r2, callsite: n2, originalMethod: i, clientVersion: o2, globalOmit: s }) {
    let a13 = At(e);
    for (let p of t3)
      pn(p, a13, s);
    let { message: l2, args: u } = bn(a13, r2), c2 = cn({ message: l2, callsite: n2, originalMethod: i, showColors: r2 === "pretty", callArguments: u });
    throw new ee(c2, { clientVersion: o2 });
  }
  var Te = class {
    constructor() {
      this._map = new Map;
    }
    get(t3) {
      return this._map.get(t3)?.value;
    }
    set(t3, r2) {
      this._map.set(t3, { value: r2 });
    }
    getOrCreate(t3, r2) {
      let n2 = this._map.get(t3);
      if (n2)
        return n2.value;
      let i = r2();
      return this.set(t3, i), i;
    }
  };
  function pr(e) {
    let t3;
    return { get() {
      return t3 || (t3 = { value: e() }), t3.value;
    } };
  }
  function Re(e) {
    return e.replace(/^./, (t3) => t3.toLowerCase());
  }
  function sa(e, t3, r2) {
    let n2 = Re(r2);
    return !t3.result || !(t3.result.$allModels || t3.result[n2]) ? e : od({ ...e, ...oa(t3.name, e, t3.result.$allModels), ...oa(t3.name, e, t3.result[n2]) });
  }
  function od(e) {
    let t3 = new Te, r2 = (n2, i) => t3.getOrCreate(n2, () => i.has(n2) ? [n2] : (i.add(n2), e[n2] ? e[n2].needs.flatMap((o2) => r2(o2, i)) : [n2]));
    return ht(e, (n2) => ({ ...n2, needs: r2(n2.name, new Set) }));
  }
  function oa(e, t3, r2) {
    return r2 ? ht(r2, ({ needs: n2, compute: i }, o2) => ({ name: o2, needs: n2 ? Object.keys(n2).filter((s) => n2[s]) : [], compute: sd(t3, o2, i) })) : {};
  }
  function sd(e, t3, r2) {
    let n2 = e?.[t3]?.compute;
    return n2 ? (i) => r2({ ...i, [t3]: n2(i) }) : r2;
  }
  function aa(e, t3) {
    if (!t3)
      return e;
    let r2 = { ...e };
    for (let n2 of Object.values(t3))
      if (e[n2.name])
        for (let i of n2.needs)
          r2[i] = true;
    return r2;
  }
  function la(e, t3) {
    if (!t3)
      return e;
    let r2 = { ...e };
    for (let n2 of Object.values(t3))
      if (!e[n2.name])
        for (let i of n2.needs)
          delete r2[i];
    return r2;
  }
  var xn = class {
    constructor(t3, r2) {
      this.extension = t3;
      this.previous = r2;
      this.computedFieldsCache = new Te;
      this.modelExtensionsCache = new Te;
      this.queryCallbacksCache = new Te;
      this.clientExtensions = pr(() => this.extension.client ? { ...this.previous?.getAllClientExtensions(), ...this.extension.client } : this.previous?.getAllClientExtensions());
      this.batchCallbacks = pr(() => {
        let t4 = this.previous?.getAllBatchQueryCallbacks() ?? [], r3 = this.extension.query?.$__internalBatch;
        return r3 ? t4.concat(r3) : t4;
      });
    }
    getAllComputedFields(t3) {
      return this.computedFieldsCache.getOrCreate(t3, () => sa(this.previous?.getAllComputedFields(t3), this.extension, t3));
    }
    getAllClientExtensions() {
      return this.clientExtensions.get();
    }
    getAllModelExtensions(t3) {
      return this.modelExtensionsCache.getOrCreate(t3, () => {
        let r2 = Re(t3);
        return !this.extension.model || !(this.extension.model[r2] || this.extension.model.$allModels) ? this.previous?.getAllModelExtensions(t3) : { ...this.previous?.getAllModelExtensions(t3), ...this.extension.model.$allModels, ...this.extension.model[r2] };
      });
    }
    getAllQueryCallbacks(t3, r2) {
      return this.queryCallbacksCache.getOrCreate(`${t3}:${r2}`, () => {
        let n2 = this.previous?.getAllQueryCallbacks(t3, r2) ?? [], i = [], o2 = this.extension.query;
        return !o2 || !(o2[t3] || o2.$allModels || o2[r2] || o2.$allOperations) ? n2 : (o2[t3] !== undefined && (o2[t3][r2] !== undefined && i.push(o2[t3][r2]), o2[t3].$allOperations !== undefined && i.push(o2[t3].$allOperations)), t3 !== "$none" && o2.$allModels !== undefined && (o2.$allModels[r2] !== undefined && i.push(o2.$allModels[r2]), o2.$allModels.$allOperations !== undefined && i.push(o2.$allModels.$allOperations)), o2[r2] !== undefined && i.push(o2[r2]), o2.$allOperations !== undefined && i.push(o2.$allOperations), n2.concat(i));
      });
    }
    getAllBatchQueryCallbacks() {
      return this.batchCallbacks.get();
    }
  };
  var It = class e {
    constructor(t3) {
      this.head = t3;
    }
    static empty() {
      return new e;
    }
    static single(t3) {
      return new e(new xn(t3));
    }
    isEmpty() {
      return this.head === undefined;
    }
    append(t3) {
      return new e(new xn(t3, this.head));
    }
    getAllComputedFields(t3) {
      return this.head?.getAllComputedFields(t3);
    }
    getAllClientExtensions() {
      return this.head?.getAllClientExtensions();
    }
    getAllModelExtensions(t3) {
      return this.head?.getAllModelExtensions(t3);
    }
    getAllQueryCallbacks(t3, r2) {
      return this.head?.getAllQueryCallbacks(t3, r2) ?? [];
    }
    getAllBatchQueryCallbacks() {
      return this.head?.getAllBatchQueryCallbacks() ?? [];
    }
  };
  var ua = Symbol();
  var dr = class {
    constructor(t3) {
      if (t3 !== ua)
        throw new Error("Skip instance can not be constructed directly");
    }
    ifUndefined(t3) {
      return t3 === undefined ? vn : t3;
    }
  };
  var vn = new dr(ua);
  function Ce(e) {
    return e instanceof dr;
  }
  var ad = { findUnique: "findUnique", findUniqueOrThrow: "findUniqueOrThrow", findFirst: "findFirst", findFirstOrThrow: "findFirstOrThrow", findMany: "findMany", count: "aggregate", create: "createOne", createMany: "createMany", createManyAndReturn: "createManyAndReturn", update: "updateOne", updateMany: "updateMany", upsert: "upsertOne", delete: "deleteOne", deleteMany: "deleteMany", executeRaw: "executeRaw", queryRaw: "queryRaw", aggregate: "aggregate", groupBy: "groupBy", runCommandRaw: "runCommandRaw", findRaw: "findRaw", aggregateRaw: "aggregateRaw" };
  var ca = "explicitly `undefined` values are not allowed";
  function Pn({ modelName: e, action: t3, args: r2, runtimeDataModel: n2, extensions: i = It.empty(), callsite: o2, clientMethod: s, errorFormat: a13, clientVersion: l2, previewFeatures: u, globalOmit: c2 }) {
    let p = new Fi({ runtimeDataModel: n2, modelName: e, action: t3, rootArgs: r2, callsite: o2, extensions: i, selectionPath: [], argumentPath: [], originalMethod: s, errorFormat: a13, clientVersion: l2, previewFeatures: u, globalOmit: c2 });
    return { modelName: e, action: ad[t3], query: mr(r2, p) };
  }
  function mr({ select: e, include: t3, ...r2 } = {}, n2) {
    let i;
    return n2.isPreviewFeatureOn("omitApi") && (i = r2.omit, delete r2.omit), { arguments: da(r2, n2), selection: ld(e, t3, i, n2) };
  }
  function ld(e, t3, r2, n2) {
    return e ? (t3 ? n2.throwValidationError({ kind: "MutuallyExclusiveFields", firstField: "include", secondField: "select", selectionPath: n2.getSelectionPath() }) : r2 && n2.isPreviewFeatureOn("omitApi") && n2.throwValidationError({ kind: "MutuallyExclusiveFields", firstField: "omit", secondField: "select", selectionPath: n2.getSelectionPath() }), dd(e, n2)) : ud(n2, t3, r2);
  }
  function ud(e, t3, r2) {
    let n2 = {};
    return e.modelOrType && !e.isRawAction() && (n2.$composites = true, n2.$scalars = true), t3 && cd(n2, t3, e), e.isPreviewFeatureOn("omitApi") && pd(n2, r2, e), n2;
  }
  function cd(e, t3, r2) {
    for (let [n2, i] of Object.entries(t3)) {
      if (Ce(i))
        continue;
      let o2 = r2.nestSelection(n2);
      if (Mi(i, o2), i === false || i === undefined) {
        e[n2] = false;
        continue;
      }
      let s = r2.findField(n2);
      if (s && s.kind !== "object" && r2.throwValidationError({ kind: "IncludeOnScalar", selectionPath: r2.getSelectionPath().concat(n2), outputType: r2.getOutputTypeDescription() }), s) {
        e[n2] = mr(i === true ? {} : i, o2);
        continue;
      }
      if (i === true) {
        e[n2] = true;
        continue;
      }
      e[n2] = mr(i, o2);
    }
  }
  function pd(e, t3, r2) {
    let n2 = r2.getComputedFields(), i = { ...r2.getGlobalOmit(), ...t3 }, o2 = la(i, n2);
    for (let [s, a13] of Object.entries(o2)) {
      if (Ce(a13))
        continue;
      Mi(a13, r2.nestSelection(s));
      let l2 = r2.findField(s);
      n2?.[s] && !l2 || (e[s] = !a13);
    }
  }
  function dd(e, t3) {
    let r2 = {}, n2 = t3.getComputedFields(), i = aa(e, n2);
    for (let [o2, s] of Object.entries(i)) {
      if (Ce(s))
        continue;
      let a13 = t3.nestSelection(o2);
      Mi(s, a13);
      let l2 = t3.findField(o2);
      if (!(n2?.[o2] && !l2)) {
        if (s === false || s === undefined || Ce(s)) {
          r2[o2] = false;
          continue;
        }
        if (s === true) {
          l2?.kind === "object" ? r2[o2] = mr({}, a13) : r2[o2] = true;
          continue;
        }
        r2[o2] = mr(s, a13);
      }
    }
    return r2;
  }
  function pa(e, t3) {
    if (e === null)
      return null;
    if (typeof e == "string" || typeof e == "number" || typeof e == "boolean")
      return e;
    if (typeof e == "bigint")
      return { $type: "BigInt", value: String(e) };
    if (xt(e)) {
      if (an(e))
        return { $type: "DateTime", value: e.toISOString() };
      t3.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: t3.getSelectionPath(), argumentPath: t3.getArgumentPath(), argument: { name: t3.getArgumentName(), typeNames: ["Date"] }, underlyingError: "Provided Date object is invalid" });
    }
    if (St(e))
      return { $type: "FieldRef", value: { _ref: e.name, _container: e.modelName } };
    if (Array.isArray(e))
      return md(e, t3);
    if (ArrayBuffer.isView(e)) {
      let { buffer: r2, byteOffset: n2, byteLength: i } = e;
      return { $type: "Bytes", value: Buffer.from(r2, n2, i).toString("base64") };
    }
    if (fd(e))
      return e.values;
    if (vt(e))
      return { $type: "Decimal", value: e.toFixed() };
    if (e instanceof $e) {
      if (e !== yn.instances[e._getName()])
        throw new Error("Invalid ObjectEnumValue");
      return { $type: "Enum", value: e._getName() };
    }
    if (gd(e))
      return e.toJSON();
    if (typeof e == "object")
      return da(e, t3);
    t3.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: t3.getSelectionPath(), argumentPath: t3.getArgumentPath(), argument: { name: t3.getArgumentName(), typeNames: [] }, underlyingError: `We could not serialize ${Object.prototype.toString.call(e)} value. Serialize the object to JSON or implement a ".toJSON()" method on it` });
  }
  function da(e, t3) {
    if (e.$type)
      return { $type: "Raw", value: e };
    let r2 = {};
    for (let n2 in e) {
      let i = e[n2], o2 = t3.nestArgument(n2);
      Ce(i) || (i !== undefined ? r2[n2] = pa(i, o2) : t3.isPreviewFeatureOn("strictUndefinedChecks") && t3.throwValidationError({ kind: "InvalidArgumentValue", argumentPath: o2.getArgumentPath(), selectionPath: t3.getSelectionPath(), argument: { name: t3.getArgumentName(), typeNames: [] }, underlyingError: ca }));
    }
    return r2;
  }
  function md(e, t3) {
    let r2 = [];
    for (let n2 = 0;n2 < e.length; n2++) {
      let i = t3.nestArgument(String(n2)), o2 = e[n2];
      if (o2 === undefined || Ce(o2)) {
        let s = o2 === undefined ? "undefined" : "Prisma.skip";
        t3.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: i.getSelectionPath(), argumentPath: i.getArgumentPath(), argument: { name: `${t3.getArgumentName()}[${n2}]`, typeNames: [] }, underlyingError: `Can not use \`${s}\` value within array. Use \`null\` or filter out \`${s}\` values` });
      }
      r2.push(pa(o2, i));
    }
    return r2;
  }
  function fd(e) {
    return typeof e == "object" && e !== null && e.__prismaRawParameters__ === true;
  }
  function gd(e) {
    return typeof e == "object" && e !== null && typeof e.toJSON == "function";
  }
  function Mi(e, t3) {
    e === undefined && t3.isPreviewFeatureOn("strictUndefinedChecks") && t3.throwValidationError({ kind: "InvalidSelectionValue", selectionPath: t3.getSelectionPath(), underlyingError: ca });
  }
  var Fi = class e {
    constructor(t3) {
      this.params = t3;
      this.params.modelName && (this.modelOrType = this.params.runtimeDataModel.models[this.params.modelName] ?? this.params.runtimeDataModel.types[this.params.modelName]);
    }
    throwValidationError(t3) {
      wn({ errors: [t3], originalMethod: this.params.originalMethod, args: this.params.rootArgs ?? {}, callsite: this.params.callsite, errorFormat: this.params.errorFormat, clientVersion: this.params.clientVersion, globalOmit: this.params.globalOmit });
    }
    getSelectionPath() {
      return this.params.selectionPath;
    }
    getArgumentPath() {
      return this.params.argumentPath;
    }
    getArgumentName() {
      return this.params.argumentPath[this.params.argumentPath.length - 1];
    }
    getOutputTypeDescription() {
      if (!(!this.params.modelName || !this.modelOrType))
        return { name: this.params.modelName, fields: this.modelOrType.fields.map((t3) => ({ name: t3.name, typeName: "boolean", isRelation: t3.kind === "object" })) };
    }
    isRawAction() {
      return ["executeRaw", "queryRaw", "runCommandRaw", "findRaw", "aggregateRaw"].includes(this.params.action);
    }
    isPreviewFeatureOn(t3) {
      return this.params.previewFeatures.includes(t3);
    }
    getComputedFields() {
      if (this.params.modelName)
        return this.params.extensions.getAllComputedFields(this.params.modelName);
    }
    findField(t3) {
      return this.modelOrType?.fields.find((r2) => r2.name === t3);
    }
    nestSelection(t3) {
      let r2 = this.findField(t3), n2 = r2?.kind === "object" ? r2.type : undefined;
      return new e({ ...this.params, modelName: n2, selectionPath: this.params.selectionPath.concat(t3) });
    }
    getGlobalOmit() {
      return this.params.modelName && this.shouldApplyGlobalOmit() ? this.params.globalOmit?.[wt(this.params.modelName)] ?? {} : {};
    }
    shouldApplyGlobalOmit() {
      switch (this.params.action) {
        case "findFirst":
        case "findFirstOrThrow":
        case "findUniqueOrThrow":
        case "findMany":
        case "upsert":
        case "findUnique":
        case "createManyAndReturn":
        case "create":
        case "update":
        case "delete":
          return true;
        case "executeRaw":
        case "aggregateRaw":
        case "runCommandRaw":
        case "findRaw":
        case "createMany":
        case "deleteMany":
        case "groupBy":
        case "updateMany":
        case "count":
        case "aggregate":
        case "queryRaw":
          return false;
        default:
          Fe(this.params.action, "Unknown action");
      }
    }
    nestArgument(t3) {
      return new e({ ...this.params, argumentPath: this.params.argumentPath.concat(t3) });
    }
  };
  var Ot = class {
    constructor(t3) {
      this._engine = t3;
    }
    prometheus(t3) {
      return this._engine.metrics({ format: "prometheus", ...t3 });
    }
    json(t3) {
      return this._engine.metrics({ format: "json", ...t3 });
    }
  };
  function ma(e) {
    return { models: $i(e.models), enums: $i(e.enums), types: $i(e.types) };
  }
  function $i(e) {
    let t3 = {};
    for (let { name: r2, ...n2 } of e)
      t3[r2] = n2;
    return t3;
  }
  function fa(e, t3) {
    let r2 = pr(() => hd(t3));
    Object.defineProperty(e, "dmmf", { get: () => r2.get() });
  }
  function hd(e) {
    return { datamodel: { models: qi(e.models), enums: qi(e.enums), types: qi(e.types) } };
  }
  function qi(e) {
    return Object.entries(e).map(([t3, r2]) => ({ name: t3, ...r2 }));
  }
  var Vi = new WeakMap;
  var Tn = "$$PrismaTypedSql";
  var ji = class {
    constructor(t3, r2) {
      Vi.set(this, { sql: t3, values: r2 }), Object.defineProperty(this, Tn, { value: Tn });
    }
    get sql() {
      return Vi.get(this).sql;
    }
    get values() {
      return Vi.get(this).values;
    }
  };
  function ga(e) {
    return (...t3) => new ji(e, t3);
  }
  function ha(e) {
    return e != null && e[Tn] === Tn;
  }
  function fr(e) {
    return { ok: false, error: e, map() {
      return fr(e);
    }, flatMap() {
      return fr(e);
    } };
  }
  var Bi = class {
    constructor() {
      this.registeredErrors = [];
    }
    consumeError(t3) {
      return this.registeredErrors[t3];
    }
    registerNewError(t3) {
      let r2 = 0;
      for (;this.registeredErrors[r2] !== undefined; )
        r2++;
      return this.registeredErrors[r2] = { error: t3 }, r2;
    }
  };
  var Ui = (e) => {
    let t3 = new Bi, r2 = Se(t3, e.transactionContext.bind(e)), n2 = { adapterName: e.adapterName, errorRegistry: t3, queryRaw: Se(t3, e.queryRaw.bind(e)), executeRaw: Se(t3, e.executeRaw.bind(e)), provider: e.provider, transactionContext: async (...i) => (await r2(...i)).map((s) => yd(t3, s)) };
    return e.getConnectionInfo && (n2.getConnectionInfo = bd(t3, e.getConnectionInfo.bind(e))), n2;
  };
  var yd = (e, t3) => {
    let r2 = Se(e, t3.startTransaction.bind(t3));
    return { adapterName: t3.adapterName, provider: t3.provider, queryRaw: Se(e, t3.queryRaw.bind(t3)), executeRaw: Se(e, t3.executeRaw.bind(t3)), startTransaction: async (...n2) => (await r2(...n2)).map((o2) => Ed(e, o2)) };
  };
  var Ed = (e, t3) => ({ adapterName: t3.adapterName, provider: t3.provider, options: t3.options, queryRaw: Se(e, t3.queryRaw.bind(t3)), executeRaw: Se(e, t3.executeRaw.bind(t3)), commit: Se(e, t3.commit.bind(t3)), rollback: Se(e, t3.rollback.bind(t3)) });
  function Se(e, t3) {
    return async (...r2) => {
      try {
        return await t3(...r2);
      } catch (n2) {
        let i = e.registerNewError(n2);
        return fr({ kind: "GenericJs", id: i });
      }
    };
  }
  function bd(e, t3) {
    return (...r2) => {
      try {
        return t3(...r2);
      } catch (n2) {
        let i = e.registerNewError(n2);
        return fr({ kind: "GenericJs", id: i });
      }
    };
  }
  var Kl = k(ai());
  var Yl = import.meta.require("async_hooks");
  var zl = import.meta.require("events");
  var Zl = k(import.meta.require("fs"));
  var Nr = k(import.meta.require("path"));
  var se = class e {
    constructor(t3, r2) {
      if (t3.length - 1 !== r2.length)
        throw t3.length === 0 ? new TypeError("Expected at least 1 string") : new TypeError(`Expected ${t3.length} strings to have ${t3.length - 1} values`);
      let n2 = r2.reduce((s, a13) => s + (a13 instanceof e ? a13.values.length : 1), 0);
      this.values = new Array(n2), this.strings = new Array(n2 + 1), this.strings[0] = t3[0];
      let i = 0, o2 = 0;
      for (;i < r2.length; ) {
        let s = r2[i++], a13 = t3[i];
        if (s instanceof e) {
          this.strings[o2] += s.strings[0];
          let l2 = 0;
          for (;l2 < s.values.length; )
            this.values[o2++] = s.values[l2++], this.strings[o2] = s.strings[l2];
          this.strings[o2] += a13;
        } else
          this.values[o2++] = s, this.strings[o2] = a13;
      }
    }
    get sql() {
      let t3 = this.strings.length, r2 = 1, n2 = this.strings[0];
      for (;r2 < t3; )
        n2 += `?${this.strings[r2++]}`;
      return n2;
    }
    get statement() {
      let t3 = this.strings.length, r2 = 1, n2 = this.strings[0];
      for (;r2 < t3; )
        n2 += `:${r2}${this.strings[r2++]}`;
      return n2;
    }
    get text() {
      let t3 = this.strings.length, r2 = 1, n2 = this.strings[0];
      for (;r2 < t3; )
        n2 += `$${r2}${this.strings[r2++]}`;
      return n2;
    }
    inspect() {
      return { sql: this.sql, statement: this.statement, text: this.text, values: this.values };
    }
  };
  function ya(e, t3 = ",", r2 = "", n2 = "") {
    if (e.length === 0)
      throw new TypeError("Expected `join([])` to be called with an array of multiple elements, but got an empty array");
    return new se([r2, ...Array(e.length - 1).fill(t3), n2], e);
  }
  function Qi(e) {
    return new se([e], []);
  }
  var Ea = Qi("");
  function Gi(e, ...t3) {
    return new se(e, t3);
  }
  function gr(e) {
    return { getKeys() {
      return Object.keys(e);
    }, getPropertyValue(t3) {
      return e[t3];
    } };
  }
  function ne(e, t3) {
    return { getKeys() {
      return [e];
    }, getPropertyValue() {
      return t3();
    } };
  }
  function ot(e) {
    let t3 = new Te;
    return { getKeys() {
      return e.getKeys();
    }, getPropertyValue(r2) {
      return t3.getOrCreate(r2, () => e.getPropertyValue(r2));
    }, getPropertyDescriptor(r2) {
      return e.getPropertyDescriptor?.(r2);
    } };
  }
  var Rn = { enumerable: true, configurable: true, writable: true };
  function Cn(e) {
    let t3 = new Set(e);
    return { getOwnPropertyDescriptor: () => Rn, has: (r2, n2) => t3.has(n2), set: (r2, n2, i) => t3.add(n2) && Reflect.set(r2, n2, i), ownKeys: () => [...t3] };
  }
  var ba = Symbol.for("nodejs.util.inspect.custom");
  function Ae(e, t3) {
    let r2 = wd(t3), n2 = new Set, i = new Proxy(e, { get(o2, s) {
      if (n2.has(s))
        return o2[s];
      let a13 = r2.get(s);
      return a13 ? a13.getPropertyValue(s) : o2[s];
    }, has(o2, s) {
      if (n2.has(s))
        return true;
      let a13 = r2.get(s);
      return a13 ? a13.has?.(s) ?? true : Reflect.has(o2, s);
    }, ownKeys(o2) {
      let s = wa(Reflect.ownKeys(o2), r2), a13 = wa(Array.from(r2.keys()), r2);
      return [...new Set([...s, ...a13, ...n2])];
    }, set(o2, s, a13) {
      return r2.get(s)?.getPropertyDescriptor?.(s)?.writable === false ? false : (n2.add(s), Reflect.set(o2, s, a13));
    }, getOwnPropertyDescriptor(o2, s) {
      let a13 = Reflect.getOwnPropertyDescriptor(o2, s);
      if (a13 && !a13.configurable)
        return a13;
      let l2 = r2.get(s);
      return l2 ? l2.getPropertyDescriptor ? { ...Rn, ...l2?.getPropertyDescriptor(s) } : Rn : a13;
    }, defineProperty(o2, s, a13) {
      return n2.add(s), Reflect.defineProperty(o2, s, a13);
    } });
    return i[ba] = function() {
      let o2 = { ...this };
      return delete o2[ba], o2;
    }, i;
  }
  function wd(e) {
    let t3 = new Map;
    for (let r2 of e) {
      let n2 = r2.getKeys();
      for (let i of n2)
        t3.set(i, r2);
    }
    return t3;
  }
  function wa(e, t3) {
    return e.filter((r2) => t3.get(r2)?.has?.(r2) ?? true);
  }
  function kt(e) {
    return { getKeys() {
      return e;
    }, has() {
      return false;
    }, getPropertyValue() {
    } };
  }
  function Dt(e, t3) {
    return { batch: e, transaction: t3?.kind === "batch" ? { isolationLevel: t3.options.isolationLevel } : undefined };
  }
  function xa(e) {
    if (e === undefined)
      return "";
    let t3 = At(e);
    return new Pt(0, { colors: fn }).write(t3).toString();
  }
  var xd = "P2037";
  function _t({ error: e, user_facing_error: t3 }, r2, n2) {
    return t3.error_code ? new X(vd(t3, n2), { code: t3.error_code, clientVersion: r2, meta: t3.meta, batchRequestIdx: t3.batch_request_idx }) : new j(e, { clientVersion: r2, batchRequestIdx: t3.batch_request_idx });
  }
  function vd(e, t3) {
    let r2 = e.message;
    return (t3 === "postgresql" || t3 === "postgres" || t3 === "mysql") && e.error_code === xd && (r2 += `
Prisma Accelerate has built-in connection pooling to prevent such errors: https://pris.ly/client/error-accelerate`), r2;
  }
  var hr = "<unknown>";
  function va(e) {
    var t3 = e.split(`
`);
    return t3.reduce(function(r2, n2) {
      var i = Rd(n2) || Sd(n2) || Od(n2) || Nd(n2) || Dd(n2);
      return i && r2.push(i), r2;
    }, []);
  }
  var Pd = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
  var Td = /\((\S*)(?::(\d+))(?::(\d+))\)/;
  function Rd(e) {
    var t3 = Pd.exec(e);
    if (!t3)
      return null;
    var r2 = t3[2] && t3[2].indexOf("native") === 0, n2 = t3[2] && t3[2].indexOf("eval") === 0, i = Td.exec(t3[2]);
    return n2 && i != null && (t3[2] = i[1], t3[3] = i[2], t3[4] = i[3]), { file: r2 ? null : t3[2], methodName: t3[1] || hr, arguments: r2 ? [t3[2]] : [], lineNumber: t3[3] ? +t3[3] : null, column: t3[4] ? +t3[4] : null };
  }
  var Cd = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
  function Sd(e) {
    var t3 = Cd.exec(e);
    return t3 ? { file: t3[2], methodName: t3[1] || hr, arguments: [], lineNumber: +t3[3], column: t3[4] ? +t3[4] : null } : null;
  }
  var Ad = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
  var Id = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
  function Od(e) {
    var t3 = Ad.exec(e);
    if (!t3)
      return null;
    var r2 = t3[3] && t3[3].indexOf(" > eval") > -1, n2 = Id.exec(t3[3]);
    return r2 && n2 != null && (t3[3] = n2[1], t3[4] = n2[2], t3[5] = null), { file: t3[3], methodName: t3[1] || hr, arguments: t3[2] ? t3[2].split(",") : [], lineNumber: t3[4] ? +t3[4] : null, column: t3[5] ? +t3[5] : null };
  }
  var kd = /^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;
  function Dd(e) {
    var t3 = kd.exec(e);
    return t3 ? { file: t3[3], methodName: t3[1] || hr, arguments: [], lineNumber: +t3[4], column: t3[5] ? +t3[5] : null } : null;
  }
  var _d = /^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;
  function Nd(e) {
    var t3 = _d.exec(e);
    return t3 ? { file: t3[2], methodName: t3[1] || hr, arguments: [], lineNumber: +t3[3], column: t3[4] ? +t3[4] : null } : null;
  }
  var Ji = class {
    getLocation() {
      return null;
    }
  };
  var Hi = class {
    constructor() {
      this._error = new Error;
    }
    getLocation() {
      let t3 = this._error.stack;
      if (!t3)
        return null;
      let n2 = va(t3).find((i) => {
        if (!i.file)
          return false;
        let o2 = yi(i.file);
        return o2 !== "<anonymous>" && !o2.includes("@prisma") && !o2.includes("/packages/client/src/runtime/") && !o2.endsWith("/runtime/binary.js") && !o2.endsWith("/runtime/library.js") && !o2.endsWith("/runtime/edge.js") && !o2.endsWith("/runtime/edge-esm.js") && !o2.startsWith("internal/") && !i.methodName.includes("new ") && !i.methodName.includes("getCallSite") && !i.methodName.includes("Proxy.") && i.methodName.split(".").length < 4;
      });
      return !n2 || !n2.file ? null : { fileName: n2.file, lineNumber: n2.lineNumber, columnNumber: n2.column };
    }
  };
  function Ze(e) {
    return e === "minimal" ? typeof $EnabledCallSite == "function" && e !== "minimal" ? new $EnabledCallSite : new Ji : new Hi;
  }
  var Pa = { _avg: true, _count: true, _sum: true, _min: true, _max: true };
  function Nt(e = {}) {
    let t3 = Fd(e);
    return Object.entries(t3).reduce((n2, [i, o2]) => (Pa[i] !== undefined ? n2.select[i] = { select: o2 } : n2[i] = o2, n2), { select: {} });
  }
  function Fd(e = {}) {
    return typeof e._count == "boolean" ? { ...e, _count: { _all: e._count } } : e;
  }
  function Sn(e = {}) {
    return (t3) => (typeof e._count == "boolean" && (t3._count = t3._count._all), t3);
  }
  function Ta(e, t3) {
    let r2 = Sn(e);
    return t3({ action: "aggregate", unpacker: r2, argsMapper: Nt })(e);
  }
  function Md(e = {}) {
    let { select: t3, ...r2 } = e;
    return typeof t3 == "object" ? Nt({ ...r2, _count: t3 }) : Nt({ ...r2, _count: { _all: true } });
  }
  function $d(e = {}) {
    return typeof e.select == "object" ? (t3) => Sn(e)(t3)._count : (t3) => Sn(e)(t3)._count._all;
  }
  function Ra(e, t3) {
    return t3({ action: "count", unpacker: $d(e), argsMapper: Md })(e);
  }
  function qd(e = {}) {
    let t3 = Nt(e);
    if (Array.isArray(t3.by))
      for (let r2 of t3.by)
        typeof r2 == "string" && (t3.select[r2] = true);
    else
      typeof t3.by == "string" && (t3.select[t3.by] = true);
    return t3;
  }
  function Vd(e = {}) {
    return (t3) => (typeof e?._count == "boolean" && t3.forEach((r2) => {
      r2._count = r2._count._all;
    }), t3);
  }
  function Ca(e, t3) {
    return t3({ action: "groupBy", unpacker: Vd(e), argsMapper: qd })(e);
  }
  function Sa(e, t3, r2) {
    if (t3 === "aggregate")
      return (n2) => Ta(n2, r2);
    if (t3 === "count")
      return (n2) => Ra(n2, r2);
    if (t3 === "groupBy")
      return (n2) => Ca(n2, r2);
  }
  function Aa(e, t3) {
    let r2 = t3.fields.filter((i) => !i.relationName), n2 = Ti(r2, (i) => i.name);
    return new Proxy({}, { get(i, o2) {
      if (o2 in i || typeof o2 == "symbol")
        return i[o2];
      let s = n2[o2];
      if (s)
        return new sr(e, o2, s.type, s.isList, s.kind === "enum");
    }, ...Cn(Object.keys(n2)) });
  }
  var Ia = (e) => Array.isArray(e) ? e : e.split(".");
  var Wi = (e, t3) => Ia(t3).reduce((r2, n2) => r2 && r2[n2], e);
  var Oa = (e, t3, r2) => Ia(t3).reduceRight((n2, i, o2, s) => Object.assign({}, Wi(e, s.slice(0, o2)), { [i]: n2 }), r2);
  function jd(e, t3) {
    return e === undefined || t3 === undefined ? [] : [...t3, "select", e];
  }
  function Bd(e, t3, r2) {
    return t3 === undefined ? e ?? {} : Oa(t3, r2, e || true);
  }
  function Ki(e, t3, r2, n2, i, o2) {
    let a13 = e._runtimeDataModel.models[t3].fields.reduce((l2, u) => ({ ...l2, [u.name]: u }), {});
    return (l2) => {
      let u = Ze(e._errorFormat), c2 = jd(n2, i), p = Bd(l2, o2, c2), d = r2({ dataPath: c2, callsite: u })(p), f = Ud(e, t3);
      return new Proxy(d, { get(g, h) {
        if (!f.includes(h))
          return g[h];
        let T = [a13[h].type, r2, h], S = [c2, p];
        return Ki(e, ...T, ...S);
      }, ...Cn([...f, ...Object.getOwnPropertyNames(d)]) });
    };
  }
  function Ud(e, t3) {
    return e._runtimeDataModel.models[t3].fields.filter((r2) => r2.kind === "object").map((r2) => r2.name);
  }
  var Qd = ["findUnique", "findUniqueOrThrow", "findFirst", "findFirstOrThrow", "create", "update", "upsert", "delete"];
  var Gd = ["aggregate", "count", "groupBy"];
  function Yi(e, t3) {
    let r2 = e._extensions.getAllModelExtensions(t3) ?? {}, n2 = [Jd(e, t3), Wd(e, t3), gr(r2), ne("name", () => t3), ne("$name", () => t3), ne("$parent", () => e._appliedParent)];
    return Ae({}, n2);
  }
  function Jd(e, t3) {
    let r2 = Re(t3), n2 = Object.keys(zt.ModelAction).concat("count");
    return { getKeys() {
      return n2;
    }, getPropertyValue(i) {
      let o2 = i, s = (a13) => (l2) => {
        let u = Ze(e._errorFormat);
        return e._createPrismaPromise((c2) => {
          let p = { args: l2, dataPath: [], action: o2, model: t3, clientMethod: `${r2}.${i}`, jsModelName: r2, transaction: c2, callsite: u };
          return e._request({ ...p, ...a13 });
        });
      };
      return Qd.includes(o2) ? Ki(e, t3, s) : Hd(i) ? Sa(e, i, s) : s({});
    } };
  }
  function Hd(e) {
    return Gd.includes(e);
  }
  function Wd(e, t3) {
    return ot(ne("fields", () => {
      let r2 = e._runtimeDataModel.models[t3];
      return Aa(t3, r2);
    }));
  }
  function ka(e) {
    return e.replace(/^./, (t3) => t3.toUpperCase());
  }
  var zi = Symbol();
  function yr(e) {
    let t3 = [Kd(e), ne(zi, () => e), ne("$parent", () => e._appliedParent)], r2 = e._extensions.getAllClientExtensions();
    return r2 && t3.push(gr(r2)), Ae(e, t3);
  }
  function Kd(e) {
    let t3 = Object.keys(e._runtimeDataModel.models), r2 = t3.map(Re), n2 = [...new Set(t3.concat(r2))];
    return ot({ getKeys() {
      return n2;
    }, getPropertyValue(i) {
      let o2 = ka(i);
      if (e._runtimeDataModel.models[o2] !== undefined)
        return Yi(e, o2);
      if (e._runtimeDataModel.models[i] !== undefined)
        return Yi(e, i);
    }, getPropertyDescriptor(i) {
      if (!r2.includes(i))
        return { enumerable: false };
    } });
  }
  function Da(e) {
    return e[zi] ? e[zi] : e;
  }
  function _a(e) {
    if (typeof e == "function")
      return e(this);
    if (e.client?.__AccelerateEngine) {
      let r2 = e.client.__AccelerateEngine;
      this._originalClient._engine = new r2(this._originalClient._accelerateEngineConfig);
    }
    let t3 = Object.create(this._originalClient, { _extensions: { value: this._extensions.append(e) }, _appliedParent: { value: this, configurable: true }, $use: { value: undefined }, $on: { value: undefined } });
    return yr(t3);
  }
  function Na({ result: e, modelName: t3, select: r2, omit: n2, extensions: i }) {
    let o2 = i.getAllComputedFields(t3);
    if (!o2)
      return e;
    let s = [], a13 = [];
    for (let l2 of Object.values(o2)) {
      if (n2) {
        if (n2[l2.name])
          continue;
        let u = l2.needs.filter((c2) => n2[c2]);
        u.length > 0 && a13.push(kt(u));
      } else if (r2) {
        if (!r2[l2.name])
          continue;
        let u = l2.needs.filter((c2) => !r2[c2]);
        u.length > 0 && a13.push(kt(u));
      }
      Yd(e, l2.needs) && s.push(zd(l2, Ae(e, s)));
    }
    return s.length > 0 || a13.length > 0 ? Ae(e, [...s, ...a13]) : e;
  }
  function Yd(e, t3) {
    return t3.every((r2) => Pi(e, r2));
  }
  function zd(e, t3) {
    return ot(ne(e.name, () => e.compute(t3)));
  }
  function An({ visitor: e, result: t3, args: r2, runtimeDataModel: n2, modelName: i }) {
    if (Array.isArray(t3)) {
      for (let s = 0;s < t3.length; s++)
        t3[s] = An({ result: t3[s], args: r2, modelName: i, runtimeDataModel: n2, visitor: e });
      return t3;
    }
    let o2 = e(t3, i, r2) ?? t3;
    return r2.include && La({ includeOrSelect: r2.include, result: o2, parentModelName: i, runtimeDataModel: n2, visitor: e }), r2.select && La({ includeOrSelect: r2.select, result: o2, parentModelName: i, runtimeDataModel: n2, visitor: e }), o2;
  }
  function La({ includeOrSelect: e, result: t3, parentModelName: r2, runtimeDataModel: n2, visitor: i }) {
    for (let [o2, s] of Object.entries(e)) {
      if (!s || t3[o2] == null || Ce(s))
        continue;
      let l2 = n2.models[r2].fields.find((c2) => c2.name === o2);
      if (!l2 || l2.kind !== "object" || !l2.relationName)
        continue;
      let u = typeof s == "object" ? s : {};
      t3[o2] = An({ visitor: i, result: t3[o2], args: u, modelName: l2.type, runtimeDataModel: n2 });
    }
  }
  function Fa({ result: e, modelName: t3, args: r2, extensions: n2, runtimeDataModel: i, globalOmit: o2 }) {
    return n2.isEmpty() || e == null || typeof e != "object" || !i.models[t3] ? e : An({ result: e, args: r2 ?? {}, modelName: t3, runtimeDataModel: i, visitor: (a13, l2, u) => {
      let c2 = Re(l2);
      return Na({ result: a13, modelName: c2, select: u.select, omit: u.select ? undefined : { ...o2?.[c2], ...u.omit }, extensions: n2 });
    } });
  }
  function Ma(e) {
    if (e instanceof se)
      return Zd(e);
    if (Array.isArray(e)) {
      let r2 = [e[0]];
      for (let n2 = 1;n2 < e.length; n2++)
        r2[n2] = Er(e[n2]);
      return r2;
    }
    let t3 = {};
    for (let r2 in e)
      t3[r2] = Er(e[r2]);
    return t3;
  }
  function Zd(e) {
    return new se(e.strings, e.values);
  }
  function Er(e) {
    if (typeof e != "object" || e == null || e instanceof $e || St(e))
      return e;
    if (vt(e))
      return new ve(e.toFixed());
    if (xt(e))
      return new Date(+e);
    if (ArrayBuffer.isView(e))
      return e.slice(0);
    if (Array.isArray(e)) {
      let t3 = e.length, r2;
      for (r2 = Array(t3);t3--; )
        r2[t3] = Er(e[t3]);
      return r2;
    }
    if (typeof e == "object") {
      let t3 = {};
      for (let r2 in e)
        r2 === "__proto__" ? Object.defineProperty(t3, r2, { value: Er(e[r2]), configurable: true, enumerable: true, writable: true }) : t3[r2] = Er(e[r2]);
      return t3;
    }
    Fe(e, "Unknown value");
  }
  function qa(e, t3, r2, n2 = 0) {
    return e._createPrismaPromise((i) => {
      let o2 = t3.customDataProxyFetch;
      return "transaction" in t3 && i !== undefined && (t3.transaction?.kind === "batch" && t3.transaction.lock.then(), t3.transaction = i), n2 === r2.length ? e._executeRequest(t3) : r2[n2]({ model: t3.model, operation: t3.model ? t3.action : t3.clientMethod, args: Ma(t3.args ?? {}), __internalParams: t3, query: (s, a13 = t3) => {
        let l2 = a13.customDataProxyFetch;
        return a13.customDataProxyFetch = Ua(o2, l2), a13.args = s, qa(e, a13, r2, n2 + 1);
      } });
    });
  }
  function Va(e, t3) {
    let { jsModelName: r2, action: n2, clientMethod: i } = t3, o2 = r2 ? n2 : i;
    if (e._extensions.isEmpty())
      return e._executeRequest(t3);
    let s = e._extensions.getAllQueryCallbacks(r2 ?? "$none", o2);
    return qa(e, t3, s);
  }
  function ja(e) {
    return (t3) => {
      let r2 = { requests: t3 }, n2 = t3[0].extensions.getAllBatchQueryCallbacks();
      return n2.length ? Ba(r2, n2, 0, e) : e(r2);
    };
  }
  function Ba(e, t3, r2, n2) {
    if (r2 === t3.length)
      return n2(e);
    let i = e.customDataProxyFetch, o2 = e.requests[0].transaction;
    return t3[r2]({ args: { queries: e.requests.map((s) => ({ model: s.modelName, operation: s.action, args: s.args })), transaction: o2 ? { isolationLevel: o2.kind === "batch" ? o2.isolationLevel : undefined } : undefined }, __internalParams: e, query(s, a13 = e) {
      let l2 = a13.customDataProxyFetch;
      return a13.customDataProxyFetch = Ua(i, l2), Ba(a13, t3, r2 + 1, n2);
    } });
  }
  var $a = (e) => e;
  function Ua(e = $a, t3 = $a) {
    return (r2) => e(t3(r2));
  }
  var Qa = L("prisma:client");
  var Ga = { Vercel: "vercel", "Netlify CI": "netlify" };
  function Ja({ postinstall: e, ciName: t3, clientVersion: r2 }) {
    if (Qa("checkPlatformCaching:postinstall", e), Qa("checkPlatformCaching:ciName", t3), e === true && t3 && t3 in Ga) {
      let n2 = `Prisma has detected that this project was built on ${t3}, which caches dependencies. This leads to an outdated Prisma Client because Prisma's auto-generation isn't triggered. To fix this, make sure to run the \`prisma generate\` command during the build process.

Learn how: https://pris.ly/d/${Ga[t3]}-build`;
      throw console.error(n2), new R(n2, r2);
    }
  }
  function Ha(e, t3) {
    return e ? e.datasources ? e.datasources : e.datasourceUrl ? { [t3[0]]: { url: e.datasourceUrl } } : {} : {};
  }
  var Xd = "Cloudflare-Workers";
  var em = "node";
  function Wa() {
    return typeof Netlify == "object" ? "netlify" : typeof EdgeRuntime == "string" ? "edge-light" : globalThis.navigator?.userAgent === Xd ? "workerd" : globalThis.Deno ? "deno" : globalThis.__lagon__ ? "lagon" : globalThis.process?.release?.name === em ? "node" : globalThis.Bun ? "bun" : globalThis.fastly ? "fastly" : "unknown";
  }
  var tm = { node: "Node.js", workerd: "Cloudflare Workers", deno: "Deno and Deno Deploy", netlify: "Netlify Edge Functions", "edge-light": "Edge Runtime (Vercel Edge Functions, Vercel Edge Middleware, Next.js (Pages Router) Edge API Routes, Next.js (App Router) Edge Route Handlers or Next.js Middleware)" };
  function In() {
    let e = Wa();
    return { id: e, prettyName: tm[e] || e, isEdge: ["workerd", "deno", "netlify", "edge-light"].includes(e) };
  }
  var Xa = k(import.meta.require("fs"));
  var br = k(import.meta.require("path"));
  function On(e) {
    let { runtimeBinaryTarget: t3 } = e;
    return `Add "${t3}" to \`binaryTargets\` in the "schema.prisma" file and run \`prisma generate\` after saving it:

${rm(e)}`;
  }
  function rm(e) {
    let { generator: t3, generatorBinaryTargets: r2, runtimeBinaryTarget: n2 } = e, i = { fromEnvVar: null, value: n2 }, o2 = [...r2, i];
    return wi({ ...t3, binaryTargets: o2 });
  }
  function Xe(e) {
    let { runtimeBinaryTarget: t3 } = e;
    return `Prisma Client could not locate the Query Engine for runtime "${t3}".`;
  }
  function et(e) {
    let { searchedLocations: t3 } = e;
    return `The following locations have been searched:
${[...new Set(t3)].map((i) => `  ${i}`).join(`
`)}`;
  }
  function Ka(e) {
    let { runtimeBinaryTarget: t3 } = e;
    return `${Xe(e)}

This happened because \`binaryTargets\` have been pinned, but the actual deployment also required "${t3}".
${On(e)}

${et(e)}`;
  }
  function kn(e) {
    return `We would appreciate if you could take the time to share some information with us.
Please help us by answering a few questions: https://pris.ly/${e}`;
  }
  function Dn(e) {
    let { errorStack: t3 } = e;
    return t3?.match(/\/\.next|\/next@|\/next\//) ? `

We detected that you are using Next.js, learn how to fix this: https://pris.ly/d/engine-not-found-nextjs.` : "";
  }
  function Ya(e) {
    let { queryEngineName: t3 } = e;
    return `${Xe(e)}${Dn(e)}

This is likely caused by a bundler that has not copied "${t3}" next to the resulting bundle.
Ensure that "${t3}" has been copied next to the bundle or in "${e.expectedLocation}".

${kn("engine-not-found-bundler-investigation")}

${et(e)}`;
  }
  function za(e) {
    let { runtimeBinaryTarget: t3, generatorBinaryTargets: r2 } = e, n2 = r2.find((i) => i.native);
    return `${Xe(e)}

This happened because Prisma Client was generated for "${n2?.value ?? "unknown"}", but the actual deployment required "${t3}".
${On(e)}

${et(e)}`;
  }
  function Za(e) {
    let { queryEngineName: t3 } = e;
    return `${Xe(e)}${Dn(e)}

This is likely caused by tooling that has not copied "${t3}" to the deployment folder.
Ensure that you ran \`prisma generate\` and that "${t3}" has been copied to "${e.expectedLocation}".

${kn("engine-not-found-tooling-investigation")}

${et(e)}`;
  }
  var nm = L("prisma:client:engines:resolveEnginePath");
  var im = () => new RegExp("runtime[\\\\/]library\\.m?js$");
  async function el(e, t3) {
    let r2 = { binary: process.env.PRISMA_QUERY_ENGINE_BINARY, library: process.env.PRISMA_QUERY_ENGINE_LIBRARY }[e] ?? t3.prismaPath;
    if (r2 !== undefined)
      return r2;
    let { enginePath: n2, searchedLocations: i } = await om(e, t3);
    if (nm("enginePath", n2), n2 !== undefined && e === "binary" && ci(n2), n2 !== undefined)
      return t3.prismaPath = n2;
    let o2 = await nt(), s = t3.generator?.binaryTargets ?? [], a13 = s.some((d) => d.native), l2 = !s.some((d) => d.value === o2), u = __filename.match(im()) === null, c2 = { searchedLocations: i, generatorBinaryTargets: s, generator: t3.generator, runtimeBinaryTarget: o2, queryEngineName: tl(e, o2), expectedLocation: br.default.relative(process.cwd(), t3.dirname), errorStack: new Error().stack }, p;
    throw a13 && l2 ? p = za(c2) : l2 ? p = Ka(c2) : u ? p = Ya(c2) : p = Za(c2), new R(p, t3.clientVersion);
  }
  async function om(engineType, config) {
    let binaryTarget = await nt(), searchedLocations = [], dirname = eval("__dirname"), searchLocations = [config.dirname, br.default.resolve(dirname, ".."), config.generator?.output?.value ?? dirname, br.default.resolve(dirname, "../../../.prisma/client"), "/tmp/prisma-engines", config.cwd];
    __filename.includes("resolveEnginePath") && searchLocations.push(es());
    for (let e of searchLocations) {
      let t3 = tl(engineType, binaryTarget), r2 = br.default.join(e, t3);
      if (searchedLocations.push(e), Xa.default.existsSync(r2))
        return { enginePath: r2, searchedLocations };
    }
    return { enginePath: undefined, searchedLocations };
  }
  function tl(e, t3) {
    return e === "library" ? qr(t3, "fs") : `query-engine-${t3}${t3 === "windows" ? ".exe" : ""}`;
  }
  var Zi = k(vi());
  function rl(e) {
    return e ? e.replace(/".*"/g, '"X"').replace(/[\s:\[]([+-]?([0-9]*[.])?[0-9]+)/g, (t3) => `${t3[0]}5`) : "";
  }
  function nl(e) {
    return e.split(`
`).map((t3) => t3.replace(/^\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)\s*/, "").replace(/\+\d+\s*ms$/, "")).join(`
`);
  }
  var il = k(xs());
  function ol({ title: e, user: t3 = "prisma", repo: r2 = "prisma", template: n2 = "bug_report.yml", body: i }) {
    return (0, il.default)({ user: t3, repo: r2, template: n2, title: e, body: i });
  }
  function sl({ version: e, binaryTarget: t3, title: r2, description: n2, engineVersion: i, database: o2, query: s }) {
    let a13 = Oo(6000 - (s?.length ?? 0)), l2 = nl((0, Zi.default)(a13)), u = n2 ? `# Description
\`\`\`
${n2}
\`\`\`` : "", c2 = (0, Zi.default)(`Hi Prisma Team! My Prisma Client just crashed. This is the report:
## Versions

| Name            | Version            |
|-----------------|--------------------|
| Node            | ${process.version?.padEnd(19)}| 
| OS              | ${t3?.padEnd(19)}|
| Prisma Client   | ${e?.padEnd(19)}|
| Query Engine    | ${i?.padEnd(19)}|
| Database        | ${o2?.padEnd(19)}|

${u}

## Logs
\`\`\`
${l2}
\`\`\`

## Client Snippet
\`\`\`ts
// PLEASE FILL YOUR CODE SNIPPET HERE
\`\`\`

## Schema
\`\`\`prisma
// PLEASE ADD YOUR SCHEMA HERE IF POSSIBLE
\`\`\`

## Prisma Engine Query
\`\`\`
${s ? rl(s) : ""}
\`\`\`
`), p = ol({ title: r2, body: c2 });
    return `${r2}

This is a non-recoverable error which probably happens when the Prisma Query Engine has a panic.

${Z3(p)}

If you want the Prisma team to look into it, please open the link above \uD83D\uDE4F
To increase the chance of success, please post your schema and a snippet of
how you used Prisma Client in the issue. 
`;
  }
  function Lt({ inlineDatasources: e, overrideDatasources: t3, env: r2, clientVersion: n2 }) {
    let i, o2 = Object.keys(e)[0], s = e[o2]?.url, a13 = t3[o2]?.url;
    if (o2 === undefined ? i = undefined : a13 ? i = a13 : s?.value ? i = s.value : s?.fromEnvVar && (i = r2[s.fromEnvVar]), s?.fromEnvVar !== undefined && i === undefined)
      throw new R(`error: Environment variable not found: ${s.fromEnvVar}.`, n2);
    if (i === undefined)
      throw new R("error: Missing URL environment variable, value, or override.", n2);
    return i;
  }
  var _n = class extends Error {
    constructor(t3, r2) {
      super(t3), this.clientVersion = r2.clientVersion, this.cause = r2.cause;
    }
    get [Symbol.toStringTag]() {
      return this.name;
    }
  };
  var ae = class extends _n {
    constructor(t3, r2) {
      super(t3, r2), this.isRetryable = r2.isRetryable ?? true;
    }
  };
  function A(e, t3) {
    return { ...e, isRetryable: t3 };
  }
  var Ft = class extends ae {
    constructor(r2) {
      super("This request must be retried", A(r2, true));
      this.name = "ForcedRetryError";
      this.code = "P5001";
    }
  };
  x(Ft, "ForcedRetryError");
  var st = class extends ae {
    constructor(r2, n2) {
      super(r2, A(n2, false));
      this.name = "InvalidDatasourceError";
      this.code = "P6001";
    }
  };
  x(st, "InvalidDatasourceError");
  var at = class extends ae {
    constructor(r2, n2) {
      super(r2, A(n2, false));
      this.name = "NotImplementedYetError";
      this.code = "P5004";
    }
  };
  x(at, "NotImplementedYetError");
  var q = class extends ae {
    constructor(t3, r2) {
      super(t3, r2), this.response = r2.response;
      let n2 = this.response.headers.get("prisma-request-id");
      if (n2) {
        let i = `(The request id was: ${n2})`;
        this.message = this.message + " " + i;
      }
    }
  };
  var lt = class extends q {
    constructor(r2) {
      super("Schema needs to be uploaded", A(r2, true));
      this.name = "SchemaMissingError";
      this.code = "P5005";
    }
  };
  x(lt, "SchemaMissingError");
  var Xi = "This request could not be understood by the server";
  var wr = class extends q {
    constructor(r2, n2, i) {
      super(n2 || Xi, A(r2, false));
      this.name = "BadRequestError";
      this.code = "P5000";
      i && (this.code = i);
    }
  };
  x(wr, "BadRequestError");
  var xr = class extends q {
    constructor(r2, n2) {
      super("Engine not started: healthcheck timeout", A(r2, true));
      this.name = "HealthcheckTimeoutError";
      this.code = "P5013";
      this.logs = n2;
    }
  };
  x(xr, "HealthcheckTimeoutError");
  var vr = class extends q {
    constructor(r2, n2, i) {
      super(n2, A(r2, true));
      this.name = "EngineStartupError";
      this.code = "P5014";
      this.logs = i;
    }
  };
  x(vr, "EngineStartupError");
  var Pr = class extends q {
    constructor(r2) {
      super("Engine version is not supported", A(r2, false));
      this.name = "EngineVersionNotSupportedError";
      this.code = "P5012";
    }
  };
  x(Pr, "EngineVersionNotSupportedError");
  var eo = "Request timed out";
  var Tr = class extends q {
    constructor(r2, n2 = eo) {
      super(n2, A(r2, false));
      this.name = "GatewayTimeoutError";
      this.code = "P5009";
    }
  };
  x(Tr, "GatewayTimeoutError");
  var sm = "Interactive transaction error";
  var Rr = class extends q {
    constructor(r2, n2 = sm) {
      super(n2, A(r2, false));
      this.name = "InteractiveTransactionError";
      this.code = "P5015";
    }
  };
  x(Rr, "InteractiveTransactionError");
  var am = "Request parameters are invalid";
  var Cr = class extends q {
    constructor(r2, n2 = am) {
      super(n2, A(r2, false));
      this.name = "InvalidRequestError";
      this.code = "P5011";
    }
  };
  x(Cr, "InvalidRequestError");
  var to = "Requested resource does not exist";
  var Sr = class extends q {
    constructor(r2, n2 = to) {
      super(n2, A(r2, false));
      this.name = "NotFoundError";
      this.code = "P5003";
    }
  };
  x(Sr, "NotFoundError");
  var ro = "Unknown server error";
  var Mt = class extends q {
    constructor(r2, n2, i) {
      super(n2 || ro, A(r2, true));
      this.name = "ServerError";
      this.code = "P5006";
      this.logs = i;
    }
  };
  x(Mt, "ServerError");
  var no = "Unauthorized, check your connection string";
  var Ar = class extends q {
    constructor(r2, n2 = no) {
      super(n2, A(r2, false));
      this.name = "UnauthorizedError";
      this.code = "P5007";
    }
  };
  x(Ar, "UnauthorizedError");
  var io = "Usage exceeded, retry again later";
  var Ir = class extends q {
    constructor(r2, n2 = io) {
      super(n2, A(r2, true));
      this.name = "UsageExceededError";
      this.code = "P5008";
    }
  };
  x(Ir, "UsageExceededError");
  async function lm(e) {
    let t3;
    try {
      t3 = await e.text();
    } catch {
      return { type: "EmptyError" };
    }
    try {
      let r2 = JSON.parse(t3);
      if (typeof r2 == "string")
        switch (r2) {
          case "InternalDataProxyError":
            return { type: "DataProxyError", body: r2 };
          default:
            return { type: "UnknownTextError", body: r2 };
        }
      if (typeof r2 == "object" && r2 !== null) {
        if ("is_panic" in r2 && "message" in r2 && "error_code" in r2)
          return { type: "QueryEngineError", body: r2 };
        if ("EngineNotStarted" in r2 || "InteractiveTransactionMisrouted" in r2 || "InvalidRequestError" in r2) {
          let n2 = Object.values(r2)[0].reason;
          return typeof n2 == "string" && !["SchemaMissing", "EngineVersionNotSupported"].includes(n2) ? { type: "UnknownJsonError", body: r2 } : { type: "DataProxyError", body: r2 };
        }
      }
      return { type: "UnknownJsonError", body: r2 };
    } catch {
      return t3 === "" ? { type: "EmptyError" } : { type: "UnknownTextError", body: t3 };
    }
  }
  async function Or3(e, t3) {
    if (e.ok)
      return;
    let r2 = { clientVersion: t3, response: e }, n2 = await lm(e);
    if (n2.type === "QueryEngineError")
      throw new X(n2.body.message, { code: n2.body.error_code, clientVersion: t3 });
    if (n2.type === "DataProxyError") {
      if (n2.body === "InternalDataProxyError")
        throw new Mt(r2, "Internal Data Proxy error");
      if ("EngineNotStarted" in n2.body) {
        if (n2.body.EngineNotStarted.reason === "SchemaMissing")
          return new lt(r2);
        if (n2.body.EngineNotStarted.reason === "EngineVersionNotSupported")
          throw new Pr(r2);
        if ("EngineStartupError" in n2.body.EngineNotStarted.reason) {
          let { msg: i, logs: o2 } = n2.body.EngineNotStarted.reason.EngineStartupError;
          throw new vr(r2, i, o2);
        }
        if ("KnownEngineStartupError" in n2.body.EngineNotStarted.reason) {
          let { msg: i, error_code: o2 } = n2.body.EngineNotStarted.reason.KnownEngineStartupError;
          throw new R(i, t3, o2);
        }
        if ("HealthcheckTimeout" in n2.body.EngineNotStarted.reason) {
          let { logs: i } = n2.body.EngineNotStarted.reason.HealthcheckTimeout;
          throw new xr(r2, i);
        }
      }
      if ("InteractiveTransactionMisrouted" in n2.body) {
        let i = { IDParseError: "Could not parse interactive transaction ID", NoQueryEngineFoundError: "Could not find Query Engine for the specified host and transaction ID", TransactionStartError: "Could not start interactive transaction" };
        throw new Rr(r2, i[n2.body.InteractiveTransactionMisrouted.reason]);
      }
      if ("InvalidRequestError" in n2.body)
        throw new Cr(r2, n2.body.InvalidRequestError.reason);
    }
    if (e.status === 401 || e.status === 403)
      throw new Ar(r2, $t(no, n2));
    if (e.status === 404)
      return new Sr(r2, $t(to, n2));
    if (e.status === 429)
      throw new Ir(r2, $t(io, n2));
    if (e.status === 504)
      throw new Tr(r2, $t(eo, n2));
    if (e.status >= 500)
      throw new Mt(r2, $t(ro, n2));
    if (e.status >= 400)
      throw new wr(r2, $t(Xi, n2));
  }
  function $t(e, t3) {
    return t3.type === "EmptyError" ? e : `${e}: ${JSON.stringify(t3)}`;
  }
  function al(e) {
    let t3 = Math.pow(2, e) * 50, r2 = Math.ceil(Math.random() * t3) - Math.ceil(t3 / 2), n2 = t3 + r2;
    return new Promise((i) => setTimeout(() => i(n2), n2));
  }
  var qe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  function ll(e) {
    let t3 = new TextEncoder().encode(e), r2 = "", n2 = t3.byteLength, i = n2 % 3, o2 = n2 - i, s, a13, l2, u, c2;
    for (let p = 0;p < o2; p = p + 3)
      c2 = t3[p] << 16 | t3[p + 1] << 8 | t3[p + 2], s = (c2 & 16515072) >> 18, a13 = (c2 & 258048) >> 12, l2 = (c2 & 4032) >> 6, u = c2 & 63, r2 += qe[s] + qe[a13] + qe[l2] + qe[u];
    return i == 1 ? (c2 = t3[o2], s = (c2 & 252) >> 2, a13 = (c2 & 3) << 4, r2 += qe[s] + qe[a13] + "==") : i == 2 && (c2 = t3[o2] << 8 | t3[o2 + 1], s = (c2 & 64512) >> 10, a13 = (c2 & 1008) >> 4, l2 = (c2 & 15) << 2, r2 += qe[s] + qe[a13] + qe[l2] + "="), r2;
  }
  function ul(e) {
    if (!!e.generator?.previewFeatures.some((r2) => r2.toLowerCase().includes("metrics")))
      throw new R("The `metrics` preview feature is not yet available with Accelerate.\nPlease remove `metrics` from the `previewFeatures` in your schema.\n\nMore information about Accelerate: https://pris.ly/d/accelerate", e.clientVersion);
  }
  function um(e) {
    return e[0] * 1000 + e[1] / 1e6;
  }
  function oo(e) {
    return new Date(um(e));
  }
  var cl = { "@prisma/debug": "workspace:*", "@prisma/engines-version": "6.1.0-21.11f085a2012c0f4778414c8db2651556ee0ef959", "@prisma/fetch-engine": "workspace:*", "@prisma/get-platform": "workspace:*" };
  var kr = class extends ae {
    constructor(r2, n2) {
      super(`Cannot fetch data from service:
${r2}`, A(n2, true));
      this.name = "RequestError";
      this.code = "P5010";
    }
  };
  x(kr, "RequestError");
  async function ut(e, t3, r2 = (n2) => n2) {
    let { clientVersion: n2, ...i } = t3, o2 = r2(fetch);
    try {
      return await o2(e, i);
    } catch (s) {
      let a13 = s.message ?? "Unknown error";
      throw new kr(a13, { clientVersion: n2, cause: s });
    }
  }
  var pm = /^[1-9][0-9]*\.[0-9]+\.[0-9]+$/;
  var pl = L("prisma:client:dataproxyEngine");
  async function dm(e, t3) {
    let r2 = cl["@prisma/engines-version"], n2 = t3.clientVersion ?? "unknown";
    if (process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION)
      return process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION;
    if (e.includes("accelerate") && n2 !== "0.0.0" && n2 !== "in-memory")
      return n2;
    let [i, o2] = n2?.split("-") ?? [];
    if (o2 === undefined && pm.test(i))
      return i;
    if (o2 !== undefined || n2 === "0.0.0" || n2 === "in-memory") {
      if (e.startsWith("localhost") || e.startsWith("127.0.0.1"))
        return "0.0.0";
      let [s] = r2.split("-") ?? [], [a13, l2, u] = s.split("."), c2 = mm(`<=${a13}.${l2}.${u}`), p = await ut(c2, { clientVersion: n2 });
      if (!p.ok)
        throw new Error(`Failed to fetch stable Prisma version, unpkg.com status ${p.status} ${p.statusText}, response body: ${await p.text() || "<empty body>"}`);
      let d = await p.text();
      pl("length of body fetched from unpkg.com", d.length);
      let f;
      try {
        f = JSON.parse(d);
      } catch (g) {
        throw console.error("JSON.parse error: body fetched from unpkg.com: ", d), g;
      }
      return f.version;
    }
    throw new at("Only `major.minor.patch` versions are supported by Accelerate.", { clientVersion: n2 });
  }
  async function dl(e, t3) {
    let r2 = await dm(e, t3);
    return pl("version", r2), r2;
  }
  function mm(e) {
    return encodeURI(`https://unpkg.com/prisma@${e}/package.json`);
  }
  var ml = 3;
  var Nn = L("prisma:client:dataproxyEngine");
  var so = class {
    constructor({ apiKey: t3, tracingHelper: r2, logLevel: n2, logQueries: i, engineHash: o2 }) {
      this.apiKey = t3, this.tracingHelper = r2, this.logLevel = n2, this.logQueries = i, this.engineHash = o2;
    }
    build({ traceparent: t3, interactiveTransaction: r2 } = {}) {
      let n2 = { Authorization: `Bearer ${this.apiKey}`, "Prisma-Engine-Hash": this.engineHash };
      this.tracingHelper.isEnabled() && (n2.traceparent = t3 ?? this.tracingHelper.getTraceParent()), r2 && (n2["X-transaction-id"] = r2.id);
      let i = this.buildCaptureSettings();
      return i.length > 0 && (n2["X-capture-telemetry"] = i.join(", ")), n2;
    }
    buildCaptureSettings() {
      let t3 = [];
      return this.tracingHelper.isEnabled() && t3.push("tracing"), this.logLevel && t3.push(this.logLevel), this.logQueries && t3.push("query"), t3;
    }
  };
  var Dr = class {
    constructor(t3) {
      this.name = "DataProxyEngine";
      ul(t3), this.config = t3, this.env = { ...t3.env, ...typeof process < "u" ? process.env : {} }, this.inlineSchema = ll(t3.inlineSchema), this.inlineDatasources = t3.inlineDatasources, this.inlineSchemaHash = t3.inlineSchemaHash, this.clientVersion = t3.clientVersion, this.engineHash = t3.engineVersion, this.logEmitter = t3.logEmitter, this.tracingHelper = t3.tracingHelper;
    }
    apiKey() {
      return this.headerBuilder.apiKey;
    }
    version() {
      return this.engineHash;
    }
    async start() {
      this.startPromise !== undefined && await this.startPromise, this.startPromise = (async () => {
        let [t3, r2] = this.extractHostAndApiKey();
        this.host = t3, this.headerBuilder = new so({ apiKey: r2, tracingHelper: this.tracingHelper, logLevel: this.config.logLevel, logQueries: this.config.logQueries, engineHash: this.engineHash }), this.remoteClientVersion = await dl(t3, this.config), Nn("host", this.host);
      })(), await this.startPromise;
    }
    async stop() {
    }
    propagateResponseExtensions(t3) {
      t3?.logs?.length && t3.logs.forEach((r2) => {
        switch (r2.level) {
          case "debug":
          case "trace":
            Nn(r2);
            break;
          case "error":
          case "warn":
          case "info": {
            this.logEmitter.emit(r2.level, { timestamp: oo(r2.timestamp), message: r2.attributes.message ?? "", target: r2.target });
            break;
          }
          case "query": {
            this.logEmitter.emit("query", { query: r2.attributes.query ?? "", timestamp: oo(r2.timestamp), duration: r2.attributes.duration_ms ?? 0, params: r2.attributes.params ?? "", target: r2.target });
            break;
          }
          default:
            r2.level;
        }
      }), t3?.traces?.length && this.tracingHelper.dispatchEngineSpans(t3.traces);
    }
    onBeforeExit() {
      throw new Error('"beforeExit" hook is not applicable to the remote query engine');
    }
    async url(t3) {
      return await this.start(), `https://${this.host}/${this.remoteClientVersion}/${this.inlineSchemaHash}/${t3}`;
    }
    async uploadSchema() {
      let t3 = { name: "schemaUpload", internal: true };
      return this.tracingHelper.runInChildSpan(t3, async () => {
        let r2 = await ut(await this.url("schema"), { method: "PUT", headers: this.headerBuilder.build(), body: this.inlineSchema, clientVersion: this.clientVersion });
        r2.ok || Nn("schema response status", r2.status);
        let n2 = await Or3(r2, this.clientVersion);
        if (n2)
          throw this.logEmitter.emit("warn", { message: `Error while uploading schema: ${n2.message}`, timestamp: new Date, target: "" }), n2;
        this.logEmitter.emit("info", { message: `Schema (re)uploaded (hash: ${this.inlineSchemaHash})`, timestamp: new Date, target: "" });
      });
    }
    request(t3, { traceparent: r2, interactiveTransaction: n2, customDataProxyFetch: i }) {
      return this.requestInternal({ body: t3, traceparent: r2, interactiveTransaction: n2, customDataProxyFetch: i });
    }
    async requestBatch(t3, { traceparent: r2, transaction: n2, customDataProxyFetch: i }) {
      let o2 = n2?.kind === "itx" ? n2.options : undefined, s = Dt(t3, n2);
      return (await this.requestInternal({ body: s, customDataProxyFetch: i, interactiveTransaction: o2, traceparent: r2 })).map((l2) => (l2.extensions && this.propagateResponseExtensions(l2.extensions), ("errors" in l2) ? this.convertProtocolErrorsToClientError(l2.errors) : l2));
    }
    requestInternal({ body: t3, traceparent: r2, customDataProxyFetch: n2, interactiveTransaction: i }) {
      return this.withRetry({ actionGerund: "querying", callback: async ({ logHttpCall: o2 }) => {
        let s = i ? `${i.payload.endpoint}/graphql` : await this.url("graphql");
        o2(s);
        let a13 = await ut(s, { method: "POST", headers: this.headerBuilder.build({ traceparent: r2, interactiveTransaction: i }), body: JSON.stringify(t3), clientVersion: this.clientVersion }, n2);
        a13.ok || Nn("graphql response status", a13.status), await this.handleError(await Or3(a13, this.clientVersion));
        let l2 = await a13.json();
        if (l2.extensions && this.propagateResponseExtensions(l2.extensions), "errors" in l2)
          throw this.convertProtocolErrorsToClientError(l2.errors);
        return "batchResult" in l2 ? l2.batchResult : l2;
      } });
    }
    async transaction(t3, r2, n2) {
      let i = { start: "starting", commit: "committing", rollback: "rolling back" };
      return this.withRetry({ actionGerund: `${i[t3]} transaction`, callback: async ({ logHttpCall: o2 }) => {
        if (t3 === "start") {
          let s = JSON.stringify({ max_wait: n2.maxWait, timeout: n2.timeout, isolation_level: n2.isolationLevel }), a13 = await this.url("transaction/start");
          o2(a13);
          let l2 = await ut(a13, { method: "POST", headers: this.headerBuilder.build({ traceparent: r2.traceparent }), body: s, clientVersion: this.clientVersion });
          await this.handleError(await Or3(l2, this.clientVersion));
          let u = await l2.json(), { extensions: c2 } = u;
          c2 && this.propagateResponseExtensions(c2);
          let p = u.id, d = u["data-proxy"].endpoint;
          return { id: p, payload: { endpoint: d } };
        } else {
          let s = `${n2.payload.endpoint}/${t3}`;
          o2(s);
          let a13 = await ut(s, { method: "POST", headers: this.headerBuilder.build({ traceparent: r2.traceparent }), clientVersion: this.clientVersion });
          await this.handleError(await Or3(a13, this.clientVersion));
          let l2 = await a13.json(), { extensions: u } = l2;
          u && this.propagateResponseExtensions(u);
          return;
        }
      } });
    }
    extractHostAndApiKey() {
      let t3 = { clientVersion: this.clientVersion }, r2 = Object.keys(this.inlineDatasources)[0], n2 = Lt({ inlineDatasources: this.inlineDatasources, overrideDatasources: this.config.overrideDatasources, clientVersion: this.clientVersion, env: this.env }), i;
      try {
        i = new URL(n2);
      } catch {
        throw new st(`Error validating datasource \`${r2}\`: the URL must start with the protocol \`prisma://\``, t3);
      }
      let { protocol: o2, host: s, searchParams: a13 } = i;
      if (o2 !== "prisma:" && o2 !== "prisma+postgres:")
        throw new st(`Error validating datasource \`${r2}\`: the URL must start with the protocol \`prisma://\``, t3);
      let l2 = a13.get("api_key");
      if (l2 === null || l2.length < 1)
        throw new st(`Error validating datasource \`${r2}\`: the URL must contain a valid API key`, t3);
      return [s, l2];
    }
    metrics() {
      throw new at("Metrics are not yet supported for Accelerate", { clientVersion: this.clientVersion });
    }
    async withRetry(t3) {
      for (let r2 = 0;; r2++) {
        let n2 = (i) => {
          this.logEmitter.emit("info", { message: `Calling ${i} (n=${r2})`, timestamp: new Date, target: "" });
        };
        try {
          return await t3.callback({ logHttpCall: n2 });
        } catch (i) {
          if (!(i instanceof ae) || !i.isRetryable)
            throw i;
          if (r2 >= ml)
            throw i instanceof Ft ? i.cause : i;
          this.logEmitter.emit("warn", { message: `Attempt ${r2 + 1}/${ml} failed for ${t3.actionGerund}: ${i.message ?? "(unknown)"}`, timestamp: new Date, target: "" });
          let o2 = await al(r2);
          this.logEmitter.emit("warn", { message: `Retrying after ${o2}ms`, timestamp: new Date, target: "" });
        }
      }
    }
    async handleError(t3) {
      if (t3 instanceof lt)
        throw await this.uploadSchema(), new Ft({ clientVersion: this.clientVersion, cause: t3 });
      if (t3)
        throw t3;
    }
    convertProtocolErrorsToClientError(t3) {
      return t3.length === 1 ? _t(t3[0], this.config.clientVersion, this.config.activeProvider) : new j(JSON.stringify(t3), { clientVersion: this.config.clientVersion });
    }
    applyPendingMigrations() {
      throw new Error("Method not implemented.");
    }
  };
  function fl(e) {
    if (e?.kind === "itx")
      return e.options.id;
  }
  var lo = k(import.meta.require("os"));
  var gl = k(import.meta.require("path"));
  var ao = Symbol("PrismaLibraryEngineCache");
  function fm() {
    let e = globalThis;
    return e[ao] === undefined && (e[ao] = {}), e[ao];
  }
  function gm(e) {
    let t3 = fm();
    if (t3[e] !== undefined)
      return t3[e];
    let r2 = gl.default.toNamespacedPath(e), n2 = { exports: {} }, i = 0;
    return process.platform !== "win32" && (i = lo.default.constants.dlopen.RTLD_LAZY | lo.default.constants.dlopen.RTLD_DEEPBIND), process.dlopen(n2, r2, i), t3[e] = n2.exports, n2.exports;
  }
  var hl = { async loadLibrary(e) {
    let t3 = await Xn(), r2 = await el("library", e);
    try {
      return e.tracingHelper.runInChildSpan({ name: "loadLibrary", internal: true }, () => gm(r2));
    } catch (n2) {
      let i = pi({ e: n2, platformInfo: t3, id: r2 });
      throw new R(i, e.clientVersion);
    }
  } };
  var uo;
  var yl = { async loadLibrary(e) {
    let { clientVersion: t3, adapter: r2, engineWasm: n2 } = e;
    if (r2 === undefined)
      throw new R(`The \`adapter\` option for \`PrismaClient\` is required in this context (${In().prettyName})`, t3);
    if (n2 === undefined)
      throw new R("WASM engine was unexpectedly `undefined`", t3);
    uo === undefined && (uo = (async () => {
      let o2 = n2.getRuntime(), s = await n2.getQueryEngineWasmModule();
      if (s == null)
        throw new R("The loaded wasm module was unexpectedly `undefined` or `null` once loaded", t3);
      let a13 = { "./query_engine_bg.js": o2 }, l2 = new WebAssembly.Instance(s, a13);
      return o2.__wbg_set_wasm(l2.exports), o2.QueryEngine;
    })());
    let i = await uo;
    return { debugPanic() {
      return Promise.reject("{}");
    }, dmmf() {
      return Promise.resolve("{}");
    }, version() {
      return { commit: "unknown", version: "unknown" };
    }, QueryEngine: i };
  } };
  var hm = "P2036";
  var Ie = L("prisma:client:libraryEngine");
  function ym(e) {
    return e.item_type === "query" && "query" in e;
  }
  function Em(e) {
    return "level" in e ? e.level === "error" && e.message === "PANIC" : false;
  }
  var El = [...Hn, "native"];
  var bm = 0xffffffffffffffffn;
  var co = 1n;
  function wm() {
    let e = co++;
    return co > bm && (co = 1n), e;
  }
  var _r = class {
    constructor(t3, r2) {
      this.name = "LibraryEngine";
      this.libraryLoader = r2 ?? hl, t3.engineWasm !== undefined && (this.libraryLoader = r2 ?? yl), this.config = t3, this.libraryStarted = false, this.logQueries = t3.logQueries ?? false, this.logLevel = t3.logLevel ?? "error", this.logEmitter = t3.logEmitter, this.datamodel = t3.inlineSchema, this.tracingHelper = t3.tracingHelper, t3.enableDebugLogs && (this.logLevel = "debug");
      let n2 = Object.keys(t3.overrideDatasources)[0], i = t3.overrideDatasources[n2]?.url;
      n2 !== undefined && i !== undefined && (this.datasourceOverrides = { [n2]: i }), this.libraryInstantiationPromise = this.instantiateLibrary();
    }
    wrapEngine(t3) {
      return { applyPendingMigrations: t3.applyPendingMigrations?.bind(t3), commitTransaction: this.withRequestId(t3.commitTransaction.bind(t3)), connect: this.withRequestId(t3.connect.bind(t3)), disconnect: this.withRequestId(t3.disconnect.bind(t3)), metrics: t3.metrics?.bind(t3), query: this.withRequestId(t3.query.bind(t3)), rollbackTransaction: this.withRequestId(t3.rollbackTransaction.bind(t3)), sdlSchema: t3.sdlSchema?.bind(t3), startTransaction: this.withRequestId(t3.startTransaction.bind(t3)), trace: t3.trace.bind(t3) };
    }
    withRequestId(t3) {
      return async (...r2) => {
        let n2 = wm().toString();
        try {
          return await t3(...r2, n2);
        } finally {
          if (this.tracingHelper.isEnabled()) {
            let i = await this.engine?.trace(n2);
            if (i) {
              let o2 = JSON.parse(i);
              this.tracingHelper.dispatchEngineSpans(o2.spans);
            }
          }
        }
      };
    }
    async applyPendingMigrations() {
      throw new Error("Cannot call this method from this type of engine instance");
    }
    async transaction(t3, r2, n2) {
      await this.start();
      let i = JSON.stringify(r2), o2;
      if (t3 === "start") {
        let a13 = JSON.stringify({ max_wait: n2.maxWait, timeout: n2.timeout, isolation_level: n2.isolationLevel });
        o2 = await this.engine?.startTransaction(a13, i);
      } else
        t3 === "commit" ? o2 = await this.engine?.commitTransaction(n2.id, i) : t3 === "rollback" && (o2 = await this.engine?.rollbackTransaction(n2.id, i));
      let s = this.parseEngineResponse(o2);
      if (xm(s)) {
        let a13 = this.getExternalAdapterError(s);
        throw a13 ? a13.error : new X(s.message, { code: s.error_code, clientVersion: this.config.clientVersion, meta: s.meta });
      }
      return s;
    }
    async instantiateLibrary() {
      if (Ie("internalSetup"), this.libraryInstantiationPromise)
        return this.libraryInstantiationPromise;
      Jn(), this.binaryTarget = await this.getCurrentBinaryTarget(), await this.tracingHelper.runInChildSpan("load_engine", () => this.loadEngine()), this.version();
    }
    async getCurrentBinaryTarget() {
      {
        if (this.binaryTarget)
          return this.binaryTarget;
        let t3 = await this.tracingHelper.runInChildSpan("detect_platform", () => nt());
        if (!El.includes(t3))
          throw new R(`Unknown ${pe("PRISMA_QUERY_ENGINE_LIBRARY")} ${pe(H(t3))}. Possible binaryTargets: ${Ve(El.join(", "))} or a path to the query engine library.
You may have to run ${Ve("prisma generate")} for your changes to take effect.`, this.config.clientVersion);
        return t3;
      }
    }
    parseEngineResponse(t3) {
      if (!t3)
        throw new j("Response from the Engine was empty", { clientVersion: this.config.clientVersion });
      try {
        return JSON.parse(t3);
      } catch {
        throw new j("Unable to JSON.parse response from engine", { clientVersion: this.config.clientVersion });
      }
    }
    async loadEngine() {
      if (!this.engine) {
        this.QueryEngineConstructor || (this.library = await this.libraryLoader.loadLibrary(this.config), this.QueryEngineConstructor = this.library.QueryEngine);
        try {
          let t3 = new WeakRef(this), { adapter: r2 } = this.config;
          r2 && Ie("Using driver adapter: %O", r2), this.engine = this.wrapEngine(new this.QueryEngineConstructor({ datamodel: this.datamodel, env: process.env, logQueries: this.config.logQueries ?? false, ignoreEnvVarErrors: true, datasourceOverrides: this.datasourceOverrides ?? {}, logLevel: this.logLevel, configDir: this.config.cwd, engineProtocol: "json", enableTracing: this.tracingHelper.isEnabled() }, (n2) => {
            t3.deref()?.logger(n2);
          }, r2));
        } catch (t3) {
          let r2 = t3, n2 = this.parseInitError(r2.message);
          throw typeof n2 == "string" ? r2 : new R(n2.message, this.config.clientVersion, n2.error_code);
        }
      }
    }
    logger(t3) {
      let r2 = this.parseEngineResponse(t3);
      r2 && (r2.level = r2?.level.toLowerCase() ?? "unknown", ym(r2) ? this.logEmitter.emit("query", { timestamp: new Date, query: r2.query, params: r2.params, duration: Number(r2.duration_ms), target: r2.module_path }) : Em(r2) ? this.loggerRustPanic = new ue(po(this, `${r2.message}: ${r2.reason} in ${r2.file}:${r2.line}:${r2.column}`), this.config.clientVersion) : this.logEmitter.emit(r2.level, { timestamp: new Date, message: r2.message, target: r2.module_path }));
    }
    parseInitError(t3) {
      try {
        return JSON.parse(t3);
      } catch {
      }
      return t3;
    }
    parseRequestError(t3) {
      try {
        return JSON.parse(t3);
      } catch {
      }
      return t3;
    }
    onBeforeExit() {
      throw new Error('"beforeExit" hook is not applicable to the library engine since Prisma 5.0.0, it is only relevant and implemented for the binary engine. Please add your event listener to the `process` object directly instead.');
    }
    async start() {
      if (await this.libraryInstantiationPromise, await this.libraryStoppingPromise, this.libraryStartingPromise)
        return Ie(`library already starting, this.libraryStarted: ${this.libraryStarted}`), this.libraryStartingPromise;
      if (this.libraryStarted)
        return;
      let t3 = async () => {
        Ie("library starting");
        try {
          let r2 = { traceparent: this.tracingHelper.getTraceParent() };
          await this.engine?.connect(JSON.stringify(r2)), this.libraryStarted = true, Ie("library started");
        } catch (r2) {
          let n2 = this.parseInitError(r2.message);
          throw typeof n2 == "string" ? r2 : new R(n2.message, this.config.clientVersion, n2.error_code);
        } finally {
          this.libraryStartingPromise = undefined;
        }
      };
      return this.libraryStartingPromise = this.tracingHelper.runInChildSpan("connect", t3), this.libraryStartingPromise;
    }
    async stop() {
      if (await this.libraryStartingPromise, await this.executingQueryPromise, this.libraryStoppingPromise)
        return Ie("library is already stopping"), this.libraryStoppingPromise;
      if (!this.libraryStarted)
        return;
      let t3 = async () => {
        await new Promise((n2) => setTimeout(n2, 5)), Ie("library stopping");
        let r2 = { traceparent: this.tracingHelper.getTraceParent() };
        await this.engine?.disconnect(JSON.stringify(r2)), this.libraryStarted = false, this.libraryStoppingPromise = undefined, Ie("library stopped");
      };
      return this.libraryStoppingPromise = this.tracingHelper.runInChildSpan("disconnect", t3), this.libraryStoppingPromise;
    }
    version() {
      return this.versionInfo = this.library?.version(), this.versionInfo?.version ?? "unknown";
    }
    debugPanic(t3) {
      return this.library?.debugPanic(t3);
    }
    async request(t3, { traceparent: r2, interactiveTransaction: n2 }) {
      Ie(`sending request, this.libraryStarted: ${this.libraryStarted}`);
      let i = JSON.stringify({ traceparent: r2 }), o2 = JSON.stringify(t3);
      try {
        await this.start(), this.executingQueryPromise = this.engine?.query(o2, i, n2?.id), this.lastQuery = o2;
        let s = this.parseEngineResponse(await this.executingQueryPromise);
        if (s.errors)
          throw s.errors.length === 1 ? this.buildQueryError(s.errors[0]) : new j(JSON.stringify(s.errors), { clientVersion: this.config.clientVersion });
        if (this.loggerRustPanic)
          throw this.loggerRustPanic;
        return { data: s };
      } catch (s) {
        if (s instanceof R)
          throw s;
        if (s.code === "GenericFailure" && s.message?.startsWith("PANIC:"))
          throw new ue(po(this, s.message), this.config.clientVersion);
        let a13 = this.parseRequestError(s.message);
        throw typeof a13 == "string" ? s : new j(`${a13.message}
${a13.backtrace}`, { clientVersion: this.config.clientVersion });
      }
    }
    async requestBatch(t3, { transaction: r2, traceparent: n2 }) {
      Ie("requestBatch");
      let i = Dt(t3, r2);
      await this.start(), this.lastQuery = JSON.stringify(i), this.executingQueryPromise = this.engine.query(this.lastQuery, JSON.stringify({ traceparent: n2 }), fl(r2));
      let o2 = await this.executingQueryPromise, s = this.parseEngineResponse(o2);
      if (s.errors)
        throw s.errors.length === 1 ? this.buildQueryError(s.errors[0]) : new j(JSON.stringify(s.errors), { clientVersion: this.config.clientVersion });
      let { batchResult: a13, errors: l2 } = s;
      if (Array.isArray(a13))
        return a13.map((u) => u.errors && u.errors.length > 0 ? this.loggerRustPanic ?? this.buildQueryError(u.errors[0]) : { data: u });
      throw l2 && l2.length === 1 ? new Error(l2[0].error) : new Error(JSON.stringify(s));
    }
    buildQueryError(t3) {
      if (t3.user_facing_error.is_panic)
        return new ue(po(this, t3.user_facing_error.message), this.config.clientVersion);
      let r2 = this.getExternalAdapterError(t3.user_facing_error);
      return r2 ? r2.error : _t(t3, this.config.clientVersion, this.config.activeProvider);
    }
    getExternalAdapterError(t3) {
      if (t3.error_code === hm && this.config.adapter) {
        let r2 = t3.meta?.id;
        Yr(typeof r2 == "number", "Malformed external JS error received from the engine");
        let n2 = this.config.adapter.errorRegistry.consumeError(r2);
        return Yr(n2, "External error with reported id was not registered"), n2;
      }
    }
    async metrics(t3) {
      await this.start();
      let r2 = await this.engine.metrics(JSON.stringify(t3));
      return t3.format === "prometheus" ? r2 : this.parseEngineResponse(r2);
    }
  };
  function xm(e) {
    return typeof e == "object" && e !== null && e.error_code !== undefined;
  }
  function po(e, t3) {
    return sl({ binaryTarget: e.binaryTarget, title: t3, version: e.config.clientVersion, engineVersion: e.versionInfo?.commit, database: e.config.activeProvider, query: e.lastQuery });
  }
  function bl({ copyEngine: e = true }, t3) {
    let r2;
    try {
      r2 = Lt({ inlineDatasources: t3.inlineDatasources, overrideDatasources: t3.overrideDatasources, env: { ...t3.env, ...process.env }, clientVersion: t3.clientVersion });
    } catch {
    }
    let n2 = !!(r2?.startsWith("prisma://") || r2?.startsWith("prisma+postgres://"));
    e && n2 && tr("recommend--no-engine", "In production, we recommend using `prisma generate --no-engine` (See: `prisma generate --help`)");
    let i = Yt(t3.generator), o2 = n2 || !e, s = !!t3.adapter, a13 = i === "library", l2 = i === "binary";
    if (o2 && s || s && false) {
      let u;
      throw e ? r2?.startsWith("prisma://") ? u = ["Prisma Client was configured to use the `adapter` option but the URL was a `prisma://` URL.", "Please either use the `prisma://` URL or remove the `adapter` from the Prisma Client constructor."] : u = ["Prisma Client was configured to use both the `adapter` and Accelerate, please chose one."] : u = ["Prisma Client was configured to use the `adapter` option but `prisma generate` was run with `--no-engine`.", "Please run `prisma generate` without `--no-engine` to be able to use Prisma Client with the adapter."], new ee(u.join(`
`), { clientVersion: t3.clientVersion });
    }
    if (o2)
      return new Dr(t3);
    if (a13)
      return new _r(t3);
    throw new ee("Invalid client engine type, please use `library` or `binary`", { clientVersion: t3.clientVersion });
  }
  function Ln({ generator: e }) {
    return e?.previewFeatures ?? [];
  }
  var wl = (e) => ({ command: e });
  var xl = (e) => e.strings.reduce((t3, r2, n2) => `${t3}@P${n2}${r2}`);
  function qt(e) {
    try {
      return vl(e, "fast");
    } catch {
      return vl(e, "slow");
    }
  }
  function vl(e, t3) {
    return JSON.stringify(e.map((r2) => Tl(r2, t3)));
  }
  function Tl(e, t3) {
    if (Array.isArray(e))
      return e.map((r2) => Tl(r2, t3));
    if (typeof e == "bigint")
      return { prisma__type: "bigint", prisma__value: e.toString() };
    if (xt(e))
      return { prisma__type: "date", prisma__value: e.toJSON() };
    if (ve.isDecimal(e))
      return { prisma__type: "decimal", prisma__value: e.toJSON() };
    if (Buffer.isBuffer(e))
      return { prisma__type: "bytes", prisma__value: e.toString("base64") };
    if (vm(e))
      return { prisma__type: "bytes", prisma__value: Buffer.from(e).toString("base64") };
    if (ArrayBuffer.isView(e)) {
      let { buffer: r2, byteOffset: n2, byteLength: i } = e;
      return { prisma__type: "bytes", prisma__value: Buffer.from(r2, n2, i).toString("base64") };
    }
    return typeof e == "object" && t3 === "slow" ? Rl(e) : e;
  }
  function vm(e) {
    return e instanceof ArrayBuffer || e instanceof SharedArrayBuffer ? true : typeof e == "object" && e !== null ? e[Symbol.toStringTag] === "ArrayBuffer" || e[Symbol.toStringTag] === "SharedArrayBuffer" : false;
  }
  function Rl(e) {
    if (typeof e != "object" || e === null)
      return e;
    if (typeof e.toJSON == "function")
      return e.toJSON();
    if (Array.isArray(e))
      return e.map(Pl);
    let t3 = {};
    for (let r2 of Object.keys(e))
      t3[r2] = Pl(e[r2]);
    return t3;
  }
  function Pl(e) {
    return typeof e == "bigint" ? e.toString() : Rl(e);
  }
  var Pm = ["$connect", "$disconnect", "$on", "$transaction", "$use", "$extends"];
  var Cl = Pm;
  var Tm = /^(\s*alter\s)/i;
  var Sl = L("prisma:client");
  function mo(e, t3, r2, n2) {
    if (!(e !== "postgresql" && e !== "cockroachdb") && r2.length > 0 && Tm.exec(t3))
      throw new Error(`Running ALTER using ${n2} is not supported
Using the example below you can still execute your query with Prisma, but please note that it is vulnerable to SQL injection attacks and requires you to take care of input sanitization.

Example:
  await prisma.$executeRawUnsafe(\`ALTER USER prisma WITH PASSWORD '\${password}'\`)

More Information: https://pris.ly/d/execute-raw
`);
  }
  var fo = ({ clientMethod: e, activeProvider: t3 }) => (r2) => {
    let n2 = "", i;
    if (ha(r2))
      n2 = r2.sql, i = { values: qt(r2.values), __prismaRawParameters__: true };
    else if (Array.isArray(r2)) {
      let [o2, ...s] = r2;
      n2 = o2, i = { values: qt(s || []), __prismaRawParameters__: true };
    } else
      switch (t3) {
        case "sqlite":
        case "mysql": {
          n2 = r2.sql, i = { values: qt(r2.values), __prismaRawParameters__: true };
          break;
        }
        case "cockroachdb":
        case "postgresql":
        case "postgres": {
          n2 = r2.text, i = { values: qt(r2.values), __prismaRawParameters__: true };
          break;
        }
        case "sqlserver": {
          n2 = xl(r2), i = { values: qt(r2.values), __prismaRawParameters__: true };
          break;
        }
        default:
          throw new Error(`The ${t3} provider does not support ${e}`);
      }
    return i?.values ? Sl(`prisma.${e}(${n2}, ${i.values})`) : Sl(`prisma.${e}(${n2})`), { query: n2, parameters: i };
  };
  var Al = { requestArgsToMiddlewareArgs(e) {
    return [e.strings, ...e.values];
  }, middlewareArgsToRequestArgs(e) {
    let [t3, ...r2] = e;
    return new se(t3, r2);
  } };
  var Il = { requestArgsToMiddlewareArgs(e) {
    return [e];
  }, middlewareArgsToRequestArgs(e) {
    return e[0];
  } };
  function go(e) {
    return function(r2) {
      let n2, i = (o2 = e) => {
        try {
          return o2 === undefined || o2?.kind === "itx" ? n2 ??= Ol(r2(o2)) : Ol(r2(o2));
        } catch (s) {
          return Promise.reject(s);
        }
      };
      return { then(o2, s) {
        return i().then(o2, s);
      }, catch(o2) {
        return i().catch(o2);
      }, finally(o2) {
        return i().finally(o2);
      }, requestTransaction(o2) {
        let s = i(o2);
        return s.requestTransaction ? s.requestTransaction(o2) : s;
      }, [Symbol.toStringTag]: "PrismaPromise" };
    };
  }
  function Ol(e) {
    return typeof e.then == "function" ? e : Promise.resolve(e);
  }
  var Rm = { isEnabled() {
    return false;
  }, getTraceParent() {
    return "00-10-10-00";
  }, dispatchEngineSpans() {
  }, getActiveContext() {
  }, runInChildSpan(e, t3) {
    return t3();
  } };
  var ho = class {
    isEnabled() {
      return this.getGlobalTracingHelper().isEnabled();
    }
    getTraceParent(t3) {
      return this.getGlobalTracingHelper().getTraceParent(t3);
    }
    dispatchEngineSpans(t3) {
      return this.getGlobalTracingHelper().dispatchEngineSpans(t3);
    }
    getActiveContext() {
      return this.getGlobalTracingHelper().getActiveContext();
    }
    runInChildSpan(t3, r2) {
      return this.getGlobalTracingHelper().runInChildSpan(t3, r2);
    }
    getGlobalTracingHelper() {
      return globalThis.PRISMA_INSTRUMENTATION?.helper ?? Rm;
    }
  };
  function kl() {
    return new ho;
  }
  function Dl(e, t3 = () => {
  }) {
    let r2, n2 = new Promise((i) => r2 = i);
    return { then(i) {
      return --e === 0 && r2(t3()), i?.(n2);
    } };
  }
  function _l(e) {
    return typeof e == "string" ? e : e.reduce((t3, r2) => {
      let n2 = typeof r2 == "string" ? r2 : r2.level;
      return n2 === "query" ? t3 : t3 && (r2 === "info" || t3 === "info") ? "info" : n2;
    }, undefined);
  }
  var Fn = class {
    constructor() {
      this._middlewares = [];
    }
    use(t3) {
      this._middlewares.push(t3);
    }
    get(t3) {
      return this._middlewares[t3];
    }
    has(t3) {
      return !!this._middlewares[t3];
    }
    length() {
      return this._middlewares.length;
    }
  };
  var Fl = k(vi());
  function Mn(e) {
    return typeof e.batchRequestIdx == "number";
  }
  function Nl(e) {
    if (e.action !== "findUnique" && e.action !== "findUniqueOrThrow")
      return;
    let t3 = [];
    return e.modelName && t3.push(e.modelName), e.query.arguments && t3.push(yo(e.query.arguments)), t3.push(yo(e.query.selection)), t3.join("");
  }
  function yo(e) {
    return `(${Object.keys(e).sort().map((r2) => {
      let n2 = e[r2];
      return typeof n2 == "object" && n2 !== null ? `(${r2} ${yo(n2)})` : r2;
    }).join(" ")})`;
  }
  var Cm = { aggregate: false, aggregateRaw: false, createMany: true, createManyAndReturn: true, createOne: true, deleteMany: true, deleteOne: true, executeRaw: true, findFirst: false, findFirstOrThrow: false, findMany: false, findRaw: false, findUnique: false, findUniqueOrThrow: false, groupBy: false, queryRaw: false, runCommandRaw: true, updateMany: true, updateOne: true, upsertOne: true };
  function Eo(e) {
    return Cm[e];
  }
  var $n = class {
    constructor(t3) {
      this.options = t3;
      this.tickActive = false;
      this.batches = {};
    }
    request(t3) {
      let r2 = this.options.batchBy(t3);
      return r2 ? (this.batches[r2] || (this.batches[r2] = [], this.tickActive || (this.tickActive = true, process.nextTick(() => {
        this.dispatchBatches(), this.tickActive = false;
      }))), new Promise((n2, i) => {
        this.batches[r2].push({ request: t3, resolve: n2, reject: i });
      })) : this.options.singleLoader(t3);
    }
    dispatchBatches() {
      for (let t3 in this.batches) {
        let r2 = this.batches[t3];
        delete this.batches[t3], r2.length === 1 ? this.options.singleLoader(r2[0].request).then((n2) => {
          n2 instanceof Error ? r2[0].reject(n2) : r2[0].resolve(n2);
        }).catch((n2) => {
          r2[0].reject(n2);
        }) : (r2.sort((n2, i) => this.options.batchOrder(n2.request, i.request)), this.options.batchLoader(r2.map((n2) => n2.request)).then((n2) => {
          if (n2 instanceof Error)
            for (let i = 0;i < r2.length; i++)
              r2[i].reject(n2);
          else
            for (let i = 0;i < r2.length; i++) {
              let o2 = n2[i];
              o2 instanceof Error ? r2[i].reject(o2) : r2[i].resolve(o2);
            }
        }).catch((n2) => {
          for (let i = 0;i < r2.length; i++)
            r2[i].reject(n2);
        }));
      }
    }
    get [Symbol.toStringTag]() {
      return "DataLoader";
    }
  };
  function ct(e, t3) {
    if (t3 === null)
      return t3;
    switch (e) {
      case "bigint":
        return BigInt(t3);
      case "bytes": {
        let { buffer: r2, byteOffset: n2, byteLength: i } = Buffer.from(t3, "base64");
        return new Uint8Array(r2, n2, i);
      }
      case "decimal":
        return new ve(t3);
      case "datetime":
      case "date":
        return new Date(t3);
      case "time":
        return new Date(`1970-01-01T${t3}Z`);
      case "bigint-array":
        return t3.map((r2) => ct("bigint", r2));
      case "bytes-array":
        return t3.map((r2) => ct("bytes", r2));
      case "decimal-array":
        return t3.map((r2) => ct("decimal", r2));
      case "datetime-array":
        return t3.map((r2) => ct("datetime", r2));
      case "date-array":
        return t3.map((r2) => ct("date", r2));
      case "time-array":
        return t3.map((r2) => ct("time", r2));
      default:
        return t3;
    }
  }
  function Ll(e) {
    let t3 = [], r2 = Sm(e);
    for (let n2 = 0;n2 < e.rows.length; n2++) {
      let i = e.rows[n2], o2 = { ...r2 };
      for (let s = 0;s < i.length; s++)
        o2[e.columns[s]] = ct(e.types[s], i[s]);
      t3.push(o2);
    }
    return t3;
  }
  function Sm(e) {
    let t3 = {};
    for (let r2 = 0;r2 < e.columns.length; r2++)
      t3[e.columns[r2]] = null;
    return t3;
  }
  var Am = L("prisma:client:request_handler");
  var qn = class {
    constructor(t3, r2) {
      this.logEmitter = r2, this.client = t3, this.dataloader = new $n({ batchLoader: ja(async ({ requests: n2, customDataProxyFetch: i }) => {
        let { transaction: o2, otelParentCtx: s } = n2[0], a13 = n2.map((p) => p.protocolQuery), l2 = this.client._tracingHelper.getTraceParent(s), u = n2.some((p) => Eo(p.protocolQuery.action));
        return (await this.client._engine.requestBatch(a13, { traceparent: l2, transaction: Im(o2), containsWrite: u, customDataProxyFetch: i })).map((p, d) => {
          if (p instanceof Error)
            return p;
          try {
            return this.mapQueryEngineResult(n2[d], p);
          } catch (f) {
            return f;
          }
        });
      }), singleLoader: async (n2) => {
        let i = n2.transaction?.kind === "itx" ? Ml(n2.transaction) : undefined, o2 = await this.client._engine.request(n2.protocolQuery, { traceparent: this.client._tracingHelper.getTraceParent(), interactiveTransaction: i, isWrite: Eo(n2.protocolQuery.action), customDataProxyFetch: n2.customDataProxyFetch });
        return this.mapQueryEngineResult(n2, o2);
      }, batchBy: (n2) => n2.transaction?.id ? `transaction-${n2.transaction.id}` : Nl(n2.protocolQuery), batchOrder(n2, i) {
        return n2.transaction?.kind === "batch" && i.transaction?.kind === "batch" ? n2.transaction.index - i.transaction.index : 0;
      } });
    }
    async request(t3) {
      try {
        return await this.dataloader.request(t3);
      } catch (r2) {
        let { clientMethod: n2, callsite: i, transaction: o2, args: s, modelName: a13 } = t3;
        this.handleAndLogRequestError({ error: r2, clientMethod: n2, callsite: i, transaction: o2, args: s, modelName: a13, globalOmit: t3.globalOmit });
      }
    }
    mapQueryEngineResult({ dataPath: t3, unpacker: r2 }, n2) {
      let i = n2?.data, o2 = this.unpack(i, t3, r2);
      return process.env.PRISMA_CLIENT_GET_TIME ? { data: o2 } : o2;
    }
    handleAndLogRequestError(t3) {
      try {
        this.handleRequestError(t3);
      } catch (r2) {
        throw this.logEmitter && this.logEmitter.emit("error", { message: r2.message, target: t3.clientMethod, timestamp: new Date }), r2;
      }
    }
    handleRequestError({ error: t3, clientMethod: r2, callsite: n2, transaction: i, args: o2, modelName: s, globalOmit: a13 }) {
      if (Am(t3), Om(t3, i))
        throw t3;
      if (t3 instanceof X && km(t3)) {
        let u = $l(t3.meta);
        wn({ args: o2, errors: [u], callsite: n2, errorFormat: this.client._errorFormat, originalMethod: r2, clientVersion: this.client._clientVersion, globalOmit: a13 });
      }
      let l2 = t3.message;
      if (n2 && (l2 = cn({ callsite: n2, originalMethod: r2, isPanic: t3.isPanic, showColors: this.client._errorFormat === "pretty", message: l2 })), l2 = this.sanitizeMessage(l2), t3.code) {
        let u = s ? { modelName: s, ...t3.meta } : t3.meta;
        throw new X(l2, { code: t3.code, clientVersion: this.client._clientVersion, meta: u, batchRequestIdx: t3.batchRequestIdx });
      } else {
        if (t3.isPanic)
          throw new ue(l2, this.client._clientVersion);
        if (t3 instanceof j)
          throw new j(l2, { clientVersion: this.client._clientVersion, batchRequestIdx: t3.batchRequestIdx });
        if (t3 instanceof R)
          throw new R(l2, this.client._clientVersion);
        if (t3 instanceof ue)
          throw new ue(l2, this.client._clientVersion);
      }
      throw t3.clientVersion = this.client._clientVersion, t3;
    }
    sanitizeMessage(t3) {
      return this.client._errorFormat && this.client._errorFormat !== "pretty" ? (0, Fl.default)(t3) : t3;
    }
    unpack(t3, r2, n2) {
      if (!t3 || (t3.data && (t3 = t3.data), !t3))
        return t3;
      let i = Object.keys(t3)[0], o2 = Object.values(t3)[0], s = r2.filter((u) => u !== "select" && u !== "include"), a13 = Wi(o2, s), l2 = i === "queryRaw" ? Ll(a13) : bt(a13);
      return n2 ? n2(l2) : l2;
    }
    get [Symbol.toStringTag]() {
      return "RequestHandler";
    }
  };
  function Im(e) {
    if (e) {
      if (e.kind === "batch")
        return { kind: "batch", options: { isolationLevel: e.isolationLevel } };
      if (e.kind === "itx")
        return { kind: "itx", options: Ml(e) };
      Fe(e, "Unknown transaction kind");
    }
  }
  function Ml(e) {
    return { id: e.id, payload: e.payload };
  }
  function Om(e, t3) {
    return Mn(e) && t3?.kind === "batch" && e.batchRequestIdx !== t3.index;
  }
  function km(e) {
    return e.code === "P2009" || e.code === "P2012";
  }
  function $l(e) {
    if (e.kind === "Union")
      return { kind: "Union", errors: e.errors.map($l) };
    if (Array.isArray(e.selectionPath)) {
      let [, ...t3] = e.selectionPath;
      return { ...e, selectionPath: t3 };
    }
    return e;
  }
  var ql = "6.1.0";
  var Vl = ql;
  var Gl = k(Di());
  var N = class extends Error {
    constructor(t3) {
      super(t3 + `
Read more at https://pris.ly/d/client-constructor`), this.name = "PrismaClientConstructorValidationError";
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientConstructorValidationError";
    }
  };
  x(N, "PrismaClientConstructorValidationError");
  var jl = ["datasources", "datasourceUrl", "errorFormat", "adapter", "log", "transactionOptions", "omit", "__internal"];
  var Bl = ["pretty", "colorless", "minimal"];
  var Ul = ["info", "query", "warn", "error"];
  var _m = { datasources: (e, { datasourceNames: t3 }) => {
    if (e) {
      if (typeof e != "object" || Array.isArray(e))
        throw new N(`Invalid value ${JSON.stringify(e)} for "datasources" provided to PrismaClient constructor`);
      for (let [r2, n2] of Object.entries(e)) {
        if (!t3.includes(r2)) {
          let i = Vt(r2, t3) || ` Available datasources: ${t3.join(", ")}`;
          throw new N(`Unknown datasource ${r2} provided to PrismaClient constructor.${i}`);
        }
        if (typeof n2 != "object" || Array.isArray(n2))
          throw new N(`Invalid value ${JSON.stringify(e)} for datasource "${r2}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
        if (n2 && typeof n2 == "object")
          for (let [i, o2] of Object.entries(n2)) {
            if (i !== "url")
              throw new N(`Invalid value ${JSON.stringify(e)} for datasource "${r2}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
            if (typeof o2 != "string")
              throw new N(`Invalid value ${JSON.stringify(o2)} for datasource "${r2}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
          }
      }
    }
  }, adapter: (e, t3) => {
    if (e === null)
      return;
    if (e === undefined)
      throw new N('"adapter" property must not be undefined, use null to conditionally disable driver adapters.');
    if (!Ln(t3).includes("driverAdapters"))
      throw new N('"adapter" property can only be provided to PrismaClient constructor when "driverAdapters" preview feature is enabled.');
    if (Yt() === "binary")
      throw new N('Cannot use a driver adapter with the "binary" Query Engine. Please use the "library" Query Engine.');
  }, datasourceUrl: (e) => {
    if (typeof e < "u" && typeof e != "string")
      throw new N(`Invalid value ${JSON.stringify(e)} for "datasourceUrl" provided to PrismaClient constructor.
Expected string or undefined.`);
  }, errorFormat: (e) => {
    if (e) {
      if (typeof e != "string")
        throw new N(`Invalid value ${JSON.stringify(e)} for "errorFormat" provided to PrismaClient constructor.`);
      if (!Bl.includes(e)) {
        let t3 = Vt(e, Bl);
        throw new N(`Invalid errorFormat ${e} provided to PrismaClient constructor.${t3}`);
      }
    }
  }, log: (e) => {
    if (!e)
      return;
    if (!Array.isArray(e))
      throw new N(`Invalid value ${JSON.stringify(e)} for "log" provided to PrismaClient constructor.`);
    function t3(r2) {
      if (typeof r2 == "string" && !Ul.includes(r2)) {
        let n2 = Vt(r2, Ul);
        throw new N(`Invalid log level "${r2}" provided to PrismaClient constructor.${n2}`);
      }
    }
    for (let r2 of e) {
      t3(r2);
      let n2 = { level: t3, emit: (i) => {
        let o2 = ["stdout", "event"];
        if (!o2.includes(i)) {
          let s = Vt(i, o2);
          throw new N(`Invalid value ${JSON.stringify(i)} for "emit" in logLevel provided to PrismaClient constructor.${s}`);
        }
      } };
      if (r2 && typeof r2 == "object")
        for (let [i, o2] of Object.entries(r2))
          if (n2[i])
            n2[i](o2);
          else
            throw new N(`Invalid property ${i} for "log" provided to PrismaClient constructor`);
    }
  }, transactionOptions: (e) => {
    if (!e)
      return;
    let t3 = e.maxWait;
    if (t3 != null && t3 <= 0)
      throw new N(`Invalid value ${t3} for maxWait in "transactionOptions" provided to PrismaClient constructor. maxWait needs to be greater than 0`);
    let r2 = e.timeout;
    if (r2 != null && r2 <= 0)
      throw new N(`Invalid value ${r2} for timeout in "transactionOptions" provided to PrismaClient constructor. timeout needs to be greater than 0`);
  }, omit: (e, t3) => {
    if (typeof e != "object")
      throw new N('"omit" option is expected to be an object.');
    if (e === null)
      throw new N('"omit" option can not be `null`');
    let r2 = [];
    for (let [n2, i] of Object.entries(e)) {
      let o2 = Lm(n2, t3.runtimeDataModel);
      if (!o2) {
        r2.push({ kind: "UnknownModel", modelKey: n2 });
        continue;
      }
      for (let [s, a13] of Object.entries(i)) {
        let l2 = o2.fields.find((u) => u.name === s);
        if (!l2) {
          r2.push({ kind: "UnknownField", modelKey: n2, fieldName: s });
          continue;
        }
        if (l2.relationName) {
          r2.push({ kind: "RelationInOmit", modelKey: n2, fieldName: s });
          continue;
        }
        typeof a13 != "boolean" && r2.push({ kind: "InvalidFieldValue", modelKey: n2, fieldName: s });
      }
    }
    if (r2.length > 0)
      throw new N(Fm(e, r2));
  }, __internal: (e) => {
    if (!e)
      return;
    let t3 = ["debug", "engine", "configOverride"];
    if (typeof e != "object")
      throw new N(`Invalid value ${JSON.stringify(e)} for "__internal" to PrismaClient constructor`);
    for (let [r2] of Object.entries(e))
      if (!t3.includes(r2)) {
        let n2 = Vt(r2, t3);
        throw new N(`Invalid property ${JSON.stringify(r2)} for "__internal" provided to PrismaClient constructor.${n2}`);
      }
  } };
  function Jl(e, t3) {
    for (let [r2, n2] of Object.entries(e)) {
      if (!jl.includes(r2)) {
        let i = Vt(r2, jl);
        throw new N(`Unknown property ${r2} provided to PrismaClient constructor.${i}`);
      }
      _m[r2](n2, t3);
    }
    if (e.datasourceUrl && e.datasources)
      throw new N('Can not use "datasourceUrl" and "datasources" options at the same time. Pick one of them');
  }
  function Vt(e, t3) {
    if (t3.length === 0 || typeof e != "string")
      return "";
    let r2 = Nm(e, t3);
    return r2 ? ` Did you mean "${r2}"?` : "";
  }
  function Nm(e, t3) {
    if (t3.length === 0)
      return null;
    let r2 = t3.map((i) => ({ value: i, distance: (0, Gl.default)(e, i) }));
    r2.sort((i, o2) => i.distance < o2.distance ? -1 : 1);
    let n2 = r2[0];
    return n2.distance < 3 ? n2.value : null;
  }
  function Lm(e, t3) {
    return Ql(t3.models, e) ?? Ql(t3.types, e);
  }
  function Ql(e, t3) {
    let r2 = Object.keys(e).find((n2) => wt(n2) === t3);
    if (r2)
      return e[r2];
  }
  function Fm(e, t3) {
    let r2 = At(e);
    for (let o2 of t3)
      switch (o2.kind) {
        case "UnknownModel":
          r2.arguments.getField(o2.modelKey)?.markAsError(), r2.addErrorMessage(() => `Unknown model name: ${o2.modelKey}.`);
          break;
        case "UnknownField":
          r2.arguments.getDeepField([o2.modelKey, o2.fieldName])?.markAsError(), r2.addErrorMessage(() => `Model "${o2.modelKey}" does not have a field named "${o2.fieldName}".`);
          break;
        case "RelationInOmit":
          r2.arguments.getDeepField([o2.modelKey, o2.fieldName])?.markAsError(), r2.addErrorMessage(() => 'Relations are already excluded by default and can not be specified in "omit".');
          break;
        case "InvalidFieldValue":
          r2.arguments.getDeepFieldValue([o2.modelKey, o2.fieldName])?.markAsError(), r2.addErrorMessage(() => "Omit field option value must be a boolean.");
          break;
      }
    let { message: n2, args: i } = bn(r2, "colorless");
    return `Error validating "omit" option:

${i}

${n2}`;
  }
  function Hl(e) {
    return e.length === 0 ? Promise.resolve([]) : new Promise((t3, r2) => {
      let n2 = new Array(e.length), i = null, o2 = false, s = 0, a13 = () => {
        o2 || (s++, s === e.length && (o2 = true, i ? r2(i) : t3(n2)));
      }, l2 = (u) => {
        o2 || (o2 = true, r2(u));
      };
      for (let u = 0;u < e.length; u++)
        e[u].then((c2) => {
          n2[u] = c2, a13();
        }, (c2) => {
          if (!Mn(c2)) {
            l2(c2);
            return;
          }
          c2.batchRequestIdx === u ? l2(c2) : (i || (i = c2), a13());
        });
    });
  }
  var tt = L("prisma:client");
  typeof globalThis == "object" && (globalThis.NODE_CLIENT = true);
  var Mm = { requestArgsToMiddlewareArgs: (e) => e, middlewareArgsToRequestArgs: (e) => e };
  var $m = Symbol.for("prisma.client.transaction.id");
  var qm = { id: 0, nextId() {
    return ++this.id;
  } };
  function Xl(e) {

    class t3 {
      constructor(n2) {
        this._originalClient = this;
        this._middlewares = new Fn;
        this._createPrismaPromise = go();
        this.$extends = _a;
        e = n2?.__internal?.configOverride?.(e) ?? e, Ja(e), n2 && Jl(n2, e);
        let i = new zl.EventEmitter().on("error", () => {
        });
        this._extensions = It.empty(), this._previewFeatures = Ln(e), this._clientVersion = e.clientVersion ?? Vl, this._activeProvider = e.activeProvider, this._globalOmit = n2?.omit, this._tracingHelper = kl();
        let o2 = { rootEnvPath: e.relativeEnvPaths.rootEnvPath && Nr.default.resolve(e.dirname, e.relativeEnvPaths.rootEnvPath), schemaEnvPath: e.relativeEnvPaths.schemaEnvPath && Nr.default.resolve(e.dirname, e.relativeEnvPaths.schemaEnvPath) }, s;
        if (n2?.adapter) {
          s = Ui(n2.adapter);
          let l2 = e.activeProvider === "postgresql" ? "postgres" : e.activeProvider;
          if (s.provider !== l2)
            throw new R(`The Driver Adapter \`${s.adapterName}\`, based on \`${s.provider}\`, is not compatible with the provider \`${l2}\` specified in the Prisma schema.`, this._clientVersion);
          if (n2.datasources || n2.datasourceUrl !== undefined)
            throw new R("Custom datasource configuration is not compatible with Prisma Driver Adapters. Please define the database connection string directly in the Driver Adapter configuration.", this._clientVersion);
        }
        let a13 = !s && Kt(o2, { conflictCheck: "none" }) || e.injectableEdgeEnv?.();
        try {
          let l2 = n2 ?? {}, u = l2.__internal ?? {}, c2 = u.debug === true;
          c2 && L.enable("prisma:client");
          let p = Nr.default.resolve(e.dirname, e.relativePath);
          Zl.default.existsSync(p) || (p = e.dirname), tt("dirname", e.dirname), tt("relativePath", e.relativePath), tt("cwd", p);
          let d = u.engine || {};
          if (l2.errorFormat ? this._errorFormat = l2.errorFormat : process.env.NO_COLOR ? this._errorFormat = "colorless" : this._errorFormat = "colorless", this._runtimeDataModel = e.runtimeDataModel, this._engineConfig = { cwd: p, dirname: e.dirname, enableDebugLogs: c2, allowTriggerPanic: d.allowTriggerPanic, datamodelPath: Nr.default.join(e.dirname, e.filename ?? "schema.prisma"), prismaPath: d.binaryPath ?? undefined, engineEndpoint: d.endpoint, generator: e.generator, showColors: this._errorFormat === "pretty", logLevel: l2.log && _l(l2.log), logQueries: l2.log && !!(typeof l2.log == "string" ? l2.log === "query" : l2.log.find((f) => typeof f == "string" ? f === "query" : f.level === "query")), env: a13?.parsed ?? {}, flags: [], engineWasm: e.engineWasm, clientVersion: e.clientVersion, engineVersion: e.engineVersion, previewFeatures: this._previewFeatures, activeProvider: e.activeProvider, inlineSchema: e.inlineSchema, overrideDatasources: Ha(l2, e.datasourceNames), inlineDatasources: e.inlineDatasources, inlineSchemaHash: e.inlineSchemaHash, tracingHelper: this._tracingHelper, transactionOptions: { maxWait: l2.transactionOptions?.maxWait ?? 2000, timeout: l2.transactionOptions?.timeout ?? 5000, isolationLevel: l2.transactionOptions?.isolationLevel }, logEmitter: i, isBundled: e.isBundled, adapter: s }, this._accelerateEngineConfig = { ...this._engineConfig, accelerateUtils: { resolveDatasourceUrl: Lt, getBatchRequestPayload: Dt, prismaGraphQLToJSError: _t, PrismaClientUnknownRequestError: j, PrismaClientInitializationError: R, PrismaClientKnownRequestError: X, debug: L("prisma:client:accelerateEngine"), engineVersion: Kl.version, clientVersion: e.clientVersion } }, tt("clientVersion", e.clientVersion), this._engine = bl(e, this._engineConfig), this._requestHandler = new qn(this, i), l2.log)
            for (let f of l2.log) {
              let g = typeof f == "string" ? f : f.emit === "stdout" ? f.level : null;
              g && this.$on(g, (h) => {
                er.log(`${er.tags[g] ?? ""}`, h.message || h.query);
              });
            }
          this._metrics = new Ot(this._engine);
        } catch (l2) {
          throw l2.clientVersion = this._clientVersion, l2;
        }
        return this._appliedParent = yr(this);
      }
      get [Symbol.toStringTag]() {
        return "PrismaClient";
      }
      $use(n2) {
        this._middlewares.use(n2);
      }
      $on(n2, i) {
        n2 === "beforeExit" ? this._engine.onBeforeExit(i) : n2 && this._engineConfig.logEmitter.on(n2, i);
      }
      $connect() {
        try {
          return this._engine.start();
        } catch (n2) {
          throw n2.clientVersion = this._clientVersion, n2;
        }
      }
      async $disconnect() {
        try {
          await this._engine.stop();
        } catch (n2) {
          throw n2.clientVersion = this._clientVersion, n2;
        } finally {
          ko();
        }
      }
      $executeRawInternal(n2, i, o2, s) {
        let a13 = this._activeProvider;
        return this._request({ action: "executeRaw", args: o2, transaction: n2, clientMethod: i, argsMapper: fo({ clientMethod: i, activeProvider: a13 }), callsite: Ze(this._errorFormat), dataPath: [], middlewareArgsMapper: s });
      }
      $executeRaw(n2, ...i) {
        return this._createPrismaPromise((o2) => {
          if (n2.raw !== undefined || n2.sql !== undefined) {
            let [s, a13] = Wl(n2, i);
            return mo(this._activeProvider, s.text, s.values, Array.isArray(n2) ? "prisma.$executeRaw`<SQL>`" : "prisma.$executeRaw(sql`<SQL>`)"), this.$executeRawInternal(o2, "$executeRaw", s, a13);
          }
          throw new ee("`$executeRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#executeraw\n", { clientVersion: this._clientVersion });
        });
      }
      $executeRawUnsafe(n2, ...i) {
        return this._createPrismaPromise((o2) => (mo(this._activeProvider, n2, i, "prisma.$executeRawUnsafe(<SQL>, [...values])"), this.$executeRawInternal(o2, "$executeRawUnsafe", [n2, ...i])));
      }
      $runCommandRaw(n2) {
        if (e.activeProvider !== "mongodb")
          throw new ee(`The ${e.activeProvider} provider does not support $runCommandRaw. Use the mongodb provider.`, { clientVersion: this._clientVersion });
        return this._createPrismaPromise((i) => this._request({ args: n2, clientMethod: "$runCommandRaw", dataPath: [], action: "runCommandRaw", argsMapper: wl, callsite: Ze(this._errorFormat), transaction: i }));
      }
      async $queryRawInternal(n2, i, o2, s) {
        let a13 = this._activeProvider;
        return this._request({ action: "queryRaw", args: o2, transaction: n2, clientMethod: i, argsMapper: fo({ clientMethod: i, activeProvider: a13 }), callsite: Ze(this._errorFormat), dataPath: [], middlewareArgsMapper: s });
      }
      $queryRaw(n2, ...i) {
        return this._createPrismaPromise((o2) => {
          if (n2.raw !== undefined || n2.sql !== undefined)
            return this.$queryRawInternal(o2, "$queryRaw", ...Wl(n2, i));
          throw new ee("`$queryRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#queryraw\n", { clientVersion: this._clientVersion });
        });
      }
      $queryRawTyped(n2) {
        return this._createPrismaPromise((i) => {
          if (!this._hasPreviewFlag("typedSql"))
            throw new ee("`typedSql` preview feature must be enabled in order to access $queryRawTyped API", { clientVersion: this._clientVersion });
          return this.$queryRawInternal(i, "$queryRawTyped", n2);
        });
      }
      $queryRawUnsafe(n2, ...i) {
        return this._createPrismaPromise((o2) => this.$queryRawInternal(o2, "$queryRawUnsafe", [n2, ...i]));
      }
      _transactionWithArray({ promises: n2, options: i }) {
        let o2 = qm.nextId(), s = Dl(n2.length), a13 = n2.map((l2, u) => {
          if (l2?.[Symbol.toStringTag] !== "PrismaPromise")
            throw new Error("All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.");
          let c2 = i?.isolationLevel ?? this._engineConfig.transactionOptions.isolationLevel, p = { kind: "batch", id: o2, index: u, isolationLevel: c2, lock: s };
          return l2.requestTransaction?.(p) ?? l2;
        });
        return Hl(a13);
      }
      async _transactionWithCallback({ callback: n2, options: i }) {
        let o2 = { traceparent: this._tracingHelper.getTraceParent() }, s = { maxWait: i?.maxWait ?? this._engineConfig.transactionOptions.maxWait, timeout: i?.timeout ?? this._engineConfig.transactionOptions.timeout, isolationLevel: i?.isolationLevel ?? this._engineConfig.transactionOptions.isolationLevel }, a13 = await this._engine.transaction("start", o2, s), l2;
        try {
          let u = { kind: "itx", ...a13 };
          l2 = await n2(this._createItxClient(u)), await this._engine.transaction("commit", o2, a13);
        } catch (u) {
          throw await this._engine.transaction("rollback", o2, a13).catch(() => {
          }), u;
        }
        return l2;
      }
      _createItxClient(n2) {
        return yr(Ae(Da(this), [ne("_appliedParent", () => this._appliedParent._createItxClient(n2)), ne("_createPrismaPromise", () => go(n2)), ne($m, () => n2.id), kt(Cl)]));
      }
      $transaction(n2, i) {
        let o2;
        typeof n2 == "function" ? this._engineConfig.adapter?.adapterName === "@prisma/adapter-d1" ? o2 = () => {
          throw new Error("Cloudflare D1 does not support interactive transactions. We recommend you to refactor your queries with that limitation in mind, and use batch transactions with `prisma.$transactions([])` where applicable.");
        } : o2 = () => this._transactionWithCallback({ callback: n2, options: i }) : o2 = () => this._transactionWithArray({ promises: n2, options: i });
        let s = { name: "transaction", attributes: { method: "$transaction" } };
        return this._tracingHelper.runInChildSpan(s, o2);
      }
      _request(n2) {
        n2.otelParentCtx = this._tracingHelper.getActiveContext();
        let i = n2.middlewareArgsMapper ?? Mm, o2 = { args: i.requestArgsToMiddlewareArgs(n2.args), dataPath: n2.dataPath, runInTransaction: !!n2.transaction, action: n2.action, model: n2.model }, s = { middleware: { name: "middleware", middleware: true, attributes: { method: "$use" }, active: false }, operation: { name: "operation", attributes: { method: o2.action, model: o2.model, name: o2.model ? `${o2.model}.${o2.action}` : o2.action } } }, a13 = -1, l2 = async (u) => {
          let c2 = this._middlewares.get(++a13);
          if (c2)
            return this._tracingHelper.runInChildSpan(s.middleware, (O) => c2(u, (T) => (O?.end(), l2(T))));
          let { runInTransaction: p, args: d, ...f } = u, g = { ...n2, ...f };
          d && (g.args = i.middlewareArgsToRequestArgs(d)), n2.transaction !== undefined && p === false && delete g.transaction;
          let h = await Va(this, g);
          return g.model ? Fa({ result: h, modelName: g.model, args: g.args, extensions: this._extensions, runtimeDataModel: this._runtimeDataModel, globalOmit: this._globalOmit }) : h;
        };
        return this._tracingHelper.runInChildSpan(s.operation, () => new Yl.AsyncResource("prisma-client-request").runInAsyncScope(() => l2(o2)));
      }
      async _executeRequest({ args: n2, clientMethod: i, dataPath: o2, callsite: s, action: a13, model: l2, argsMapper: u, transaction: c2, unpacker: p, otelParentCtx: d, customDataProxyFetch: f }) {
        try {
          n2 = u ? u(n2) : n2;
          let g = { name: "serialize" }, h = this._tracingHelper.runInChildSpan(g, () => Pn({ modelName: l2, runtimeDataModel: this._runtimeDataModel, action: a13, args: n2, clientMethod: i, callsite: s, extensions: this._extensions, errorFormat: this._errorFormat, clientVersion: this._clientVersion, previewFeatures: this._previewFeatures, globalOmit: this._globalOmit }));
          return L.enabled("prisma:client") && (tt("Prisma Client call:"), tt(`prisma.${i}(${xa(n2)})`), tt("Generated request:"), tt(JSON.stringify(h, null, 2) + `
`)), c2?.kind === "batch" && await c2.lock, this._requestHandler.request({ protocolQuery: h, modelName: l2, action: a13, clientMethod: i, dataPath: o2, callsite: s, args: n2, extensions: this._extensions, transaction: c2, unpacker: p, otelParentCtx: d, otelChildCtx: this._tracingHelper.getActiveContext(), globalOmit: this._globalOmit, customDataProxyFetch: f });
        } catch (g) {
          throw g.clientVersion = this._clientVersion, g;
        }
      }
      get $metrics() {
        if (!this._hasPreviewFlag("metrics"))
          throw new ee("`metrics` preview feature must be enabled in order to access metrics API", { clientVersion: this._clientVersion });
        return this._metrics;
      }
      _hasPreviewFlag(n2) {
        return !!this._engineConfig.previewFeatures?.includes(n2);
      }
      $applyPendingMigrations() {
        return this._engine.applyPendingMigrations();
      }
    }
    return t3;
  }
  function Wl(e, t3) {
    return Vm(e) ? [new se(e, t3), Al] : [e, Il];
  }
  function Vm(e) {
    return Array.isArray(e) && Array.isArray(e.raw);
  }
  var jm = new Set(["toJSON", "$$typeof", "asymmetricMatch", Symbol.iterator, Symbol.toStringTag, Symbol.isConcatSpreadable, Symbol.toPrimitive]);
  function eu(e) {
    return new Proxy(e, { get(t3, r2) {
      if (r2 in t3)
        return t3[r2];
      if (!jm.has(r2))
        throw new TypeError(`Invalid enum value: ${String(r2)}`);
    } });
  }
  function tu(e) {
    Kt(e, { conflictCheck: "warn" });
  }
  /*! Bundled license information:
  
  decimal.js/decimal.mjs:
    (*!
     *  decimal.js v10.4.3
     *  An arbitrary-precision Decimal type for JavaScript.
     *  https://github.com/MikeMcl/decimal.js
     *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
     *  MIT Licence
     *)
  */
});

// node_modules/.pnpm/@prisma+client@6.1.0_prisma@6.1.0/node_modules/.prisma/client/index.js
var require_client = __commonJS((exports) => {
  var __dirname = "/home/hussain/React Native/New-Cart-Task/elysiaApis/apisEly/node_modules/.pnpm/@prisma+client@6.1.0_prisma@6.1.0/node_modules/.prisma/client";
  Object.defineProperty(exports, "__esModule", { value: true });
  var {
    PrismaClientKnownRequestError: PrismaClientKnownRequestError2,
    PrismaClientUnknownRequestError: PrismaClientUnknownRequestError2,
    PrismaClientRustPanicError: PrismaClientRustPanicError2,
    PrismaClientInitializationError: PrismaClientInitializationError2,
    PrismaClientValidationError: PrismaClientValidationError2,
    getPrismaClient: getPrismaClient2,
    sqltag: sqltag2,
    empty: empty2,
    join: join3,
    raw: raw2,
    skip: skip2,
    Decimal: Decimal2,
    Debug: Debug2,
    objectEnumValues: objectEnumValues2,
    makeStrictEnum: makeStrictEnum2,
    Extensions: Extensions2,
    warnOnce: warnOnce2,
    defineDmmfProperty: defineDmmfProperty2,
    Public: Public2,
    getRuntime: getRuntime2
  } = require_library();
  var Prisma = {};
  exports.Prisma = Prisma;
  exports.$Enums = {};
  Prisma.prismaVersion = {
    client: "6.1.0",
    engine: "11f085a2012c0f4778414c8db2651556ee0ef959"
  };
  Prisma.PrismaClientKnownRequestError = PrismaClientKnownRequestError2;
  Prisma.PrismaClientUnknownRequestError = PrismaClientUnknownRequestError2;
  Prisma.PrismaClientRustPanicError = PrismaClientRustPanicError2;
  Prisma.PrismaClientInitializationError = PrismaClientInitializationError2;
  Prisma.PrismaClientValidationError = PrismaClientValidationError2;
  Prisma.Decimal = Decimal2;
  Prisma.sql = sqltag2;
  Prisma.empty = empty2;
  Prisma.join = join3;
  Prisma.raw = raw2;
  Prisma.validator = Public2.validator;
  Prisma.getExtensionContext = Extensions2.getExtensionContext;
  Prisma.defineExtension = Extensions2.defineExtension;
  Prisma.DbNull = objectEnumValues2.instances.DbNull;
  Prisma.JsonNull = objectEnumValues2.instances.JsonNull;
  Prisma.AnyNull = objectEnumValues2.instances.AnyNull;
  Prisma.NullTypes = {
    DbNull: objectEnumValues2.classes.DbNull,
    JsonNull: objectEnumValues2.classes.JsonNull,
    AnyNull: objectEnumValues2.classes.AnyNull
  };
  var path2 = import.meta.require("path");
  exports.Prisma.TransactionIsolationLevel = makeStrictEnum2({
    ReadUncommitted: "ReadUncommitted",
    ReadCommitted: "ReadCommitted",
    RepeatableRead: "RepeatableRead",
    Serializable: "Serializable"
  });
  exports.Prisma.UserScalarFieldEnum = {
    id: "id",
    name: "name",
    image: "image",
    email: "email",
    password: "password",
    createdAt: "createdAt",
    updatedAt: "updatedAt"
  };
  exports.Prisma.ProductScalarFieldEnum = {
    id: "id",
    name: "name",
    description: "description",
    price: "price",
    image: "image",
    stock: "stock",
    createdAt: "createdAt",
    updatedAt: "updatedAt"
  };
  exports.Prisma.OrderItemScalarFieldEnum = {
    id: "id",
    quantity: "quantity",
    price: "price",
    productId: "productId",
    orderId: "orderId",
    createdAt: "createdAt",
    updatedAt: "updatedAt"
  };
  exports.Prisma.OrderScalarFieldEnum = {
    id: "id",
    userId: "userId",
    totalPrice: "totalPrice",
    deliveryAddress: "deliveryAddress",
    deliveryStatus: "deliveryStatus",
    paymentStatus: "paymentStatus",
    paymentIntentId: "paymentIntentId",
    paymentDetails: "paymentDetails",
    createdAt: "createdAt",
    updatedAt: "updatedAt"
  };
  exports.Prisma.SortOrder = {
    asc: "asc",
    desc: "desc"
  };
  exports.Prisma.JsonNullValueInput = {
    JsonNull: Prisma.JsonNull
  };
  exports.Prisma.QueryMode = {
    default: "default",
    insensitive: "insensitive"
  };
  exports.Prisma.JsonNullValueFilter = {
    DbNull: Prisma.DbNull,
    JsonNull: Prisma.JsonNull,
    AnyNull: Prisma.AnyNull
  };
  exports.PaymentStatus = exports.$Enums.PaymentStatus = {
    PAID: "PAID",
    PENDING: "PENDING",
    FAILED: "FAILED"
  };
  exports.DeliveryStatus = exports.$Enums.DeliveryStatus = {
    DELIVERED: "DELIVERED",
    PENDING: "PENDING",
    FAILED: "FAILED"
  };
  exports.Prisma.ModelName = {
    User: "User",
    Product: "Product",
    OrderItem: "OrderItem",
    Order: "Order"
  };
  var config2 = {
    generator: {
      name: "client",
      provider: {
        fromEnvVar: null,
        value: "prisma-client-js"
      },
      output: {
        value: "/home/hussain/React Native/New-Cart-Task/elysiaApis/apisEly/node_modules/.pnpm/@prisma+client@6.1.0_prisma@6.1.0/node_modules/@prisma/client",
        fromEnvVar: null
      },
      config: {
        engineType: "library"
      },
      binaryTargets: [
        {
          fromEnvVar: null,
          value: "debian-openssl-3.0.x",
          native: true
        },
        {
          fromEnvVar: null,
          value: "debian-openssl-3.0.x"
        }
      ],
      previewFeatures: [],
      sourceFilePath: "/home/hussain/React Native/New-Cart-Task/elysiaApis/apisEly/prisma/schema.prisma"
    },
    relativeEnvPaths: {
      rootEnvPath: null,
      schemaEnvPath: "../../../../../../.env"
    },
    relativePath: "../../../../../../prisma",
    clientVersion: "6.1.0",
    engineVersion: "11f085a2012c0f4778414c8db2651556ee0ef959",
    datasourceNames: [
      "db"
    ],
    activeProvider: "postgresql",
    postinstall: false,
    inlineDatasources: {
      db: {
        url: {
          fromEnvVar: "DATABASE_URL",
          value: null
        }
      }
    },
    inlineSchema: `generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

//User Data
model User {
  id        String   @id @default(uuid())
  name      String
  image     String
  email     String   @unique
  password  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  order Order[]
}

//Product Data
model Product {
  id          String   @id @default(uuid())
  name        String
  description String
  price       Float
  image       String
  stock       Int
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  orderItems OrderItem[]
}

//Order Item

model OrderItem {
  id        String   @id @default(uuid())
  quantity  Int
  price     Float
  productId String
  product   Product  @relation(fields: [productId], references: [id])
  orderId   String
  order     Order    @relation(fields: [orderId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

//Payment Status
enum PaymentStatus {
  PAID
  PENDING
  FAILED
}

enum DeliveryStatus {
  DELIVERED
  PENDING
  FAILED
}

//Order Data
model Order {
  id              String         @id @default(uuid())
  userId          String
  user            User           @relation(fields: [userId], references: [id])
  totalPrice      Float
  deliveryAddress String
  deliveryStatus  DeliveryStatus
  paymentStatus   PaymentStatus
  paymentIntentId String
  paymentDetails  Json
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  orderItems OrderItem[]
}
`,
    inlineSchemaHash: "9a729ccf0d292c6ad45cae7a79686e135dd45546d26ed62bdd378987b6d29869",
    copyEngine: true
  };
  var fs = import.meta.require("fs");
  config2.dirname = __dirname;
  if (!fs.existsSync(path2.join(__dirname, "schema.prisma"))) {
    const alternativePaths = [
      "node_modules/.pnpm/@prisma+client@6.1.0_prisma@6.1.0/node_modules/.prisma/client",
      ".pnpm/@prisma+client@6.1.0_prisma@6.1.0/node_modules/.prisma/client"
    ];
    const alternativePath = alternativePaths.find((altPath) => {
      return fs.existsSync(path2.join(process.cwd(), altPath, "schema.prisma"));
    }) ?? alternativePaths[0];
    config2.dirname = path2.join(process.cwd(), alternativePath);
    config2.isBundled = true;
  }
  config2.runtimeDataModel = JSON.parse('{"models":{"User":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"uuid","args":[4]},"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"image","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"email","kind":"scalar","isList":false,"isRequired":true,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"password","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"order","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Order","nativeType":null,"relationName":"OrderToUser","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Product":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"uuid","args":[4]},"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"description","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"price","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Float","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"image","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"stock","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"orderItems","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"OrderItem","nativeType":null,"relationName":"OrderItemToProduct","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"OrderItem":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"uuid","args":[4]},"isGenerated":false,"isUpdatedAt":false},{"name":"quantity","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"price","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Float","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"productId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"product","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Product","nativeType":null,"relationName":"OrderItemToProduct","relationFromFields":["productId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"orderId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"order","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Order","nativeType":null,"relationName":"OrderToOrderItem","relationFromFields":["orderId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},"Order":{"dbName":null,"schema":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","nativeType":null,"default":{"name":"uuid","args":[4]},"isGenerated":false,"isUpdatedAt":false},{"name":"userId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"user","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","nativeType":null,"relationName":"OrderToUser","relationFromFields":["userId"],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false},{"name":"totalPrice","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Float","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"deliveryAddress","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"deliveryStatus","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DeliveryStatus","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"paymentStatus","kind":"enum","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"PaymentStatus","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"paymentIntentId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"paymentDetails","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Json","nativeType":null,"isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","nativeType":null,"default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","nativeType":null,"isGenerated":false,"isUpdatedAt":true},{"name":"orderItems","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"OrderItem","nativeType":null,"relationName":"OrderToOrderItem","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false}},"enums":{"PaymentStatus":{"values":[{"name":"PAID","dbName":null},{"name":"PENDING","dbName":null},{"name":"FAILED","dbName":null}],"dbName":null},"DeliveryStatus":{"values":[{"name":"DELIVERED","dbName":null},{"name":"PENDING","dbName":null},{"name":"FAILED","dbName":null}],"dbName":null}},"types":{}}');
  defineDmmfProperty2(exports.Prisma, config2.runtimeDataModel);
  config2.engineWasm = undefined;
  var { warnEnvConflicts: warnEnvConflicts2 } = require_library();
  warnEnvConflicts2({
    rootEnvPath: config2.relativeEnvPaths.rootEnvPath && path2.resolve(config2.dirname, config2.relativeEnvPaths.rootEnvPath),
    schemaEnvPath: config2.relativeEnvPaths.schemaEnvPath && path2.resolve(config2.dirname, config2.relativeEnvPaths.schemaEnvPath)
  });
  var PrismaClient = getPrismaClient2(config2);
  exports.PrismaClient = PrismaClient;
  Object.assign(exports, Prisma);
  path2.join(__dirname, "libquery_engine-debian-openssl-3.0.x.so.node");
  path2.join(process.cwd(), "node_modules/.pnpm/@prisma+client@6.1.0_prisma@6.1.0/node_modules/.prisma/client/libquery_engine-debian-openssl-3.0.x.so.node");
  path2.join(__dirname, "schema.prisma");
  path2.join(process.cwd(), "node_modules/.pnpm/@prisma+client@6.1.0_prisma@6.1.0/node_modules/.prisma/client/schema.prisma");
});

// node_modules/.pnpm/@prisma+client@6.1.0_prisma@6.1.0/node_modules/.prisma/client/default.js
var require_default = __commonJS((exports, module) => {
  module.exports = { ...require_client() };
});

// node_modules/.pnpm/@prisma+client@6.1.0_prisma@6.1.0/node_modules/@prisma/client/default.js
var require_default2 = __commonJS((exports, module) => {
  module.exports = {
    ...require_default()
  };
});

// node_modules/pino-std-serializers/lib/err-helpers.js
var require_err_helpers = __commonJS((exports, module) => {
  var isErrorLike = (err) => {
    return err && typeof err.message === "string";
  };
  var getErrorCause = (err) => {
    if (!err)
      return;
    const cause = err.cause;
    if (typeof cause === "function") {
      const causeResult = err.cause();
      return isErrorLike(causeResult) ? causeResult : undefined;
    } else {
      return isErrorLike(cause) ? cause : undefined;
    }
  };
  var _stackWithCauses = (err, seen) => {
    if (!isErrorLike(err))
      return "";
    const stack = err.stack || "";
    if (seen.has(err)) {
      return stack + `
causes have become circular...`;
    }
    const cause = getErrorCause(err);
    if (cause) {
      seen.add(err);
      return stack + `
caused by: ` + _stackWithCauses(cause, seen);
    } else {
      return stack;
    }
  };
  var stackWithCauses = (err) => _stackWithCauses(err, new Set);
  var _messageWithCauses = (err, seen, skip2) => {
    if (!isErrorLike(err))
      return "";
    const message2 = skip2 ? "" : err.message || "";
    if (seen.has(err)) {
      return message2 + ": ...";
    }
    const cause = getErrorCause(err);
    if (cause) {
      seen.add(err);
      const skipIfVErrorStyleCause = typeof err.cause === "function";
      return message2 + (skipIfVErrorStyleCause ? "" : ": ") + _messageWithCauses(cause, seen, skipIfVErrorStyleCause);
    } else {
      return message2;
    }
  };
  var messageWithCauses = (err) => _messageWithCauses(err, new Set);
  module.exports = {
    isErrorLike,
    getErrorCause,
    stackWithCauses,
    messageWithCauses
  };
});

// node_modules/pino-std-serializers/lib/err-proto.js
var require_err_proto = __commonJS((exports, module) => {
  var seen = Symbol("circular-ref-tag");
  var rawSymbol = Symbol("pino-raw-err-ref");
  var pinoErrProto = Object.create({}, {
    type: {
      enumerable: true,
      writable: true,
      value: undefined
    },
    message: {
      enumerable: true,
      writable: true,
      value: undefined
    },
    stack: {
      enumerable: true,
      writable: true,
      value: undefined
    },
    aggregateErrors: {
      enumerable: true,
      writable: true,
      value: undefined
    },
    raw: {
      enumerable: false,
      get: function() {
        return this[rawSymbol];
      },
      set: function(val) {
        this[rawSymbol] = val;
      }
    }
  });
  Object.defineProperty(pinoErrProto, rawSymbol, {
    writable: true,
    value: {}
  });
  module.exports = {
    pinoErrProto,
    pinoErrorSymbols: {
      seen,
      rawSymbol
    }
  };
});

// node_modules/pino-std-serializers/lib/err.js
var require_err = __commonJS((exports, module) => {
  module.exports = errSerializer;
  var { messageWithCauses, stackWithCauses, isErrorLike } = require_err_helpers();
  var { pinoErrProto, pinoErrorSymbols } = require_err_proto();
  var { seen } = pinoErrorSymbols;
  var { toString } = Object.prototype;
  function errSerializer(err) {
    if (!isErrorLike(err)) {
      return err;
    }
    err[seen] = undefined;
    const _err = Object.create(pinoErrProto);
    _err.type = toString.call(err.constructor) === "[object Function]" ? err.constructor.name : err.name;
    _err.message = messageWithCauses(err);
    _err.stack = stackWithCauses(err);
    if (Array.isArray(err.errors)) {
      _err.aggregateErrors = err.errors.map((err2) => errSerializer(err2));
    }
    for (const key in err) {
      if (_err[key] === undefined) {
        const val = err[key];
        if (isErrorLike(val)) {
          if (key !== "cause" && !Object.prototype.hasOwnProperty.call(val, seen)) {
            _err[key] = errSerializer(val);
          }
        } else {
          _err[key] = val;
        }
      }
    }
    delete err[seen];
    _err.raw = err;
    return _err;
  }
});

// node_modules/pino-std-serializers/lib/err-with-cause.js
var require_err_with_cause = __commonJS((exports, module) => {
  module.exports = errWithCauseSerializer;
  var { isErrorLike } = require_err_helpers();
  var { pinoErrProto, pinoErrorSymbols } = require_err_proto();
  var { seen } = pinoErrorSymbols;
  var { toString } = Object.prototype;
  function errWithCauseSerializer(err) {
    if (!isErrorLike(err)) {
      return err;
    }
    err[seen] = undefined;
    const _err = Object.create(pinoErrProto);
    _err.type = toString.call(err.constructor) === "[object Function]" ? err.constructor.name : err.name;
    _err.message = err.message;
    _err.stack = err.stack;
    if (Array.isArray(err.errors)) {
      _err.aggregateErrors = err.errors.map((err2) => errWithCauseSerializer(err2));
    }
    if (isErrorLike(err.cause) && !Object.prototype.hasOwnProperty.call(err.cause, seen)) {
      _err.cause = errWithCauseSerializer(err.cause);
    }
    for (const key in err) {
      if (_err[key] === undefined) {
        const val = err[key];
        if (isErrorLike(val)) {
          if (!Object.prototype.hasOwnProperty.call(val, seen)) {
            _err[key] = errWithCauseSerializer(val);
          }
        } else {
          _err[key] = val;
        }
      }
    }
    delete err[seen];
    _err.raw = err;
    return _err;
  }
});

// node_modules/pino-std-serializers/lib/req.js
var require_req = __commonJS((exports, module) => {
  module.exports = {
    mapHttpRequest,
    reqSerializer
  };
  var rawSymbol = Symbol("pino-raw-req-ref");
  var pinoReqProto = Object.create({}, {
    id: {
      enumerable: true,
      writable: true,
      value: ""
    },
    method: {
      enumerable: true,
      writable: true,
      value: ""
    },
    url: {
      enumerable: true,
      writable: true,
      value: ""
    },
    query: {
      enumerable: true,
      writable: true,
      value: ""
    },
    params: {
      enumerable: true,
      writable: true,
      value: ""
    },
    headers: {
      enumerable: true,
      writable: true,
      value: {}
    },
    remoteAddress: {
      enumerable: true,
      writable: true,
      value: ""
    },
    remotePort: {
      enumerable: true,
      writable: true,
      value: ""
    },
    raw: {
      enumerable: false,
      get: function() {
        return this[rawSymbol];
      },
      set: function(val) {
        this[rawSymbol] = val;
      }
    }
  });
  Object.defineProperty(pinoReqProto, rawSymbol, {
    writable: true,
    value: {}
  });
  function reqSerializer(req) {
    const connection = req.info || req.socket;
    const _req = Object.create(pinoReqProto);
    _req.id = typeof req.id === "function" ? req.id() : req.id || (req.info ? req.info.id : undefined);
    _req.method = req.method;
    if (req.originalUrl) {
      _req.url = req.originalUrl;
    } else {
      const path2 = req.path;
      _req.url = typeof path2 === "string" ? path2 : req.url ? req.url.path || req.url : undefined;
    }
    if (req.query) {
      _req.query = req.query;
    }
    if (req.params) {
      _req.params = req.params;
    }
    _req.headers = req.headers;
    _req.remoteAddress = connection && connection.remoteAddress;
    _req.remotePort = connection && connection.remotePort;
    _req.raw = req.raw || req;
    return _req;
  }
  function mapHttpRequest(req) {
    return {
      req: reqSerializer(req)
    };
  }
});

// node_modules/pino-std-serializers/lib/res.js
var require_res = __commonJS((exports, module) => {
  module.exports = {
    mapHttpResponse,
    resSerializer
  };
  var rawSymbol = Symbol("pino-raw-res-ref");
  var pinoResProto = Object.create({}, {
    statusCode: {
      enumerable: true,
      writable: true,
      value: 0
    },
    headers: {
      enumerable: true,
      writable: true,
      value: ""
    },
    raw: {
      enumerable: false,
      get: function() {
        return this[rawSymbol];
      },
      set: function(val) {
        this[rawSymbol] = val;
      }
    }
  });
  Object.defineProperty(pinoResProto, rawSymbol, {
    writable: true,
    value: {}
  });
  function resSerializer(res) {
    const _res = Object.create(pinoResProto);
    _res.statusCode = res.headersSent ? res.statusCode : null;
    _res.headers = res.getHeaders ? res.getHeaders() : res._headers;
    _res.raw = res;
    return _res;
  }
  function mapHttpResponse(res) {
    return {
      res: resSerializer(res)
    };
  }
});

// node_modules/pino-std-serializers/index.js
var require_pino_std_serializers = __commonJS((exports, module) => {
  var errSerializer = require_err();
  var errWithCauseSerializer = require_err_with_cause();
  var reqSerializers = require_req();
  var resSerializers = require_res();
  module.exports = {
    err: errSerializer,
    errWithCause: errWithCauseSerializer,
    mapHttpRequest: reqSerializers.mapHttpRequest,
    mapHttpResponse: resSerializers.mapHttpResponse,
    req: reqSerializers.reqSerializer,
    res: resSerializers.resSerializer,
    wrapErrorSerializer: function wrapErrorSerializer(customSerializer) {
      if (customSerializer === errSerializer)
        return customSerializer;
      return function wrapErrSerializer(err) {
        return customSerializer(errSerializer(err));
      };
    },
    wrapRequestSerializer: function wrapRequestSerializer(customSerializer) {
      if (customSerializer === reqSerializers.reqSerializer)
        return customSerializer;
      return function wrappedReqSerializer(req) {
        return customSerializer(reqSerializers.reqSerializer(req));
      };
    },
    wrapResponseSerializer: function wrapResponseSerializer(customSerializer) {
      if (customSerializer === resSerializers.resSerializer)
        return customSerializer;
      return function wrappedResSerializer(res) {
        return customSerializer(resSerializers.resSerializer(res));
      };
    }
  };
});

// node_modules/pino/lib/caller.js
var require_caller = __commonJS((exports, module) => {
  function noOpPrepareStackTrace(_3, stack) {
    return stack;
  }
  module.exports = function getCallers() {
    const originalPrepare = Error.prepareStackTrace;
    Error.prepareStackTrace = noOpPrepareStackTrace;
    const stack = new Error().stack;
    Error.prepareStackTrace = originalPrepare;
    if (!Array.isArray(stack)) {
      return;
    }
    const entries = stack.slice(2);
    const fileNames = [];
    for (const entry of entries) {
      if (!entry) {
        continue;
      }
      fileNames.push(entry.getFileName());
    }
    return fileNames;
  };
});

// node_modules/fast-redact/lib/validator.js
var require_validator = __commonJS((exports, module) => {
  module.exports = validator;
  function validator(opts = {}) {
    const {
      ERR_PATHS_MUST_BE_STRINGS = () => "fast-redact - Paths must be (non-empty) strings",
      ERR_INVALID_PATH = (s) => `fast-redact \u2013 Invalid path (${s})`
    } = opts;
    return function validate({ paths }) {
      paths.forEach((s) => {
        if (typeof s !== "string") {
          throw Error(ERR_PATHS_MUST_BE_STRINGS());
        }
        try {
          if (/\u3007/.test(s))
            throw Error();
          const expr = (s[0] === "[" ? "" : ".") + s.replace(/^\*/, "\u3007").replace(/\.\*/g, ".\u3007").replace(/\[\*\]/g, "[\u3007]");
          if (/\n|\r|;/.test(expr))
            throw Error();
          if (/\/\*/.test(expr))
            throw Error();
          Function(`
            'use strict'
            const o = new Proxy({}, { get: () => o, set: () => { throw Error() } });
            const \u3007 = null;
            o${expr}
            if ([o${expr}].length !== 1) throw Error()`)();
        } catch (e) {
          throw Error(ERR_INVALID_PATH(s));
        }
      });
    };
  }
});

// node_modules/fast-redact/lib/rx.js
var require_rx = __commonJS((exports, module) => {
  module.exports = /[^.[\]]+|\[((?:.)*?)\]/g;
});

// node_modules/fast-redact/lib/parse.js
var require_parse = __commonJS((exports, module) => {
  var rx = require_rx();
  module.exports = parse6;
  function parse6({ paths }) {
    const wildcards = [];
    var wcLen = 0;
    const secret = paths.reduce(function(o2, strPath, ix) {
      var path2 = strPath.match(rx).map((p) => p.replace(/'|"|`/g, ""));
      const leadingBracket = strPath[0] === "[";
      path2 = path2.map((p) => {
        if (p[0] === "[")
          return p.substr(1, p.length - 2);
        else
          return p;
      });
      const star = path2.indexOf("*");
      if (star > -1) {
        const before = path2.slice(0, star);
        const beforeStr = before.join(".");
        const after = path2.slice(star + 1, path2.length);
        const nested = after.length > 0;
        wcLen++;
        wildcards.push({
          before,
          beforeStr,
          after,
          nested
        });
      } else {
        o2[strPath] = {
          path: path2,
          val: undefined,
          precensored: false,
          circle: "",
          escPath: JSON.stringify(strPath),
          leadingBracket
        };
      }
      return o2;
    }, {});
    return { wildcards, wcLen, secret };
  }
});

// node_modules/fast-redact/lib/redactor.js
var require_redactor = __commonJS((exports, module) => {
  var rx = require_rx();
  module.exports = redactor;
  function redactor({ secret, serialize: serialize3, wcLen, strict, isCensorFct, censorFctTakesPath }, state) {
    const redact = Function("o", `
    if (typeof o !== 'object' || o == null) {
      ${strictImpl(strict, serialize3)}
    }
    const { censor, secret } = this
    const originalSecret = {}
    const secretKeys = Object.keys(secret)
    for (var i = 0; i < secretKeys.length; i++) {
      originalSecret[secretKeys[i]] = secret[secretKeys[i]]
    }

    ${redactTmpl(secret, isCensorFct, censorFctTakesPath)}
    this.compileRestore()
    ${dynamicRedactTmpl(wcLen > 0, isCensorFct, censorFctTakesPath)}
    this.secret = originalSecret
    ${resultTmpl(serialize3)}
  `).bind(state);
    redact.state = state;
    if (serialize3 === false) {
      redact.restore = (o2) => state.restore(o2);
    }
    return redact;
  }
  function redactTmpl(secret, isCensorFct, censorFctTakesPath) {
    return Object.keys(secret).map((path2) => {
      const { escPath, leadingBracket, path: arrPath } = secret[path2];
      const skip2 = leadingBracket ? 1 : 0;
      const delim = leadingBracket ? "" : ".";
      const hops = [];
      var match;
      while ((match = rx.exec(path2)) !== null) {
        const [, ix] = match;
        const { index, input } = match;
        if (index > skip2)
          hops.push(input.substring(0, index - (ix ? 0 : 1)));
      }
      var existence = hops.map((p) => `o${delim}${p}`).join(" && ");
      if (existence.length === 0)
        existence += `o${delim}${path2} != null`;
      else
        existence += ` && o${delim}${path2} != null`;
      const circularDetection = `
      switch (true) {
        ${hops.reverse().map((p) => `
          case o${delim}${p} === censor:
            secret[${escPath}].circle = ${JSON.stringify(p)}
            break
        `).join(`
`)}
      }
    `;
      const censorArgs = censorFctTakesPath ? `val, ${JSON.stringify(arrPath)}` : `val`;
      return `
      if (${existence}) {
        const val = o${delim}${path2}
        if (val === censor) {
          secret[${escPath}].precensored = true
        } else {
          secret[${escPath}].val = val
          o${delim}${path2} = ${isCensorFct ? `censor(${censorArgs})` : "censor"}
          ${circularDetection}
        }
      }
    `;
    }).join(`
`);
  }
  function dynamicRedactTmpl(hasWildcards, isCensorFct, censorFctTakesPath) {
    return hasWildcards === true ? `
    {
      const { wildcards, wcLen, groupRedact, nestedRedact } = this
      for (var i = 0; i < wcLen; i++) {
        const { before, beforeStr, after, nested } = wildcards[i]
        if (nested === true) {
          secret[beforeStr] = secret[beforeStr] || []
          nestedRedact(secret[beforeStr], o, before, after, censor, ${isCensorFct}, ${censorFctTakesPath})
        } else secret[beforeStr] = groupRedact(o, before, censor, ${isCensorFct}, ${censorFctTakesPath})
      }
    }
  ` : "";
  }
  function resultTmpl(serialize3) {
    return serialize3 === false ? `return o` : `
    var s = this.serialize(o)
    this.restore(o)
    return s
  `;
  }
  function strictImpl(strict, serialize3) {
    return strict === true ? `throw Error('fast-redact: primitives cannot be redacted')` : serialize3 === false ? `return o` : `return this.serialize(o)`;
  }
});

// node_modules/fast-redact/lib/modifiers.js
var require_modifiers = __commonJS((exports, module) => {
  module.exports = {
    groupRedact,
    groupRestore,
    nestedRedact,
    nestedRestore
  };
  function groupRestore({ keys, values, target }) {
    if (target == null || typeof target === "string")
      return;
    const length = keys.length;
    for (var i = 0;i < length; i++) {
      const k = keys[i];
      target[k] = values[i];
    }
  }
  function groupRedact(o2, path2, censor, isCensorFct, censorFctTakesPath) {
    const target = get(o2, path2);
    if (target == null || typeof target === "string")
      return { keys: null, values: null, target, flat: true };
    const keys = Object.keys(target);
    const keysLength = keys.length;
    const pathLength = path2.length;
    const pathWithKey = censorFctTakesPath ? [...path2] : undefined;
    const values = new Array(keysLength);
    for (var i = 0;i < keysLength; i++) {
      const key = keys[i];
      values[i] = target[key];
      if (censorFctTakesPath) {
        pathWithKey[pathLength] = key;
        target[key] = censor(target[key], pathWithKey);
      } else if (isCensorFct) {
        target[key] = censor(target[key]);
      } else {
        target[key] = censor;
      }
    }
    return { keys, values, target, flat: true };
  }
  function nestedRestore(instructions) {
    for (let i = 0;i < instructions.length; i++) {
      const { target, path: path2, value } = instructions[i];
      let current = target;
      for (let i2 = path2.length - 1;i2 > 0; i2--) {
        current = current[path2[i2]];
      }
      current[path2[0]] = value;
    }
  }
  function nestedRedact(store, o2, path2, ns, censor, isCensorFct, censorFctTakesPath) {
    const target = get(o2, path2);
    if (target == null)
      return;
    const keys = Object.keys(target);
    const keysLength = keys.length;
    for (var i = 0;i < keysLength; i++) {
      const key = keys[i];
      specialSet(store, target, key, path2, ns, censor, isCensorFct, censorFctTakesPath);
    }
    return store;
  }
  function has(obj, prop) {
    return obj !== undefined && obj !== null ? "hasOwn" in Object ? Object.hasOwn(obj, prop) : Object.prototype.hasOwnProperty.call(obj, prop) : false;
  }
  function specialSet(store, o2, k, path2, afterPath, censor, isCensorFct, censorFctTakesPath) {
    const afterPathLen = afterPath.length;
    const lastPathIndex = afterPathLen - 1;
    const originalKey = k;
    var i = -1;
    var n2;
    var nv;
    var ov;
    var oov = null;
    var wc = null;
    var kIsWc;
    var wcov;
    var consecutive = false;
    var level = 0;
    var depth = 0;
    var redactPathCurrent = tree();
    ov = n2 = o2[k];
    if (typeof n2 !== "object")
      return;
    while (n2 != null && ++i < afterPathLen) {
      depth += 1;
      k = afterPath[i];
      oov = ov;
      if (k !== "*" && !wc && !(typeof n2 === "object" && (k in n2))) {
        break;
      }
      if (k === "*") {
        if (wc === "*") {
          consecutive = true;
        }
        wc = k;
        if (i !== lastPathIndex) {
          continue;
        }
      }
      if (wc) {
        const wcKeys = Object.keys(n2);
        for (var j = 0;j < wcKeys.length; j++) {
          const wck = wcKeys[j];
          wcov = n2[wck];
          kIsWc = k === "*";
          if (consecutive) {
            redactPathCurrent = node(redactPathCurrent, wck, depth);
            level = i;
            ov = iterateNthLevel(wcov, level - 1, k, path2, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n2, nv, ov, kIsWc, wck, i, lastPathIndex, redactPathCurrent, store, o2[originalKey], depth + 1);
          } else {
            if (kIsWc || typeof wcov === "object" && wcov !== null && k in wcov) {
              if (kIsWc) {
                ov = wcov;
              } else {
                ov = wcov[k];
              }
              nv = i !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [...path2, originalKey, ...afterPath]) : censor(ov) : censor;
              if (kIsWc) {
                const rv = restoreInstr(node(redactPathCurrent, wck, depth), ov, o2[originalKey]);
                store.push(rv);
                n2[wck] = nv;
              } else {
                if (wcov[k] === nv) {
                } else if (nv === undefined && censor !== undefined || has(wcov, k) && nv === ov) {
                  redactPathCurrent = node(redactPathCurrent, wck, depth);
                } else {
                  redactPathCurrent = node(redactPathCurrent, wck, depth);
                  const rv = restoreInstr(node(redactPathCurrent, k, depth + 1), ov, o2[originalKey]);
                  store.push(rv);
                  wcov[k] = nv;
                }
              }
            }
          }
        }
        wc = null;
      } else {
        ov = n2[k];
        redactPathCurrent = node(redactPathCurrent, k, depth);
        nv = i !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [...path2, originalKey, ...afterPath]) : censor(ov) : censor;
        if (has(n2, k) && nv === ov || nv === undefined && censor !== undefined) {
        } else {
          const rv = restoreInstr(redactPathCurrent, ov, o2[originalKey]);
          store.push(rv);
          n2[k] = nv;
        }
        n2 = n2[k];
      }
      if (typeof n2 !== "object")
        break;
      if (ov === oov || typeof ov === "undefined") {
      }
    }
  }
  function get(o2, p) {
    var i = -1;
    var l2 = p.length;
    var n2 = o2;
    while (n2 != null && ++i < l2) {
      n2 = n2[p[i]];
    }
    return n2;
  }
  function iterateNthLevel(wcov, level, k, path2, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n2, nv, ov, kIsWc, wck, i, lastPathIndex, redactPathCurrent, store, parent, depth) {
    if (level === 0) {
      if (kIsWc || typeof wcov === "object" && wcov !== null && k in wcov) {
        if (kIsWc) {
          ov = wcov;
        } else {
          ov = wcov[k];
        }
        nv = i !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [...path2, originalKey, ...afterPath]) : censor(ov) : censor;
        if (kIsWc) {
          const rv = restoreInstr(redactPathCurrent, ov, parent);
          store.push(rv);
          n2[wck] = nv;
        } else {
          if (wcov[k] === nv) {
          } else if (nv === undefined && censor !== undefined || has(wcov, k) && nv === ov) {
          } else {
            const rv = restoreInstr(node(redactPathCurrent, k, depth + 1), ov, parent);
            store.push(rv);
            wcov[k] = nv;
          }
        }
      }
    }
    for (const key in wcov) {
      if (typeof wcov[key] === "object") {
        redactPathCurrent = node(redactPathCurrent, key, depth);
        iterateNthLevel(wcov[key], level - 1, k, path2, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n2, nv, ov, kIsWc, wck, i, lastPathIndex, redactPathCurrent, store, parent, depth + 1);
      }
    }
  }
  function tree() {
    return { parent: null, key: null, children: [], depth: 0 };
  }
  function node(parent, key, depth) {
    if (parent.depth === depth) {
      return node(parent.parent, key, depth);
    }
    var child = {
      parent,
      key,
      depth,
      children: []
    };
    parent.children.push(child);
    return child;
  }
  function restoreInstr(node2, value, target) {
    let current = node2;
    const path2 = [];
    do {
      path2.push(current.key);
      current = current.parent;
    } while (current.parent != null);
    return { path: path2, value, target };
  }
});

// node_modules/fast-redact/lib/restorer.js
var require_restorer = __commonJS((exports, module) => {
  var { groupRestore, nestedRestore } = require_modifiers();
  module.exports = restorer;
  function restorer() {
    return function compileRestore() {
      if (this.restore) {
        this.restore.state.secret = this.secret;
        return;
      }
      const { secret, wcLen } = this;
      const paths = Object.keys(secret);
      const resetters = resetTmpl(secret, paths);
      const hasWildcards = wcLen > 0;
      const state = hasWildcards ? { secret, groupRestore, nestedRestore } : { secret };
      this.restore = Function("o", restoreTmpl(resetters, paths, hasWildcards)).bind(state);
      this.restore.state = state;
    };
  }
  function resetTmpl(secret, paths) {
    return paths.map((path2) => {
      const { circle, escPath, leadingBracket } = secret[path2];
      const delim = leadingBracket ? "" : ".";
      const reset = circle ? `o.${circle} = secret[${escPath}].val` : `o${delim}${path2} = secret[${escPath}].val`;
      const clear = `secret[${escPath}].val = undefined`;
      return `
      if (secret[${escPath}].val !== undefined) {
        try { ${reset} } catch (e) {}
        ${clear}
      }
    `;
    }).join("");
  }
  function restoreTmpl(resetters, paths, hasWildcards) {
    const dynamicReset = hasWildcards === true ? `
    const keys = Object.keys(secret)
    const len = keys.length
    for (var i = len - 1; i >= ${paths.length}; i--) {
      const k = keys[i]
      const o = secret[k]
      if (o) {
        if (o.flat === true) this.groupRestore(o)
        else this.nestedRestore(o)
        secret[k] = null
      }
    }
  ` : "";
    return `
    const secret = this.secret
    ${dynamicReset}
    ${resetters}
    return o
  `;
  }
});

// node_modules/fast-redact/lib/state.js
var require_state = __commonJS((exports, module) => {
  module.exports = state;
  function state(o2) {
    const {
      secret,
      censor,
      compileRestore,
      serialize: serialize3,
      groupRedact,
      nestedRedact,
      wildcards,
      wcLen
    } = o2;
    const builder = [{ secret, censor, compileRestore }];
    if (serialize3 !== false)
      builder.push({ serialize: serialize3 });
    if (wcLen > 0)
      builder.push({ groupRedact, nestedRedact, wildcards, wcLen });
    return Object.assign(...builder);
  }
});

// node_modules/fast-redact/index.js
var require_fast_redact = __commonJS((exports, module) => {
  var validator = require_validator();
  var parse6 = require_parse();
  var redactor = require_redactor();
  var restorer = require_restorer();
  var { groupRedact, nestedRedact } = require_modifiers();
  var state = require_state();
  var rx = require_rx();
  var validate = validator();
  var noop = (o2) => o2;
  noop.restore = noop;
  var DEFAULT_CENSOR = "[REDACTED]";
  fastRedact.rx = rx;
  fastRedact.validator = validator;
  module.exports = fastRedact;
  function fastRedact(opts = {}) {
    const paths = Array.from(new Set(opts.paths || []));
    const serialize3 = "serialize" in opts ? opts.serialize === false ? opts.serialize : typeof opts.serialize === "function" ? opts.serialize : JSON.stringify : JSON.stringify;
    const remove = opts.remove;
    if (remove === true && serialize3 !== JSON.stringify) {
      throw Error("fast-redact \u2013 remove option may only be set when serializer is JSON.stringify");
    }
    const censor = remove === true ? undefined : ("censor" in opts) ? opts.censor : DEFAULT_CENSOR;
    const isCensorFct = typeof censor === "function";
    const censorFctTakesPath = isCensorFct && censor.length > 1;
    if (paths.length === 0)
      return serialize3 || noop;
    validate({ paths, serialize: serialize3, censor });
    const { wildcards, wcLen, secret } = parse6({ paths, censor });
    const compileRestore = restorer();
    const strict = "strict" in opts ? opts.strict : true;
    return redactor({ secret, wcLen, serialize: serialize3, strict, isCensorFct, censorFctTakesPath }, state({
      secret,
      censor,
      compileRestore,
      serialize: serialize3,
      groupRedact,
      nestedRedact,
      wildcards,
      wcLen
    }));
  }
});

// node_modules/pino/lib/symbols.js
var require_symbols = __commonJS((exports, module) => {
  var setLevelSym = Symbol("pino.setLevel");
  var getLevelSym = Symbol("pino.getLevel");
  var levelValSym = Symbol("pino.levelVal");
  var levelCompSym = Symbol("pino.levelComp");
  var useLevelLabelsSym = Symbol("pino.useLevelLabels");
  var useOnlyCustomLevelsSym = Symbol("pino.useOnlyCustomLevels");
  var mixinSym = Symbol("pino.mixin");
  var lsCacheSym = Symbol("pino.lsCache");
  var chindingsSym = Symbol("pino.chindings");
  var asJsonSym = Symbol("pino.asJson");
  var writeSym = Symbol("pino.write");
  var redactFmtSym = Symbol("pino.redactFmt");
  var timeSym = Symbol("pino.time");
  var timeSliceIndexSym = Symbol("pino.timeSliceIndex");
  var streamSym = Symbol("pino.stream");
  var stringifySym = Symbol("pino.stringify");
  var stringifySafeSym = Symbol("pino.stringifySafe");
  var stringifiersSym = Symbol("pino.stringifiers");
  var endSym = Symbol("pino.end");
  var formatOptsSym = Symbol("pino.formatOpts");
  var messageKeySym = Symbol("pino.messageKey");
  var errorKeySym = Symbol("pino.errorKey");
  var nestedKeySym = Symbol("pino.nestedKey");
  var nestedKeyStrSym = Symbol("pino.nestedKeyStr");
  var mixinMergeStrategySym = Symbol("pino.mixinMergeStrategy");
  var msgPrefixSym = Symbol("pino.msgPrefix");
  var wildcardFirstSym = Symbol("pino.wildcardFirst");
  var serializersSym = Symbol.for("pino.serializers");
  var formattersSym = Symbol.for("pino.formatters");
  var hooksSym = Symbol.for("pino.hooks");
  var needsMetadataGsym = Symbol.for("pino.metadata");
  module.exports = {
    setLevelSym,
    getLevelSym,
    levelValSym,
    levelCompSym,
    useLevelLabelsSym,
    mixinSym,
    lsCacheSym,
    chindingsSym,
    asJsonSym,
    writeSym,
    serializersSym,
    redactFmtSym,
    timeSym,
    timeSliceIndexSym,
    streamSym,
    stringifySym,
    stringifySafeSym,
    stringifiersSym,
    endSym,
    formatOptsSym,
    messageKeySym,
    errorKeySym,
    nestedKeySym,
    wildcardFirstSym,
    needsMetadataGsym,
    useOnlyCustomLevelsSym,
    formattersSym,
    hooksSym,
    nestedKeyStrSym,
    mixinMergeStrategySym,
    msgPrefixSym
  };
});

// node_modules/pino/lib/redaction.js
var require_redaction = __commonJS((exports, module) => {
  var fastRedact = require_fast_redact();
  var { redactFmtSym, wildcardFirstSym } = require_symbols();
  var { rx, validator } = fastRedact;
  var validate = validator({
    ERR_PATHS_MUST_BE_STRINGS: () => "pino \u2013 redacted paths must be strings",
    ERR_INVALID_PATH: (s) => `pino \u2013 redact paths array contains an invalid path (${s})`
  });
  var CENSOR = "[Redacted]";
  var strict = false;
  function redaction(opts, serialize3) {
    const { paths, censor } = handle(opts);
    const shape = paths.reduce((o2, str) => {
      rx.lastIndex = 0;
      const first = rx.exec(str);
      const next = rx.exec(str);
      let ns = first[1] !== undefined ? first[1].replace(/^(?:"|'|`)(.*)(?:"|'|`)$/, "$1") : first[0];
      if (ns === "*") {
        ns = wildcardFirstSym;
      }
      if (next === null) {
        o2[ns] = null;
        return o2;
      }
      if (o2[ns] === null) {
        return o2;
      }
      const { index } = next;
      const nextPath = `${str.substr(index, str.length - 1)}`;
      o2[ns] = o2[ns] || [];
      if (ns !== wildcardFirstSym && o2[ns].length === 0) {
        o2[ns].push(...o2[wildcardFirstSym] || []);
      }
      if (ns === wildcardFirstSym) {
        Object.keys(o2).forEach(function(k) {
          if (o2[k]) {
            o2[k].push(nextPath);
          }
        });
      }
      o2[ns].push(nextPath);
      return o2;
    }, {});
    const result = {
      [redactFmtSym]: fastRedact({ paths, censor, serialize: serialize3, strict })
    };
    const topCensor = (...args) => {
      return typeof censor === "function" ? serialize3(censor(...args)) : serialize3(censor);
    };
    return [...Object.keys(shape), ...Object.getOwnPropertySymbols(shape)].reduce((o2, k) => {
      if (shape[k] === null) {
        o2[k] = (value) => topCensor(value, [k]);
      } else {
        const wrappedCensor = typeof censor === "function" ? (value, path2) => {
          return censor(value, [k, ...path2]);
        } : censor;
        o2[k] = fastRedact({
          paths: shape[k],
          censor: wrappedCensor,
          serialize: serialize3,
          strict
        });
      }
      return o2;
    }, result);
  }
  function handle(opts) {
    if (Array.isArray(opts)) {
      opts = { paths: opts, censor: CENSOR };
      validate(opts);
      return opts;
    }
    let { paths, censor = CENSOR, remove } = opts;
    if (Array.isArray(paths) === false) {
      throw Error("pino \u2013 redact must contain an array of strings");
    }
    if (remove === true)
      censor = undefined;
    validate({ paths, censor });
    return { paths, censor };
  }
  module.exports = redaction;
});

// node_modules/pino/lib/time.js
var require_time = __commonJS((exports, module) => {
  var nullTime = () => "";
  var epochTime = () => `,"time":${Date.now()}`;
  var unixTime = () => `,"time":${Math.round(Date.now() / 1000)}`;
  var isoTime = () => `,"time":"${new Date(Date.now()).toISOString()}"`;
  module.exports = { nullTime, epochTime, unixTime, isoTime };
});

// node_modules/quick-format-unescaped/index.js
var require_quick_format_unescaped = __commonJS((exports, module) => {
  function tryStringify(o2) {
    try {
      return JSON.stringify(o2);
    } catch (e) {
      return '"[Circular]"';
    }
  }
  module.exports = format2;
  function format2(f, args, opts) {
    var ss = opts && opts.stringify || tryStringify;
    var offset = 1;
    if (typeof f === "object" && f !== null) {
      var len = args.length + offset;
      if (len === 1)
        return f;
      var objects = new Array(len);
      objects[0] = ss(f);
      for (var index = 1;index < len; index++) {
        objects[index] = ss(args[index]);
      }
      return objects.join(" ");
    }
    if (typeof f !== "string") {
      return f;
    }
    var argLen = args.length;
    if (argLen === 0)
      return f;
    var str = "";
    var a13 = 1 - offset;
    var lastPos = -1;
    var flen = f && f.length || 0;
    for (var i = 0;i < flen; ) {
      if (f.charCodeAt(i) === 37 && i + 1 < flen) {
        lastPos = lastPos > -1 ? lastPos : 0;
        switch (f.charCodeAt(i + 1)) {
          case 100:
          case 102:
            if (a13 >= argLen)
              break;
            if (args[a13] == null)
              break;
            if (lastPos < i)
              str += f.slice(lastPos, i);
            str += Number(args[a13]);
            lastPos = i + 2;
            i++;
            break;
          case 105:
            if (a13 >= argLen)
              break;
            if (args[a13] == null)
              break;
            if (lastPos < i)
              str += f.slice(lastPos, i);
            str += Math.floor(Number(args[a13]));
            lastPos = i + 2;
            i++;
            break;
          case 79:
          case 111:
          case 106:
            if (a13 >= argLen)
              break;
            if (args[a13] === undefined)
              break;
            if (lastPos < i)
              str += f.slice(lastPos, i);
            var type = typeof args[a13];
            if (type === "string") {
              str += "'" + args[a13] + "'";
              lastPos = i + 2;
              i++;
              break;
            }
            if (type === "function") {
              str += args[a13].name || "<anonymous>";
              lastPos = i + 2;
              i++;
              break;
            }
            str += ss(args[a13]);
            lastPos = i + 2;
            i++;
            break;
          case 115:
            if (a13 >= argLen)
              break;
            if (lastPos < i)
              str += f.slice(lastPos, i);
            str += String(args[a13]);
            lastPos = i + 2;
            i++;
            break;
          case 37:
            if (lastPos < i)
              str += f.slice(lastPos, i);
            str += "%";
            lastPos = i + 2;
            i++;
            a13--;
            break;
        }
        ++a13;
      }
      ++i;
    }
    if (lastPos === -1)
      return f;
    else if (lastPos < flen) {
      str += f.slice(lastPos);
    }
    return str;
  }
});

// node_modules/atomic-sleep/index.js
var require_atomic_sleep = __commonJS((exports, module) => {
  if (typeof SharedArrayBuffer !== "undefined" && typeof Atomics !== "undefined") {
    let sleep = function(ms) {
      const valid = ms > 0 && ms < Infinity;
      if (valid === false) {
        if (typeof ms !== "number" && typeof ms !== "bigint") {
          throw TypeError("sleep: ms must be a number");
        }
        throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
      }
      Atomics.wait(nil, 0, 0, Number(ms));
    };
    const nil = new Int32Array(new SharedArrayBuffer(4));
    module.exports = sleep;
  } else {
    let sleep = function(ms) {
      const valid = ms > 0 && ms < Infinity;
      if (valid === false) {
        if (typeof ms !== "number" && typeof ms !== "bigint") {
          throw TypeError("sleep: ms must be a number");
        }
        throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
      }
      const target = Date.now() + Number(ms);
      while (target > Date.now()) {
      }
    };
    module.exports = sleep;
  }
});

// node_modules/sonic-boom/index.js
var require_sonic_boom = __commonJS((exports, module) => {
  var fs = import.meta.require("fs");
  var EventEmitter = import.meta.require("events");
  var inherits = import.meta.require("util").inherits;
  var path2 = import.meta.require("path");
  var sleep = require_atomic_sleep();
  var assert3 = import.meta.require("assert");
  var BUSY_WRITE_TIMEOUT = 100;
  var kEmptyBuffer = Buffer.allocUnsafe(0);
  var MAX_WRITE = 16 * 1024;
  var kContentModeBuffer = "buffer";
  var kContentModeUtf8 = "utf8";
  var [major, minor] = (process.versions.node || "0.0").split(".").map(Number);
  var kCopyBuffer = major >= 22 && minor >= 7;
  function openFile(file, sonic) {
    sonic._opening = true;
    sonic._writing = true;
    sonic._asyncDrainScheduled = false;
    function fileOpened(err, fd) {
      if (err) {
        sonic._reopening = false;
        sonic._writing = false;
        sonic._opening = false;
        if (sonic.sync) {
          process.nextTick(() => {
            if (sonic.listenerCount("error") > 0) {
              sonic.emit("error", err);
            }
          });
        } else {
          sonic.emit("error", err);
        }
        return;
      }
      const reopening = sonic._reopening;
      sonic.fd = fd;
      sonic.file = file;
      sonic._reopening = false;
      sonic._opening = false;
      sonic._writing = false;
      if (sonic.sync) {
        process.nextTick(() => sonic.emit("ready"));
      } else {
        sonic.emit("ready");
      }
      if (sonic.destroyed) {
        return;
      }
      if (!sonic._writing && sonic._len > sonic.minLength || sonic._flushPending) {
        sonic._actualWrite();
      } else if (reopening) {
        process.nextTick(() => sonic.emit("drain"));
      }
    }
    const flags = sonic.append ? "a" : "w";
    const mode = sonic.mode;
    if (sonic.sync) {
      try {
        if (sonic.mkdir)
          fs.mkdirSync(path2.dirname(file), { recursive: true });
        const fd = fs.openSync(file, flags, mode);
        fileOpened(null, fd);
      } catch (err) {
        fileOpened(err);
        throw err;
      }
    } else if (sonic.mkdir) {
      fs.mkdir(path2.dirname(file), { recursive: true }, (err) => {
        if (err)
          return fileOpened(err);
        fs.open(file, flags, mode, fileOpened);
      });
    } else {
      fs.open(file, flags, mode, fileOpened);
    }
  }
  function SonicBoom(opts) {
    if (!(this instanceof SonicBoom)) {
      return new SonicBoom(opts);
    }
    let { fd, dest, minLength, maxLength, maxWrite, periodicFlush, sync, append = true, mkdir, retryEAGAIN, fsync, contentMode, mode } = opts || {};
    fd = fd || dest;
    this._len = 0;
    this.fd = -1;
    this._bufs = [];
    this._lens = [];
    this._writing = false;
    this._ending = false;
    this._reopening = false;
    this._asyncDrainScheduled = false;
    this._flushPending = false;
    this._hwm = Math.max(minLength || 0, 16387);
    this.file = null;
    this.destroyed = false;
    this.minLength = minLength || 0;
    this.maxLength = maxLength || 0;
    this.maxWrite = maxWrite || MAX_WRITE;
    this._periodicFlush = periodicFlush || 0;
    this._periodicFlushTimer = undefined;
    this.sync = sync || false;
    this.writable = true;
    this._fsync = fsync || false;
    this.append = append || false;
    this.mode = mode;
    this.retryEAGAIN = retryEAGAIN || (() => true);
    this.mkdir = mkdir || false;
    let fsWriteSync;
    let fsWrite;
    if (contentMode === kContentModeBuffer) {
      this._writingBuf = kEmptyBuffer;
      this.write = writeBuffer;
      this.flush = flushBuffer;
      this.flushSync = flushBufferSync;
      this._actualWrite = actualWriteBuffer;
      fsWriteSync = () => fs.writeSync(this.fd, this._writingBuf);
      fsWrite = () => fs.write(this.fd, this._writingBuf, this.release);
    } else if (contentMode === undefined || contentMode === kContentModeUtf8) {
      this._writingBuf = "";
      this.write = write;
      this.flush = flush;
      this.flushSync = flushSync;
      this._actualWrite = actualWrite;
      fsWriteSync = () => fs.writeSync(this.fd, this._writingBuf, "utf8");
      fsWrite = () => fs.write(this.fd, this._writingBuf, "utf8", this.release);
    } else {
      throw new Error(`SonicBoom supports "${kContentModeUtf8}" and "${kContentModeBuffer}", but passed ${contentMode}`);
    }
    if (typeof fd === "number") {
      this.fd = fd;
      process.nextTick(() => this.emit("ready"));
    } else if (typeof fd === "string") {
      openFile(fd, this);
    } else {
      throw new Error("SonicBoom supports only file descriptors and files");
    }
    if (this.minLength >= this.maxWrite) {
      throw new Error(`minLength should be smaller than maxWrite (${this.maxWrite})`);
    }
    this.release = (err, n2) => {
      if (err) {
        if ((err.code === "EAGAIN" || err.code === "EBUSY") && this.retryEAGAIN(err, this._writingBuf.length, this._len - this._writingBuf.length)) {
          if (this.sync) {
            try {
              sleep(BUSY_WRITE_TIMEOUT);
              this.release(undefined, 0);
            } catch (err2) {
              this.release(err2);
            }
          } else {
            setTimeout(fsWrite, BUSY_WRITE_TIMEOUT);
          }
        } else {
          this._writing = false;
          this.emit("error", err);
        }
        return;
      }
      this.emit("write", n2);
      const releasedBufObj = releaseWritingBuf(this._writingBuf, this._len, n2);
      this._len = releasedBufObj.len;
      this._writingBuf = releasedBufObj.writingBuf;
      if (this._writingBuf.length) {
        if (!this.sync) {
          fsWrite();
          return;
        }
        try {
          do {
            const n3 = fsWriteSync();
            const releasedBufObj2 = releaseWritingBuf(this._writingBuf, this._len, n3);
            this._len = releasedBufObj2.len;
            this._writingBuf = releasedBufObj2.writingBuf;
          } while (this._writingBuf.length);
        } catch (err2) {
          this.release(err2);
          return;
        }
      }
      if (this._fsync) {
        fs.fsyncSync(this.fd);
      }
      const len = this._len;
      if (this._reopening) {
        this._writing = false;
        this._reopening = false;
        this.reopen();
      } else if (len > this.minLength) {
        this._actualWrite();
      } else if (this._ending) {
        if (len > 0) {
          this._actualWrite();
        } else {
          this._writing = false;
          actualClose(this);
        }
      } else {
        this._writing = false;
        if (this.sync) {
          if (!this._asyncDrainScheduled) {
            this._asyncDrainScheduled = true;
            process.nextTick(emitDrain, this);
          }
        } else {
          this.emit("drain");
        }
      }
    };
    this.on("newListener", function(name) {
      if (name === "drain") {
        this._asyncDrainScheduled = false;
      }
    });
    if (this._periodicFlush !== 0) {
      this._periodicFlushTimer = setInterval(() => this.flush(null), this._periodicFlush);
      this._periodicFlushTimer.unref();
    }
  }
  function releaseWritingBuf(writingBuf, len, n2) {
    if (typeof writingBuf === "string" && Buffer.byteLength(writingBuf) !== n2) {
      n2 = Buffer.from(writingBuf).subarray(0, n2).toString().length;
    }
    len = Math.max(len - n2, 0);
    writingBuf = writingBuf.slice(n2);
    return { writingBuf, len };
  }
  function emitDrain(sonic) {
    const hasListeners = sonic.listenerCount("drain") > 0;
    if (!hasListeners)
      return;
    sonic._asyncDrainScheduled = false;
    sonic.emit("drain");
  }
  inherits(SonicBoom, EventEmitter);
  function mergeBuf(bufs, len) {
    if (bufs.length === 0) {
      return kEmptyBuffer;
    }
    if (bufs.length === 1) {
      return bufs[0];
    }
    return Buffer.concat(bufs, len);
  }
  function write(data) {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    const len = this._len + data.length;
    const bufs = this._bufs;
    if (this.maxLength && len > this.maxLength) {
      this.emit("drop", data);
      return this._len < this._hwm;
    }
    if (bufs.length === 0 || bufs[bufs.length - 1].length + data.length > this.maxWrite) {
      bufs.push("" + data);
    } else {
      bufs[bufs.length - 1] += data;
    }
    this._len = len;
    if (!this._writing && this._len >= this.minLength) {
      this._actualWrite();
    }
    return this._len < this._hwm;
  }
  function writeBuffer(data) {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    const len = this._len + data.length;
    const bufs = this._bufs;
    const lens = this._lens;
    if (this.maxLength && len > this.maxLength) {
      this.emit("drop", data);
      return this._len < this._hwm;
    }
    if (bufs.length === 0 || lens[lens.length - 1] + data.length > this.maxWrite) {
      bufs.push([data]);
      lens.push(data.length);
    } else {
      bufs[bufs.length - 1].push(data);
      lens[lens.length - 1] += data.length;
    }
    this._len = len;
    if (!this._writing && this._len >= this.minLength) {
      this._actualWrite();
    }
    return this._len < this._hwm;
  }
  function callFlushCallbackOnDrain(cb) {
    this._flushPending = true;
    const onDrain = () => {
      if (!this._fsync) {
        try {
          fs.fsync(this.fd, (err) => {
            this._flushPending = false;
            cb(err);
          });
        } catch (err) {
          cb(err);
        }
      } else {
        this._flushPending = false;
        cb();
      }
      this.off("error", onError);
    };
    const onError = (err) => {
      this._flushPending = false;
      cb(err);
      this.off("drain", onDrain);
    };
    this.once("drain", onDrain);
    this.once("error", onError);
  }
  function flush(cb) {
    if (cb != null && typeof cb !== "function") {
      throw new Error("flush cb must be a function");
    }
    if (this.destroyed) {
      const error3 = new Error("SonicBoom destroyed");
      if (cb) {
        cb(error3);
        return;
      }
      throw error3;
    }
    if (this.minLength <= 0) {
      cb?.();
      return;
    }
    if (cb) {
      callFlushCallbackOnDrain.call(this, cb);
    }
    if (this._writing) {
      return;
    }
    if (this._bufs.length === 0) {
      this._bufs.push("");
    }
    this._actualWrite();
  }
  function flushBuffer(cb) {
    if (cb != null && typeof cb !== "function") {
      throw new Error("flush cb must be a function");
    }
    if (this.destroyed) {
      const error3 = new Error("SonicBoom destroyed");
      if (cb) {
        cb(error3);
        return;
      }
      throw error3;
    }
    if (this.minLength <= 0) {
      cb?.();
      return;
    }
    if (cb) {
      callFlushCallbackOnDrain.call(this, cb);
    }
    if (this._writing) {
      return;
    }
    if (this._bufs.length === 0) {
      this._bufs.push([]);
      this._lens.push(0);
    }
    this._actualWrite();
  }
  SonicBoom.prototype.reopen = function(file) {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    if (this._opening) {
      this.once("ready", () => {
        this.reopen(file);
      });
      return;
    }
    if (this._ending) {
      return;
    }
    if (!this.file) {
      throw new Error("Unable to reopen a file descriptor, you must pass a file to SonicBoom");
    }
    if (file) {
      this.file = file;
    }
    this._reopening = true;
    if (this._writing) {
      return;
    }
    const fd = this.fd;
    this.once("ready", () => {
      if (fd !== this.fd) {
        fs.close(fd, (err) => {
          if (err) {
            return this.emit("error", err);
          }
        });
      }
    });
    openFile(this.file, this);
  };
  SonicBoom.prototype.end = function() {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    if (this._opening) {
      this.once("ready", () => {
        this.end();
      });
      return;
    }
    if (this._ending) {
      return;
    }
    this._ending = true;
    if (this._writing) {
      return;
    }
    if (this._len > 0 && this.fd >= 0) {
      this._actualWrite();
    } else {
      actualClose(this);
    }
  };
  function flushSync() {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    if (this.fd < 0) {
      throw new Error("sonic boom is not ready yet");
    }
    if (!this._writing && this._writingBuf.length > 0) {
      this._bufs.unshift(this._writingBuf);
      this._writingBuf = "";
    }
    let buf = "";
    while (this._bufs.length || buf) {
      if (buf.length <= 0) {
        buf = this._bufs[0];
      }
      try {
        const n2 = fs.writeSync(this.fd, buf, "utf8");
        const releasedBufObj = releaseWritingBuf(buf, this._len, n2);
        buf = releasedBufObj.writingBuf;
        this._len = releasedBufObj.len;
        if (buf.length <= 0) {
          this._bufs.shift();
        }
      } catch (err) {
        const shouldRetry = err.code === "EAGAIN" || err.code === "EBUSY";
        if (shouldRetry && !this.retryEAGAIN(err, buf.length, this._len - buf.length)) {
          throw err;
        }
        sleep(BUSY_WRITE_TIMEOUT);
      }
    }
    try {
      fs.fsyncSync(this.fd);
    } catch {
    }
  }
  function flushBufferSync() {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    if (this.fd < 0) {
      throw new Error("sonic boom is not ready yet");
    }
    if (!this._writing && this._writingBuf.length > 0) {
      this._bufs.unshift([this._writingBuf]);
      this._writingBuf = kEmptyBuffer;
    }
    let buf = kEmptyBuffer;
    while (this._bufs.length || buf.length) {
      if (buf.length <= 0) {
        buf = mergeBuf(this._bufs[0], this._lens[0]);
      }
      try {
        const n2 = fs.writeSync(this.fd, buf);
        buf = buf.subarray(n2);
        this._len = Math.max(this._len - n2, 0);
        if (buf.length <= 0) {
          this._bufs.shift();
          this._lens.shift();
        }
      } catch (err) {
        const shouldRetry = err.code === "EAGAIN" || err.code === "EBUSY";
        if (shouldRetry && !this.retryEAGAIN(err, buf.length, this._len - buf.length)) {
          throw err;
        }
        sleep(BUSY_WRITE_TIMEOUT);
      }
    }
  }
  SonicBoom.prototype.destroy = function() {
    if (this.destroyed) {
      return;
    }
    actualClose(this);
  };
  function actualWrite() {
    const release = this.release;
    this._writing = true;
    this._writingBuf = this._writingBuf || this._bufs.shift() || "";
    if (this.sync) {
      try {
        const written = fs.writeSync(this.fd, this._writingBuf, "utf8");
        release(null, written);
      } catch (err) {
        release(err);
      }
    } else {
      fs.write(this.fd, this._writingBuf, "utf8", release);
    }
  }
  function actualWriteBuffer() {
    const release = this.release;
    this._writing = true;
    this._writingBuf = this._writingBuf.length ? this._writingBuf : mergeBuf(this._bufs.shift(), this._lens.shift());
    if (this.sync) {
      try {
        const written = fs.writeSync(this.fd, this._writingBuf);
        release(null, written);
      } catch (err) {
        release(err);
      }
    } else {
      if (kCopyBuffer) {
        this._writingBuf = Buffer.from(this._writingBuf);
      }
      fs.write(this.fd, this._writingBuf, release);
    }
  }
  function actualClose(sonic) {
    if (sonic.fd === -1) {
      sonic.once("ready", actualClose.bind(null, sonic));
      return;
    }
    if (sonic._periodicFlushTimer !== undefined) {
      clearInterval(sonic._periodicFlushTimer);
    }
    sonic.destroyed = true;
    sonic._bufs = [];
    sonic._lens = [];
    assert3(typeof sonic.fd === "number", `sonic.fd must be a number, got ${typeof sonic.fd}`);
    try {
      fs.fsync(sonic.fd, closeWrapped);
    } catch {
    }
    function closeWrapped() {
      if (sonic.fd !== 1 && sonic.fd !== 2) {
        fs.close(sonic.fd, done);
      } else {
        done();
      }
    }
    function done(err) {
      if (err) {
        sonic.emit("error", err);
        return;
      }
      if (sonic._ending && !sonic._writing) {
        sonic.emit("finish");
      }
      sonic.emit("close");
    }
  }
  SonicBoom.SonicBoom = SonicBoom;
  SonicBoom.default = SonicBoom;
  module.exports = SonicBoom;
});

// node_modules/on-exit-leak-free/index.js
var require_on_exit_leak_free = __commonJS((exports, module) => {
  var refs = {
    exit: [],
    beforeExit: []
  };
  var functions = {
    exit: onExit,
    beforeExit: onBeforeExit
  };
  var registry;
  function ensureRegistry() {
    if (registry === undefined) {
      registry = new FinalizationRegistry(clear);
    }
  }
  function install(event) {
    if (refs[event].length > 0) {
      return;
    }
    process.on(event, functions[event]);
  }
  function uninstall(event) {
    if (refs[event].length > 0) {
      return;
    }
    process.removeListener(event, functions[event]);
    if (refs.exit.length === 0 && refs.beforeExit.length === 0) {
      registry = undefined;
    }
  }
  function onExit() {
    callRefs("exit");
  }
  function onBeforeExit() {
    callRefs("beforeExit");
  }
  function callRefs(event) {
    for (const ref of refs[event]) {
      const obj = ref.deref();
      const fn = ref.fn;
      if (obj !== undefined) {
        fn(obj, event);
      }
    }
    refs[event] = [];
  }
  function clear(ref) {
    for (const event of ["exit", "beforeExit"]) {
      const index = refs[event].indexOf(ref);
      refs[event].splice(index, index + 1);
      uninstall(event);
    }
  }
  function _register(event, obj, fn) {
    if (obj === undefined) {
      throw new Error("the object can't be undefined");
    }
    install(event);
    const ref = new WeakRef(obj);
    ref.fn = fn;
    ensureRegistry();
    registry.register(obj, ref);
    refs[event].push(ref);
  }
  function register(obj, fn) {
    _register("exit", obj, fn);
  }
  function registerBeforeExit(obj, fn) {
    _register("beforeExit", obj, fn);
  }
  function unregister(obj) {
    if (registry === undefined) {
      return;
    }
    registry.unregister(obj);
    for (const event of ["exit", "beforeExit"]) {
      refs[event] = refs[event].filter((ref) => {
        const _obj = ref.deref();
        return _obj && _obj !== obj;
      });
      uninstall(event);
    }
  }
  module.exports = {
    register,
    registerBeforeExit,
    unregister
  };
});

// node_modules/thread-stream/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "thread-stream",
    version: "3.1.0",
    description: "A streaming way to send data to a Node.js Worker Thread",
    main: "index.js",
    types: "index.d.ts",
    dependencies: {
      "real-require": "^0.2.0"
    },
    devDependencies: {
      "@types/node": "^20.1.0",
      "@types/tap": "^15.0.0",
      "@yao-pkg/pkg": "^5.11.5",
      desm: "^1.3.0",
      fastbench: "^1.0.1",
      husky: "^9.0.6",
      "pino-elasticsearch": "^8.0.0",
      "sonic-boom": "^4.0.1",
      standard: "^17.0.0",
      tap: "^16.2.0",
      "ts-node": "^10.8.0",
      typescript: "^5.3.2",
      "why-is-node-running": "^2.2.2"
    },
    scripts: {
      build: "tsc --noEmit",
      test: 'standard && npm run build && npm run transpile && tap "test/**/*.test.*js" && tap --ts test/*.test.*ts',
      "test:ci": "standard && npm run transpile && npm run test:ci:js && npm run test:ci:ts",
      "test:ci:js": 'tap --no-check-coverage --timeout=120 --coverage-report=lcovonly "test/**/*.test.*js"',
      "test:ci:ts": 'tap --ts --no-check-coverage --coverage-report=lcovonly "test/**/*.test.*ts"',
      "test:yarn": 'npm run transpile && tap "test/**/*.test.js" --no-check-coverage',
      transpile: "sh ./test/ts/transpile.sh",
      prepare: "husky install"
    },
    standard: {
      ignore: [
        "test/ts/**/*",
        "test/syntax-error.mjs"
      ]
    },
    repository: {
      type: "git",
      url: "git+https://github.com/mcollina/thread-stream.git"
    },
    keywords: [
      "worker",
      "thread",
      "threads",
      "stream"
    ],
    author: "Matteo Collina <hello@matteocollina.com>",
    license: "MIT",
    bugs: {
      url: "https://github.com/mcollina/thread-stream/issues"
    },
    homepage: "https://github.com/mcollina/thread-stream#readme"
  };
});

// node_modules/thread-stream/lib/wait.js
var require_wait = __commonJS((exports, module) => {
  var MAX_TIMEOUT = 1000;
  function wait(state, index, expected, timeout, done) {
    const max = Date.now() + timeout;
    let current = Atomics.load(state, index);
    if (current === expected) {
      done(null, "ok");
      return;
    }
    let prior = current;
    const check3 = (backoff) => {
      if (Date.now() > max) {
        done(null, "timed-out");
      } else {
        setTimeout(() => {
          prior = current;
          current = Atomics.load(state, index);
          if (current === prior) {
            check3(backoff >= MAX_TIMEOUT ? MAX_TIMEOUT : backoff * 2);
          } else {
            if (current === expected)
              done(null, "ok");
            else
              done(null, "not-equal");
          }
        }, backoff);
      }
    };
    check3(1);
  }
  function waitDiff(state, index, expected, timeout, done) {
    const max = Date.now() + timeout;
    let current = Atomics.load(state, index);
    if (current !== expected) {
      done(null, "ok");
      return;
    }
    const check3 = (backoff) => {
      if (Date.now() > max) {
        done(null, "timed-out");
      } else {
        setTimeout(() => {
          current = Atomics.load(state, index);
          if (current !== expected) {
            done(null, "ok");
          } else {
            check3(backoff >= MAX_TIMEOUT ? MAX_TIMEOUT : backoff * 2);
          }
        }, backoff);
      }
    };
    check3(1);
  }
  module.exports = { wait, waitDiff };
});

// node_modules/thread-stream/lib/indexes.js
var require_indexes = __commonJS((exports, module) => {
  var WRITE_INDEX = 4;
  var READ_INDEX = 8;
  module.exports = {
    WRITE_INDEX,
    READ_INDEX
  };
});

// node_modules/thread-stream/index.js
var require_thread_stream = __commonJS((exports, module) => {
  var __dirname = "/home/hussain/React Native/New-Cart-Task/elysiaApis/apisEly/node_modules/thread-stream";
  var { version } = require_package();
  var { EventEmitter } = import.meta.require("events");
  var { Worker } = import.meta.require("worker_threads");
  var { join: join3 } = import.meta.require("path");
  var { pathToFileURL } = import.meta.require("url");
  var { wait } = require_wait();
  var {
    WRITE_INDEX,
    READ_INDEX
  } = require_indexes();
  var buffer = import.meta.require("buffer");
  var assert3 = import.meta.require("assert");
  var kImpl = Symbol("kImpl");
  var MAX_STRING = buffer.constants.MAX_STRING_LENGTH;

  class FakeWeakRef {
    constructor(value) {
      this._value = value;
    }
    deref() {
      return this._value;
    }
  }

  class FakeFinalizationRegistry {
    register() {
    }
    unregister() {
    }
  }
  var FinalizationRegistry2 = process.env.NODE_V8_COVERAGE ? FakeFinalizationRegistry : global.FinalizationRegistry || FakeFinalizationRegistry;
  var WeakRef2 = process.env.NODE_V8_COVERAGE ? FakeWeakRef : global.WeakRef || FakeWeakRef;
  var registry = new FinalizationRegistry2((worker) => {
    if (worker.exited) {
      return;
    }
    worker.terminate();
  });
  function createWorker(stream, opts) {
    const { filename, workerData } = opts;
    const bundlerOverrides = "__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {};
    const toExecute = bundlerOverrides["thread-stream-worker"] || join3(__dirname, "lib", "worker.js");
    const worker = new Worker(toExecute, {
      ...opts.workerOpts,
      trackUnmanagedFds: false,
      workerData: {
        filename: filename.indexOf("file://") === 0 ? filename : pathToFileURL(filename).href,
        dataBuf: stream[kImpl].dataBuf,
        stateBuf: stream[kImpl].stateBuf,
        workerData: {
          $context: {
            threadStreamVersion: version
          },
          ...workerData
        }
      }
    });
    worker.stream = new FakeWeakRef(stream);
    worker.on("message", onWorkerMessage);
    worker.on("exit", onWorkerExit);
    registry.register(stream, worker);
    return worker;
  }
  function drain(stream) {
    assert3(!stream[kImpl].sync);
    if (stream[kImpl].needDrain) {
      stream[kImpl].needDrain = false;
      stream.emit("drain");
    }
  }
  function nextFlush(stream) {
    const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
    let leftover = stream[kImpl].data.length - writeIndex;
    if (leftover > 0) {
      if (stream[kImpl].buf.length === 0) {
        stream[kImpl].flushing = false;
        if (stream[kImpl].ending) {
          end(stream);
        } else if (stream[kImpl].needDrain) {
          process.nextTick(drain, stream);
        }
        return;
      }
      let toWrite = stream[kImpl].buf.slice(0, leftover);
      let toWriteBytes = Buffer.byteLength(toWrite);
      if (toWriteBytes <= leftover) {
        stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
        write(stream, toWrite, nextFlush.bind(null, stream));
      } else {
        stream.flush(() => {
          if (stream.destroyed) {
            return;
          }
          Atomics.store(stream[kImpl].state, READ_INDEX, 0);
          Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
          while (toWriteBytes > stream[kImpl].data.length) {
            leftover = leftover / 2;
            toWrite = stream[kImpl].buf.slice(0, leftover);
            toWriteBytes = Buffer.byteLength(toWrite);
          }
          stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
          write(stream, toWrite, nextFlush.bind(null, stream));
        });
      }
    } else if (leftover === 0) {
      if (writeIndex === 0 && stream[kImpl].buf.length === 0) {
        return;
      }
      stream.flush(() => {
        Atomics.store(stream[kImpl].state, READ_INDEX, 0);
        Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
        nextFlush(stream);
      });
    } else {
      destroy(stream, new Error("overwritten"));
    }
  }
  function onWorkerMessage(msg) {
    const stream = this.stream.deref();
    if (stream === undefined) {
      this.exited = true;
      this.terminate();
      return;
    }
    switch (msg.code) {
      case "READY":
        this.stream = new WeakRef2(stream);
        stream.flush(() => {
          stream[kImpl].ready = true;
          stream.emit("ready");
        });
        break;
      case "ERROR":
        destroy(stream, msg.err);
        break;
      case "EVENT":
        if (Array.isArray(msg.args)) {
          stream.emit(msg.name, ...msg.args);
        } else {
          stream.emit(msg.name, msg.args);
        }
        break;
      case "WARNING":
        process.emitWarning(msg.err);
        break;
      default:
        destroy(stream, new Error("this should not happen: " + msg.code));
    }
  }
  function onWorkerExit(code) {
    const stream = this.stream.deref();
    if (stream === undefined) {
      return;
    }
    registry.unregister(stream);
    stream.worker.exited = true;
    stream.worker.off("exit", onWorkerExit);
    destroy(stream, code !== 0 ? new Error("the worker thread exited") : null);
  }

  class ThreadStream extends EventEmitter {
    constructor(opts = {}) {
      super();
      if (opts.bufferSize < 4) {
        throw new Error("bufferSize must at least fit a 4-byte utf-8 char");
      }
      this[kImpl] = {};
      this[kImpl].stateBuf = new SharedArrayBuffer(128);
      this[kImpl].state = new Int32Array(this[kImpl].stateBuf);
      this[kImpl].dataBuf = new SharedArrayBuffer(opts.bufferSize || 4 * 1024 * 1024);
      this[kImpl].data = Buffer.from(this[kImpl].dataBuf);
      this[kImpl].sync = opts.sync || false;
      this[kImpl].ending = false;
      this[kImpl].ended = false;
      this[kImpl].needDrain = false;
      this[kImpl].destroyed = false;
      this[kImpl].flushing = false;
      this[kImpl].ready = false;
      this[kImpl].finished = false;
      this[kImpl].errored = null;
      this[kImpl].closed = false;
      this[kImpl].buf = "";
      this.worker = createWorker(this, opts);
      this.on("message", (message2, transferList) => {
        this.worker.postMessage(message2, transferList);
      });
    }
    write(data) {
      if (this[kImpl].destroyed) {
        error3(this, new Error("the worker has exited"));
        return false;
      }
      if (this[kImpl].ending) {
        error3(this, new Error("the worker is ending"));
        return false;
      }
      if (this[kImpl].flushing && this[kImpl].buf.length + data.length >= MAX_STRING) {
        try {
          writeSync(this);
          this[kImpl].flushing = true;
        } catch (err) {
          destroy(this, err);
          return false;
        }
      }
      this[kImpl].buf += data;
      if (this[kImpl].sync) {
        try {
          writeSync(this);
          return true;
        } catch (err) {
          destroy(this, err);
          return false;
        }
      }
      if (!this[kImpl].flushing) {
        this[kImpl].flushing = true;
        setImmediate(nextFlush, this);
      }
      this[kImpl].needDrain = this[kImpl].data.length - this[kImpl].buf.length - Atomics.load(this[kImpl].state, WRITE_INDEX) <= 0;
      return !this[kImpl].needDrain;
    }
    end() {
      if (this[kImpl].destroyed) {
        return;
      }
      this[kImpl].ending = true;
      end(this);
    }
    flush(cb) {
      if (this[kImpl].destroyed) {
        if (typeof cb === "function") {
          process.nextTick(cb, new Error("the worker has exited"));
        }
        return;
      }
      const writeIndex = Atomics.load(this[kImpl].state, WRITE_INDEX);
      wait(this[kImpl].state, READ_INDEX, writeIndex, Infinity, (err, res) => {
        if (err) {
          destroy(this, err);
          process.nextTick(cb, err);
          return;
        }
        if (res === "not-equal") {
          this.flush(cb);
          return;
        }
        process.nextTick(cb);
      });
    }
    flushSync() {
      if (this[kImpl].destroyed) {
        return;
      }
      writeSync(this);
      flushSync(this);
    }
    unref() {
      this.worker.unref();
    }
    ref() {
      this.worker.ref();
    }
    get ready() {
      return this[kImpl].ready;
    }
    get destroyed() {
      return this[kImpl].destroyed;
    }
    get closed() {
      return this[kImpl].closed;
    }
    get writable() {
      return !this[kImpl].destroyed && !this[kImpl].ending;
    }
    get writableEnded() {
      return this[kImpl].ending;
    }
    get writableFinished() {
      return this[kImpl].finished;
    }
    get writableNeedDrain() {
      return this[kImpl].needDrain;
    }
    get writableObjectMode() {
      return false;
    }
    get writableErrored() {
      return this[kImpl].errored;
    }
  }
  function error3(stream, err) {
    setImmediate(() => {
      stream.emit("error", err);
    });
  }
  function destroy(stream, err) {
    if (stream[kImpl].destroyed) {
      return;
    }
    stream[kImpl].destroyed = true;
    if (err) {
      stream[kImpl].errored = err;
      error3(stream, err);
    }
    if (!stream.worker.exited) {
      stream.worker.terminate().catch(() => {
      }).then(() => {
        stream[kImpl].closed = true;
        stream.emit("close");
      });
    } else {
      setImmediate(() => {
        stream[kImpl].closed = true;
        stream.emit("close");
      });
    }
  }
  function write(stream, data, cb) {
    const current = Atomics.load(stream[kImpl].state, WRITE_INDEX);
    const length = Buffer.byteLength(data);
    stream[kImpl].data.write(data, current);
    Atomics.store(stream[kImpl].state, WRITE_INDEX, current + length);
    Atomics.notify(stream[kImpl].state, WRITE_INDEX);
    cb();
    return true;
  }
  function end(stream) {
    if (stream[kImpl].ended || !stream[kImpl].ending || stream[kImpl].flushing) {
      return;
    }
    stream[kImpl].ended = true;
    try {
      stream.flushSync();
      let readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
      Atomics.store(stream[kImpl].state, WRITE_INDEX, -1);
      Atomics.notify(stream[kImpl].state, WRITE_INDEX);
      let spins = 0;
      while (readIndex !== -1) {
        Atomics.wait(stream[kImpl].state, READ_INDEX, readIndex, 1000);
        readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
        if (readIndex === -2) {
          destroy(stream, new Error("end() failed"));
          return;
        }
        if (++spins === 10) {
          destroy(stream, new Error("end() took too long (10s)"));
          return;
        }
      }
      process.nextTick(() => {
        stream[kImpl].finished = true;
        stream.emit("finish");
      });
    } catch (err) {
      destroy(stream, err);
    }
  }
  function writeSync(stream) {
    const cb = () => {
      if (stream[kImpl].ending) {
        end(stream);
      } else if (stream[kImpl].needDrain) {
        process.nextTick(drain, stream);
      }
    };
    stream[kImpl].flushing = false;
    while (stream[kImpl].buf.length !== 0) {
      const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
      let leftover = stream[kImpl].data.length - writeIndex;
      if (leftover === 0) {
        flushSync(stream);
        Atomics.store(stream[kImpl].state, READ_INDEX, 0);
        Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
        continue;
      } else if (leftover < 0) {
        throw new Error("overwritten");
      }
      let toWrite = stream[kImpl].buf.slice(0, leftover);
      let toWriteBytes = Buffer.byteLength(toWrite);
      if (toWriteBytes <= leftover) {
        stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
        write(stream, toWrite, cb);
      } else {
        flushSync(stream);
        Atomics.store(stream[kImpl].state, READ_INDEX, 0);
        Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
        while (toWriteBytes > stream[kImpl].buf.length) {
          leftover = leftover / 2;
          toWrite = stream[kImpl].buf.slice(0, leftover);
          toWriteBytes = Buffer.byteLength(toWrite);
        }
        stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
        write(stream, toWrite, cb);
      }
    }
  }
  function flushSync(stream) {
    if (stream[kImpl].flushing) {
      throw new Error("unable to flush while flushing");
    }
    const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
    let spins = 0;
    while (true) {
      const readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
      if (readIndex === -2) {
        throw Error("_flushSync failed");
      }
      if (readIndex !== writeIndex) {
        Atomics.wait(stream[kImpl].state, READ_INDEX, readIndex, 1000);
      } else {
        break;
      }
      if (++spins === 10) {
        throw new Error("_flushSync took too long (10s)");
      }
    }
  }
  module.exports = ThreadStream;
});

// node_modules/pino/lib/transport.js
var require_transport = __commonJS((exports, module) => {
  var __dirname = "/home/hussain/React Native/New-Cart-Task/elysiaApis/apisEly/node_modules/pino/lib";
  var { createRequire } = import.meta.require("module");
  var getCallers = require_caller();
  var { join: join3, isAbsolute: isAbsolute2, sep: sep2 } = import.meta.require("path");
  var sleep = require_atomic_sleep();
  var onExit = require_on_exit_leak_free();
  var ThreadStream = require_thread_stream();
  function setupOnExit(stream) {
    onExit.register(stream, autoEnd);
    onExit.registerBeforeExit(stream, flush);
    stream.on("close", function() {
      onExit.unregister(stream);
    });
  }
  function buildStream(filename, workerData, workerOpts, sync) {
    const stream = new ThreadStream({
      filename,
      workerData,
      workerOpts,
      sync
    });
    stream.on("ready", onReady);
    stream.on("close", function() {
      process.removeListener("exit", onExit2);
    });
    process.on("exit", onExit2);
    function onReady() {
      process.removeListener("exit", onExit2);
      stream.unref();
      if (workerOpts.autoEnd !== false) {
        setupOnExit(stream);
      }
    }
    function onExit2() {
      if (stream.closed) {
        return;
      }
      stream.flushSync();
      sleep(100);
      stream.end();
    }
    return stream;
  }
  function autoEnd(stream) {
    stream.ref();
    stream.flushSync();
    stream.end();
    stream.once("close", function() {
      stream.unref();
    });
  }
  function flush(stream) {
    stream.flushSync();
  }
  function transport(fullOptions) {
    const { pipeline, targets, levels, dedupe, worker = {}, caller = getCallers(), sync = false } = fullOptions;
    const options = {
      ...fullOptions.options
    };
    const callers = typeof caller === "string" ? [caller] : caller;
    const bundlerOverrides = "__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {};
    let target = fullOptions.target;
    if (target && targets) {
      throw new Error("only one of target or targets can be specified");
    }
    if (targets) {
      target = bundlerOverrides["pino-worker"] || join3(__dirname, "worker.js");
      options.targets = targets.filter((dest) => dest.target).map((dest) => {
        return {
          ...dest,
          target: fixTarget(dest.target)
        };
      });
      options.pipelines = targets.filter((dest) => dest.pipeline).map((dest) => {
        return dest.pipeline.map((t3) => {
          return {
            ...t3,
            level: dest.level,
            target: fixTarget(t3.target)
          };
        });
      });
    } else if (pipeline) {
      target = bundlerOverrides["pino-worker"] || join3(__dirname, "worker.js");
      options.pipelines = [pipeline.map((dest) => {
        return {
          ...dest,
          target: fixTarget(dest.target)
        };
      })];
    }
    if (levels) {
      options.levels = levels;
    }
    if (dedupe) {
      options.dedupe = dedupe;
    }
    options.pinoWillSendConfig = true;
    return buildStream(fixTarget(target), options, worker, sync);
    function fixTarget(origin) {
      origin = bundlerOverrides[origin] || origin;
      if (isAbsolute2(origin) || origin.indexOf("file://") === 0) {
        return origin;
      }
      if (origin === "pino/file") {
        return join3(__dirname, "..", "file.js");
      }
      let fixTarget2;
      for (const filePath of callers) {
        try {
          const context = filePath === "node:repl" ? process.cwd() + sep2 : filePath;
          fixTarget2 = createRequire(context).resolve(origin);
          break;
        } catch (err) {
          continue;
        }
      }
      if (!fixTarget2) {
        throw new Error(`unable to determine transport target for "${origin}"`);
      }
      return fixTarget2;
    }
  }
  module.exports = transport;
});

// node_modules/pino/lib/tools.js
var require_tools = __commonJS((exports, module) => {
  var format2 = require_quick_format_unescaped();
  var { mapHttpRequest, mapHttpResponse } = require_pino_std_serializers();
  var SonicBoom = require_sonic_boom();
  var onExit = require_on_exit_leak_free();
  var {
    lsCacheSym,
    chindingsSym,
    writeSym,
    serializersSym,
    formatOptsSym,
    endSym,
    stringifiersSym,
    stringifySym,
    stringifySafeSym,
    wildcardFirstSym,
    nestedKeySym,
    formattersSym,
    messageKeySym,
    errorKeySym,
    nestedKeyStrSym,
    msgPrefixSym
  } = require_symbols();
  var { isMainThread } = import.meta.require("worker_threads");
  var transport = require_transport();
  function noop() {
  }
  function genLog(level, hook) {
    if (!hook)
      return LOG;
    return function hookWrappedLog(...args) {
      hook.call(this, args, LOG, level);
    };
    function LOG(o2, ...n2) {
      if (typeof o2 === "object") {
        let msg = o2;
        if (o2 !== null) {
          if (o2.method && o2.headers && o2.socket) {
            o2 = mapHttpRequest(o2);
          } else if (typeof o2.setHeader === "function") {
            o2 = mapHttpResponse(o2);
          }
        }
        let formatParams;
        if (msg === null && n2.length === 0) {
          formatParams = [null];
        } else {
          msg = n2.shift();
          formatParams = n2;
        }
        if (typeof this[msgPrefixSym] === "string" && msg !== undefined && msg !== null) {
          msg = this[msgPrefixSym] + msg;
        }
        this[writeSym](o2, format2(msg, formatParams, this[formatOptsSym]), level);
      } else {
        let msg = o2 === undefined ? n2.shift() : o2;
        if (typeof this[msgPrefixSym] === "string" && msg !== undefined && msg !== null) {
          msg = this[msgPrefixSym] + msg;
        }
        this[writeSym](null, format2(msg, n2, this[formatOptsSym]), level);
      }
    }
  }
  function asString(str) {
    let result = "";
    let last = 0;
    let found = false;
    let point = 255;
    const l2 = str.length;
    if (l2 > 100) {
      return JSON.stringify(str);
    }
    for (var i = 0;i < l2 && point >= 32; i++) {
      point = str.charCodeAt(i);
      if (point === 34 || point === 92) {
        result += str.slice(last, i) + "\\";
        last = i;
        found = true;
      }
    }
    if (!found) {
      result = str;
    } else {
      result += str.slice(last);
    }
    return point < 32 ? JSON.stringify(str) : '"' + result + '"';
  }
  function asJson(obj, msg, num, time) {
    const stringify2 = this[stringifySym];
    const stringifySafe = this[stringifySafeSym];
    const stringifiers = this[stringifiersSym];
    const end = this[endSym];
    const chindings = this[chindingsSym];
    const serializers = this[serializersSym];
    const formatters = this[formattersSym];
    const messageKey = this[messageKeySym];
    const errorKey = this[errorKeySym];
    let data = this[lsCacheSym][num] + time;
    data = data + chindings;
    let value;
    if (formatters.log) {
      obj = formatters.log(obj);
    }
    const wildcardStringifier = stringifiers[wildcardFirstSym];
    let propStr = "";
    for (const key in obj) {
      value = obj[key];
      if (Object.prototype.hasOwnProperty.call(obj, key) && value !== undefined) {
        if (serializers[key]) {
          value = serializers[key](value);
        } else if (key === errorKey && serializers.err) {
          value = serializers.err(value);
        }
        const stringifier = stringifiers[key] || wildcardStringifier;
        switch (typeof value) {
          case "undefined":
          case "function":
            continue;
          case "number":
            if (Number.isFinite(value) === false) {
              value = null;
            }
          case "boolean":
            if (stringifier)
              value = stringifier(value);
            break;
          case "string":
            value = (stringifier || asString)(value);
            break;
          default:
            value = (stringifier || stringify2)(value, stringifySafe);
        }
        if (value === undefined)
          continue;
        const strKey = asString(key);
        propStr += "," + strKey + ":" + value;
      }
    }
    let msgStr = "";
    if (msg !== undefined) {
      value = serializers[messageKey] ? serializers[messageKey](msg) : msg;
      const stringifier = stringifiers[messageKey] || wildcardStringifier;
      switch (typeof value) {
        case "function":
          break;
        case "number":
          if (Number.isFinite(value) === false) {
            value = null;
          }
        case "boolean":
          if (stringifier)
            value = stringifier(value);
          msgStr = ',"' + messageKey + '":' + value;
          break;
        case "string":
          value = (stringifier || asString)(value);
          msgStr = ',"' + messageKey + '":' + value;
          break;
        default:
          value = (stringifier || stringify2)(value, stringifySafe);
          msgStr = ',"' + messageKey + '":' + value;
      }
    }
    if (this[nestedKeySym] && propStr) {
      return data + this[nestedKeyStrSym] + propStr.slice(1) + "}" + msgStr + end;
    } else {
      return data + propStr + msgStr + end;
    }
  }
  function asChindings(instance, bindings) {
    let value;
    let data = instance[chindingsSym];
    const stringify2 = instance[stringifySym];
    const stringifySafe = instance[stringifySafeSym];
    const stringifiers = instance[stringifiersSym];
    const wildcardStringifier = stringifiers[wildcardFirstSym];
    const serializers = instance[serializersSym];
    const formatter = instance[formattersSym].bindings;
    bindings = formatter(bindings);
    for (const key in bindings) {
      value = bindings[key];
      const valid = key !== "level" && key !== "serializers" && key !== "formatters" && key !== "customLevels" && bindings.hasOwnProperty(key) && value !== undefined;
      if (valid === true) {
        value = serializers[key] ? serializers[key](value) : value;
        value = (stringifiers[key] || wildcardStringifier || stringify2)(value, stringifySafe);
        if (value === undefined)
          continue;
        data += ',"' + key + '":' + value;
      }
    }
    return data;
  }
  function hasBeenTampered(stream) {
    return stream.write !== stream.constructor.prototype.write;
  }
  var hasNodeCodeCoverage = process.env.NODE_V8_COVERAGE || process.env.V8_COVERAGE;
  function buildSafeSonicBoom(opts) {
    const stream = new SonicBoom(opts);
    stream.on("error", filterBrokenPipe);
    if (!hasNodeCodeCoverage && !opts.sync && isMainThread) {
      onExit.register(stream, autoEnd);
      stream.on("close", function() {
        onExit.unregister(stream);
      });
    }
    return stream;
    function filterBrokenPipe(err) {
      if (err.code === "EPIPE") {
        stream.write = noop;
        stream.end = noop;
        stream.flushSync = noop;
        stream.destroy = noop;
        return;
      }
      stream.removeListener("error", filterBrokenPipe);
      stream.emit("error", err);
    }
  }
  function autoEnd(stream, eventName) {
    if (stream.destroyed) {
      return;
    }
    if (eventName === "beforeExit") {
      stream.flush();
      stream.on("drain", function() {
        stream.end();
      });
    } else {
      stream.flushSync();
    }
  }
  function createArgsNormalizer(defaultOptions) {
    return function normalizeArgs(instance, caller, opts = {}, stream) {
      if (typeof opts === "string") {
        stream = buildSafeSonicBoom({ dest: opts });
        opts = {};
      } else if (typeof stream === "string") {
        if (opts && opts.transport) {
          throw Error("only one of option.transport or stream can be specified");
        }
        stream = buildSafeSonicBoom({ dest: stream });
      } else if (opts instanceof SonicBoom || opts.writable || opts._writableState) {
        stream = opts;
        opts = {};
      } else if (opts.transport) {
        if (opts.transport instanceof SonicBoom || opts.transport.writable || opts.transport._writableState) {
          throw Error("option.transport do not allow stream, please pass to option directly. e.g. pino(transport)");
        }
        if (opts.transport.targets && opts.transport.targets.length && opts.formatters && typeof opts.formatters.level === "function") {
          throw Error("option.transport.targets do not allow custom level formatters");
        }
        let customLevels;
        if (opts.customLevels) {
          customLevels = opts.useOnlyCustomLevels ? opts.customLevels : Object.assign({}, opts.levels, opts.customLevels);
        }
        stream = transport({ caller, ...opts.transport, levels: customLevels });
      }
      opts = Object.assign({}, defaultOptions, opts);
      opts.serializers = Object.assign({}, defaultOptions.serializers, opts.serializers);
      opts.formatters = Object.assign({}, defaultOptions.formatters, opts.formatters);
      if (opts.prettyPrint) {
        throw new Error("prettyPrint option is no longer supported, see the pino-pretty package (https://github.com/pinojs/pino-pretty)");
      }
      const { enabled, onChild } = opts;
      if (enabled === false)
        opts.level = "silent";
      if (!onChild)
        opts.onChild = noop;
      if (!stream) {
        if (!hasBeenTampered(process.stdout)) {
          stream = buildSafeSonicBoom({ fd: process.stdout.fd || 1 });
        } else {
          stream = process.stdout;
        }
      }
      return { opts, stream };
    };
  }
  function stringify(obj, stringifySafeFn) {
    try {
      return JSON.stringify(obj);
    } catch (_3) {
      try {
        const stringify2 = stringifySafeFn || this[stringifySafeSym];
        return stringify2(obj);
      } catch (_4) {
        return '"[unable to serialize, circular reference is too complex to analyze]"';
      }
    }
  }
  function buildFormatters(level, bindings, log) {
    return {
      level,
      bindings,
      log
    };
  }
  function normalizeDestFileDescriptor(destination) {
    const fd = Number(destination);
    if (typeof destination === "string" && Number.isFinite(fd)) {
      return fd;
    }
    if (destination === undefined) {
      return 1;
    }
    return destination;
  }
  module.exports = {
    noop,
    buildSafeSonicBoom,
    asChindings,
    asJson,
    genLog,
    createArgsNormalizer,
    stringify,
    buildFormatters,
    normalizeDestFileDescriptor
  };
});

// node_modules/pino/lib/constants.js
var require_constants = __commonJS((exports, module) => {
  var DEFAULT_LEVELS = {
    trace: 10,
    debug: 20,
    info: 30,
    warn: 40,
    error: 50,
    fatal: 60
  };
  var SORTING_ORDER = {
    ASC: "ASC",
    DESC: "DESC"
  };
  module.exports = {
    DEFAULT_LEVELS,
    SORTING_ORDER
  };
});

// node_modules/pino/lib/levels.js
var require_levels = __commonJS((exports, module) => {
  var {
    lsCacheSym,
    levelValSym,
    useOnlyCustomLevelsSym,
    streamSym,
    formattersSym,
    hooksSym,
    levelCompSym
  } = require_symbols();
  var { noop, genLog } = require_tools();
  var { DEFAULT_LEVELS, SORTING_ORDER } = require_constants();
  var levelMethods = {
    fatal: (hook) => {
      const logFatal = genLog(DEFAULT_LEVELS.fatal, hook);
      return function(...args) {
        const stream = this[streamSym];
        logFatal.call(this, ...args);
        if (typeof stream.flushSync === "function") {
          try {
            stream.flushSync();
          } catch (e) {
          }
        }
      };
    },
    error: (hook) => genLog(DEFAULT_LEVELS.error, hook),
    warn: (hook) => genLog(DEFAULT_LEVELS.warn, hook),
    info: (hook) => genLog(DEFAULT_LEVELS.info, hook),
    debug: (hook) => genLog(DEFAULT_LEVELS.debug, hook),
    trace: (hook) => genLog(DEFAULT_LEVELS.trace, hook)
  };
  var nums = Object.keys(DEFAULT_LEVELS).reduce((o2, k) => {
    o2[DEFAULT_LEVELS[k]] = k;
    return o2;
  }, {});
  var initialLsCache = Object.keys(nums).reduce((o2, k) => {
    o2[k] = '{"level":' + Number(k);
    return o2;
  }, {});
  function genLsCache(instance) {
    const formatter = instance[formattersSym].level;
    const { labels } = instance.levels;
    const cache = {};
    for (const label in labels) {
      const level = formatter(labels[label], Number(label));
      cache[label] = JSON.stringify(level).slice(0, -1);
    }
    instance[lsCacheSym] = cache;
    return instance;
  }
  function isStandardLevel(level, useOnlyCustomLevels) {
    if (useOnlyCustomLevels) {
      return false;
    }
    switch (level) {
      case "fatal":
      case "error":
      case "warn":
      case "info":
      case "debug":
      case "trace":
        return true;
      default:
        return false;
    }
  }
  function setLevel(level) {
    const { labels, values } = this.levels;
    if (typeof level === "number") {
      if (labels[level] === undefined)
        throw Error("unknown level value" + level);
      level = labels[level];
    }
    if (values[level] === undefined)
      throw Error("unknown level " + level);
    const preLevelVal = this[levelValSym];
    const levelVal = this[levelValSym] = values[level];
    const useOnlyCustomLevelsVal = this[useOnlyCustomLevelsSym];
    const levelComparison = this[levelCompSym];
    const hook = this[hooksSym].logMethod;
    for (const key in values) {
      if (levelComparison(values[key], levelVal) === false) {
        this[key] = noop;
        continue;
      }
      this[key] = isStandardLevel(key, useOnlyCustomLevelsVal) ? levelMethods[key](hook) : genLog(values[key], hook);
    }
    this.emit("level-change", level, levelVal, labels[preLevelVal], preLevelVal, this);
  }
  function getLevel(level) {
    const { levels, levelVal } = this;
    return levels && levels.labels ? levels.labels[levelVal] : "";
  }
  function isLevelEnabled(logLevel) {
    const { values } = this.levels;
    const logLevelVal = values[logLevel];
    return logLevelVal !== undefined && this[levelCompSym](logLevelVal, this[levelValSym]);
  }
  function compareLevel(direction, current, expected) {
    if (direction === SORTING_ORDER.DESC) {
      return current <= expected;
    }
    return current >= expected;
  }
  function genLevelComparison(levelComparison) {
    if (typeof levelComparison === "string") {
      return compareLevel.bind(null, levelComparison);
    }
    return levelComparison;
  }
  function mappings(customLevels = null, useOnlyCustomLevels = false) {
    const customNums = customLevels ? Object.keys(customLevels).reduce((o2, k) => {
      o2[customLevels[k]] = k;
      return o2;
    }, {}) : null;
    const labels = Object.assign(Object.create(Object.prototype, { Infinity: { value: "silent" } }), useOnlyCustomLevels ? null : nums, customNums);
    const values = Object.assign(Object.create(Object.prototype, { silent: { value: Infinity } }), useOnlyCustomLevels ? null : DEFAULT_LEVELS, customLevels);
    return { labels, values };
  }
  function assertDefaultLevelFound(defaultLevel, customLevels, useOnlyCustomLevels) {
    if (typeof defaultLevel === "number") {
      const values = [].concat(Object.keys(customLevels || {}).map((key) => customLevels[key]), useOnlyCustomLevels ? [] : Object.keys(nums).map((level) => +level), Infinity);
      if (!values.includes(defaultLevel)) {
        throw Error(`default level:${defaultLevel} must be included in custom levels`);
      }
      return;
    }
    const labels = Object.assign(Object.create(Object.prototype, { silent: { value: Infinity } }), useOnlyCustomLevels ? null : DEFAULT_LEVELS, customLevels);
    if (!(defaultLevel in labels)) {
      throw Error(`default level:${defaultLevel} must be included in custom levels`);
    }
  }
  function assertNoLevelCollisions(levels, customLevels) {
    const { labels, values } = levels;
    for (const k in customLevels) {
      if (k in values) {
        throw Error("levels cannot be overridden");
      }
      if (customLevels[k] in labels) {
        throw Error("pre-existing level values cannot be used for new levels");
      }
    }
  }
  function assertLevelComparison(levelComparison) {
    if (typeof levelComparison === "function") {
      return;
    }
    if (typeof levelComparison === "string" && Object.values(SORTING_ORDER).includes(levelComparison)) {
      return;
    }
    throw new Error('Levels comparison should be one of "ASC", "DESC" or "function" type');
  }
  module.exports = {
    initialLsCache,
    genLsCache,
    levelMethods,
    getLevel,
    setLevel,
    isLevelEnabled,
    mappings,
    assertNoLevelCollisions,
    assertDefaultLevelFound,
    genLevelComparison,
    assertLevelComparison
  };
});

// node_modules/pino/lib/meta.js
var require_meta = __commonJS((exports, module) => {
  module.exports = { version: "9.6.0" };
});

// node_modules/pino/lib/proto.js
var require_proto = __commonJS((exports, module) => {
  var { EventEmitter } = import.meta.require("events");
  var {
    lsCacheSym,
    levelValSym,
    setLevelSym,
    getLevelSym,
    chindingsSym,
    parsedChindingsSym,
    mixinSym,
    asJsonSym,
    writeSym,
    mixinMergeStrategySym,
    timeSym,
    timeSliceIndexSym,
    streamSym,
    serializersSym,
    formattersSym,
    errorKeySym,
    messageKeySym,
    useOnlyCustomLevelsSym,
    needsMetadataGsym,
    redactFmtSym,
    stringifySym,
    formatOptsSym,
    stringifiersSym,
    msgPrefixSym,
    hooksSym
  } = require_symbols();
  var {
    getLevel,
    setLevel,
    isLevelEnabled,
    mappings,
    initialLsCache,
    genLsCache,
    assertNoLevelCollisions
  } = require_levels();
  var {
    asChindings,
    asJson,
    buildFormatters,
    stringify
  } = require_tools();
  var {
    version
  } = require_meta();
  var redaction = require_redaction();
  var constructor = class Pino {
  };
  var prototype = {
    constructor,
    child,
    bindings,
    setBindings,
    flush,
    isLevelEnabled,
    version,
    get level() {
      return this[getLevelSym]();
    },
    set level(lvl) {
      this[setLevelSym](lvl);
    },
    get levelVal() {
      return this[levelValSym];
    },
    set levelVal(n2) {
      throw Error("levelVal is read-only");
    },
    [lsCacheSym]: initialLsCache,
    [writeSym]: write,
    [asJsonSym]: asJson,
    [getLevelSym]: getLevel,
    [setLevelSym]: setLevel
  };
  Object.setPrototypeOf(prototype, EventEmitter.prototype);
  module.exports = function() {
    return Object.create(prototype);
  };
  var resetChildingsFormatter = (bindings2) => bindings2;
  function child(bindings2, options) {
    if (!bindings2) {
      throw Error("missing bindings for child Pino");
    }
    options = options || {};
    const serializers = this[serializersSym];
    const formatters = this[formattersSym];
    const instance = Object.create(this);
    if (options.hasOwnProperty("serializers") === true) {
      instance[serializersSym] = Object.create(null);
      for (const k in serializers) {
        instance[serializersSym][k] = serializers[k];
      }
      const parentSymbols = Object.getOwnPropertySymbols(serializers);
      for (var i = 0;i < parentSymbols.length; i++) {
        const ks = parentSymbols[i];
        instance[serializersSym][ks] = serializers[ks];
      }
      for (const bk in options.serializers) {
        instance[serializersSym][bk] = options.serializers[bk];
      }
      const bindingsSymbols = Object.getOwnPropertySymbols(options.serializers);
      for (var bi = 0;bi < bindingsSymbols.length; bi++) {
        const bks = bindingsSymbols[bi];
        instance[serializersSym][bks] = options.serializers[bks];
      }
    } else
      instance[serializersSym] = serializers;
    if (options.hasOwnProperty("formatters")) {
      const { level, bindings: chindings, log } = options.formatters;
      instance[formattersSym] = buildFormatters(level || formatters.level, chindings || resetChildingsFormatter, log || formatters.log);
    } else {
      instance[formattersSym] = buildFormatters(formatters.level, resetChildingsFormatter, formatters.log);
    }
    if (options.hasOwnProperty("customLevels") === true) {
      assertNoLevelCollisions(this.levels, options.customLevels);
      instance.levels = mappings(options.customLevels, instance[useOnlyCustomLevelsSym]);
      genLsCache(instance);
    }
    if (typeof options.redact === "object" && options.redact !== null || Array.isArray(options.redact)) {
      instance.redact = options.redact;
      const stringifiers = redaction(instance.redact, stringify);
      const formatOpts = { stringify: stringifiers[redactFmtSym] };
      instance[stringifySym] = stringify;
      instance[stringifiersSym] = stringifiers;
      instance[formatOptsSym] = formatOpts;
    }
    if (typeof options.msgPrefix === "string") {
      instance[msgPrefixSym] = (this[msgPrefixSym] || "") + options.msgPrefix;
    }
    instance[chindingsSym] = asChindings(instance, bindings2);
    const childLevel = options.level || this.level;
    instance[setLevelSym](childLevel);
    this.onChild(instance);
    return instance;
  }
  function bindings() {
    const chindings = this[chindingsSym];
    const chindingsJson = `{${chindings.substr(1)}}`;
    const bindingsFromJson = JSON.parse(chindingsJson);
    delete bindingsFromJson.pid;
    delete bindingsFromJson.hostname;
    return bindingsFromJson;
  }
  function setBindings(newBindings) {
    const chindings = asChindings(this, newBindings);
    this[chindingsSym] = chindings;
    delete this[parsedChindingsSym];
  }
  function defaultMixinMergeStrategy(mergeObject, mixinObject) {
    return Object.assign(mixinObject, mergeObject);
  }
  function write(_obj, msg, num) {
    const t3 = this[timeSym]();
    const mixin = this[mixinSym];
    const errorKey = this[errorKeySym];
    const messageKey = this[messageKeySym];
    const mixinMergeStrategy = this[mixinMergeStrategySym] || defaultMixinMergeStrategy;
    let obj;
    const streamWriteHook = this[hooksSym].streamWrite;
    if (_obj === undefined || _obj === null) {
      obj = {};
    } else if (_obj instanceof Error) {
      obj = { [errorKey]: _obj };
      if (msg === undefined) {
        msg = _obj.message;
      }
    } else {
      obj = _obj;
      if (msg === undefined && _obj[messageKey] === undefined && _obj[errorKey]) {
        msg = _obj[errorKey].message;
      }
    }
    if (mixin) {
      obj = mixinMergeStrategy(obj, mixin(obj, num, this));
    }
    const s = this[asJsonSym](obj, msg, num, t3);
    const stream = this[streamSym];
    if (stream[needsMetadataGsym] === true) {
      stream.lastLevel = num;
      stream.lastObj = obj;
      stream.lastMsg = msg;
      stream.lastTime = t3.slice(this[timeSliceIndexSym]);
      stream.lastLogger = this;
    }
    stream.write(streamWriteHook ? streamWriteHook(s) : s);
  }
  function noop() {
  }
  function flush(cb) {
    if (cb != null && typeof cb !== "function") {
      throw Error("callback must be a function");
    }
    const stream = this[streamSym];
    if (typeof stream.flush === "function") {
      stream.flush(cb || noop);
    } else if (cb)
      cb();
  }
});

// node_modules/safe-stable-stringify/index.js
var require_safe_stable_stringify = __commonJS((exports, module) => {
  var { hasOwnProperty } = Object.prototype;
  var stringify = configure();
  stringify.configure = configure;
  stringify.stringify = stringify;
  stringify.default = stringify;
  exports.stringify = stringify;
  exports.configure = configure;
  module.exports = stringify;
  var strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
  function strEscape(str) {
    if (str.length < 5000 && !strEscapeSequencesRegExp.test(str)) {
      return `"${str}"`;
    }
    return JSON.stringify(str);
  }
  function sort(array, comparator) {
    if (array.length > 200 || comparator) {
      return array.sort(comparator);
    }
    for (let i = 1;i < array.length; i++) {
      const currentValue = array[i];
      let position = i;
      while (position !== 0 && array[position - 1] > currentValue) {
        array[position] = array[position - 1];
        position--;
      }
      array[position] = currentValue;
    }
    return array;
  }
  var typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Object.getPrototypeOf(new Int8Array)), Symbol.toStringTag).get;
  function isTypedArrayWithEntries(value) {
    return typedArrayPrototypeGetSymbolToStringTag.call(value) !== undefined && value.length !== 0;
  }
  function stringifyTypedArray(array, separator, maximumBreadth) {
    if (array.length < maximumBreadth) {
      maximumBreadth = array.length;
    }
    const whitespace = separator === "," ? "" : " ";
    let res = `"0":${whitespace}${array[0]}`;
    for (let i = 1;i < maximumBreadth; i++) {
      res += `${separator}"${i}":${whitespace}${array[i]}`;
    }
    return res;
  }
  function getCircularValueOption(options) {
    if (hasOwnProperty.call(options, "circularValue")) {
      const circularValue = options.circularValue;
      if (typeof circularValue === "string") {
        return `"${circularValue}"`;
      }
      if (circularValue == null) {
        return circularValue;
      }
      if (circularValue === Error || circularValue === TypeError) {
        return {
          toString() {
            throw new TypeError("Converting circular structure to JSON");
          }
        };
      }
      throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
    }
    return '"[Circular]"';
  }
  function getDeterministicOption(options) {
    let value;
    if (hasOwnProperty.call(options, "deterministic")) {
      value = options.deterministic;
      if (typeof value !== "boolean" && typeof value !== "function") {
        throw new TypeError('The "deterministic" argument must be of type boolean or comparator function');
      }
    }
    return value === undefined ? true : value;
  }
  function getBooleanOption(options, key) {
    let value;
    if (hasOwnProperty.call(options, key)) {
      value = options[key];
      if (typeof value !== "boolean") {
        throw new TypeError(`The "${key}" argument must be of type boolean`);
      }
    }
    return value === undefined ? true : value;
  }
  function getPositiveIntegerOption(options, key) {
    let value;
    if (hasOwnProperty.call(options, key)) {
      value = options[key];
      if (typeof value !== "number") {
        throw new TypeError(`The "${key}" argument must be of type number`);
      }
      if (!Number.isInteger(value)) {
        throw new TypeError(`The "${key}" argument must be an integer`);
      }
      if (value < 1) {
        throw new RangeError(`The "${key}" argument must be >= 1`);
      }
    }
    return value === undefined ? Infinity : value;
  }
  function getItemCount(number) {
    if (number === 1) {
      return "1 item";
    }
    return `${number} items`;
  }
  function getUniqueReplacerSet(replacerArray) {
    const replacerSet = new Set;
    for (const value of replacerArray) {
      if (typeof value === "string" || typeof value === "number") {
        replacerSet.add(String(value));
      }
    }
    return replacerSet;
  }
  function getStrictOption(options) {
    if (hasOwnProperty.call(options, "strict")) {
      const value = options.strict;
      if (typeof value !== "boolean") {
        throw new TypeError('The "strict" argument must be of type boolean');
      }
      if (value) {
        return (value2) => {
          let message2 = `Object can not safely be stringified. Received type ${typeof value2}`;
          if (typeof value2 !== "function")
            message2 += ` (${value2.toString()})`;
          throw new Error(message2);
        };
      }
    }
  }
  function configure(options) {
    options = { ...options };
    const fail = getStrictOption(options);
    if (fail) {
      if (options.bigint === undefined) {
        options.bigint = false;
      }
      if (!("circularValue" in options)) {
        options.circularValue = Error;
      }
    }
    const circularValue = getCircularValueOption(options);
    const bigint = getBooleanOption(options, "bigint");
    const deterministic = getDeterministicOption(options);
    const comparator = typeof deterministic === "function" ? deterministic : undefined;
    const maximumDepth = getPositiveIntegerOption(options, "maximumDepth");
    const maximumBreadth = getPositiveIntegerOption(options, "maximumBreadth");
    function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {
      let value = parent[key];
      if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
        value = value.toJSON(key);
      }
      value = replacer.call(parent, key, value);
      switch (typeof value) {
        case "string":
          return strEscape(value);
        case "object": {
          if (value === null) {
            return "null";
          }
          if (stack.indexOf(value) !== -1) {
            return circularValue;
          }
          let res = "";
          let join3 = ",";
          const originalIndentation = indentation;
          if (Array.isArray(value)) {
            if (value.length === 0) {
              return "[]";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Array]"';
            }
            stack.push(value);
            if (spacer !== "") {
              indentation += spacer;
              res += `
${indentation}`;
              join3 = `,
${indentation}`;
            }
            const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
            let i = 0;
            for (;i < maximumValuesToStringify - 1; i++) {
              const tmp2 = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
              res += tmp2 !== undefined ? tmp2 : "null";
              res += join3;
            }
            const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
            res += tmp !== undefined ? tmp : "null";
            if (value.length - 1 > maximumBreadth) {
              const removedKeys = value.length - maximumBreadth - 1;
              res += `${join3}"... ${getItemCount(removedKeys)} not stringified"`;
            }
            if (spacer !== "") {
              res += `
${originalIndentation}`;
            }
            stack.pop();
            return `[${res}]`;
          }
          let keys = Object.keys(value);
          const keyLength = keys.length;
          if (keyLength === 0) {
            return "{}";
          }
          if (maximumDepth < stack.length + 1) {
            return '"[Object]"';
          }
          let whitespace = "";
          let separator = "";
          if (spacer !== "") {
            indentation += spacer;
            join3 = `,
${indentation}`;
            whitespace = " ";
          }
          const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
          if (deterministic && !isTypedArrayWithEntries(value)) {
            keys = sort(keys, comparator);
          }
          stack.push(value);
          for (let i = 0;i < maximumPropertiesToStringify; i++) {
            const key2 = keys[i];
            const tmp = stringifyFnReplacer(key2, value, stack, replacer, spacer, indentation);
            if (tmp !== undefined) {
              res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
              separator = join3;
            }
          }
          if (keyLength > maximumBreadth) {
            const removedKeys = keyLength - maximumBreadth;
            res += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`;
            separator = join3;
          }
          if (spacer !== "" && separator.length > 1) {
            res = `
${indentation}${res}
${originalIndentation}`;
          }
          stack.pop();
          return `{${res}}`;
        }
        case "number":
          return isFinite(value) ? String(value) : fail ? fail(value) : "null";
        case "boolean":
          return value === true ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (bigint) {
            return String(value);
          }
        default:
          return fail ? fail(value) : undefined;
      }
    }
    function stringifyArrayReplacer(key, value, stack, replacer, spacer, indentation) {
      if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
        value = value.toJSON(key);
      }
      switch (typeof value) {
        case "string":
          return strEscape(value);
        case "object": {
          if (value === null) {
            return "null";
          }
          if (stack.indexOf(value) !== -1) {
            return circularValue;
          }
          const originalIndentation = indentation;
          let res = "";
          let join3 = ",";
          if (Array.isArray(value)) {
            if (value.length === 0) {
              return "[]";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Array]"';
            }
            stack.push(value);
            if (spacer !== "") {
              indentation += spacer;
              res += `
${indentation}`;
              join3 = `,
${indentation}`;
            }
            const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
            let i = 0;
            for (;i < maximumValuesToStringify - 1; i++) {
              const tmp2 = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
              res += tmp2 !== undefined ? tmp2 : "null";
              res += join3;
            }
            const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
            res += tmp !== undefined ? tmp : "null";
            if (value.length - 1 > maximumBreadth) {
              const removedKeys = value.length - maximumBreadth - 1;
              res += `${join3}"... ${getItemCount(removedKeys)} not stringified"`;
            }
            if (spacer !== "") {
              res += `
${originalIndentation}`;
            }
            stack.pop();
            return `[${res}]`;
          }
          stack.push(value);
          let whitespace = "";
          if (spacer !== "") {
            indentation += spacer;
            join3 = `,
${indentation}`;
            whitespace = " ";
          }
          let separator = "";
          for (const key2 of replacer) {
            const tmp = stringifyArrayReplacer(key2, value[key2], stack, replacer, spacer, indentation);
            if (tmp !== undefined) {
              res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
              separator = join3;
            }
          }
          if (spacer !== "" && separator.length > 1) {
            res = `
${indentation}${res}
${originalIndentation}`;
          }
          stack.pop();
          return `{${res}}`;
        }
        case "number":
          return isFinite(value) ? String(value) : fail ? fail(value) : "null";
        case "boolean":
          return value === true ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (bigint) {
            return String(value);
          }
        default:
          return fail ? fail(value) : undefined;
      }
    }
    function stringifyIndent(key, value, stack, spacer, indentation) {
      switch (typeof value) {
        case "string":
          return strEscape(value);
        case "object": {
          if (value === null) {
            return "null";
          }
          if (typeof value.toJSON === "function") {
            value = value.toJSON(key);
            if (typeof value !== "object") {
              return stringifyIndent(key, value, stack, spacer, indentation);
            }
            if (value === null) {
              return "null";
            }
          }
          if (stack.indexOf(value) !== -1) {
            return circularValue;
          }
          const originalIndentation = indentation;
          if (Array.isArray(value)) {
            if (value.length === 0) {
              return "[]";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Array]"';
            }
            stack.push(value);
            indentation += spacer;
            let res2 = `
${indentation}`;
            const join4 = `,
${indentation}`;
            const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
            let i = 0;
            for (;i < maximumValuesToStringify - 1; i++) {
              const tmp2 = stringifyIndent(String(i), value[i], stack, spacer, indentation);
              res2 += tmp2 !== undefined ? tmp2 : "null";
              res2 += join4;
            }
            const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation);
            res2 += tmp !== undefined ? tmp : "null";
            if (value.length - 1 > maximumBreadth) {
              const removedKeys = value.length - maximumBreadth - 1;
              res2 += `${join4}"... ${getItemCount(removedKeys)} not stringified"`;
            }
            res2 += `
${originalIndentation}`;
            stack.pop();
            return `[${res2}]`;
          }
          let keys = Object.keys(value);
          const keyLength = keys.length;
          if (keyLength === 0) {
            return "{}";
          }
          if (maximumDepth < stack.length + 1) {
            return '"[Object]"';
          }
          indentation += spacer;
          const join3 = `,
${indentation}`;
          let res = "";
          let separator = "";
          let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
          if (isTypedArrayWithEntries(value)) {
            res += stringifyTypedArray(value, join3, maximumBreadth);
            keys = keys.slice(value.length);
            maximumPropertiesToStringify -= value.length;
            separator = join3;
          }
          if (deterministic) {
            keys = sort(keys, comparator);
          }
          stack.push(value);
          for (let i = 0;i < maximumPropertiesToStringify; i++) {
            const key2 = keys[i];
            const tmp = stringifyIndent(key2, value[key2], stack, spacer, indentation);
            if (tmp !== undefined) {
              res += `${separator}${strEscape(key2)}: ${tmp}`;
              separator = join3;
            }
          }
          if (keyLength > maximumBreadth) {
            const removedKeys = keyLength - maximumBreadth;
            res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`;
            separator = join3;
          }
          if (separator !== "") {
            res = `
${indentation}${res}
${originalIndentation}`;
          }
          stack.pop();
          return `{${res}}`;
        }
        case "number":
          return isFinite(value) ? String(value) : fail ? fail(value) : "null";
        case "boolean":
          return value === true ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (bigint) {
            return String(value);
          }
        default:
          return fail ? fail(value) : undefined;
      }
    }
    function stringifySimple(key, value, stack) {
      switch (typeof value) {
        case "string":
          return strEscape(value);
        case "object": {
          if (value === null) {
            return "null";
          }
          if (typeof value.toJSON === "function") {
            value = value.toJSON(key);
            if (typeof value !== "object") {
              return stringifySimple(key, value, stack);
            }
            if (value === null) {
              return "null";
            }
          }
          if (stack.indexOf(value) !== -1) {
            return circularValue;
          }
          let res = "";
          const hasLength = value.length !== undefined;
          if (hasLength && Array.isArray(value)) {
            if (value.length === 0) {
              return "[]";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Array]"';
            }
            stack.push(value);
            const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
            let i = 0;
            for (;i < maximumValuesToStringify - 1; i++) {
              const tmp2 = stringifySimple(String(i), value[i], stack);
              res += tmp2 !== undefined ? tmp2 : "null";
              res += ",";
            }
            const tmp = stringifySimple(String(i), value[i], stack);
            res += tmp !== undefined ? tmp : "null";
            if (value.length - 1 > maximumBreadth) {
              const removedKeys = value.length - maximumBreadth - 1;
              res += `,"... ${getItemCount(removedKeys)} not stringified"`;
            }
            stack.pop();
            return `[${res}]`;
          }
          let keys = Object.keys(value);
          const keyLength = keys.length;
          if (keyLength === 0) {
            return "{}";
          }
          if (maximumDepth < stack.length + 1) {
            return '"[Object]"';
          }
          let separator = "";
          let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
          if (hasLength && isTypedArrayWithEntries(value)) {
            res += stringifyTypedArray(value, ",", maximumBreadth);
            keys = keys.slice(value.length);
            maximumPropertiesToStringify -= value.length;
            separator = ",";
          }
          if (deterministic) {
            keys = sort(keys, comparator);
          }
          stack.push(value);
          for (let i = 0;i < maximumPropertiesToStringify; i++) {
            const key2 = keys[i];
            const tmp = stringifySimple(key2, value[key2], stack);
            if (tmp !== undefined) {
              res += `${separator}${strEscape(key2)}:${tmp}`;
              separator = ",";
            }
          }
          if (keyLength > maximumBreadth) {
            const removedKeys = keyLength - maximumBreadth;
            res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
          }
          stack.pop();
          return `{${res}}`;
        }
        case "number":
          return isFinite(value) ? String(value) : fail ? fail(value) : "null";
        case "boolean":
          return value === true ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (bigint) {
            return String(value);
          }
        default:
          return fail ? fail(value) : undefined;
      }
    }
    function stringify2(value, replacer, space) {
      if (arguments.length > 1) {
        let spacer = "";
        if (typeof space === "number") {
          spacer = " ".repeat(Math.min(space, 10));
        } else if (typeof space === "string") {
          spacer = space.slice(0, 10);
        }
        if (replacer != null) {
          if (typeof replacer === "function") {
            return stringifyFnReplacer("", { "": value }, [], replacer, spacer, "");
          }
          if (Array.isArray(replacer)) {
            return stringifyArrayReplacer("", value, [], getUniqueReplacerSet(replacer), spacer, "");
          }
        }
        if (spacer.length !== 0) {
          return stringifyIndent("", value, [], spacer, "");
        }
      }
      return stringifySimple("", value, []);
    }
    return stringify2;
  }
});

// node_modules/pino/lib/multistream.js
var require_multistream = __commonJS((exports, module) => {
  var metadata = Symbol.for("pino.metadata");
  var { DEFAULT_LEVELS } = require_constants();
  var DEFAULT_INFO_LEVEL = DEFAULT_LEVELS.info;
  function multistream(streamsArray, opts) {
    let counter = 0;
    streamsArray = streamsArray || [];
    opts = opts || { dedupe: false };
    const streamLevels = Object.create(DEFAULT_LEVELS);
    streamLevels.silent = Infinity;
    if (opts.levels && typeof opts.levels === "object") {
      Object.keys(opts.levels).forEach((i) => {
        streamLevels[i] = opts.levels[i];
      });
    }
    const res = {
      write,
      add,
      emit,
      flushSync,
      end,
      minLevel: 0,
      streams: [],
      clone: clone3,
      [metadata]: true,
      streamLevels
    };
    if (Array.isArray(streamsArray)) {
      streamsArray.forEach(add, res);
    } else {
      add.call(res, streamsArray);
    }
    streamsArray = null;
    return res;
    function write(data) {
      let dest;
      const level = this.lastLevel;
      const { streams } = this;
      let recordedLevel = 0;
      let stream;
      for (let i = initLoopVar(streams.length, opts.dedupe);checkLoopVar(i, streams.length, opts.dedupe); i = adjustLoopVar(i, opts.dedupe)) {
        dest = streams[i];
        if (dest.level <= level) {
          if (recordedLevel !== 0 && recordedLevel !== dest.level) {
            break;
          }
          stream = dest.stream;
          if (stream[metadata]) {
            const { lastTime, lastMsg, lastObj, lastLogger } = this;
            stream.lastLevel = level;
            stream.lastTime = lastTime;
            stream.lastMsg = lastMsg;
            stream.lastObj = lastObj;
            stream.lastLogger = lastLogger;
          }
          stream.write(data);
          if (opts.dedupe) {
            recordedLevel = dest.level;
          }
        } else if (!opts.dedupe) {
          break;
        }
      }
    }
    function emit(...args) {
      for (const { stream } of this.streams) {
        if (typeof stream.emit === "function") {
          stream.emit(...args);
        }
      }
    }
    function flushSync() {
      for (const { stream } of this.streams) {
        if (typeof stream.flushSync === "function") {
          stream.flushSync();
        }
      }
    }
    function add(dest) {
      if (!dest) {
        return res;
      }
      const isStream = typeof dest.write === "function" || dest.stream;
      const stream_ = dest.write ? dest : dest.stream;
      if (!isStream) {
        throw Error("stream object needs to implement either StreamEntry or DestinationStream interface");
      }
      const { streams, streamLevels: streamLevels2 } = this;
      let level;
      if (typeof dest.levelVal === "number") {
        level = dest.levelVal;
      } else if (typeof dest.level === "string") {
        level = streamLevels2[dest.level];
      } else if (typeof dest.level === "number") {
        level = dest.level;
      } else {
        level = DEFAULT_INFO_LEVEL;
      }
      const dest_ = {
        stream: stream_,
        level,
        levelVal: undefined,
        id: counter++
      };
      streams.unshift(dest_);
      streams.sort(compareByLevel);
      this.minLevel = streams[0].level;
      return res;
    }
    function end() {
      for (const { stream } of this.streams) {
        if (typeof stream.flushSync === "function") {
          stream.flushSync();
        }
        stream.end();
      }
    }
    function clone3(level) {
      const streams = new Array(this.streams.length);
      for (let i = 0;i < streams.length; i++) {
        streams[i] = {
          level,
          stream: this.streams[i].stream
        };
      }
      return {
        write,
        add,
        minLevel: level,
        streams,
        clone: clone3,
        emit,
        flushSync,
        [metadata]: true
      };
    }
  }
  function compareByLevel(a13, b) {
    return a13.level - b.level;
  }
  function initLoopVar(length, dedupe) {
    return dedupe ? length - 1 : 0;
  }
  function adjustLoopVar(i, dedupe) {
    return dedupe ? i - 1 : i + 1;
  }
  function checkLoopVar(i, length, dedupe) {
    return dedupe ? i >= 0 : i < length;
  }
  module.exports = multistream;
});

// node_modules/pino/pino.js
var require_pino = __commonJS((exports, module) => {
  var os = import.meta.require("os");
  var stdSerializers = require_pino_std_serializers();
  var caller = require_caller();
  var redaction = require_redaction();
  var time = require_time();
  var proto = require_proto();
  var symbols = require_symbols();
  var { configure } = require_safe_stable_stringify();
  var { assertDefaultLevelFound, mappings, genLsCache, genLevelComparison, assertLevelComparison } = require_levels();
  var { DEFAULT_LEVELS, SORTING_ORDER } = require_constants();
  var {
    createArgsNormalizer,
    asChindings,
    buildSafeSonicBoom,
    buildFormatters,
    stringify,
    normalizeDestFileDescriptor,
    noop
  } = require_tools();
  var { version } = require_meta();
  var {
    chindingsSym,
    redactFmtSym,
    serializersSym,
    timeSym,
    timeSliceIndexSym,
    streamSym,
    stringifySym,
    stringifySafeSym,
    stringifiersSym,
    setLevelSym,
    endSym,
    formatOptsSym,
    messageKeySym,
    errorKeySym,
    nestedKeySym,
    mixinSym,
    levelCompSym,
    useOnlyCustomLevelsSym,
    formattersSym,
    hooksSym,
    nestedKeyStrSym,
    mixinMergeStrategySym,
    msgPrefixSym
  } = symbols;
  var { epochTime, nullTime } = time;
  var { pid } = process;
  var hostname = os.hostname();
  var defaultErrorSerializer = stdSerializers.err;
  var defaultOptions = {
    level: "info",
    levelComparison: SORTING_ORDER.ASC,
    levels: DEFAULT_LEVELS,
    messageKey: "msg",
    errorKey: "err",
    nestedKey: null,
    enabled: true,
    base: { pid, hostname },
    serializers: Object.assign(Object.create(null), {
      err: defaultErrorSerializer
    }),
    formatters: Object.assign(Object.create(null), {
      bindings(bindings) {
        return bindings;
      },
      level(label, number) {
        return { level: number };
      }
    }),
    hooks: {
      logMethod: undefined,
      streamWrite: undefined
    },
    timestamp: epochTime,
    name: undefined,
    redact: null,
    customLevels: null,
    useOnlyCustomLevels: false,
    depthLimit: 5,
    edgeLimit: 100
  };
  var normalize2 = createArgsNormalizer(defaultOptions);
  var serializers = Object.assign(Object.create(null), stdSerializers);
  function pino(...args) {
    const instance = {};
    const { opts, stream } = normalize2(instance, caller(), ...args);
    if (opts.level && typeof opts.level === "string" && DEFAULT_LEVELS[opts.level.toLowerCase()] !== undefined)
      opts.level = opts.level.toLowerCase();
    const {
      redact,
      crlf,
      serializers: serializers2,
      timestamp,
      messageKey,
      errorKey,
      nestedKey,
      base,
      name,
      level,
      customLevels,
      levelComparison,
      mixin,
      mixinMergeStrategy,
      useOnlyCustomLevels,
      formatters,
      hooks,
      depthLimit,
      edgeLimit,
      onChild,
      msgPrefix
    } = opts;
    const stringifySafe = configure({
      maximumDepth: depthLimit,
      maximumBreadth: edgeLimit
    });
    const allFormatters = buildFormatters(formatters.level, formatters.bindings, formatters.log);
    const stringifyFn = stringify.bind({
      [stringifySafeSym]: stringifySafe
    });
    const stringifiers = redact ? redaction(redact, stringifyFn) : {};
    const formatOpts = redact ? { stringify: stringifiers[redactFmtSym] } : { stringify: stringifyFn };
    const end = "}" + (crlf ? `\r
` : `
`);
    const coreChindings = asChindings.bind(null, {
      [chindingsSym]: "",
      [serializersSym]: serializers2,
      [stringifiersSym]: stringifiers,
      [stringifySym]: stringify,
      [stringifySafeSym]: stringifySafe,
      [formattersSym]: allFormatters
    });
    let chindings = "";
    if (base !== null) {
      if (name === undefined) {
        chindings = coreChindings(base);
      } else {
        chindings = coreChindings(Object.assign({}, base, { name }));
      }
    }
    const time2 = timestamp instanceof Function ? timestamp : timestamp ? epochTime : nullTime;
    const timeSliceIndex = time2().indexOf(":") + 1;
    if (useOnlyCustomLevels && !customLevels)
      throw Error("customLevels is required if useOnlyCustomLevels is set true");
    if (mixin && typeof mixin !== "function")
      throw Error(`Unknown mixin type "${typeof mixin}" - expected "function"`);
    if (msgPrefix && typeof msgPrefix !== "string")
      throw Error(`Unknown msgPrefix type "${typeof msgPrefix}" - expected "string"`);
    assertDefaultLevelFound(level, customLevels, useOnlyCustomLevels);
    const levels = mappings(customLevels, useOnlyCustomLevels);
    if (typeof stream.emit === "function") {
      stream.emit("message", { code: "PINO_CONFIG", config: { levels, messageKey, errorKey } });
    }
    assertLevelComparison(levelComparison);
    const levelCompFunc = genLevelComparison(levelComparison);
    Object.assign(instance, {
      levels,
      [levelCompSym]: levelCompFunc,
      [useOnlyCustomLevelsSym]: useOnlyCustomLevels,
      [streamSym]: stream,
      [timeSym]: time2,
      [timeSliceIndexSym]: timeSliceIndex,
      [stringifySym]: stringify,
      [stringifySafeSym]: stringifySafe,
      [stringifiersSym]: stringifiers,
      [endSym]: end,
      [formatOptsSym]: formatOpts,
      [messageKeySym]: messageKey,
      [errorKeySym]: errorKey,
      [nestedKeySym]: nestedKey,
      [nestedKeyStrSym]: nestedKey ? `,${JSON.stringify(nestedKey)}:{` : "",
      [serializersSym]: serializers2,
      [mixinSym]: mixin,
      [mixinMergeStrategySym]: mixinMergeStrategy,
      [chindingsSym]: chindings,
      [formattersSym]: allFormatters,
      [hooksSym]: hooks,
      silent: noop,
      onChild,
      [msgPrefixSym]: msgPrefix
    });
    Object.setPrototypeOf(instance, proto());
    genLsCache(instance);
    instance[setLevelSym](level);
    return instance;
  }
  module.exports = pino;
  module.exports.destination = (dest = process.stdout.fd) => {
    if (typeof dest === "object") {
      dest.dest = normalizeDestFileDescriptor(dest.dest || process.stdout.fd);
      return buildSafeSonicBoom(dest);
    } else {
      return buildSafeSonicBoom({ dest: normalizeDestFileDescriptor(dest), minLength: 0 });
    }
  };
  module.exports.transport = require_transport();
  module.exports.multistream = require_multistream();
  module.exports.levels = mappings();
  module.exports.stdSerializers = serializers;
  module.exports.stdTimeFunctions = Object.assign({}, time);
  module.exports.symbols = symbols;
  module.exports.version = version;
  module.exports.default = pino;
  module.exports.pino = pino;
});

// node_modules/es-errors/type.js
var require_type = __commonJS((exports, module) => {
  module.exports = TypeError;
});

// node_modules/object-inspect/util.inspect.js
var require_util_inspect = __commonJS((exports, module) => {
  module.exports = import.meta.require("util").inspect;
});

// node_modules/object-inspect/index.js
var require_object_inspect = __commonJS((exports, module) => {
  var hasMap = typeof Map === "function" && Map.prototype;
  var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
  var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
  var mapForEach = hasMap && Map.prototype.forEach;
  var hasSet = typeof Set === "function" && Set.prototype;
  var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
  var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
  var setForEach = hasSet && Set.prototype.forEach;
  var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
  var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
  var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
  var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
  var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
  var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
  var booleanValueOf = Boolean.prototype.valueOf;
  var objectToString = Object.prototype.toString;
  var functionToString = Function.prototype.toString;
  var $match = String.prototype.match;
  var $slice = String.prototype.slice;
  var $replace = String.prototype.replace;
  var $toUpperCase = String.prototype.toUpperCase;
  var $toLowerCase = String.prototype.toLowerCase;
  var $test = RegExp.prototype.test;
  var $concat = Array.prototype.concat;
  var $join = Array.prototype.join;
  var $arrSlice = Array.prototype.slice;
  var $floor = Math.floor;
  var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
  var gOPS = Object.getOwnPropertySymbols;
  var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
  var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
  var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
  var isEnumerable = Object.prototype.propertyIsEnumerable;
  var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
    return O.__proto__;
  } : null);
  function addNumericSeparator(num, str) {
    if (num === Infinity || num === -Infinity || num !== num || num && num > -1000 && num < 1000 || $test.call(/e/, str)) {
      return str;
    }
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num === "number") {
      var int = num < 0 ? -$floor(-num) : $floor(num);
      if (int !== num) {
        var intStr = String(int);
        var dec = $slice.call(str, intStr.length + 1);
        return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
      }
    }
    return $replace.call(str, sepRegex, "$&_");
  }
  var utilInspect = require_util_inspect();
  var inspectCustom = utilInspect.custom;
  var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
  var quotes = {
    __proto__: null,
    double: '"',
    single: "'"
  };
  var quoteREs = {
    __proto__: null,
    double: /(["\\])/g,
    single: /(['\\])/g
  };
  module.exports = function inspect_(obj, options, depth, seen) {
    var opts = options || {};
    if (has(opts, "quoteStyle") && !has(quotes, opts.quoteStyle)) {
      throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
      throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
    if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
      throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
    }
    if (has(opts, "indent") && opts.indent !== null && opts.indent !== "\t" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
      throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    }
    if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
      throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    }
    var numericSeparator = opts.numericSeparator;
    if (typeof obj === "undefined") {
      return "undefined";
    }
    if (obj === null) {
      return "null";
    }
    if (typeof obj === "boolean") {
      return obj ? "true" : "false";
    }
    if (typeof obj === "string") {
      return inspectString(obj, opts);
    }
    if (typeof obj === "number") {
      if (obj === 0) {
        return Infinity / obj > 0 ? "0" : "-0";
      }
      var str = String(obj);
      return numericSeparator ? addNumericSeparator(obj, str) : str;
    }
    if (typeof obj === "bigint") {
      var bigIntStr = String(obj) + "n";
      return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
    }
    var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
    if (typeof depth === "undefined") {
      depth = 0;
    }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
      return isArray(obj) ? "[Array]" : "[Object]";
    }
    var indent = getIndent(opts, depth);
    if (typeof seen === "undefined") {
      seen = [];
    } else if (indexOf(seen, obj) >= 0) {
      return "[Circular]";
    }
    function inspect(value, from, noIndent) {
      if (from) {
        seen = $arrSlice.call(seen);
        seen.push(from);
      }
      if (noIndent) {
        var newOpts = {
          depth: opts.depth
        };
        if (has(opts, "quoteStyle")) {
          newOpts.quoteStyle = opts.quoteStyle;
        }
        return inspect_(value, newOpts, depth + 1, seen);
      }
      return inspect_(value, opts, depth + 1, seen);
    }
    if (typeof obj === "function" && !isRegExp(obj)) {
      var name = nameOf(obj);
      var keys = arrObjKeys(obj, inspect);
      return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
    }
    if (isSymbol(obj)) {
      var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
      return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
      var s = "<" + $toLowerCase.call(String(obj.nodeName));
      var attrs = obj.attributes || [];
      for (var i = 0;i < attrs.length; i++) {
        s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
      }
      s += ">";
      if (obj.childNodes && obj.childNodes.length) {
        s += "...";
      }
      s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
      return s;
    }
    if (isArray(obj)) {
      if (obj.length === 0) {
        return "[]";
      }
      var xs = arrObjKeys(obj, inspect);
      if (indent && !singleLineValues(xs)) {
        return "[" + indentedJoin(xs, indent) + "]";
      }
      return "[ " + $join.call(xs, ", ") + " ]";
    }
    if (isError(obj)) {
      var parts = arrObjKeys(obj, inspect);
      if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
        return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
      }
      if (parts.length === 0) {
        return "[" + String(obj) + "]";
      }
      return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
    }
    if (typeof obj === "object" && customInspect) {
      if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
        return utilInspect(obj, { depth: maxDepth - depth });
      } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
        return obj.inspect();
      }
    }
    if (isMap(obj)) {
      var mapParts = [];
      if (mapForEach) {
        mapForEach.call(obj, function(value, key) {
          mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
        });
      }
      return collectionOf("Map", mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
      var setParts = [];
      if (setForEach) {
        setForEach.call(obj, function(value) {
          setParts.push(inspect(value, obj));
        });
      }
      return collectionOf("Set", setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
      return weakCollectionOf("WeakMap");
    }
    if (isWeakSet(obj)) {
      return weakCollectionOf("WeakSet");
    }
    if (isWeakRef(obj)) {
      return weakCollectionOf("WeakRef");
    }
    if (isNumber(obj)) {
      return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
      return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean(obj)) {
      return markBoxed(booleanValueOf.call(obj));
    }
    if (isString(obj)) {
      return markBoxed(inspect(String(obj)));
    }
    if (typeof window !== "undefined" && obj === window) {
      return "{ [object Window] }";
    }
    if (typeof globalThis !== "undefined" && obj === globalThis || typeof global !== "undefined" && obj === global) {
      return "{ [object globalThis] }";
    }
    if (!isDate(obj) && !isRegExp(obj)) {
      var ys = arrObjKeys(obj, inspect);
      var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
      var protoTag = obj instanceof Object ? "" : "null prototype";
      var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
      var constructorTag = isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
      var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
      if (ys.length === 0) {
        return tag + "{}";
      }
      if (indent) {
        return tag + "{" + indentedJoin(ys, indent) + "}";
      }
      return tag + "{ " + $join.call(ys, ", ") + " }";
    }
    return String(obj);
  };
  function wrapQuotes(s, defaultStyle, opts) {
    var style = opts.quoteStyle || defaultStyle;
    var quoteChar = quotes[style];
    return quoteChar + s + quoteChar;
  }
  function quote(s) {
    return $replace.call(String(s), /"/g, "&quot;");
  }
  function isArray(obj) {
    return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && (toStringTag in obj)));
  }
  function isDate(obj) {
    return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && (toStringTag in obj)));
  }
  function isRegExp(obj) {
    return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && (toStringTag in obj)));
  }
  function isError(obj) {
    return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && (toStringTag in obj)));
  }
  function isString(obj) {
    return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && (toStringTag in obj)));
  }
  function isNumber(obj) {
    return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && (toStringTag in obj)));
  }
  function isBoolean(obj) {
    return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && (toStringTag in obj)));
  }
  function isSymbol(obj) {
    if (hasShammedSymbols) {
      return obj && typeof obj === "object" && obj instanceof Symbol;
    }
    if (typeof obj === "symbol") {
      return true;
    }
    if (!obj || typeof obj !== "object" || !symToString) {
      return false;
    }
    try {
      symToString.call(obj);
      return true;
    } catch (e) {
    }
    return false;
  }
  function isBigInt(obj) {
    if (!obj || typeof obj !== "object" || !bigIntValueOf) {
      return false;
    }
    try {
      bigIntValueOf.call(obj);
      return true;
    } catch (e) {
    }
    return false;
  }
  var hasOwn = Object.prototype.hasOwnProperty || function(key) {
    return key in this;
  };
  function has(obj, key) {
    return hasOwn.call(obj, key);
  }
  function toStr(obj) {
    return objectToString.call(obj);
  }
  function nameOf(f) {
    if (f.name) {
      return f.name;
    }
    var m2 = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m2) {
      return m2[1];
    }
    return null;
  }
  function indexOf(xs, x) {
    if (xs.indexOf) {
      return xs.indexOf(x);
    }
    for (var i = 0, l2 = xs.length;i < l2; i++) {
      if (xs[i] === x) {
        return i;
      }
    }
    return -1;
  }
  function isMap(x) {
    if (!mapSize || !x || typeof x !== "object") {
      return false;
    }
    try {
      mapSize.call(x);
      try {
        setSize.call(x);
      } catch (s) {
        return true;
      }
      return x instanceof Map;
    } catch (e) {
    }
    return false;
  }
  function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== "object") {
      return false;
    }
    try {
      weakMapHas.call(x, weakMapHas);
      try {
        weakSetHas.call(x, weakSetHas);
      } catch (s) {
        return true;
      }
      return x instanceof WeakMap;
    } catch (e) {
    }
    return false;
  }
  function isWeakRef(x) {
    if (!weakRefDeref || !x || typeof x !== "object") {
      return false;
    }
    try {
      weakRefDeref.call(x);
      return true;
    } catch (e) {
    }
    return false;
  }
  function isSet(x) {
    if (!setSize || !x || typeof x !== "object") {
      return false;
    }
    try {
      setSize.call(x);
      try {
        mapSize.call(x);
      } catch (m2) {
        return true;
      }
      return x instanceof Set;
    } catch (e) {
    }
    return false;
  }
  function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== "object") {
      return false;
    }
    try {
      weakSetHas.call(x, weakSetHas);
      try {
        weakMapHas.call(x, weakMapHas);
      } catch (s) {
        return true;
      }
      return x instanceof WeakSet;
    } catch (e) {
    }
    return false;
  }
  function isElement(x) {
    if (!x || typeof x !== "object") {
      return false;
    }
    if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
      return true;
    }
    return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
  }
  function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
      var remaining = str.length - opts.maxStringLength;
      var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
      return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
    }
    var quoteRE = quoteREs[opts.quoteStyle || "single"];
    quoteRE.lastIndex = 0;
    var s = $replace.call($replace.call(str, quoteRE, "\\$1"), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, "single", opts);
  }
  function lowbyte(c2) {
    var n2 = c2.charCodeAt(0);
    var x = {
      8: "b",
      9: "t",
      10: "n",
      12: "f",
      13: "r"
    }[n2];
    if (x) {
      return "\\" + x;
    }
    return "\\x" + (n2 < 16 ? "0" : "") + $toUpperCase.call(n2.toString(16));
  }
  function markBoxed(str) {
    return "Object(" + str + ")";
  }
  function weakCollectionOf(type) {
    return type + " { ? }";
  }
  function collectionOf(type, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
    return type + " (" + size + ") {" + joinedEntries + "}";
  }
  function singleLineValues(xs) {
    for (var i = 0;i < xs.length; i++) {
      if (indexOf(xs[i], `
`) >= 0) {
        return false;
      }
    }
    return true;
  }
  function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === "\t") {
      baseIndent = "\t";
    } else if (typeof opts.indent === "number" && opts.indent > 0) {
      baseIndent = $join.call(Array(opts.indent + 1), " ");
    } else {
      return null;
    }
    return {
      base: baseIndent,
      prev: $join.call(Array(depth + 1), baseIndent)
    };
  }
  function indentedJoin(xs, indent) {
    if (xs.length === 0) {
      return "";
    }
    var lineJoiner = `
` + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, "," + lineJoiner) + `
` + indent.prev;
  }
  function arrObjKeys(obj, inspect) {
    var isArr = isArray(obj);
    var xs = [];
    if (isArr) {
      xs.length = obj.length;
      for (var i = 0;i < obj.length; i++) {
        xs[i] = has(obj, i) ? inspect(obj[i], obj) : "";
      }
    }
    var syms = typeof gOPS === "function" ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
      symMap = {};
      for (var k = 0;k < syms.length; k++) {
        symMap["$" + syms[k]] = syms[k];
      }
    }
    for (var key in obj) {
      if (!has(obj, key)) {
        continue;
      }
      if (isArr && String(Number(key)) === key && key < obj.length) {
        continue;
      }
      if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
        continue;
      } else if ($test.call(/[^\w$]/, key)) {
        xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
      } else {
        xs.push(key + ": " + inspect(obj[key], obj));
      }
    }
    if (typeof gOPS === "function") {
      for (var j = 0;j < syms.length; j++) {
        if (isEnumerable.call(obj, syms[j])) {
          xs.push("[" + inspect(syms[j]) + "]: " + inspect(obj[syms[j]], obj));
        }
      }
    }
    return xs;
  }
});

// node_modules/side-channel-list/index.js
var require_side_channel_list = __commonJS((exports, module) => {
  var inspect = require_object_inspect();
  var $TypeError = require_type();
  var listGetNode = function(list, key, isDelete) {
    var prev = list;
    var curr;
    for (;(curr = prev.next) != null; prev = curr) {
      if (curr.key === key) {
        prev.next = curr.next;
        if (!isDelete) {
          curr.next = list.next;
          list.next = curr;
        }
        return curr;
      }
    }
  };
  var listGet = function(objects, key) {
    if (!objects) {
      return;
    }
    var node = listGetNode(objects, key);
    return node && node.value;
  };
  var listSet = function(objects, key, value) {
    var node = listGetNode(objects, key);
    if (node) {
      node.value = value;
    } else {
      objects.next = {
        key,
        next: objects.next,
        value
      };
    }
  };
  var listHas = function(objects, key) {
    if (!objects) {
      return false;
    }
    return !!listGetNode(objects, key);
  };
  var listDelete = function(objects, key) {
    if (objects) {
      return listGetNode(objects, key, true);
    }
  };
  module.exports = function getSideChannelList() {
    var $o;
    var channel = {
      assert: function(key) {
        if (!channel.has(key)) {
          throw new $TypeError("Side channel does not contain " + inspect(key));
        }
      },
      delete: function(key) {
        var root = $o && $o.next;
        var deletedNode = listDelete($o, key);
        if (deletedNode && root && root === deletedNode) {
          $o = undefined;
        }
        return !!deletedNode;
      },
      get: function(key) {
        return listGet($o, key);
      },
      has: function(key) {
        return listHas($o, key);
      },
      set: function(key, value) {
        if (!$o) {
          $o = {
            next: undefined
          };
        }
        listSet($o, key, value);
      }
    };
    return channel;
  };
});

// node_modules/es-object-atoms/index.js
var require_es_object_atoms = __commonJS((exports, module) => {
  module.exports = Object;
});

// node_modules/es-errors/index.js
var require_es_errors = __commonJS((exports, module) => {
  module.exports = Error;
});

// node_modules/es-errors/eval.js
var require_eval = __commonJS((exports, module) => {
  module.exports = EvalError;
});

// node_modules/es-errors/range.js
var require_range = __commonJS((exports, module) => {
  module.exports = RangeError;
});

// node_modules/es-errors/ref.js
var require_ref = __commonJS((exports, module) => {
  module.exports = ReferenceError;
});

// node_modules/es-errors/syntax.js
var require_syntax = __commonJS((exports, module) => {
  module.exports = SyntaxError;
});

// node_modules/es-errors/uri.js
var require_uri = __commonJS((exports, module) => {
  module.exports = URIError;
});

// node_modules/math-intrinsics/abs.js
var require_abs = __commonJS((exports, module) => {
  module.exports = Math.abs;
});

// node_modules/math-intrinsics/floor.js
var require_floor = __commonJS((exports, module) => {
  module.exports = Math.floor;
});

// node_modules/math-intrinsics/max.js
var require_max = __commonJS((exports, module) => {
  module.exports = Math.max;
});

// node_modules/math-intrinsics/min.js
var require_min = __commonJS((exports, module) => {
  module.exports = Math.min;
});

// node_modules/math-intrinsics/pow.js
var require_pow = __commonJS((exports, module) => {
  module.exports = Math.pow;
});

// node_modules/gopd/gOPD.js
var require_gOPD = __commonJS((exports, module) => {
  module.exports = Object.getOwnPropertyDescriptor;
});

// node_modules/gopd/index.js
var require_gopd = __commonJS((exports, module) => {
  var $gOPD = require_gOPD();
  if ($gOPD) {
    try {
      $gOPD([], "length");
    } catch (e) {
      $gOPD = null;
    }
  }
  module.exports = $gOPD;
});

// node_modules/es-define-property/index.js
var require_es_define_property = __commonJS((exports, module) => {
  var $defineProperty = Object.defineProperty || false;
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
    } catch (e) {
      $defineProperty = false;
    }
  }
  module.exports = $defineProperty;
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS((exports, module) => {
  module.exports = function hasSymbols() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj[sym] = symVal;
    for (var _3 in obj) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS((exports, module) => {
  var origSymbol = typeof Symbol !== "undefined" && Symbol;
  var hasSymbolSham = require_shams();
  module.exports = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS((exports, module) => {
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var toStr = Object.prototype.toString;
  var max = Math.max;
  var funcType = "[object Function]";
  var concatty = function concatty(a13, b) {
    var arr = [];
    for (var i = 0;i < a13.length; i += 1) {
      arr[i] = a13[i];
    }
    for (var j = 0;j < b.length; j += 1) {
      arr[j + a13.length] = b[j];
    }
    return arr;
  };
  var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for (var i = offset || 0, j = 0;i < arrLike.length; i += 1, j += 1) {
      arr[j] = arrLike[i];
    }
    return arr;
  };
  var joiny = function(arr, joiner) {
    var str = "";
    for (var i = 0;i < arr.length; i += 1) {
      str += arr[i];
      if (i + 1 < arr.length) {
        str += joiner;
      }
    }
    return str;
  };
  module.exports = function bind(that) {
    var target = this;
    if (typeof target !== "function" || toStr.apply(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(this, concatty(args, arguments));
        if (Object(result) === result) {
          return result;
        }
        return this;
      }
      return target.apply(that, concatty(args, arguments));
    };
    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0;i < boundLength; i++) {
      boundArgs[i] = "$" + i;
    }
    bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty() {
      };
      Empty.prototype = target.prototype;
      bound.prototype = new Empty;
      Empty.prototype = null;
    }
    return bound;
  };
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS((exports, module) => {
  var implementation = require_implementation();
  module.exports = Function.prototype.bind || implementation;
});

// node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = __commonJS((exports, module) => {
  module.exports = Function.prototype.call;
});

// node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = __commonJS((exports, module) => {
  module.exports = Function.prototype.apply;
});

// node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = __commonJS((exports, module) => {
  module.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
});

// node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = __commonJS((exports, module) => {
  var bind = require_function_bind();
  var $apply = require_functionApply();
  var $call = require_functionCall();
  var $reflectApply = require_reflectApply();
  module.exports = $reflectApply || bind.call($call, $apply);
});

// node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = __commonJS((exports, module) => {
  var bind = require_function_bind();
  var $TypeError = require_type();
  var $call = require_functionCall();
  var $actualApply = require_actualApply();
  module.exports = function callBindBasic(args) {
    if (args.length < 1 || typeof args[0] !== "function") {
      throw new $TypeError("a function is required");
    }
    return $actualApply(bind, $call, args);
  };
});

// node_modules/dunder-proto/get.js
var require_get = __commonJS((exports, module) => {
  var callBind = require_call_bind_apply_helpers();
  var gOPD = require_gopd();
  var hasProtoAccessor;
  try {
    hasProtoAccessor = [].__proto__ === Array.prototype;
  } catch (e) {
    if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
      throw e;
    }
  }
  var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, "__proto__");
  var $Object = Object;
  var $getPrototypeOf = $Object.getPrototypeOf;
  module.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? function getDunder(value) {
    return $getPrototypeOf(value == null ? value : $Object(value));
  } : false;
});

// node_modules/hasown/index.js
var require_hasown = __commonJS((exports, module) => {
  var call = Function.prototype.call;
  var $hasOwn = Object.prototype.hasOwnProperty;
  var bind = require_function_bind();
  module.exports = bind.call(call, $hasOwn);
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS((exports, module) => {
  var undefined2;
  var $Object = require_es_object_atoms();
  var $Error = require_es_errors();
  var $EvalError = require_eval();
  var $RangeError = require_range();
  var $ReferenceError = require_ref();
  var $SyntaxError = require_syntax();
  var $TypeError = require_type();
  var $URIError = require_uri();
  var abs = require_abs();
  var floor = require_floor();
  var max = require_max();
  var min = require_min();
  var pow = require_pow();
  var $Function = Function;
  var getEvalledConstructor = function(expressionSyntax) {
    try {
      return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
    } catch (e) {
    }
  };
  var $gOPD = require_gopd();
  var $defineProperty = require_es_define_property();
  var throwTypeError = function() {
    throw new $TypeError;
  };
  var ThrowTypeError = $gOPD ? function() {
    try {
      arguments.callee;
      return throwTypeError;
    } catch (calleeThrows) {
      try {
        return $gOPD(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError;
      }
    }
  }() : throwTypeError;
  var hasSymbols = require_has_symbols()();
  var getDunderProto = require_get();
  var getProto = typeof Reflect === "function" && Reflect.getPrototypeOf || $Object.getPrototypeOf || getDunderProto;
  var $apply = require_functionApply();
  var $call = require_functionCall();
  var needsEval = {};
  var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
  var INTRINSICS = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
    "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
    "%AsyncFromSyncIteratorPrototype%": undefined2,
    "%AsyncFunction%": needsEval,
    "%AsyncGenerator%": needsEval,
    "%AsyncGeneratorFunction%": needsEval,
    "%AsyncIteratorPrototype%": needsEval,
    "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
    "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": $Error,
    "%eval%": eval,
    "%EvalError%": $EvalError,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
    "%Function%": $Function,
    "%GeneratorFunction%": needsEval,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
    "%JSON%": typeof JSON === "object" ? JSON : undefined2,
    "%Map%": typeof Map === "undefined" ? undefined2 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto(new Map()[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": $Object,
    "%Object.getOwnPropertyDescriptor%": $gOPD,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
    "%RangeError%": $RangeError,
    "%ReferenceError%": $ReferenceError,
    "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? undefined2 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto(new Set()[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
    "%Symbol%": hasSymbols ? Symbol : undefined2,
    "%SyntaxError%": $SyntaxError,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypeError%": $TypeError,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
    "%URIError%": $URIError,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
    "%Function.prototype.call%": $call,
    "%Function.prototype.apply%": $apply,
    "%Object.defineProperty%": $defineProperty,
    "%Math.abs%": abs,
    "%Math.floor%": floor,
    "%Math.max%": max,
    "%Math.min%": min,
    "%Math.pow%": pow
  };
  if (getProto) {
    try {
      null.error;
    } catch (e) {
      errorProto = getProto(getProto(e));
      INTRINSICS["%Error.prototype%"] = errorProto;
    }
  }
  var errorProto;
  var doEval = function doEval(name) {
    var value;
    if (name === "%AsyncFunction%") {
      value = getEvalledConstructor("async function () {}");
    } else if (name === "%GeneratorFunction%") {
      value = getEvalledConstructor("function* () {}");
    } else if (name === "%AsyncGeneratorFunction%") {
      value = getEvalledConstructor("async function* () {}");
    } else if (name === "%AsyncGenerator%") {
      var fn = doEval("%AsyncGeneratorFunction%");
      if (fn) {
        value = fn.prototype;
      }
    } else if (name === "%AsyncIteratorPrototype%") {
      var gen = doEval("%AsyncGenerator%");
      if (gen && getProto) {
        value = getProto(gen.prototype);
      }
    }
    INTRINSICS[name] = value;
    return value;
  };
  var LEGACY_ALIASES = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  };
  var bind = require_function_bind();
  var hasOwn = require_hasown();
  var $concat = bind.call($call, Array.prototype.concat);
  var $spliceApply = bind.call($apply, Array.prototype.splice);
  var $replace = bind.call($call, String.prototype.replace);
  var $strSlice = bind.call($call, String.prototype.slice);
  var $exec = bind.call($call, RegExp.prototype.exec);
  var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = function stringToPath(string) {
    var first = $strSlice(string, 0, 1);
    var last = $strSlice(string, -1);
    if (first === "%" && last !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
    } else if (last === "%" && first !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
    }
    var result = [];
    $replace(string, rePropName, function(match, number, quote, subString) {
      result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
    });
    return result;
  };
  var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
      alias = LEGACY_ALIASES[intrinsicName];
      intrinsicName = "%" + alias[0] + "%";
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
      var value = INTRINSICS[intrinsicName];
      if (value === needsEval) {
        value = doEval(intrinsicName);
      }
      if (typeof value === "undefined" && !allowMissing) {
        throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
      }
      return {
        alias,
        name: intrinsicName,
        value
      };
    }
    throw new $SyntaxError("intrinsic " + name + " does not exist!");
  };
  module.exports = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== "string" || name.length === 0) {
      throw new $TypeError("intrinsic name must be a non-empty string");
    }
    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
      throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name) === null) {
      throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    }
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
      intrinsicBaseName = alias[0];
      $spliceApply(parts, $concat([0, 1], alias));
    }
    for (var i = 1, isOwn = true;i < parts.length; i += 1) {
      var part = parts[i];
      var first = $strSlice(part, 0, 1);
      var last = $strSlice(part, -1);
      if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
        throw new $SyntaxError("property names with quotes must have matching quotes");
      }
      if (part === "constructor" || !isOwn) {
        skipFurtherCaching = true;
      }
      intrinsicBaseName += "." + part;
      intrinsicRealName = "%" + intrinsicBaseName + "%";
      if (hasOwn(INTRINSICS, intrinsicRealName)) {
        value = INTRINSICS[intrinsicRealName];
      } else if (value != null) {
        if (!(part in value)) {
          if (!allowMissing) {
            throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
          }
          return;
        }
        if ($gOPD && i + 1 >= parts.length) {
          var desc = $gOPD(value, part);
          isOwn = !!desc;
          if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
            value = desc.get;
          } else {
            value = value[part];
          }
        } else {
          isOwn = hasOwn(value, part);
          value = value[part];
        }
        if (isOwn && !skipFurtherCaching) {
          INTRINSICS[intrinsicRealName] = value;
        }
      }
    }
    return value;
  };
});

// node_modules/call-bound/index.js
var require_call_bound = __commonJS((exports, module) => {
  var GetIntrinsic = require_get_intrinsic();
  var callBindBasic = require_call_bind_apply_helpers();
  var $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
  module.exports = function callBoundIntrinsic(name, allowMissing) {
    var intrinsic = GetIntrinsic(name, !!allowMissing);
    if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
      return callBindBasic([intrinsic]);
    }
    return intrinsic;
  };
});

// node_modules/side-channel-map/index.js
var require_side_channel_map = __commonJS((exports, module) => {
  var GetIntrinsic = require_get_intrinsic();
  var callBound = require_call_bound();
  var inspect = require_object_inspect();
  var $TypeError = require_type();
  var $Map = GetIntrinsic("%Map%", true);
  var $mapGet = callBound("Map.prototype.get", true);
  var $mapSet = callBound("Map.prototype.set", true);
  var $mapHas = callBound("Map.prototype.has", true);
  var $mapDelete = callBound("Map.prototype.delete", true);
  var $mapSize = callBound("Map.prototype.size", true);
  module.exports = !!$Map && function getSideChannelMap() {
    var $m;
    var channel = {
      assert: function(key) {
        if (!channel.has(key)) {
          throw new $TypeError("Side channel does not contain " + inspect(key));
        }
      },
      delete: function(key) {
        if ($m) {
          var result = $mapDelete($m, key);
          if ($mapSize($m) === 0) {
            $m = undefined;
          }
          return result;
        }
        return false;
      },
      get: function(key) {
        if ($m) {
          return $mapGet($m, key);
        }
      },
      has: function(key) {
        if ($m) {
          return $mapHas($m, key);
        }
        return false;
      },
      set: function(key, value) {
        if (!$m) {
          $m = new $Map;
        }
        $mapSet($m, key, value);
      }
    };
    return channel;
  };
});

// node_modules/side-channel-weakmap/index.js
var require_side_channel_weakmap = __commonJS((exports, module) => {
  var GetIntrinsic = require_get_intrinsic();
  var callBound = require_call_bound();
  var inspect = require_object_inspect();
  var getSideChannelMap = require_side_channel_map();
  var $TypeError = require_type();
  var $WeakMap = GetIntrinsic("%WeakMap%", true);
  var $weakMapGet = callBound("WeakMap.prototype.get", true);
  var $weakMapSet = callBound("WeakMap.prototype.set", true);
  var $weakMapHas = callBound("WeakMap.prototype.has", true);
  var $weakMapDelete = callBound("WeakMap.prototype.delete", true);
  module.exports = $WeakMap ? function getSideChannelWeakMap() {
    var $wm;
    var $m;
    var channel = {
      assert: function(key) {
        if (!channel.has(key)) {
          throw new $TypeError("Side channel does not contain " + inspect(key));
        }
      },
      delete: function(key) {
        if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
          if ($wm) {
            return $weakMapDelete($wm, key);
          }
        } else if (getSideChannelMap) {
          if ($m) {
            return $m["delete"](key);
          }
        }
        return false;
      },
      get: function(key) {
        if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
          if ($wm) {
            return $weakMapGet($wm, key);
          }
        }
        return $m && $m.get(key);
      },
      has: function(key) {
        if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
          if ($wm) {
            return $weakMapHas($wm, key);
          }
        }
        return !!$m && $m.has(key);
      },
      set: function(key, value) {
        if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
          if (!$wm) {
            $wm = new $WeakMap;
          }
          $weakMapSet($wm, key, value);
        } else if (getSideChannelMap) {
          if (!$m) {
            $m = getSideChannelMap();
          }
          $m.set(key, value);
        }
      }
    };
    return channel;
  } : getSideChannelMap;
});

// node_modules/side-channel/index.js
var require_side_channel = __commonJS((exports, module) => {
  var $TypeError = require_type();
  var inspect = require_object_inspect();
  var getSideChannelList = require_side_channel_list();
  var getSideChannelMap = require_side_channel_map();
  var getSideChannelWeakMap = require_side_channel_weakmap();
  var makeChannel = getSideChannelWeakMap || getSideChannelMap || getSideChannelList;
  module.exports = function getSideChannel() {
    var $channelData;
    var channel = {
      assert: function(key) {
        if (!channel.has(key)) {
          throw new $TypeError("Side channel does not contain " + inspect(key));
        }
      },
      delete: function(key) {
        return !!$channelData && $channelData["delete"](key);
      },
      get: function(key) {
        return $channelData && $channelData.get(key);
      },
      has: function(key) {
        return !!$channelData && $channelData.has(key);
      },
      set: function(key, value) {
        if (!$channelData) {
          $channelData = makeChannel();
        }
        $channelData.set(key, value);
      }
    };
    return channel;
  };
});

// node_modules/qs/lib/formats.js
var require_formats = __commonJS((exports, module) => {
  var replace = String.prototype.replace;
  var percentTwenties = /%20/g;
  var Format3 = {
    RFC1738: "RFC1738",
    RFC3986: "RFC3986"
  };
  module.exports = {
    default: Format3.RFC3986,
    formatters: {
      RFC1738: function(value) {
        return replace.call(value, percentTwenties, "+");
      },
      RFC3986: function(value) {
        return String(value);
      }
    },
    RFC1738: Format3.RFC1738,
    RFC3986: Format3.RFC3986
  };
});

// node_modules/qs/lib/utils.js
var require_utils = __commonJS((exports, module) => {
  var formats = require_formats();
  var has = Object.prototype.hasOwnProperty;
  var isArray = Array.isArray;
  var hexTable = function() {
    var array = [];
    for (var i = 0;i < 256; ++i) {
      array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
    }
    return array;
  }();
  var compactQueue = function compactQueue(queue) {
    while (queue.length > 1) {
      var item = queue.pop();
      var obj = item.obj[item.prop];
      if (isArray(obj)) {
        var compacted = [];
        for (var j = 0;j < obj.length; ++j) {
          if (typeof obj[j] !== "undefined") {
            compacted.push(obj[j]);
          }
        }
        item.obj[item.prop] = compacted;
      }
    }
  };
  var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? { __proto__: null } : {};
    for (var i = 0;i < source.length; ++i) {
      if (typeof source[i] !== "undefined") {
        obj[i] = source[i];
      }
    }
    return obj;
  };
  var merge = function merge(target, source, options) {
    if (!source) {
      return target;
    }
    if (typeof source !== "object" && typeof source !== "function") {
      if (isArray(target)) {
        target.push(source);
      } else if (target && typeof target === "object") {
        if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
          target[source] = true;
        }
      } else {
        return [target, source];
      }
      return target;
    }
    if (!target || typeof target !== "object") {
      return [target].concat(source);
    }
    var mergeTarget = target;
    if (isArray(target) && !isArray(source)) {
      mergeTarget = arrayToObject(target, options);
    }
    if (isArray(target) && isArray(source)) {
      source.forEach(function(item, i) {
        if (has.call(target, i)) {
          var targetItem = target[i];
          if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
            target[i] = merge(targetItem, item, options);
          } else {
            target.push(item);
          }
        } else {
          target[i] = item;
        }
      });
      return target;
    }
    return Object.keys(source).reduce(function(acc, key) {
      var value = source[key];
      if (has.call(acc, key)) {
        acc[key] = merge(acc[key], value, options);
      } else {
        acc[key] = value;
      }
      return acc;
    }, mergeTarget);
  };
  var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function(acc, key) {
      acc[key] = source[key];
      return acc;
    }, target);
  };
  var decode4 = function(str, defaultDecoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, " ");
    if (charset === "iso-8859-1") {
      return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    try {
      return decodeURIComponent(strWithoutPlus);
    } catch (e) {
      return strWithoutPlus;
    }
  };
  var limit = 1024;
  var encode4 = function encode(str, defaultEncoder, charset, kind, format2) {
    if (str.length === 0) {
      return str;
    }
    var string = str;
    if (typeof str === "symbol") {
      string = Symbol.prototype.toString.call(str);
    } else if (typeof str !== "string") {
      string = String(str);
    }
    if (charset === "iso-8859-1") {
      return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
        return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
      });
    }
    var out = "";
    for (var j = 0;j < string.length; j += limit) {
      var segment = string.length >= limit ? string.slice(j, j + limit) : string;
      var arr = [];
      for (var i = 0;i < segment.length; ++i) {
        var c2 = segment.charCodeAt(i);
        if (c2 === 45 || c2 === 46 || c2 === 95 || c2 === 126 || c2 >= 48 && c2 <= 57 || c2 >= 65 && c2 <= 90 || c2 >= 97 && c2 <= 122 || format2 === formats.RFC1738 && (c2 === 40 || c2 === 41)) {
          arr[arr.length] = segment.charAt(i);
          continue;
        }
        if (c2 < 128) {
          arr[arr.length] = hexTable[c2];
          continue;
        }
        if (c2 < 2048) {
          arr[arr.length] = hexTable[192 | c2 >> 6] + hexTable[128 | c2 & 63];
          continue;
        }
        if (c2 < 55296 || c2 >= 57344) {
          arr[arr.length] = hexTable[224 | c2 >> 12] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63];
          continue;
        }
        i += 1;
        c2 = 65536 + ((c2 & 1023) << 10 | segment.charCodeAt(i) & 1023);
        arr[arr.length] = hexTable[240 | c2 >> 18] + hexTable[128 | c2 >> 12 & 63] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63];
      }
      out += arr.join("");
    }
    return out;
  };
  var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: "o" }];
    var refs = [];
    for (var i = 0;i < queue.length; ++i) {
      var item = queue[i];
      var obj = item.obj[item.prop];
      var keys = Object.keys(obj);
      for (var j = 0;j < keys.length; ++j) {
        var key = keys[j];
        var val = obj[key];
        if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
          queue.push({ obj, prop: key });
          refs.push(val);
        }
      }
    }
    compactQueue(queue);
    return value;
  };
  var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === "[object RegExp]";
  };
  var isBuffer = function isBuffer(obj) {
    if (!obj || typeof obj !== "object") {
      return false;
    }
    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
  };
  var combine = function combine(a13, b) {
    return [].concat(a13, b);
  };
  var maybeMap = function maybeMap(val, fn) {
    if (isArray(val)) {
      var mapped = [];
      for (var i = 0;i < val.length; i += 1) {
        mapped.push(fn(val[i]));
      }
      return mapped;
    }
    return fn(val);
  };
  module.exports = {
    arrayToObject,
    assign,
    combine,
    compact,
    decode: decode4,
    encode: encode4,
    isBuffer,
    isRegExp,
    maybeMap,
    merge
  };
});

// node_modules/qs/lib/stringify.js
var require_stringify = __commonJS((exports, module) => {
  var getSideChannel = require_side_channel();
  var utils = require_utils();
  var formats = require_formats();
  var has = Object.prototype.hasOwnProperty;
  var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
      return prefix + "[]";
    },
    comma: "comma",
    indices: function indices(prefix, key) {
      return prefix + "[" + key + "]";
    },
    repeat: function repeat(prefix) {
      return prefix;
    }
  };
  var isArray = Array.isArray;
  var push = Array.prototype.push;
  var pushToArray = function(arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
  };
  var toISO = Date.prototype.toISOString;
  var defaultFormat = formats["default"];
  var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    allowEmptyArrays: false,
    arrayFormat: "indices",
    charset: "utf-8",
    charsetSentinel: false,
    commaRoundTrip: false,
    delimiter: "&",
    encode: true,
    encodeDotInKeys: false,
    encoder: utils.encode,
    encodeValuesOnly: false,
    filter: undefined,
    format: defaultFormat,
    formatter: formats.formatters[defaultFormat],
    indices: false,
    serializeDate: function serializeDate(date3) {
      return toISO.call(date3);
    },
    skipNulls: false,
    strictNullHandling: false
  };
  var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
    return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
  };
  var sentinel = {};
  var stringify = function stringify(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder4, filter, sort, allowDots, serializeDate, format2, formatter, encodeValuesOnly, charset, sideChannel) {
    var obj = object;
    var tmpSc = sideChannel;
    var step = 0;
    var findFlag = false;
    while ((tmpSc = tmpSc.get(sentinel)) !== undefined && !findFlag) {
      var pos = tmpSc.get(object);
      step += 1;
      if (typeof pos !== "undefined") {
        if (pos === step) {
          throw new RangeError("Cyclic object value");
        } else {
          findFlag = true;
        }
      }
      if (typeof tmpSc.get(sentinel) === "undefined") {
        step = 0;
      }
    }
    if (typeof filter === "function") {
      obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
      obj = serializeDate(obj);
    } else if (generateArrayPrefix === "comma" && isArray(obj)) {
      obj = utils.maybeMap(obj, function(value2) {
        if (value2 instanceof Date) {
          return serializeDate(value2);
        }
        return value2;
      });
    }
    if (obj === null) {
      if (strictNullHandling) {
        return encoder4 && !encodeValuesOnly ? encoder4(prefix, defaults.encoder, charset, "key", format2) : prefix;
      }
      obj = "";
    }
    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
      if (encoder4) {
        var keyValue = encodeValuesOnly ? prefix : encoder4(prefix, defaults.encoder, charset, "key", format2);
        return [formatter(keyValue) + "=" + formatter(encoder4(obj, defaults.encoder, charset, "value", format2))];
      }
      return [formatter(prefix) + "=" + formatter(String(obj))];
    }
    var values = [];
    if (typeof obj === "undefined") {
      return values;
    }
    var objKeys;
    if (generateArrayPrefix === "comma" && isArray(obj)) {
      if (encodeValuesOnly && encoder4) {
        obj = utils.maybeMap(obj, encoder4);
      }
      objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : undefined }];
    } else if (isArray(filter)) {
      objKeys = filter;
    } else {
      var keys = Object.keys(obj);
      objKeys = sort ? keys.sort(sort) : keys;
    }
    var encodedPrefix = encodeDotInKeys ? String(prefix).replace(/\./g, "%2E") : String(prefix);
    var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encodedPrefix + "[]" : encodedPrefix;
    if (allowEmptyArrays && isArray(obj) && obj.length === 0) {
      return adjustedPrefix + "[]";
    }
    for (var j = 0;j < objKeys.length; ++j) {
      var key = objKeys[j];
      var value = typeof key === "object" && key && typeof key.value !== "undefined" ? key.value : obj[key];
      if (skipNulls && value === null) {
        continue;
      }
      var encodedKey = allowDots && encodeDotInKeys ? String(key).replace(/\./g, "%2E") : String(key);
      var keyPrefix = isArray(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + encodedKey : "[" + encodedKey + "]");
      sideChannel.set(object, step);
      var valueSideChannel = getSideChannel();
      valueSideChannel.set(sentinel, sideChannel);
      pushToArray(values, stringify(value, keyPrefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, generateArrayPrefix === "comma" && encodeValuesOnly && isArray(obj) ? null : encoder4, filter, sort, allowDots, serializeDate, format2, formatter, encodeValuesOnly, charset, valueSideChannel));
    }
    return values;
  };
  var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
    if (!opts) {
      return defaults;
    }
    if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
      throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
    }
    if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
      throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
    }
    if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
      throw new TypeError("Encoder has to be a function.");
    }
    var charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    }
    var format2 = formats["default"];
    if (typeof opts.format !== "undefined") {
      if (!has.call(formats.formatters, opts.format)) {
        throw new TypeError("Unknown format option provided.");
      }
      format2 = opts.format;
    }
    var formatter = formats.formatters[format2];
    var filter = defaults.filter;
    if (typeof opts.filter === "function" || isArray(opts.filter)) {
      filter = opts.filter;
    }
    var arrayFormat;
    if (opts.arrayFormat in arrayPrefixGenerators) {
      arrayFormat = opts.arrayFormat;
    } else if ("indices" in opts) {
      arrayFormat = opts.indices ? "indices" : "repeat";
    } else {
      arrayFormat = defaults.arrayFormat;
    }
    if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
      throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
    }
    var allowDots = typeof opts.allowDots === "undefined" ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
    return {
      addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
      allowDots,
      allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
      arrayFormat,
      charset,
      charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
      commaRoundTrip: !!opts.commaRoundTrip,
      delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
      encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
      encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
      encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
      encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
      filter,
      format: format2,
      formatter,
      serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
      skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
      sort: typeof opts.sort === "function" ? opts.sort : null,
      strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
    };
  };
  module.exports = function(object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);
    var objKeys;
    var filter;
    if (typeof options.filter === "function") {
      filter = options.filter;
      obj = filter("", obj);
    } else if (isArray(options.filter)) {
      filter = options.filter;
      objKeys = filter;
    }
    var keys = [];
    if (typeof obj !== "object" || obj === null) {
      return "";
    }
    var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
    var commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
    if (!objKeys) {
      objKeys = Object.keys(obj);
    }
    if (options.sort) {
      objKeys.sort(options.sort);
    }
    var sideChannel = getSideChannel();
    for (var i = 0;i < objKeys.length; ++i) {
      var key = objKeys[i];
      var value = obj[key];
      if (options.skipNulls && value === null) {
        continue;
      }
      pushToArray(keys, stringify(value, key, generateArrayPrefix, commaRoundTrip, options.allowEmptyArrays, options.strictNullHandling, options.skipNulls, options.encodeDotInKeys, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset, sideChannel));
    }
    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? "?" : "";
    if (options.charsetSentinel) {
      if (options.charset === "iso-8859-1") {
        prefix += "utf8=%26%2310003%3B&";
      } else {
        prefix += "utf8=%E2%9C%93&";
      }
    }
    return joined.length > 0 ? prefix + joined : "";
  };
});

// node_modules/qs/lib/parse.js
var require_parse2 = __commonJS((exports, module) => {
  var utils = require_utils();
  var has = Object.prototype.hasOwnProperty;
  var isArray = Array.isArray;
  var defaults = {
    allowDots: false,
    allowEmptyArrays: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: "utf-8",
    charsetSentinel: false,
    comma: false,
    decodeDotInKeys: false,
    decoder: utils.decode,
    delimiter: "&",
    depth: 5,
    duplicates: "combine",
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictDepth: false,
    strictNullHandling: false
  };
  var interpretNumericEntities = function(str) {
    return str.replace(/&#(\d+);/g, function($0, numberStr) {
      return String.fromCharCode(parseInt(numberStr, 10));
    });
  };
  var parseArrayValue = function(val, options) {
    if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
      return val.split(",");
    }
    return val;
  };
  var isoSentinel = "utf8=%26%2310003%3B";
  var charsetSentinel = "utf8=%E2%9C%93";
  var parseValues = function parseQueryStringValues(str, options) {
    var obj = { __proto__: null };
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
    cleanStr = cleanStr.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    var skipIndex = -1;
    var i;
    var charset = options.charset;
    if (options.charsetSentinel) {
      for (i = 0;i < parts.length; ++i) {
        if (parts[i].indexOf("utf8=") === 0) {
          if (parts[i] === charsetSentinel) {
            charset = "utf-8";
          } else if (parts[i] === isoSentinel) {
            charset = "iso-8859-1";
          }
          skipIndex = i;
          i = parts.length;
        }
      }
    }
    for (i = 0;i < parts.length; ++i) {
      if (i === skipIndex) {
        continue;
      }
      var part = parts[i];
      var bracketEqualsPos = part.indexOf("]=");
      var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
      var key;
      var val;
      if (pos === -1) {
        key = options.decoder(part, defaults.decoder, charset, "key");
        val = options.strictNullHandling ? null : "";
      } else {
        key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
        val = utils.maybeMap(parseArrayValue(part.slice(pos + 1), options), function(encodedVal) {
          return options.decoder(encodedVal, defaults.decoder, charset, "value");
        });
      }
      if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
        val = interpretNumericEntities(String(val));
      }
      if (part.indexOf("[]=") > -1) {
        val = isArray(val) ? [val] : val;
      }
      var existing = has.call(obj, key);
      if (existing && options.duplicates === "combine") {
        obj[key] = utils.combine(obj[key], val);
      } else if (!existing || options.duplicates === "last") {
        obj[key] = val;
      }
    }
    return obj;
  };
  var parseObject = function(chain, val, options, valuesParsed) {
    var leaf = valuesParsed ? val : parseArrayValue(val, options);
    for (var i = chain.length - 1;i >= 0; --i) {
      var obj;
      var root = chain[i];
      if (root === "[]" && options.parseArrays) {
        obj = options.allowEmptyArrays && (leaf === "" || options.strictNullHandling && leaf === null) ? [] : [].concat(leaf);
      } else {
        obj = options.plainObjects ? { __proto__: null } : {};
        var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
        var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, ".") : cleanRoot;
        var index = parseInt(decodedRoot, 10);
        if (!options.parseArrays && decodedRoot === "") {
          obj = { 0: leaf };
        } else if (!isNaN(index) && root !== decodedRoot && String(index) === decodedRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
          obj = [];
          obj[index] = leaf;
        } else if (decodedRoot !== "__proto__") {
          obj[decodedRoot] = leaf;
        }
      }
      leaf = obj;
    }
    return leaf;
  };
  var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
      return;
    }
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;
    var segment = options.depth > 0 && brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;
    var keys = [];
    if (parent) {
      if (!options.plainObjects && has.call(Object.prototype, parent)) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      keys.push(parent);
    }
    var i = 0;
    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
      i += 1;
      if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      keys.push(segment[1]);
    }
    if (segment) {
      if (options.strictDepth === true) {
        throw new RangeError("Input depth exceeded depth option of " + options.depth + " and strictDepth is true");
      }
      keys.push("[" + key.slice(segment.index) + "]");
    }
    return parseObject(keys, val, options, valuesParsed);
  };
  var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
      return defaults;
    }
    if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
      throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
    }
    if (typeof opts.decodeDotInKeys !== "undefined" && typeof opts.decodeDotInKeys !== "boolean") {
      throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
    }
    if (opts.decoder !== null && typeof opts.decoder !== "undefined" && typeof opts.decoder !== "function") {
      throw new TypeError("Decoder has to be a function.");
    }
    if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    }
    var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
    var duplicates = typeof opts.duplicates === "undefined" ? defaults.duplicates : opts.duplicates;
    if (duplicates !== "combine" && duplicates !== "first" && duplicates !== "last") {
      throw new TypeError("The duplicates option must be either combine, first, or last");
    }
    var allowDots = typeof opts.allowDots === "undefined" ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
    return {
      allowDots,
      allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
      allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
      allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
      arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
      charset,
      charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
      comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
      decodeDotInKeys: typeof opts.decodeDotInKeys === "boolean" ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
      decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
      delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
      depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
      duplicates,
      ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
      interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
      parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
      parseArrays: opts.parseArrays !== false,
      plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
      strictDepth: typeof opts.strictDepth === "boolean" ? !!opts.strictDepth : defaults.strictDepth,
      strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
    };
  };
  module.exports = function(str, opts) {
    var options = normalizeParseOptions(opts);
    if (str === "" || str === null || typeof str === "undefined") {
      return options.plainObjects ? { __proto__: null } : {};
    }
    var tempObj = typeof str === "string" ? parseValues(str, options) : str;
    var obj = options.plainObjects ? { __proto__: null } : {};
    var keys = Object.keys(tempObj);
    for (var i = 0;i < keys.length; ++i) {
      var key = keys[i];
      var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
      obj = utils.merge(obj, newObj, options);
    }
    if (options.allowSparse === true) {
      return obj;
    }
    return utils.compact(obj);
  };
});

// node_modules/qs/lib/index.js
var require_lib = __commonJS((exports, module) => {
  var stringify = require_stringify();
  var parse6 = require_parse2();
  var formats = require_formats();
  module.exports = {
    formats,
    parse: parse6,
    stringify
  };
});

// node_modules/.pnpm/memoirist@0.2.0/node_modules/memoirist/dist/bun/index.js
var U = (z, q) => {
  const v = q?.length ? {} : null;
  if (v)
    for (let K of q)
      v[K.part.charCodeAt(0)] = K;
  return { part: z, store: null, inert: v, params: null, wildcardStore: null };
};
var _ = (z, q) => ({ ...z, part: q });
var $ = (z) => ({ name: z, store: null, inert: null });

class Y {
  root = {};
  history = [];
  static regex = { static: /:.+?(?=\/|$)/, params: /:.+?(?=\/|$)/g, optionalParams: /:.+?\?(?=\/|$)/g };
  add(z, q, v, { ignoreError: K = false, ignoreHistory: V = false } = {}) {
    if (typeof q !== "string")
      throw new TypeError("Route path must be a string");
    if (q === "")
      q = "/";
    else if (q[0] !== "/")
      q = `/${q}`;
    const S = q[q.length - 1] === "*", D = q.match(Y.regex.optionalParams);
    if (D) {
      const F = q.replaceAll("?", "");
      this.add(z, F, v, { ignoreError: K });
      for (let B = 0;B < D.length; B++) {
        let A = q.replace("/" + D[B], "");
        this.add(z, A, v, { ignoreError: true });
      }
      return v;
    }
    if (D)
      q = q.replaceAll("?", "");
    if (this.history.find(([F, B, A]) => F === z && B === q))
      return v;
    if (S || D && q.charCodeAt(q.length - 1) === 63)
      q = q.slice(0, -1);
    if (!V)
      this.history.push([z, q, v]);
    const G = q.split(Y.regex.static), J = q.match(Y.regex.params) || [];
    if (G[G.length - 1] === "")
      G.pop();
    let b;
    if (!this.root[z])
      b = this.root[z] = U("/");
    else
      b = this.root[z];
    let Q = 0;
    for (let F = 0;F < G.length; ++F) {
      let B = G[F];
      if (F > 0) {
        const A = J[Q++].slice(1);
        if (b.params === null)
          b.params = $(A);
        else if (b.params.name !== A)
          if (K)
            return v;
          else
            throw new Error(`Cannot create route "${q}" with parameter "${A}" ` + "because a route already exists with a different parameter name " + `("${b.params.name}") in the same location`);
        const O = b.params;
        if (O.inert === null) {
          b = O.inert = U(B);
          continue;
        }
        b = O.inert;
      }
      for (let A = 0;; ) {
        if (A === B.length) {
          if (A < b.part.length) {
            const O = _(b, b.part.slice(A));
            Object.assign(b, U(B, [O]));
          }
          break;
        }
        if (A === b.part.length) {
          if (b.inert === null)
            b.inert = {};
          const O = b.inert[B.charCodeAt(A)];
          if (O) {
            b = O, B = B.slice(A), A = 0;
            continue;
          }
          const X = U(B.slice(A));
          b.inert[B.charCodeAt(A)] = X, b = X;
          break;
        }
        if (B[A] !== b.part[A]) {
          const O = _(b, b.part.slice(A)), X = U(B.slice(A));
          Object.assign(b, U(b.part.slice(0, A), [O, X])), b = X;
          break;
        }
        ++A;
      }
    }
    if (Q < J.length) {
      const B = J[Q].slice(1);
      if (b.params === null)
        b.params = $(B);
      else if (b.params.name !== B)
        if (K)
          return v;
        else
          throw new Error(`Cannot create route "${q}" with parameter "${B}" ` + "because a route already exists with a different parameter name " + `("${b.params.name}") in the same location`);
      if (b.params.store === null)
        b.params.store = v;
      return b.params.store;
    }
    if (S) {
      if (b.wildcardStore === null)
        b.wildcardStore = v;
      return b.wildcardStore;
    }
    if (b.store === null)
      b.store = v;
    return b.store;
  }
  find(z, q) {
    const v = this.root[z];
    if (!v)
      return null;
    return Z(q, q.length, v, 0);
  }
}
var Z = (z, q, v, K) => {
  const V = v.part, S = V.length, D = K + S;
  if (S > 1) {
    if (D > q)
      return null;
    if (S < 15) {
      for (let G = 1, J = K + 1;G < S; ++G, ++J)
        if (V.charCodeAt(G) !== z.charCodeAt(J))
          return null;
    } else if (z.slice(K, D) !== V)
      return null;
  }
  if (D === q) {
    if (v.store !== null)
      return { store: v.store, params: {} };
    if (v.wildcardStore !== null)
      return { store: v.wildcardStore, params: { "*": "" } };
    return null;
  }
  if (v.inert !== null) {
    const G = v.inert[z.charCodeAt(D)];
    if (G !== undefined) {
      const J = Z(z, q, G, D);
      if (J !== null)
        return J;
    }
  }
  if (v.params !== null) {
    const { store: G, name: J, inert: b } = v.params, Q = z.indexOf("/", D);
    if (Q !== D) {
      if (Q === -1 || Q >= q) {
        if (G !== null) {
          const F = {};
          return F[J] = z.substring(D, q), { store: G, params: F };
        }
      } else if (b !== null) {
        const F = Z(z, q, b, Q);
        if (F !== null)
          return F.params[J] = z.substring(D, Q), F;
      }
    }
  }
  if (v.wildcardStore !== null)
    return { store: v.wildcardStore, params: { "*": z.substring(D, q) } };
  return null;
};

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/guard/value.mjs
var exports_value = {};
__export(exports_value, {
  IsUndefined: () => IsUndefined,
  IsUint8Array: () => IsUint8Array,
  IsSymbol: () => IsSymbol,
  IsString: () => IsString,
  IsRegExp: () => IsRegExp,
  IsObject: () => IsObject,
  IsNumber: () => IsNumber,
  IsNull: () => IsNull,
  IsIterator: () => IsIterator,
  IsFunction: () => IsFunction,
  IsDate: () => IsDate,
  IsBoolean: () => IsBoolean,
  IsBigInt: () => IsBigInt,
  IsAsyncIterator: () => IsAsyncIterator,
  IsArray: () => IsArray,
  HasPropertyKey: () => HasPropertyKey
});
function HasPropertyKey(value, key) {
  return key in value;
}
function IsAsyncIterator(value) {
  return IsObject(value) && !IsArray(value) && !IsUint8Array(value) && Symbol.asyncIterator in value;
}
function IsArray(value) {
  return Array.isArray(value);
}
function IsBigInt(value) {
  return typeof value === "bigint";
}
function IsBoolean(value) {
  return typeof value === "boolean";
}
function IsDate(value) {
  return value instanceof globalThis.Date;
}
function IsFunction(value) {
  return typeof value === "function";
}
function IsIterator(value) {
  return IsObject(value) && !IsArray(value) && !IsUint8Array(value) && Symbol.iterator in value;
}
function IsNull(value) {
  return value === null;
}
function IsNumber(value) {
  return typeof value === "number";
}
function IsObject(value) {
  return typeof value === "object" && value !== null;
}
function IsRegExp(value) {
  return value instanceof globalThis.RegExp;
}
function IsString(value) {
  return typeof value === "string";
}
function IsSymbol(value) {
  return typeof value === "symbol";
}
function IsUint8Array(value) {
  return value instanceof globalThis.Uint8Array;
}
function IsUndefined(value) {
  return value === undefined;
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/clone/value.mjs
function ArrayType(value) {
  return value.map((value2) => Visit(value2));
}
function DateType(value) {
  return new Date(value.getTime());
}
function Uint8ArrayType(value) {
  return new Uint8Array(value);
}
function RegExpType(value) {
  return new RegExp(value.source, value.flags);
}
function ObjectType(value) {
  const result = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    result[key] = Visit(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    result[key] = Visit(value[key]);
  }
  return result;
}
function Visit(value) {
  return IsArray(value) ? ArrayType(value) : IsDate(value) ? DateType(value) : IsUint8Array(value) ? Uint8ArrayType(value) : IsRegExp(value) ? RegExpType(value) : IsObject(value) ? ObjectType(value) : value;
}
function Clone(value) {
  return Visit(value);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/clone/type.mjs
function CloneType(schema, options) {
  return options === undefined ? Clone(schema) : Clone({ ...options, ...schema });
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/value/guard/guard.mjs
function IsAsyncIterator2(value) {
  return IsObject2(value) && Symbol.asyncIterator in value;
}
function IsIterator2(value) {
  return IsObject2(value) && Symbol.iterator in value;
}
function IsStandardObject(value) {
  return IsObject2(value) && (Object.getPrototypeOf(value) === Object.prototype || Object.getPrototypeOf(value) === null);
}
function IsPromise(value) {
  return value instanceof Promise;
}
function IsDate2(value) {
  return value instanceof Date && Number.isFinite(value.getTime());
}
function IsMap(value) {
  return value instanceof globalThis.Map;
}
function IsSet(value) {
  return value instanceof globalThis.Set;
}
function IsTypedArray(value) {
  return ArrayBuffer.isView(value);
}
function IsUint8Array2(value) {
  return value instanceof globalThis.Uint8Array;
}
function HasPropertyKey2(value, key) {
  return key in value;
}
function IsObject2(value) {
  return value !== null && typeof value === "object";
}
function IsArray2(value) {
  return Array.isArray(value) && !ArrayBuffer.isView(value);
}
function IsUndefined2(value) {
  return value === undefined;
}
function IsNull2(value) {
  return value === null;
}
function IsBoolean2(value) {
  return typeof value === "boolean";
}
function IsNumber2(value) {
  return typeof value === "number";
}
function IsInteger(value) {
  return Number.isInteger(value);
}
function IsBigInt2(value) {
  return typeof value === "bigint";
}
function IsString2(value) {
  return typeof value === "string";
}
function IsFunction2(value) {
  return typeof value === "function";
}
function IsSymbol2(value) {
  return typeof value === "symbol";
}
function IsValueType(value) {
  return IsBigInt2(value) || IsBoolean2(value) || IsNull2(value) || IsNumber2(value) || IsString2(value) || IsSymbol2(value) || IsUndefined2(value);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/system/policy.mjs
var TypeSystemPolicy;
(function(TypeSystemPolicy2) {
  TypeSystemPolicy2.InstanceMode = "default";
  TypeSystemPolicy2.ExactOptionalPropertyTypes = false;
  TypeSystemPolicy2.AllowArrayObject = false;
  TypeSystemPolicy2.AllowNaN = false;
  TypeSystemPolicy2.AllowNullVoid = false;
  function IsExactOptionalProperty(value, key) {
    return TypeSystemPolicy2.ExactOptionalPropertyTypes ? key in value : value[key] !== undefined;
  }
  TypeSystemPolicy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value) {
    const isObject = IsObject2(value);
    return TypeSystemPolicy2.AllowArrayObject ? isObject : isObject && !IsArray2(value);
  }
  TypeSystemPolicy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value) {
    return IsObjectLike(value) && !(value instanceof Date) && !(value instanceof Uint8Array);
  }
  TypeSystemPolicy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value) {
    return TypeSystemPolicy2.AllowNaN ? IsNumber2(value) : Number.isFinite(value);
  }
  TypeSystemPolicy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value) {
    const isUndefined = IsUndefined2(value);
    return TypeSystemPolicy2.AllowNullVoid ? isUndefined || value === null : isUndefined;
  }
  TypeSystemPolicy2.IsVoidLike = IsVoidLike;
})(TypeSystemPolicy || (TypeSystemPolicy = {}));

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/create/immutable.mjs
function ImmutableArray(value) {
  return globalThis.Object.freeze(value).map((value2) => Immutable(value2));
}
function ImmutableDate(value) {
  return value;
}
function ImmutableUint8Array(value) {
  return value;
}
function ImmutableRegExp(value) {
  return value;
}
function ImmutableObject(value) {
  const result = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    result[key] = Immutable(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    result[key] = Immutable(value[key]);
  }
  return globalThis.Object.freeze(result);
}
function Immutable(value) {
  return IsArray(value) ? ImmutableArray(value) : IsDate(value) ? ImmutableDate(value) : IsUint8Array(value) ? ImmutableUint8Array(value) : IsRegExp(value) ? ImmutableRegExp(value) : IsObject(value) ? ImmutableObject(value) : value;
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/create/type.mjs
function CreateType(schema, options) {
  const result = options !== undefined ? { ...options, ...schema } : schema;
  switch (TypeSystemPolicy.InstanceMode) {
    case "freeze":
      return Immutable(result);
    case "clone":
      return Clone(result);
    default:
      return result;
  }
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/error/error.mjs
class TypeBoxError extends Error {
  constructor(message) {
    super(message);
  }
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/symbols/symbols.mjs
var TransformKind = Symbol.for("TypeBox.Transform");
var ReadonlyKind = Symbol.for("TypeBox.Readonly");
var OptionalKind = Symbol.for("TypeBox.Optional");
var Hint = Symbol.for("TypeBox.Hint");
var Kind = Symbol.for("TypeBox.Kind");

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/guard/kind.mjs
function IsReadonly(value) {
  return IsObject(value) && value[ReadonlyKind] === "Readonly";
}
function IsOptional(value) {
  return IsObject(value) && value[OptionalKind] === "Optional";
}
function IsAny(value) {
  return IsKindOf(value, "Any");
}
function IsArray3(value) {
  return IsKindOf(value, "Array");
}
function IsAsyncIterator3(value) {
  return IsKindOf(value, "AsyncIterator");
}
function IsBigInt3(value) {
  return IsKindOf(value, "BigInt");
}
function IsBoolean3(value) {
  return IsKindOf(value, "Boolean");
}
function IsComputed(value) {
  return IsKindOf(value, "Computed");
}
function IsConstructor(value) {
  return IsKindOf(value, "Constructor");
}
function IsDate3(value) {
  return IsKindOf(value, "Date");
}
function IsFunction3(value) {
  return IsKindOf(value, "Function");
}
function IsInteger2(value) {
  return IsKindOf(value, "Integer");
}
function IsIntersect(value) {
  return IsKindOf(value, "Intersect");
}
function IsIterator3(value) {
  return IsKindOf(value, "Iterator");
}
function IsKindOf(value, kind) {
  return IsObject(value) && Kind in value && value[Kind] === kind;
}
function IsLiteralValue(value) {
  return IsBoolean(value) || IsNumber(value) || IsString(value);
}
function IsLiteral(value) {
  return IsKindOf(value, "Literal");
}
function IsMappedKey(value) {
  return IsKindOf(value, "MappedKey");
}
function IsMappedResult(value) {
  return IsKindOf(value, "MappedResult");
}
function IsNever(value) {
  return IsKindOf(value, "Never");
}
function IsNot(value) {
  return IsKindOf(value, "Not");
}
function IsNull3(value) {
  return IsKindOf(value, "Null");
}
function IsNumber3(value) {
  return IsKindOf(value, "Number");
}
function IsObject3(value) {
  return IsKindOf(value, "Object");
}
function IsPromise2(value) {
  return IsKindOf(value, "Promise");
}
function IsRecord(value) {
  return IsKindOf(value, "Record");
}
function IsRef(value) {
  return IsKindOf(value, "Ref");
}
function IsRegExp2(value) {
  return IsKindOf(value, "RegExp");
}
function IsString3(value) {
  return IsKindOf(value, "String");
}
function IsSymbol3(value) {
  return IsKindOf(value, "Symbol");
}
function IsTemplateLiteral(value) {
  return IsKindOf(value, "TemplateLiteral");
}
function IsThis(value) {
  return IsKindOf(value, "This");
}
function IsTransform(value) {
  return IsObject(value) && TransformKind in value;
}
function IsTuple(value) {
  return IsKindOf(value, "Tuple");
}
function IsUndefined3(value) {
  return IsKindOf(value, "Undefined");
}
function IsUnion(value) {
  return IsKindOf(value, "Union");
}
function IsUint8Array3(value) {
  return IsKindOf(value, "Uint8Array");
}
function IsUnknown(value) {
  return IsKindOf(value, "Unknown");
}
function IsUnsafe(value) {
  return IsKindOf(value, "Unsafe");
}
function IsVoid(value) {
  return IsKindOf(value, "Void");
}
function IsKind(value) {
  return IsObject(value) && Kind in value && IsString(value[Kind]);
}
function IsSchema(value) {
  return IsAny(value) || IsArray3(value) || IsBoolean3(value) || IsBigInt3(value) || IsAsyncIterator3(value) || IsComputed(value) || IsConstructor(value) || IsDate3(value) || IsFunction3(value) || IsInteger2(value) || IsIntersect(value) || IsIterator3(value) || IsLiteral(value) || IsMappedKey(value) || IsMappedResult(value) || IsNever(value) || IsNot(value) || IsNull3(value) || IsNumber3(value) || IsObject3(value) || IsPromise2(value) || IsRecord(value) || IsRef(value) || IsRegExp2(value) || IsString3(value) || IsSymbol3(value) || IsTemplateLiteral(value) || IsThis(value) || IsTuple(value) || IsUndefined3(value) || IsUnion(value) || IsUint8Array3(value) || IsUnknown(value) || IsUnsafe(value) || IsVoid(value) || IsKind(value);
}
// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/guard/type.mjs
var exports_type = {};
__export(exports_type, {
  TypeGuardUnknownTypeError: () => TypeGuardUnknownTypeError,
  IsVoid: () => IsVoid2,
  IsUnsafe: () => IsUnsafe2,
  IsUnknown: () => IsUnknown2,
  IsUnionLiteral: () => IsUnionLiteral,
  IsUnion: () => IsUnion2,
  IsUndefined: () => IsUndefined4,
  IsUint8Array: () => IsUint8Array4,
  IsTuple: () => IsTuple2,
  IsTransform: () => IsTransform2,
  IsThis: () => IsThis2,
  IsTemplateLiteral: () => IsTemplateLiteral2,
  IsSymbol: () => IsSymbol4,
  IsString: () => IsString4,
  IsSchema: () => IsSchema2,
  IsRegExp: () => IsRegExp3,
  IsRef: () => IsRef2,
  IsRecursive: () => IsRecursive,
  IsRecord: () => IsRecord2,
  IsReadonly: () => IsReadonly2,
  IsProperties: () => IsProperties,
  IsPromise: () => IsPromise3,
  IsOptional: () => IsOptional2,
  IsObject: () => IsObject4,
  IsNumber: () => IsNumber4,
  IsNull: () => IsNull4,
  IsNot: () => IsNot2,
  IsNever: () => IsNever2,
  IsMappedResult: () => IsMappedResult2,
  IsMappedKey: () => IsMappedKey2,
  IsLiteralValue: () => IsLiteralValue2,
  IsLiteralString: () => IsLiteralString,
  IsLiteralNumber: () => IsLiteralNumber,
  IsLiteralBoolean: () => IsLiteralBoolean,
  IsLiteral: () => IsLiteral2,
  IsKindOf: () => IsKindOf2,
  IsKind: () => IsKind2,
  IsIterator: () => IsIterator4,
  IsIntersect: () => IsIntersect2,
  IsInteger: () => IsInteger3,
  IsImport: () => IsImport,
  IsFunction: () => IsFunction4,
  IsDate: () => IsDate4,
  IsConstructor: () => IsConstructor2,
  IsComputed: () => IsComputed2,
  IsBoolean: () => IsBoolean4,
  IsBigInt: () => IsBigInt4,
  IsAsyncIterator: () => IsAsyncIterator4,
  IsArray: () => IsArray4,
  IsAny: () => IsAny2
});
class TypeGuardUnknownTypeError extends TypeBoxError {
}
var KnownTypes = [
  "Any",
  "Array",
  "AsyncIterator",
  "BigInt",
  "Boolean",
  "Computed",
  "Constructor",
  "Date",
  "Enum",
  "Function",
  "Integer",
  "Intersect",
  "Iterator",
  "Literal",
  "MappedKey",
  "MappedResult",
  "Not",
  "Null",
  "Number",
  "Object",
  "Promise",
  "Record",
  "Ref",
  "RegExp",
  "String",
  "Symbol",
  "TemplateLiteral",
  "This",
  "Tuple",
  "Undefined",
  "Union",
  "Uint8Array",
  "Unknown",
  "Void"
];
function IsPattern(value) {
  try {
    new RegExp(value);
    return true;
  } catch {
    return false;
  }
}
function IsControlCharacterFree(value) {
  if (!IsString(value))
    return false;
  for (let i = 0;i < value.length; i++) {
    const code = value.charCodeAt(i);
    if (code >= 7 && code <= 13 || code === 27 || code === 127) {
      return false;
    }
  }
  return true;
}
function IsAdditionalProperties(value) {
  return IsOptionalBoolean(value) || IsSchema2(value);
}
function IsOptionalBigInt(value) {
  return IsUndefined(value) || IsBigInt(value);
}
function IsOptionalNumber(value) {
  return IsUndefined(value) || IsNumber(value);
}
function IsOptionalBoolean(value) {
  return IsUndefined(value) || IsBoolean(value);
}
function IsOptionalString(value) {
  return IsUndefined(value) || IsString(value);
}
function IsOptionalPattern(value) {
  return IsUndefined(value) || IsString(value) && IsControlCharacterFree(value) && IsPattern(value);
}
function IsOptionalFormat(value) {
  return IsUndefined(value) || IsString(value) && IsControlCharacterFree(value);
}
function IsOptionalSchema(value) {
  return IsUndefined(value) || IsSchema2(value);
}
function IsReadonly2(value) {
  return IsObject(value) && value[ReadonlyKind] === "Readonly";
}
function IsOptional2(value) {
  return IsObject(value) && value[OptionalKind] === "Optional";
}
function IsAny2(value) {
  return IsKindOf2(value, "Any") && IsOptionalString(value.$id);
}
function IsArray4(value) {
  return IsKindOf2(value, "Array") && value.type === "array" && IsOptionalString(value.$id) && IsSchema2(value.items) && IsOptionalNumber(value.minItems) && IsOptionalNumber(value.maxItems) && IsOptionalBoolean(value.uniqueItems) && IsOptionalSchema(value.contains) && IsOptionalNumber(value.minContains) && IsOptionalNumber(value.maxContains);
}
function IsAsyncIterator4(value) {
  return IsKindOf2(value, "AsyncIterator") && value.type === "AsyncIterator" && IsOptionalString(value.$id) && IsSchema2(value.items);
}
function IsBigInt4(value) {
  return IsKindOf2(value, "BigInt") && value.type === "bigint" && IsOptionalString(value.$id) && IsOptionalBigInt(value.exclusiveMaximum) && IsOptionalBigInt(value.exclusiveMinimum) && IsOptionalBigInt(value.maximum) && IsOptionalBigInt(value.minimum) && IsOptionalBigInt(value.multipleOf);
}
function IsBoolean4(value) {
  return IsKindOf2(value, "Boolean") && value.type === "boolean" && IsOptionalString(value.$id);
}
function IsComputed2(value) {
  return IsKindOf2(value, "Computed") && IsString(value.target) && IsArray(value.parameters) && value.parameters.every((schema) => IsSchema2(schema));
}
function IsConstructor2(value) {
  return IsKindOf2(value, "Constructor") && value.type === "Constructor" && IsOptionalString(value.$id) && IsArray(value.parameters) && value.parameters.every((schema) => IsSchema2(schema)) && IsSchema2(value.returns);
}
function IsDate4(value) {
  return IsKindOf2(value, "Date") && value.type === "Date" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximumTimestamp) && IsOptionalNumber(value.exclusiveMinimumTimestamp) && IsOptionalNumber(value.maximumTimestamp) && IsOptionalNumber(value.minimumTimestamp) && IsOptionalNumber(value.multipleOfTimestamp);
}
function IsFunction4(value) {
  return IsKindOf2(value, "Function") && value.type === "Function" && IsOptionalString(value.$id) && IsArray(value.parameters) && value.parameters.every((schema) => IsSchema2(schema)) && IsSchema2(value.returns);
}
function IsImport(value) {
  return IsKindOf2(value, "Import") && HasPropertyKey(value, "$defs") && IsObject(value.$defs) && IsProperties(value.$defs) && HasPropertyKey(value, "$ref") && IsString(value.$ref) && value.$ref in value.$defs;
}
function IsInteger3(value) {
  return IsKindOf2(value, "Integer") && value.type === "integer" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximum) && IsOptionalNumber(value.exclusiveMinimum) && IsOptionalNumber(value.maximum) && IsOptionalNumber(value.minimum) && IsOptionalNumber(value.multipleOf);
}
function IsProperties(value) {
  return IsObject(value) && Object.entries(value).every(([key, schema]) => IsControlCharacterFree(key) && IsSchema2(schema));
}
function IsIntersect2(value) {
  return IsKindOf2(value, "Intersect") && (IsString(value.type) && value.type !== "object" ? false : true) && IsArray(value.allOf) && value.allOf.every((schema) => IsSchema2(schema) && !IsTransform2(schema)) && IsOptionalString(value.type) && (IsOptionalBoolean(value.unevaluatedProperties) || IsOptionalSchema(value.unevaluatedProperties)) && IsOptionalString(value.$id);
}
function IsIterator4(value) {
  return IsKindOf2(value, "Iterator") && value.type === "Iterator" && IsOptionalString(value.$id) && IsSchema2(value.items);
}
function IsKindOf2(value, kind) {
  return IsObject(value) && Kind in value && value[Kind] === kind;
}
function IsLiteralString(value) {
  return IsLiteral2(value) && IsString(value.const);
}
function IsLiteralNumber(value) {
  return IsLiteral2(value) && IsNumber(value.const);
}
function IsLiteralBoolean(value) {
  return IsLiteral2(value) && IsBoolean(value.const);
}
function IsLiteral2(value) {
  return IsKindOf2(value, "Literal") && IsOptionalString(value.$id) && IsLiteralValue2(value.const);
}
function IsLiteralValue2(value) {
  return IsBoolean(value) || IsNumber(value) || IsString(value);
}
function IsMappedKey2(value) {
  return IsKindOf2(value, "MappedKey") && IsArray(value.keys) && value.keys.every((key) => IsNumber(key) || IsString(key));
}
function IsMappedResult2(value) {
  return IsKindOf2(value, "MappedResult") && IsProperties(value.properties);
}
function IsNever2(value) {
  return IsKindOf2(value, "Never") && IsObject(value.not) && Object.getOwnPropertyNames(value.not).length === 0;
}
function IsNot2(value) {
  return IsKindOf2(value, "Not") && IsSchema2(value.not);
}
function IsNull4(value) {
  return IsKindOf2(value, "Null") && value.type === "null" && IsOptionalString(value.$id);
}
function IsNumber4(value) {
  return IsKindOf2(value, "Number") && value.type === "number" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximum) && IsOptionalNumber(value.exclusiveMinimum) && IsOptionalNumber(value.maximum) && IsOptionalNumber(value.minimum) && IsOptionalNumber(value.multipleOf);
}
function IsObject4(value) {
  return IsKindOf2(value, "Object") && value.type === "object" && IsOptionalString(value.$id) && IsProperties(value.properties) && IsAdditionalProperties(value.additionalProperties) && IsOptionalNumber(value.minProperties) && IsOptionalNumber(value.maxProperties);
}
function IsPromise3(value) {
  return IsKindOf2(value, "Promise") && value.type === "Promise" && IsOptionalString(value.$id) && IsSchema2(value.item);
}
function IsRecord2(value) {
  return IsKindOf2(value, "Record") && value.type === "object" && IsOptionalString(value.$id) && IsAdditionalProperties(value.additionalProperties) && IsObject(value.patternProperties) && ((schema) => {
    const keys = Object.getOwnPropertyNames(schema.patternProperties);
    return keys.length === 1 && IsPattern(keys[0]) && IsObject(schema.patternProperties) && IsSchema2(schema.patternProperties[keys[0]]);
  })(value);
}
function IsRecursive(value) {
  return IsObject(value) && Hint in value && value[Hint] === "Recursive";
}
function IsRef2(value) {
  return IsKindOf2(value, "Ref") && IsOptionalString(value.$id) && IsString(value.$ref);
}
function IsRegExp3(value) {
  return IsKindOf2(value, "RegExp") && IsOptionalString(value.$id) && IsString(value.source) && IsString(value.flags) && IsOptionalNumber(value.maxLength) && IsOptionalNumber(value.minLength);
}
function IsString4(value) {
  return IsKindOf2(value, "String") && value.type === "string" && IsOptionalString(value.$id) && IsOptionalNumber(value.minLength) && IsOptionalNumber(value.maxLength) && IsOptionalPattern(value.pattern) && IsOptionalFormat(value.format);
}
function IsSymbol4(value) {
  return IsKindOf2(value, "Symbol") && value.type === "symbol" && IsOptionalString(value.$id);
}
function IsTemplateLiteral2(value) {
  return IsKindOf2(value, "TemplateLiteral") && value.type === "string" && IsString(value.pattern) && value.pattern[0] === "^" && value.pattern[value.pattern.length - 1] === "$";
}
function IsThis2(value) {
  return IsKindOf2(value, "This") && IsOptionalString(value.$id) && IsString(value.$ref);
}
function IsTransform2(value) {
  return IsObject(value) && TransformKind in value;
}
function IsTuple2(value) {
  return IsKindOf2(value, "Tuple") && value.type === "array" && IsOptionalString(value.$id) && IsNumber(value.minItems) && IsNumber(value.maxItems) && value.minItems === value.maxItems && (IsUndefined(value.items) && IsUndefined(value.additionalItems) && value.minItems === 0 || IsArray(value.items) && value.items.every((schema) => IsSchema2(schema)));
}
function IsUndefined4(value) {
  return IsKindOf2(value, "Undefined") && value.type === "undefined" && IsOptionalString(value.$id);
}
function IsUnionLiteral(value) {
  return IsUnion2(value) && value.anyOf.every((schema) => IsLiteralString(schema) || IsLiteralNumber(schema));
}
function IsUnion2(value) {
  return IsKindOf2(value, "Union") && IsOptionalString(value.$id) && IsObject(value) && IsArray(value.anyOf) && value.anyOf.every((schema) => IsSchema2(schema));
}
function IsUint8Array4(value) {
  return IsKindOf2(value, "Uint8Array") && value.type === "Uint8Array" && IsOptionalString(value.$id) && IsOptionalNumber(value.minByteLength) && IsOptionalNumber(value.maxByteLength);
}
function IsUnknown2(value) {
  return IsKindOf2(value, "Unknown") && IsOptionalString(value.$id);
}
function IsUnsafe2(value) {
  return IsKindOf2(value, "Unsafe");
}
function IsVoid2(value) {
  return IsKindOf2(value, "Void") && value.type === "void" && IsOptionalString(value.$id);
}
function IsKind2(value) {
  return IsObject(value) && Kind in value && IsString(value[Kind]) && !KnownTypes.includes(value[Kind]);
}
function IsSchema2(value) {
  return IsObject(value) && (IsAny2(value) || IsArray4(value) || IsBoolean4(value) || IsBigInt4(value) || IsAsyncIterator4(value) || IsComputed2(value) || IsConstructor2(value) || IsDate4(value) || IsFunction4(value) || IsInteger3(value) || IsIntersect2(value) || IsIterator4(value) || IsLiteral2(value) || IsMappedKey2(value) || IsMappedResult2(value) || IsNever2(value) || IsNot2(value) || IsNull4(value) || IsNumber4(value) || IsObject4(value) || IsPromise3(value) || IsRecord2(value) || IsRef2(value) || IsRegExp3(value) || IsString4(value) || IsSymbol4(value) || IsTemplateLiteral2(value) || IsThis2(value) || IsTuple2(value) || IsUndefined4(value) || IsUnion2(value) || IsUint8Array4(value) || IsUnknown2(value) || IsUnsafe2(value) || IsVoid2(value) || IsKind2(value));
}
// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/patterns/patterns.mjs
var PatternBoolean = "(true|false)";
var PatternNumber = "(0|[1-9][0-9]*)";
var PatternString = "(.*)";
var PatternNever = "(?!.*)";
var PatternBooleanExact = `^${PatternBoolean}$`;
var PatternNumberExact = `^${PatternNumber}$`;
var PatternStringExact = `^${PatternString}$`;
var PatternNeverExact = `^${PatternNever}$`;

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/registry/format.mjs
var exports_format = {};
__export(exports_format, {
  Set: () => Set2,
  Has: () => Has,
  Get: () => Get,
  Entries: () => Entries,
  Delete: () => Delete,
  Clear: () => Clear
});
var map = new Map;
function Entries() {
  return new Map(map);
}
function Clear() {
  return map.clear();
}
function Delete(format) {
  return map.delete(format);
}
function Has(format) {
  return map.has(format);
}
function Set2(format, func) {
  map.set(format, func);
}
function Get(format) {
  return map.get(format);
}
// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/registry/type.mjs
var exports_type2 = {};
__export(exports_type2, {
  Set: () => Set3,
  Has: () => Has2,
  Get: () => Get2,
  Entries: () => Entries2,
  Delete: () => Delete2,
  Clear: () => Clear2
});
var map2 = new Map;
function Entries2() {
  return new Map(map2);
}
function Clear2() {
  return map2.clear();
}
function Delete2(kind) {
  return map2.delete(kind);
}
function Has2(kind) {
  return map2.has(kind);
}
function Set3(kind, func) {
  map2.set(kind, func);
}
function Get2(kind) {
  return map2.get(kind);
}
// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/sets/set.mjs
function SetIncludes(T, S) {
  return T.includes(S);
}
function SetDistinct(T) {
  return [...new Set(T)];
}
function SetIntersect(T, S) {
  return T.filter((L) => S.includes(L));
}
function SetIntersectManyResolve(T, Init) {
  return T.reduce((Acc, L) => {
    return SetIntersect(Acc, L);
  }, Init);
}
function SetIntersectMany(T) {
  return T.length === 1 ? T[0] : T.length > 1 ? SetIntersectManyResolve(T.slice(1), T[0]) : [];
}
function SetUnionMany(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...L);
  return Acc;
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/any/any.mjs
function Any(options) {
  return CreateType({ [Kind]: "Any" }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/array/array.mjs
function Array2(items, options) {
  return CreateType({ [Kind]: "Array", type: "array", items }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/async-iterator/async-iterator.mjs
function AsyncIterator(items, options) {
  return CreateType({ [Kind]: "AsyncIterator", type: "AsyncIterator", items }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/computed/computed.mjs
function Computed(target, parameters, options) {
  return CreateType({ [Kind]: "Computed", target, parameters }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/discard/discard.mjs
function DiscardKey(value, key) {
  const { [key]: _2, ...rest } = value;
  return rest;
}
function Discard(value, keys) {
  return keys.reduce((acc, key) => DiscardKey(acc, key), value);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/never/never.mjs
function Never(options) {
  return CreateType({ [Kind]: "Never", not: {} }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/mapped/mapped-result.mjs
function MappedResult(properties) {
  return CreateType({
    [Kind]: "MappedResult",
    properties
  });
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/constructor/constructor.mjs
function Constructor(parameters, returns, options) {
  return CreateType({ [Kind]: "Constructor", type: "Constructor", parameters, returns }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/function/function.mjs
function Function2(parameters, returns, options) {
  return CreateType({ [Kind]: "Function", type: "Function", parameters, returns }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/union/union-create.mjs
function UnionCreate(T, options) {
  return CreateType({ [Kind]: "Union", anyOf: T }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/union/union-evaluated.mjs
function IsUnionOptional(types) {
  return types.some((type) => IsOptional(type));
}
function RemoveOptionalFromRest(types) {
  return types.map((left) => IsOptional(left) ? RemoveOptionalFromType(left) : left);
}
function RemoveOptionalFromType(T) {
  return Discard(T, [OptionalKind]);
}
function ResolveUnion(types, options) {
  const isOptional = IsUnionOptional(types);
  return isOptional ? Optional(UnionCreate(RemoveOptionalFromRest(types), options)) : UnionCreate(RemoveOptionalFromRest(types), options);
}
function UnionEvaluated(T, options) {
  return T.length === 1 ? CreateType(T[0], options) : T.length === 0 ? Never(options) : ResolveUnion(T, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/union/union.mjs
function Union(types, options) {
  return types.length === 0 ? Never(options) : types.length === 1 ? CreateType(types[0], options) : UnionCreate(types, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/template-literal/parse.mjs
class TemplateLiteralParserError extends TypeBoxError {
}
function Unescape(pattern) {
  return pattern.replace(/\\\$/g, "$").replace(/\\\*/g, "*").replace(/\\\^/g, "^").replace(/\\\|/g, "|").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}
function IsNonEscaped(pattern, index, char) {
  return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
}
function IsOpenParen(pattern, index) {
  return IsNonEscaped(pattern, index, "(");
}
function IsCloseParen(pattern, index) {
  return IsNonEscaped(pattern, index, ")");
}
function IsSeparator(pattern, index) {
  return IsNonEscaped(pattern, index, "|");
}
function IsGroup(pattern) {
  if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))
    return false;
  let count = 0;
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (count === 0 && index !== pattern.length - 1)
      return false;
  }
  return true;
}
function InGroup(pattern) {
  return pattern.slice(1, pattern.length - 1);
}
function IsPrecedenceOr(pattern) {
  let count = 0;
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0)
      return true;
  }
  return false;
}
function IsPrecedenceAnd(pattern) {
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      return true;
  }
  return false;
}
function Or(pattern) {
  let [count, start] = [0, 0];
  const expressions = [];
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0) {
      const range2 = pattern.slice(start, index);
      if (range2.length > 0)
        expressions.push(TemplateLiteralParse(range2));
      start = index + 1;
    }
  }
  const range = pattern.slice(start);
  if (range.length > 0)
    expressions.push(TemplateLiteralParse(range));
  if (expressions.length === 0)
    return { type: "const", const: "" };
  if (expressions.length === 1)
    return expressions[0];
  return { type: "or", expr: expressions };
}
function And(pattern) {
  function Group(value, index) {
    if (!IsOpenParen(value, index))
      throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
    let count = 0;
    for (let scan = index;scan < value.length; scan++) {
      if (IsOpenParen(value, scan))
        count += 1;
      if (IsCloseParen(value, scan))
        count -= 1;
      if (count === 0)
        return [index, scan];
    }
    throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
  }
  function Range(pattern2, index) {
    for (let scan = index;scan < pattern2.length; scan++) {
      if (IsOpenParen(pattern2, scan))
        return [index, scan];
    }
    return [index, pattern2.length];
  }
  const expressions = [];
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index)) {
      const [start, end] = Group(pattern, index);
      const range = pattern.slice(start, end + 1);
      expressions.push(TemplateLiteralParse(range));
      index = end;
    } else {
      const [start, end] = Range(pattern, index);
      const range = pattern.slice(start, end);
      if (range.length > 0)
        expressions.push(TemplateLiteralParse(range));
      index = end - 1;
    }
  }
  return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
}
function TemplateLiteralParse(pattern) {
  return IsGroup(pattern) ? TemplateLiteralParse(InGroup(pattern)) : IsPrecedenceOr(pattern) ? Or(pattern) : IsPrecedenceAnd(pattern) ? And(pattern) : { type: "const", const: Unescape(pattern) };
}
function TemplateLiteralParseExact(pattern) {
  return TemplateLiteralParse(pattern.slice(1, pattern.length - 1));
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/template-literal/finite.mjs
class TemplateLiteralFiniteError extends TypeBoxError {
}
function IsNumberExpression(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
}
function IsBooleanExpression(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
}
function IsStringExpression(expression) {
  return expression.type === "const" && expression.const === ".*";
}
function IsTemplateLiteralExpressionFinite(expression) {
  return IsNumberExpression(expression) || IsStringExpression(expression) ? false : IsBooleanExpression(expression) ? true : expression.type === "and" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "or" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "const" ? true : (() => {
    throw new TemplateLiteralFiniteError(`Unknown expression type`);
  })();
}
function IsTemplateLiteralFinite(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/template-literal/generate.mjs
class TemplateLiteralGenerateError extends TypeBoxError {
}
function* GenerateReduce(buffer) {
  if (buffer.length === 1)
    return yield* buffer[0];
  for (const left of buffer[0]) {
    for (const right of GenerateReduce(buffer.slice(1))) {
      yield `${left}${right}`;
    }
  }
}
function* GenerateAnd(expression) {
  return yield* GenerateReduce(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate(expr)]));
}
function* GenerateOr(expression) {
  for (const expr of expression.expr)
    yield* TemplateLiteralExpressionGenerate(expr);
}
function* GenerateConst(expression) {
  return yield expression.const;
}
function* TemplateLiteralExpressionGenerate(expression) {
  return expression.type === "and" ? yield* GenerateAnd(expression) : expression.type === "or" ? yield* GenerateOr(expression) : expression.type === "const" ? yield* GenerateConst(expression) : (() => {
    throw new TemplateLiteralGenerateError("Unknown expression");
  })();
}
function TemplateLiteralGenerate(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression) ? [...TemplateLiteralExpressionGenerate(expression)] : [];
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/literal/literal.mjs
function Literal(value, options) {
  return CreateType({
    [Kind]: "Literal",
    const: value,
    type: typeof value
  }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/boolean/boolean.mjs
function Boolean2(options) {
  return CreateType({ [Kind]: "Boolean", type: "boolean" }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/bigint/bigint.mjs
function BigInt2(options) {
  return CreateType({ [Kind]: "BigInt", type: "bigint" }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/number/number.mjs
function Number2(options) {
  return CreateType({ [Kind]: "Number", type: "number" }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/string/string.mjs
function String2(options) {
  return CreateType({ [Kind]: "String", type: "string" }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/template-literal/syntax.mjs
function* FromUnion(syntax) {
  const trim = syntax.trim().replace(/"|'/g, "");
  return trim === "boolean" ? yield Boolean2() : trim === "number" ? yield Number2() : trim === "bigint" ? yield BigInt2() : trim === "string" ? yield String2() : yield (() => {
    const literals = trim.split("|").map((literal) => Literal(literal.trim()));
    return literals.length === 0 ? Never() : literals.length === 1 ? literals[0] : UnionEvaluated(literals);
  })();
}
function* FromTerminal(syntax) {
  if (syntax[1] !== "{") {
    const L = Literal("$");
    const R = FromSyntax(syntax.slice(1));
    return yield* [L, ...R];
  }
  for (let i = 2;i < syntax.length; i++) {
    if (syntax[i] === "}") {
      const L = FromUnion(syntax.slice(2, i));
      const R = FromSyntax(syntax.slice(i + 1));
      return yield* [...L, ...R];
    }
  }
  yield Literal(syntax);
}
function* FromSyntax(syntax) {
  for (let i = 0;i < syntax.length; i++) {
    if (syntax[i] === "$") {
      const L = Literal(syntax.slice(0, i));
      const R = FromTerminal(syntax.slice(i));
      return yield* [L, ...R];
    }
  }
  yield Literal(syntax);
}
function TemplateLiteralSyntax(syntax) {
  return [...FromSyntax(syntax)];
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/template-literal/pattern.mjs
class TemplateLiteralPatternError extends TypeBoxError {
}
function Escape(value) {
  return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Visit2(schema, acc) {
  return IsTemplateLiteral(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) : IsUnion(schema) ? `(${schema.anyOf.map((schema2) => Visit2(schema2, acc)).join("|")})` : IsNumber3(schema) ? `${acc}${PatternNumber}` : IsInteger2(schema) ? `${acc}${PatternNumber}` : IsBigInt3(schema) ? `${acc}${PatternNumber}` : IsString3(schema) ? `${acc}${PatternString}` : IsLiteral(schema) ? `${acc}${Escape(schema.const.toString())}` : IsBoolean3(schema) ? `${acc}${PatternBoolean}` : (() => {
    throw new TemplateLiteralPatternError(`Unexpected Kind '${schema[Kind]}'`);
  })();
}
function TemplateLiteralPattern(kinds) {
  return `^${kinds.map((schema) => Visit2(schema, "")).join("")}$`;
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/template-literal/union.mjs
function TemplateLiteralToUnion(schema) {
  const R = TemplateLiteralGenerate(schema);
  const L = R.map((S) => Literal(S));
  return UnionEvaluated(L);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/template-literal/template-literal.mjs
function TemplateLiteral(unresolved, options) {
  const pattern = IsString(unresolved) ? TemplateLiteralPattern(TemplateLiteralSyntax(unresolved)) : TemplateLiteralPattern(unresolved);
  return CreateType({ [Kind]: "TemplateLiteral", type: "string", pattern }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-property-keys.mjs
function FromTemplateLiteral(templateLiteral) {
  const keys = TemplateLiteralGenerate(templateLiteral);
  return keys.map((key) => key.toString());
}
function FromUnion2(types) {
  const result = [];
  for (const type of types)
    result.push(...IndexPropertyKeys(type));
  return result;
}
function FromLiteral(literalValue) {
  return [literalValue.toString()];
}
function IndexPropertyKeys(type) {
  return [...new Set(IsTemplateLiteral(type) ? FromTemplateLiteral(type) : IsUnion(type) ? FromUnion2(type.anyOf) : IsLiteral(type) ? FromLiteral(type.const) : IsNumber3(type) ? ["[number]"] : IsInteger2(type) ? ["[number]"] : [])];
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-result.mjs
function FromProperties(type, properties, options) {
  const result = {};
  for (const K2 of Object.getOwnPropertyNames(properties)) {
    result[K2] = Index(type, IndexPropertyKeys(properties[K2]), options);
  }
  return result;
}
function FromMappedResult(type, mappedResult, options) {
  return FromProperties(type, mappedResult.properties, options);
}
function IndexFromMappedResult(type, mappedResult, options) {
  const properties = FromMappedResult(type, mappedResult, options);
  return MappedResult(properties);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/indexed/indexed.mjs
function FromRest(types, key) {
  return types.map((type) => IndexFromPropertyKey(type, key));
}
function FromIntersectRest(types) {
  return types.filter((type) => !IsNever(type));
}
function FromIntersect(types, key) {
  return IntersectEvaluated(FromIntersectRest(FromRest(types, key)));
}
function FromUnionRest(types) {
  return types.some((L) => IsNever(L)) ? [] : types;
}
function FromUnion3(types, key) {
  return UnionEvaluated(FromUnionRest(FromRest(types, key)));
}
function FromTuple(types, key) {
  return key in types ? types[key] : key === "[number]" ? UnionEvaluated(types) : Never();
}
function FromArray(type, key) {
  return key === "[number]" ? type : Never();
}
function FromProperty(properties, propertyKey) {
  return propertyKey in properties ? properties[propertyKey] : Never();
}
function IndexFromPropertyKey(type, propertyKey) {
  return IsIntersect(type) ? FromIntersect(type.allOf, propertyKey) : IsUnion(type) ? FromUnion3(type.anyOf, propertyKey) : IsTuple(type) ? FromTuple(type.items ?? [], propertyKey) : IsArray3(type) ? FromArray(type.items, propertyKey) : IsObject3(type) ? FromProperty(type.properties, propertyKey) : Never();
}
function IndexFromPropertyKeys(type, propertyKeys) {
  return propertyKeys.map((propertyKey) => IndexFromPropertyKey(type, propertyKey));
}
function FromSchema(type, propertyKeys) {
  return UnionEvaluated(IndexFromPropertyKeys(type, propertyKeys));
}
function Index(type, key, options) {
  if (IsRef(type) || IsRef(key)) {
    const error = `Index types using Ref parameters require both Type and Key to be of TSchema`;
    if (!IsSchema(type) || !IsSchema(key))
      throw new TypeBoxError(error);
    return Computed("Index", [type, key]);
  }
  if (IsMappedResult(key))
    return IndexFromMappedResult(type, key, options);
  if (IsMappedKey(key))
    return IndexFromMappedKey(type, key, options);
  return CreateType(IsSchema(key) ? FromSchema(type, IndexPropertyKeys(key)) : FromSchema(type, key), options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-key.mjs
function MappedIndexPropertyKey(type, key, options) {
  return { [key]: Index(type, [key], Clone(options)) };
}
function MappedIndexPropertyKeys(type, propertyKeys, options) {
  return propertyKeys.reduce((result, left) => {
    return { ...result, ...MappedIndexPropertyKey(type, left, options) };
  }, {});
}
function MappedIndexProperties(type, mappedKey, options) {
  return MappedIndexPropertyKeys(type, mappedKey.keys, options);
}
function IndexFromMappedKey(type, mappedKey, options) {
  const properties = MappedIndexProperties(type, mappedKey, options);
  return MappedResult(properties);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/iterator/iterator.mjs
function Iterator(items, options) {
  return CreateType({ [Kind]: "Iterator", type: "Iterator", items }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/object/object.mjs
function RequiredKeys(properties) {
  const keys = [];
  for (let key in properties) {
    if (!IsOptional(properties[key]))
      keys.push(key);
  }
  return keys;
}
function _Object(properties, options) {
  const required = RequiredKeys(properties);
  const schematic = required.length > 0 ? { [Kind]: "Object", type: "object", properties, required } : { [Kind]: "Object", type: "object", properties };
  return CreateType(schematic, options);
}
var Object2 = _Object;

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/promise/promise.mjs
function Promise2(item, options) {
  return CreateType({ [Kind]: "Promise", type: "Promise", item }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/readonly/readonly.mjs
function RemoveReadonly(schema) {
  return CreateType(Discard(schema, [ReadonlyKind]));
}
function AddReadonly(schema) {
  return CreateType({ ...schema, [ReadonlyKind]: "Readonly" });
}
function ReadonlyWithFlag(schema, F) {
  return F === false ? RemoveReadonly(schema) : AddReadonly(schema);
}
function Readonly(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult(schema) ? ReadonlyFromMappedResult(schema, F) : ReadonlyWithFlag(schema, F);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/readonly/readonly-from-mapped-result.mjs
function FromProperties2(K, F) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Readonly(K[K2], F);
  return Acc;
}
function FromMappedResult2(R, F) {
  return FromProperties2(R.properties, F);
}
function ReadonlyFromMappedResult(R, F) {
  const P = FromMappedResult2(R, F);
  return MappedResult(P);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/tuple/tuple.mjs
function Tuple(types, options) {
  return CreateType(types.length > 0 ? { [Kind]: "Tuple", type: "array", items: types, additionalItems: false, minItems: types.length, maxItems: types.length } : { [Kind]: "Tuple", type: "array", minItems: types.length, maxItems: types.length }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/mapped/mapped.mjs
function FromMappedResult3(K, P) {
  return K in P ? FromSchemaType(K, P[K]) : MappedResult(P);
}
function MappedKeyToKnownMappedResultProperties(K) {
  return { [K]: Literal(K) };
}
function MappedKeyToUnknownMappedResultProperties(P) {
  const Acc = {};
  for (const L of P)
    Acc[L] = Literal(L);
  return Acc;
}
function MappedKeyToMappedResultProperties(K, P) {
  return SetIncludes(P, K) ? MappedKeyToKnownMappedResultProperties(K) : MappedKeyToUnknownMappedResultProperties(P);
}
function FromMappedKey(K, P) {
  const R = MappedKeyToMappedResultProperties(K, P);
  return FromMappedResult3(K, R);
}
function FromRest2(K, T) {
  return T.map((L) => FromSchemaType(K, L));
}
function FromProperties3(K, T) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(T))
    Acc[K2] = FromSchemaType(K, T[K2]);
  return Acc;
}
function FromSchemaType(K, T) {
  const options = { ...T };
  return IsOptional(T) ? Optional(FromSchemaType(K, Discard(T, [OptionalKind]))) : IsReadonly(T) ? Readonly(FromSchemaType(K, Discard(T, [ReadonlyKind]))) : IsMappedResult(T) ? FromMappedResult3(K, T.properties) : IsMappedKey(T) ? FromMappedKey(K, T.keys) : IsConstructor(T) ? Constructor(FromRest2(K, T.parameters), FromSchemaType(K, T.returns), options) : IsFunction3(T) ? Function2(FromRest2(K, T.parameters), FromSchemaType(K, T.returns), options) : IsAsyncIterator3(T) ? AsyncIterator(FromSchemaType(K, T.items), options) : IsIterator3(T) ? Iterator(FromSchemaType(K, T.items), options) : IsIntersect(T) ? Intersect(FromRest2(K, T.allOf), options) : IsUnion(T) ? Union(FromRest2(K, T.anyOf), options) : IsTuple(T) ? Tuple(FromRest2(K, T.items ?? []), options) : IsObject3(T) ? Object2(FromProperties3(K, T.properties), options) : IsArray3(T) ? Array2(FromSchemaType(K, T.items), options) : IsPromise2(T) ? Promise2(FromSchemaType(K, T.item), options) : T;
}
function MappedFunctionReturnType(K, T) {
  const Acc = {};
  for (const L of K)
    Acc[L] = FromSchemaType(L, T);
  return Acc;
}
function Mapped(key, map3, options) {
  const K = IsSchema(key) ? IndexPropertyKeys(key) : key;
  const RT = map3({ [Kind]: "MappedKey", keys: K });
  const R = MappedFunctionReturnType(K, RT);
  return Object2(R, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/optional/optional.mjs
function RemoveOptional(schema) {
  return CreateType(Discard(schema, [OptionalKind]));
}
function AddOptional(schema) {
  return CreateType({ ...schema, [OptionalKind]: "Optional" });
}
function OptionalWithFlag(schema, F) {
  return F === false ? RemoveOptional(schema) : AddOptional(schema);
}
function Optional(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult(schema) ? OptionalFromMappedResult(schema, F) : OptionalWithFlag(schema, F);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/optional/optional-from-mapped-result.mjs
function FromProperties4(P, F) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Optional(P[K2], F);
  return Acc;
}
function FromMappedResult4(R, F) {
  return FromProperties4(R.properties, F);
}
function OptionalFromMappedResult(R, F) {
  const P = FromMappedResult4(R, F);
  return MappedResult(P);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-create.mjs
function IntersectCreate(T, options = {}) {
  const allObjects = T.every((schema) => IsObject3(schema));
  const clonedUnevaluatedProperties = IsSchema(options.unevaluatedProperties) ? { unevaluatedProperties: options.unevaluatedProperties } : {};
  return CreateType(options.unevaluatedProperties === false || IsSchema(options.unevaluatedProperties) || allObjects ? { ...clonedUnevaluatedProperties, [Kind]: "Intersect", type: "object", allOf: T } : { ...clonedUnevaluatedProperties, [Kind]: "Intersect", allOf: T }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-evaluated.mjs
function IsIntersectOptional(types) {
  return types.every((left) => IsOptional(left));
}
function RemoveOptionalFromType2(type) {
  return Discard(type, [OptionalKind]);
}
function RemoveOptionalFromRest2(types) {
  return types.map((left) => IsOptional(left) ? RemoveOptionalFromType2(left) : left);
}
function ResolveIntersect(types, options) {
  return IsIntersectOptional(types) ? Optional(IntersectCreate(RemoveOptionalFromRest2(types), options)) : IntersectCreate(RemoveOptionalFromRest2(types), options);
}
function IntersectEvaluated(types, options = {}) {
  if (types.length === 1)
    return CreateType(types[0], options);
  if (types.length === 0)
    return Never(options);
  if (types.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return ResolveIntersect(types, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/intersect/intersect.mjs
function Intersect(types, options) {
  if (types.length === 1)
    return CreateType(types[0], options);
  if (types.length === 0)
    return Never(options);
  if (types.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return IntersectCreate(types, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/ref/ref.mjs
function Ref(...args) {
  const [$ref, options] = typeof args[0] === "string" ? [args[0], args[1]] : [args[0].$id, args[1]];
  if (typeof $ref !== "string")
    throw new TypeBoxError("Ref: $ref must be a string");
  return CreateType({ [Kind]: "Ref", $ref }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/awaited/awaited.mjs
function FromComputed(target, parameters) {
  return Computed("Awaited", [Computed(target, parameters)]);
}
function FromRef($ref) {
  return Computed("Awaited", [Ref($ref)]);
}
function FromIntersect2(types) {
  return Intersect(FromRest3(types));
}
function FromUnion4(types) {
  return Union(FromRest3(types));
}
function FromPromise(type) {
  return Awaited(type);
}
function FromRest3(types) {
  return types.map((type) => Awaited(type));
}
function Awaited(type, options) {
  return CreateType(IsComputed(type) ? FromComputed(type.target, type.parameters) : IsIntersect(type) ? FromIntersect2(type.allOf) : IsUnion(type) ? FromUnion4(type.anyOf) : IsPromise2(type) ? FromPromise(type.item) : IsRef(type) ? FromRef(type.$ref) : type, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-property-keys.mjs
function FromRest4(types) {
  const result = [];
  for (const L of types)
    result.push(KeyOfPropertyKeys(L));
  return result;
}
function FromIntersect3(types) {
  const propertyKeysArray = FromRest4(types);
  const propertyKeys = SetUnionMany(propertyKeysArray);
  return propertyKeys;
}
function FromUnion5(types) {
  const propertyKeysArray = FromRest4(types);
  const propertyKeys = SetIntersectMany(propertyKeysArray);
  return propertyKeys;
}
function FromTuple2(types) {
  return types.map((_2, indexer) => indexer.toString());
}
function FromArray2(_2) {
  return ["[number]"];
}
function FromProperties5(T) {
  return globalThis.Object.getOwnPropertyNames(T);
}
function FromPatternProperties(patternProperties) {
  if (!includePatternProperties)
    return [];
  const patternPropertyKeys = globalThis.Object.getOwnPropertyNames(patternProperties);
  return patternPropertyKeys.map((key) => {
    return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
  });
}
function KeyOfPropertyKeys(type) {
  return IsIntersect(type) ? FromIntersect3(type.allOf) : IsUnion(type) ? FromUnion5(type.anyOf) : IsTuple(type) ? FromTuple2(type.items ?? []) : IsArray3(type) ? FromArray2(type.items) : IsObject3(type) ? FromProperties5(type.properties) : IsRecord(type) ? FromPatternProperties(type.patternProperties) : [];
}
var includePatternProperties = false;
function KeyOfPattern(schema) {
  includePatternProperties = true;
  const keys = KeyOfPropertyKeys(schema);
  includePatternProperties = false;
  const pattern = keys.map((key) => `(${key})`);
  return `^(${pattern.join("|")})$`;
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/keyof/keyof.mjs
function FromComputed2(target, parameters) {
  return Computed("KeyOf", [Computed(target, parameters)]);
}
function FromRef2($ref) {
  return Computed("KeyOf", [Ref($ref)]);
}
function KeyOfFromType(type, options) {
  const propertyKeys = KeyOfPropertyKeys(type);
  const propertyKeyTypes = KeyOfPropertyKeysToRest(propertyKeys);
  const result = UnionEvaluated(propertyKeyTypes);
  return CreateType(result, options);
}
function KeyOfPropertyKeysToRest(propertyKeys) {
  return propertyKeys.map((L) => L === "[number]" ? Number2() : Literal(L));
}
function KeyOf(type, options) {
  return IsComputed(type) ? FromComputed2(type.target, type.parameters) : IsRef(type) ? FromRef2(type.$ref) : IsMappedResult(type) ? KeyOfFromMappedResult(type, options) : KeyOfFromType(type, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-from-mapped-result.mjs
function FromProperties6(properties, options) {
  const result = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
    result[K2] = KeyOf(properties[K2], Clone(options));
  return result;
}
function FromMappedResult5(mappedResult, options) {
  return FromProperties6(mappedResult.properties, options);
}
function KeyOfFromMappedResult(mappedResult, options) {
  const properties = FromMappedResult5(mappedResult, options);
  return MappedResult(properties);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-property-entries.mjs
function KeyOfPropertyEntries(schema) {
  const keys = KeyOfPropertyKeys(schema);
  const schemas = IndexFromPropertyKeys(schema, keys);
  return keys.map((_2, index) => [keys[index], schemas[index]]);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/composite/composite.mjs
function CompositeKeys(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...KeyOfPropertyKeys(L));
  return SetDistinct(Acc);
}
function FilterNever(T) {
  return T.filter((L) => !IsNever(L));
}
function CompositeProperty(T, K) {
  const Acc = [];
  for (const L of T)
    Acc.push(...IndexFromPropertyKeys(L, [K]));
  return FilterNever(Acc);
}
function CompositeProperties(T, K) {
  const Acc = {};
  for (const L of K) {
    Acc[L] = IntersectEvaluated(CompositeProperty(T, L));
  }
  return Acc;
}
function Composite(T, options) {
  const K = CompositeKeys(T);
  const P = CompositeProperties(T, K);
  const R = Object2(P, options);
  return R;
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/date/date.mjs
function Date2(options) {
  return CreateType({ [Kind]: "Date", type: "Date" }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/null/null.mjs
function Null(options) {
  return CreateType({ [Kind]: "Null", type: "null" }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/symbol/symbol.mjs
function Symbol2(options) {
  return CreateType({ [Kind]: "Symbol", type: "symbol" }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/undefined/undefined.mjs
function Undefined(options) {
  return CreateType({ [Kind]: "Undefined", type: "undefined" }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/uint8array/uint8array.mjs
function Uint8Array2(options) {
  return CreateType({ [Kind]: "Uint8Array", type: "Uint8Array" }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/unknown/unknown.mjs
function Unknown(options) {
  return CreateType({ [Kind]: "Unknown" }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/const/const.mjs
function FromArray3(T) {
  return T.map((L) => FromValue(L, false));
}
function FromProperties7(value) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(value))
    Acc[K] = Readonly(FromValue(value[K], false));
  return Acc;
}
function ConditionalReadonly(T, root) {
  return root === true ? T : Readonly(T);
}
function FromValue(value, root) {
  return IsAsyncIterator(value) ? ConditionalReadonly(Any(), root) : IsIterator(value) ? ConditionalReadonly(Any(), root) : IsArray(value) ? Readonly(Tuple(FromArray3(value))) : IsUint8Array(value) ? Uint8Array2() : IsDate(value) ? Date2() : IsObject(value) ? ConditionalReadonly(Object2(FromProperties7(value)), root) : IsFunction(value) ? ConditionalReadonly(Function2([], Unknown()), root) : IsUndefined(value) ? Undefined() : IsNull(value) ? Null() : IsSymbol(value) ? Symbol2() : IsBigInt(value) ? BigInt2() : IsNumber(value) ? Literal(value) : IsBoolean(value) ? Literal(value) : IsString(value) ? Literal(value) : Object2({});
}
function Const(T, options) {
  return CreateType(FromValue(T, true), options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/constructor-parameters/constructor-parameters.mjs
function ConstructorParameters(schema, options) {
  return Tuple(schema.parameters, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/enum/enum.mjs
function Enum(item, options) {
  if (IsUndefined(item))
    throw new Error("Enum undefined or empty");
  const values1 = globalThis.Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
  const values2 = [...new Set(values1)];
  const anyOf = values2.map((value) => Literal(value));
  return Union(anyOf, { ...options, [Hint]: "Enum" });
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/extends/extends-check.mjs
class ExtendsResolverError extends TypeBoxError {
}
var ExtendsResult;
(function(ExtendsResult2) {
  ExtendsResult2[ExtendsResult2["Union"] = 0] = "Union";
  ExtendsResult2[ExtendsResult2["True"] = 1] = "True";
  ExtendsResult2[ExtendsResult2["False"] = 2] = "False";
})(ExtendsResult || (ExtendsResult = {}));
function IntoBooleanResult(result) {
  return result === ExtendsResult.False ? result : ExtendsResult.True;
}
function Throw(message) {
  throw new ExtendsResolverError(message);
}
function IsStructuralRight(right) {
  return exports_type.IsNever(right) || exports_type.IsIntersect(right) || exports_type.IsUnion(right) || exports_type.IsUnknown(right) || exports_type.IsAny(right);
}
function StructuralRight(left, right) {
  return exports_type.IsNever(right) ? FromNeverRight(left, right) : exports_type.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type.IsUnion(right) ? FromUnionRight(left, right) : exports_type.IsUnknown(right) ? FromUnknownRight(left, right) : exports_type.IsAny(right) ? FromAnyRight(left, right) : Throw("StructuralRight");
}
function FromAnyRight(left, right) {
  return ExtendsResult.True;
}
function FromAny(left, right) {
  return exports_type.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type.IsUnion(right) && right.anyOf.some((schema) => exports_type.IsAny(schema) || exports_type.IsUnknown(schema)) ? ExtendsResult.True : exports_type.IsUnion(right) ? ExtendsResult.Union : exports_type.IsUnknown(right) ? ExtendsResult.True : exports_type.IsAny(right) ? ExtendsResult.True : ExtendsResult.Union;
}
function FromArrayRight(left, right) {
  return exports_type.IsUnknown(left) ? ExtendsResult.False : exports_type.IsAny(left) ? ExtendsResult.Union : exports_type.IsNever(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromArray4(left, right) {
  return exports_type.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type.IsArray(right) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.items, right.items));
}
function FromAsyncIterator(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type.IsAsyncIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.items, right.items));
}
function FromBigInt(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsBigInt(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromBooleanRight(left, right) {
  return exports_type.IsLiteralBoolean(left) ? ExtendsResult.True : exports_type.IsBoolean(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromBoolean(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsBoolean(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromConstructor(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : !exports_type.IsConstructor(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit3(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.returns, right.returns));
}
function FromDate(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsDate(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromFunction(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : !exports_type.IsFunction(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit3(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.returns, right.returns));
}
function FromIntegerRight(left, right) {
  return exports_type.IsLiteral(left) && exports_value.IsNumber(left.const) ? ExtendsResult.True : exports_type.IsNumber(left) || exports_type.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromInteger(left, right) {
  return exports_type.IsInteger(right) || exports_type.IsNumber(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : ExtendsResult.False;
}
function FromIntersectRight(left, right) {
  return right.allOf.every((schema) => Visit3(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromIntersect4(left, right) {
  return left.allOf.some((schema) => Visit3(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromIterator(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type.IsIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.items, right.items));
}
function FromLiteral2(left, right) {
  return exports_type.IsLiteral(right) && right.const === left.const ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsString(right) ? FromStringRight(left, right) : exports_type.IsNumber(right) ? FromNumberRight(left, right) : exports_type.IsInteger(right) ? FromIntegerRight(left, right) : exports_type.IsBoolean(right) ? FromBooleanRight(left, right) : ExtendsResult.False;
}
function FromNeverRight(left, right) {
  return ExtendsResult.False;
}
function FromNever(left, right) {
  return ExtendsResult.True;
}
function UnwrapTNot(schema) {
  let [current, depth] = [schema, 0];
  while (true) {
    if (!exports_type.IsNot(current))
      break;
    current = current.not;
    depth += 1;
  }
  return depth % 2 === 0 ? current : Unknown();
}
function FromNot(left, right) {
  return exports_type.IsNot(left) ? Visit3(UnwrapTNot(left), right) : exports_type.IsNot(right) ? Visit3(left, UnwrapTNot(right)) : Throw("Invalid fallthrough for Not");
}
function FromNull(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsNull(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromNumberRight(left, right) {
  return exports_type.IsLiteralNumber(left) ? ExtendsResult.True : exports_type.IsNumber(left) || exports_type.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromNumber(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsInteger(right) || exports_type.IsNumber(right) ? ExtendsResult.True : ExtendsResult.False;
}
function IsObjectPropertyCount(schema, count) {
  return Object.getOwnPropertyNames(schema.properties).length === count;
}
function IsObjectStringLike(schema) {
  return IsObjectArrayLike(schema);
}
function IsObjectSymbolLike(schema) {
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "description" in schema.properties && exports_type.IsUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (exports_type.IsString(schema.properties.description.anyOf[0]) && exports_type.IsUndefined(schema.properties.description.anyOf[1]) || exports_type.IsString(schema.properties.description.anyOf[1]) && exports_type.IsUndefined(schema.properties.description.anyOf[0]));
}
function IsObjectNumberLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectBooleanLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectBigIntLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectDateLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectUint8ArrayLike(schema) {
  return IsObjectArrayLike(schema);
}
function IsObjectFunctionLike(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit3(schema.properties["length"], length)) === ExtendsResult.True;
}
function IsObjectConstructorLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectArrayLike(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit3(schema.properties["length"], length)) === ExtendsResult.True;
}
function IsObjectPromiseLike(schema) {
  const then = Function2([Any()], Any());
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "then" in schema.properties && IntoBooleanResult(Visit3(schema.properties["then"], then)) === ExtendsResult.True;
}
function Property(left, right) {
  return Visit3(left, right) === ExtendsResult.False ? ExtendsResult.False : exports_type.IsOptional(left) && !exports_type.IsOptional(right) ? ExtendsResult.False : ExtendsResult.True;
}
function FromObjectRight(left, right) {
  return exports_type.IsUnknown(left) ? ExtendsResult.False : exports_type.IsAny(left) ? ExtendsResult.Union : exports_type.IsNever(left) || exports_type.IsLiteralString(left) && IsObjectStringLike(right) || exports_type.IsLiteralNumber(left) && IsObjectNumberLike(right) || exports_type.IsLiteralBoolean(left) && IsObjectBooleanLike(right) || exports_type.IsSymbol(left) && IsObjectSymbolLike(right) || exports_type.IsBigInt(left) && IsObjectBigIntLike(right) || exports_type.IsString(left) && IsObjectStringLike(right) || exports_type.IsSymbol(left) && IsObjectSymbolLike(right) || exports_type.IsNumber(left) && IsObjectNumberLike(right) || exports_type.IsInteger(left) && IsObjectNumberLike(right) || exports_type.IsBoolean(left) && IsObjectBooleanLike(right) || exports_type.IsUint8Array(left) && IsObjectUint8ArrayLike(right) || exports_type.IsDate(left) && IsObjectDateLike(right) || exports_type.IsConstructor(left) && IsObjectConstructorLike(right) || exports_type.IsFunction(left) && IsObjectFunctionLike(right) ? ExtendsResult.True : exports_type.IsRecord(left) && exports_type.IsString(RecordKey(left)) ? (() => {
    return right[Hint] === "Record" ? ExtendsResult.True : ExtendsResult.False;
  })() : exports_type.IsRecord(left) && exports_type.IsNumber(RecordKey(left)) ? (() => {
    return IsObjectPropertyCount(right, 0) ? ExtendsResult.True : ExtendsResult.False;
  })() : ExtendsResult.False;
}
function FromObject(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : !exports_type.IsObject(right) ? ExtendsResult.False : (() => {
    for (const key of Object.getOwnPropertyNames(right.properties)) {
      if (!(key in left.properties) && !exports_type.IsOptional(right.properties[key])) {
        return ExtendsResult.False;
      }
      if (exports_type.IsOptional(right.properties[key])) {
        return ExtendsResult.True;
      }
      if (Property(left.properties[key], right.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })();
}
function FromPromise2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) && IsObjectPromiseLike(right) ? ExtendsResult.True : !exports_type.IsPromise(right) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.item, right.item));
}
function RecordKey(schema) {
  return PatternNumberExact in schema.patternProperties ? Number2() : (PatternStringExact in schema.patternProperties) ? String2() : Throw("Unknown record key pattern");
}
function RecordValue(schema) {
  return PatternNumberExact in schema.patternProperties ? schema.patternProperties[PatternNumberExact] : (PatternStringExact in schema.patternProperties) ? schema.patternProperties[PatternStringExact] : Throw("Unable to get record value schema");
}
function FromRecordRight(left, right) {
  const [Key, Value] = [RecordKey(right), RecordValue(right)];
  return exports_type.IsLiteralString(left) && exports_type.IsNumber(Key) && IntoBooleanResult(Visit3(left, Value)) === ExtendsResult.True ? ExtendsResult.True : exports_type.IsUint8Array(left) && exports_type.IsNumber(Key) ? Visit3(left, Value) : exports_type.IsString(left) && exports_type.IsNumber(Key) ? Visit3(left, Value) : exports_type.IsArray(left) && exports_type.IsNumber(Key) ? Visit3(left, Value) : exports_type.IsObject(left) ? (() => {
    for (const key of Object.getOwnPropertyNames(left.properties)) {
      if (Property(Value, left.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })() : ExtendsResult.False;
}
function FromRecord(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : !exports_type.IsRecord(right) ? ExtendsResult.False : Visit3(RecordValue(left), RecordValue(right));
}
function FromRegExp(left, right) {
  const L = exports_type.IsRegExp(left) ? String2() : left;
  const R = exports_type.IsRegExp(right) ? String2() : right;
  return Visit3(L, R);
}
function FromStringRight(left, right) {
  return exports_type.IsLiteral(left) && exports_value.IsString(left.const) ? ExtendsResult.True : exports_type.IsString(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromString(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsString(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromSymbol(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsSymbol(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromTemplateLiteral2(left, right) {
  return exports_type.IsTemplateLiteral(left) ? Visit3(TemplateLiteralToUnion(left), right) : exports_type.IsTemplateLiteral(right) ? Visit3(left, TemplateLiteralToUnion(right)) : Throw("Invalid fallthrough for TemplateLiteral");
}
function IsArrayOfTuple(left, right) {
  return exports_type.IsArray(right) && left.items !== undefined && left.items.every((schema) => Visit3(schema, right.items) === ExtendsResult.True);
}
function FromTupleRight(left, right) {
  return exports_type.IsNever(left) ? ExtendsResult.True : exports_type.IsUnknown(left) ? ExtendsResult.False : exports_type.IsAny(left) ? ExtendsResult.Union : ExtendsResult.False;
}
function FromTuple3(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : exports_type.IsArray(right) && IsArrayOfTuple(left, right) ? ExtendsResult.True : !exports_type.IsTuple(right) ? ExtendsResult.False : exports_value.IsUndefined(left.items) && !exports_value.IsUndefined(right.items) || !exports_value.IsUndefined(left.items) && exports_value.IsUndefined(right.items) ? ExtendsResult.False : exports_value.IsUndefined(left.items) && !exports_value.IsUndefined(right.items) ? ExtendsResult.True : left.items.every((schema, index) => Visit3(schema, right.items[index]) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUint8Array(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsUint8Array(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUndefined(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsVoid(right) ? FromVoidRight(left, right) : exports_type.IsUndefined(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnionRight(left, right) {
  return right.anyOf.some((schema) => Visit3(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnion6(left, right) {
  return left.anyOf.every((schema) => Visit3(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnknownRight(left, right) {
  return ExtendsResult.True;
}
function FromUnknown(left, right) {
  return exports_type.IsNever(right) ? FromNeverRight(left, right) : exports_type.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type.IsUnion(right) ? FromUnionRight(left, right) : exports_type.IsAny(right) ? FromAnyRight(left, right) : exports_type.IsString(right) ? FromStringRight(left, right) : exports_type.IsNumber(right) ? FromNumberRight(left, right) : exports_type.IsInteger(right) ? FromIntegerRight(left, right) : exports_type.IsBoolean(right) ? FromBooleanRight(left, right) : exports_type.IsArray(right) ? FromArrayRight(left, right) : exports_type.IsTuple(right) ? FromTupleRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsUnknown(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromVoidRight(left, right) {
  return exports_type.IsUndefined(left) ? ExtendsResult.True : exports_type.IsUndefined(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromVoid(left, right) {
  return exports_type.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type.IsUnion(right) ? FromUnionRight(left, right) : exports_type.IsUnknown(right) ? FromUnknownRight(left, right) : exports_type.IsAny(right) ? FromAnyRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsVoid(right) ? ExtendsResult.True : ExtendsResult.False;
}
function Visit3(left, right) {
  return exports_type.IsTemplateLiteral(left) || exports_type.IsTemplateLiteral(right) ? FromTemplateLiteral2(left, right) : exports_type.IsRegExp(left) || exports_type.IsRegExp(right) ? FromRegExp(left, right) : exports_type.IsNot(left) || exports_type.IsNot(right) ? FromNot(left, right) : exports_type.IsAny(left) ? FromAny(left, right) : exports_type.IsArray(left) ? FromArray4(left, right) : exports_type.IsBigInt(left) ? FromBigInt(left, right) : exports_type.IsBoolean(left) ? FromBoolean(left, right) : exports_type.IsAsyncIterator(left) ? FromAsyncIterator(left, right) : exports_type.IsConstructor(left) ? FromConstructor(left, right) : exports_type.IsDate(left) ? FromDate(left, right) : exports_type.IsFunction(left) ? FromFunction(left, right) : exports_type.IsInteger(left) ? FromInteger(left, right) : exports_type.IsIntersect(left) ? FromIntersect4(left, right) : exports_type.IsIterator(left) ? FromIterator(left, right) : exports_type.IsLiteral(left) ? FromLiteral2(left, right) : exports_type.IsNever(left) ? FromNever(left, right) : exports_type.IsNull(left) ? FromNull(left, right) : exports_type.IsNumber(left) ? FromNumber(left, right) : exports_type.IsObject(left) ? FromObject(left, right) : exports_type.IsRecord(left) ? FromRecord(left, right) : exports_type.IsString(left) ? FromString(left, right) : exports_type.IsSymbol(left) ? FromSymbol(left, right) : exports_type.IsTuple(left) ? FromTuple3(left, right) : exports_type.IsPromise(left) ? FromPromise2(left, right) : exports_type.IsUint8Array(left) ? FromUint8Array(left, right) : exports_type.IsUndefined(left) ? FromUndefined(left, right) : exports_type.IsUnion(left) ? FromUnion6(left, right) : exports_type.IsUnknown(left) ? FromUnknown(left, right) : exports_type.IsVoid(left) ? FromVoid(left, right) : Throw(`Unknown left type operand '${left[Kind]}'`);
}
function ExtendsCheck(left, right) {
  return Visit3(left, right);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-result.mjs
function FromProperties8(P, Right, True, False, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Extends(P[K2], Right, True, False, Clone(options));
  return Acc;
}
function FromMappedResult6(Left, Right, True, False, options) {
  return FromProperties8(Left.properties, Right, True, False, options);
}
function ExtendsFromMappedResult(Left, Right, True, False, options) {
  const P = FromMappedResult6(Left, Right, True, False, options);
  return MappedResult(P);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/extends/extends.mjs
function ExtendsResolve(left, right, trueType, falseType) {
  const R = ExtendsCheck(left, right);
  return R === ExtendsResult.Union ? Union([trueType, falseType]) : R === ExtendsResult.True ? trueType : falseType;
}
function Extends(L, R, T, F, options) {
  return IsMappedResult(L) ? ExtendsFromMappedResult(L, R, T, F, options) : IsMappedKey(L) ? CreateType(ExtendsFromMappedKey(L, R, T, F, options)) : CreateType(ExtendsResolve(L, R, T, F), options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-key.mjs
function FromPropertyKey(K, U2, L, R, options) {
  return {
    [K]: Extends(Literal(K), U2, L, R, Clone(options))
  };
}
function FromPropertyKeys(K, U2, L, R, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey(LK, U2, L, R, options) };
  }, {});
}
function FromMappedKey2(K, U2, L, R, options) {
  return FromPropertyKeys(K.keys, U2, L, R, options);
}
function ExtendsFromMappedKey(T, U2, L, R, options) {
  const P = FromMappedKey2(T, U2, L, R, options);
  return MappedResult(P);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/extends/extends-undefined.mjs
function Intersect2(schema) {
  return schema.allOf.every((schema2) => ExtendsUndefinedCheck(schema2));
}
function Union2(schema) {
  return schema.anyOf.some((schema2) => ExtendsUndefinedCheck(schema2));
}
function Not(schema) {
  return !ExtendsUndefinedCheck(schema.not);
}
function ExtendsUndefinedCheck(schema) {
  return schema[Kind] === "Intersect" ? Intersect2(schema) : schema[Kind] === "Union" ? Union2(schema) : schema[Kind] === "Not" ? Not(schema) : schema[Kind] === "Undefined" ? true : false;
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-template-literal.mjs
function ExcludeFromTemplateLiteral(L, R) {
  return Exclude(TemplateLiteralToUnion(L), R);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/exclude/exclude.mjs
function ExcludeRest(L, R) {
  const excluded = L.filter((inner) => ExtendsCheck(inner, R) === ExtendsResult.False);
  return excluded.length === 1 ? excluded[0] : Union(excluded);
}
function Exclude(L, R, options = {}) {
  if (IsTemplateLiteral(L))
    return CreateType(ExcludeFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CreateType(ExcludeFromMappedResult(L, R), options);
  return CreateType(IsUnion(L) ? ExcludeRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? Never() : L, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-mapped-result.mjs
function FromProperties9(P, U2) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Exclude(P[K2], U2);
  return Acc;
}
function FromMappedResult7(R, T) {
  return FromProperties9(R.properties, T);
}
function ExcludeFromMappedResult(R, T) {
  const P = FromMappedResult7(R, T);
  return MappedResult(P);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-template-literal.mjs
function ExtractFromTemplateLiteral(L, R) {
  return Extract(TemplateLiteralToUnion(L), R);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/extract/extract.mjs
function ExtractRest(L, R) {
  const extracted = L.filter((inner) => ExtendsCheck(inner, R) !== ExtendsResult.False);
  return extracted.length === 1 ? extracted[0] : Union(extracted);
}
function Extract(L, R, options) {
  if (IsTemplateLiteral(L))
    return CreateType(ExtractFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CreateType(ExtractFromMappedResult(L, R), options);
  return CreateType(IsUnion(L) ? ExtractRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? L : Never(), options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-mapped-result.mjs
function FromProperties10(P, T) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Extract(P[K2], T);
  return Acc;
}
function FromMappedResult8(R, T) {
  return FromProperties10(R.properties, T);
}
function ExtractFromMappedResult(R, T) {
  const P = FromMappedResult8(R, T);
  return MappedResult(P);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/instance-type/instance-type.mjs
function InstanceType(schema, options) {
  return CreateType(schema.returns, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/integer/integer.mjs
function Integer(options) {
  return CreateType({ [Kind]: "Integer", type: "integer" }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic-from-mapped-key.mjs
function MappedIntrinsicPropertyKey(K, M, options) {
  return {
    [K]: Intrinsic(Literal(K), M, Clone(options))
  };
}
function MappedIntrinsicPropertyKeys(K, M, options) {
  const result = K.reduce((Acc, L) => {
    return { ...Acc, ...MappedIntrinsicPropertyKey(L, M, options) };
  }, {});
  return result;
}
function MappedIntrinsicProperties(T, M, options) {
  return MappedIntrinsicPropertyKeys(T["keys"], M, options);
}
function IntrinsicFromMappedKey(T, M, options) {
  const P = MappedIntrinsicProperties(T, M, options);
  return MappedResult(P);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic.mjs
function ApplyUncapitalize(value) {
  const [first, rest] = [value.slice(0, 1), value.slice(1)];
  return [first.toLowerCase(), rest].join("");
}
function ApplyCapitalize(value) {
  const [first, rest] = [value.slice(0, 1), value.slice(1)];
  return [first.toUpperCase(), rest].join("");
}
function ApplyUppercase(value) {
  return value.toUpperCase();
}
function ApplyLowercase(value) {
  return value.toLowerCase();
}
function FromTemplateLiteral3(schema, mode, options) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  const finite = IsTemplateLiteralExpressionFinite(expression);
  if (!finite)
    return { ...schema, pattern: FromLiteralValue(schema.pattern, mode) };
  const strings = [...TemplateLiteralExpressionGenerate(expression)];
  const literals = strings.map((value) => Literal(value));
  const mapped = FromRest5(literals, mode);
  const union = Union(mapped);
  return TemplateLiteral([union], options);
}
function FromLiteralValue(value, mode) {
  return typeof value === "string" ? mode === "Uncapitalize" ? ApplyUncapitalize(value) : mode === "Capitalize" ? ApplyCapitalize(value) : mode === "Uppercase" ? ApplyUppercase(value) : mode === "Lowercase" ? ApplyLowercase(value) : value : value.toString();
}
function FromRest5(T, M) {
  return T.map((L) => Intrinsic(L, M));
}
function Intrinsic(schema, mode, options = {}) {
  return IsMappedKey(schema) ? IntrinsicFromMappedKey(schema, mode, options) : IsTemplateLiteral(schema) ? FromTemplateLiteral3(schema, mode, options) : IsUnion(schema) ? Union(FromRest5(schema.anyOf, mode), options) : IsLiteral(schema) ? Literal(FromLiteralValue(schema.const, mode), options) : CreateType(schema, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/intrinsic/capitalize.mjs
function Capitalize(T, options = {}) {
  return Intrinsic(T, "Capitalize", options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/intrinsic/lowercase.mjs
function Lowercase(T, options = {}) {
  return Intrinsic(T, "Lowercase", options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/intrinsic/uncapitalize.mjs
function Uncapitalize(T, options = {}) {
  return Intrinsic(T, "Uncapitalize", options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/intrinsic/uppercase.mjs
function Uppercase(T, options = {}) {
  return Intrinsic(T, "Uppercase", options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-result.mjs
function FromProperties11(properties, propertyKeys, options) {
  const result = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
    result[K2] = Omit(properties[K2], propertyKeys, Clone(options));
  return result;
}
function FromMappedResult9(mappedResult, propertyKeys, options) {
  return FromProperties11(mappedResult.properties, propertyKeys, options);
}
function OmitFromMappedResult(mappedResult, propertyKeys, options) {
  const properties = FromMappedResult9(mappedResult, propertyKeys, options);
  return MappedResult(properties);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/omit/omit.mjs
function FromIntersect5(types, propertyKeys) {
  return types.map((type) => OmitResolve(type, propertyKeys));
}
function FromUnion7(types, propertyKeys) {
  return types.map((type) => OmitResolve(type, propertyKeys));
}
function FromProperty2(properties, key) {
  const { [key]: _2, ...R } = properties;
  return R;
}
function FromProperties12(properties, propertyKeys) {
  return propertyKeys.reduce((T, K2) => FromProperty2(T, K2), properties);
}
function FromObject2(properties, propertyKeys) {
  const options = Discard(properties, [TransformKind, "$id", "required", "properties"]);
  const omittedProperties = FromProperties12(properties["properties"], propertyKeys);
  return Object2(omittedProperties, options);
}
function UnionFromPropertyKeys(propertyKeys) {
  const result = propertyKeys.reduce((result2, key) => IsLiteralValue(key) ? [...result2, Literal(key)] : result2, []);
  return Union(result);
}
function OmitResolve(properties, propertyKeys) {
  return IsIntersect(properties) ? Intersect(FromIntersect5(properties.allOf, propertyKeys)) : IsUnion(properties) ? Union(FromUnion7(properties.anyOf, propertyKeys)) : IsObject3(properties) ? FromObject2(properties, propertyKeys) : Object2({});
}
function Omit(type, key, options) {
  const typeKey = IsArray(key) ? UnionFromPropertyKeys(key) : key;
  const propertyKeys = IsSchema(key) ? IndexPropertyKeys(key) : key;
  const isTypeRef = IsRef(type);
  const isKeyRef = IsRef(key);
  return IsMappedResult(type) ? OmitFromMappedResult(type, propertyKeys, options) : IsMappedKey(key) ? OmitFromMappedKey(type, key, options) : isTypeRef && isKeyRef ? Computed("Omit", [type, typeKey], options) : !isTypeRef && isKeyRef ? Computed("Omit", [type, typeKey], options) : isTypeRef && !isKeyRef ? Computed("Omit", [type, typeKey], options) : CreateType({ ...OmitResolve(type, propertyKeys), ...options });
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-key.mjs
function FromPropertyKey2(type, key, options) {
  return { [key]: Omit(type, [key], Clone(options)) };
}
function FromPropertyKeys2(type, propertyKeys, options) {
  return propertyKeys.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey2(type, LK, options) };
  }, {});
}
function FromMappedKey3(type, mappedKey, options) {
  return FromPropertyKeys2(type, mappedKey.keys, options);
}
function OmitFromMappedKey(type, mappedKey, options) {
  const properties = FromMappedKey3(type, mappedKey, options);
  return MappedResult(properties);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-result.mjs
function FromProperties13(properties, propertyKeys, options) {
  const result = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
    result[K2] = Pick(properties[K2], propertyKeys, Clone(options));
  return result;
}
function FromMappedResult10(mappedResult, propertyKeys, options) {
  return FromProperties13(mappedResult.properties, propertyKeys, options);
}
function PickFromMappedResult(mappedResult, propertyKeys, options) {
  const properties = FromMappedResult10(mappedResult, propertyKeys, options);
  return MappedResult(properties);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/pick/pick.mjs
function FromIntersect6(types, propertyKeys) {
  return types.map((type) => PickResolve(type, propertyKeys));
}
function FromUnion8(types, propertyKeys) {
  return types.map((type) => PickResolve(type, propertyKeys));
}
function FromProperties14(properties, propertyKeys) {
  const result = {};
  for (const K2 of propertyKeys)
    if (K2 in properties)
      result[K2] = properties[K2];
  return result;
}
function FromObject3(T, K) {
  const options = Discard(T, [TransformKind, "$id", "required", "properties"]);
  const properties = FromProperties14(T["properties"], K);
  return Object2(properties, options);
}
function UnionFromPropertyKeys2(propertyKeys) {
  const result = propertyKeys.reduce((result2, key) => IsLiteralValue(key) ? [...result2, Literal(key)] : result2, []);
  return Union(result);
}
function PickResolve(properties, propertyKeys) {
  return IsIntersect(properties) ? Intersect(FromIntersect6(properties.allOf, propertyKeys)) : IsUnion(properties) ? Union(FromUnion8(properties.anyOf, propertyKeys)) : IsObject3(properties) ? FromObject3(properties, propertyKeys) : Object2({});
}
function Pick(type, key, options) {
  const typeKey = IsArray(key) ? UnionFromPropertyKeys2(key) : key;
  const propertyKeys = IsSchema(key) ? IndexPropertyKeys(key) : key;
  const isTypeRef = IsRef(type);
  const isKeyRef = IsRef(key);
  return IsMappedResult(type) ? PickFromMappedResult(type, propertyKeys, options) : IsMappedKey(key) ? PickFromMappedKey(type, key, options) : isTypeRef && isKeyRef ? Computed("Pick", [type, typeKey], options) : !isTypeRef && isKeyRef ? Computed("Pick", [type, typeKey], options) : isTypeRef && !isKeyRef ? Computed("Pick", [type, typeKey], options) : CreateType({ ...PickResolve(type, propertyKeys), ...options });
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-key.mjs
function FromPropertyKey3(type, key, options) {
  return {
    [key]: Pick(type, [key], Clone(options))
  };
}
function FromPropertyKeys3(type, propertyKeys, options) {
  return propertyKeys.reduce((result, leftKey) => {
    return { ...result, ...FromPropertyKey3(type, leftKey, options) };
  }, {});
}
function FromMappedKey4(type, mappedKey, options) {
  return FromPropertyKeys3(type, mappedKey.keys, options);
}
function PickFromMappedKey(type, mappedKey, options) {
  const properties = FromMappedKey4(type, mappedKey, options);
  return MappedResult(properties);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/partial/partial.mjs
function FromComputed3(target, parameters) {
  return Computed("Partial", [Computed(target, parameters)]);
}
function FromRef3($ref) {
  return Computed("Partial", [Ref($ref)]);
}
function FromProperties15(properties) {
  const partialProperties = {};
  for (const K of globalThis.Object.getOwnPropertyNames(properties))
    partialProperties[K] = Optional(properties[K]);
  return partialProperties;
}
function FromObject4(T) {
  const options = Discard(T, [TransformKind, "$id", "required", "properties"]);
  const properties = FromProperties15(T["properties"]);
  return Object2(properties, options);
}
function FromRest6(types) {
  return types.map((type) => PartialResolve(type));
}
function PartialResolve(type) {
  return IsComputed(type) ? FromComputed3(type.target, type.parameters) : IsRef(type) ? FromRef3(type.$ref) : IsIntersect(type) ? Intersect(FromRest6(type.allOf)) : IsUnion(type) ? Union(FromRest6(type.anyOf)) : IsObject3(type) ? FromObject4(type) : Object2({});
}
function Partial(type, options) {
  if (IsMappedResult(type)) {
    return PartialFromMappedResult(type, options);
  } else {
    return CreateType({ ...PartialResolve(type), ...options });
  }
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/partial/partial-from-mapped-result.mjs
function FromProperties16(K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Partial(K[K2], Clone(options));
  return Acc;
}
function FromMappedResult11(R, options) {
  return FromProperties16(R.properties, options);
}
function PartialFromMappedResult(R, options) {
  const P = FromMappedResult11(R, options);
  return MappedResult(P);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/record/record.mjs
function RecordCreateFromPattern(pattern, T, options) {
  return CreateType({ [Kind]: "Record", type: "object", patternProperties: { [pattern]: T } }, options);
}
function RecordCreateFromKeys(K, T, options) {
  const result = {};
  for (const K2 of K)
    result[K2] = T;
  return Object2(result, { ...options, [Hint]: "Record" });
}
function FromTemplateLiteralKey(K, T, options) {
  return IsTemplateLiteralFinite(K) ? RecordCreateFromKeys(IndexPropertyKeys(K), T, options) : RecordCreateFromPattern(K.pattern, T, options);
}
function FromUnionKey(key, type, options) {
  return RecordCreateFromKeys(IndexPropertyKeys(Union(key)), type, options);
}
function FromLiteralKey(key, type, options) {
  return RecordCreateFromKeys([key.toString()], type, options);
}
function FromRegExpKey(key, type, options) {
  return RecordCreateFromPattern(key.source, type, options);
}
function FromStringKey(key, type, options) {
  const pattern = IsUndefined(key.pattern) ? PatternStringExact : key.pattern;
  return RecordCreateFromPattern(pattern, type, options);
}
function FromAnyKey(_2, type, options) {
  return RecordCreateFromPattern(PatternStringExact, type, options);
}
function FromNeverKey(_key, type, options) {
  return RecordCreateFromPattern(PatternNeverExact, type, options);
}
function FromIntegerKey(_key, type, options) {
  return RecordCreateFromPattern(PatternNumberExact, type, options);
}
function FromNumberKey(_2, type, options) {
  return RecordCreateFromPattern(PatternNumberExact, type, options);
}
function Record(key, type, options = {}) {
  return IsComputed(type) ? Computed("Record", [key, Computed(type.target, type.parameters)], options) : IsComputed(key) ? Computed("Record", [Computed(type.target, type.parameters), type], options) : IsRef(key) ? Computed("Record", [Ref(key.$ref), type]) : IsUnion(key) ? FromUnionKey(key.anyOf, type, options) : IsTemplateLiteral(key) ? FromTemplateLiteralKey(key, type, options) : IsLiteral(key) ? FromLiteralKey(key.const, type, options) : IsInteger2(key) ? FromIntegerKey(key, type, options) : IsNumber3(key) ? FromNumberKey(key, type, options) : IsRegExp2(key) ? FromRegExpKey(key, type, options) : IsString3(key) ? FromStringKey(key, type, options) : IsAny(key) ? FromAnyKey(key, type, options) : IsNever(key) ? FromNeverKey(key, type, options) : Never(options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/required/required.mjs
function FromComputed4(target, parameters) {
  return Computed("Required", [Computed(target, parameters)]);
}
function FromRef4($ref) {
  return Computed("Required", [Ref($ref)]);
}
function FromProperties17(properties) {
  const requiredProperties = {};
  for (const K of globalThis.Object.getOwnPropertyNames(properties))
    requiredProperties[K] = Discard(properties[K], [OptionalKind]);
  return requiredProperties;
}
function FromObject5(type) {
  const options = Discard(type, [TransformKind, "$id", "required", "properties"]);
  const properties = FromProperties17(type["properties"]);
  return Object2(properties, options);
}
function FromRest7(types) {
  return types.map((type) => RequiredResolve(type));
}
function RequiredResolve(type) {
  return IsComputed(type) ? FromComputed4(type.target, type.parameters) : IsRef(type) ? FromRef4(type.$ref) : IsIntersect(type) ? Intersect(FromRest7(type.allOf)) : IsUnion(type) ? Union(FromRest7(type.anyOf)) : IsObject3(type) ? FromObject5(type) : Object2({});
}
function Required(type, options) {
  if (IsMappedResult(type)) {
    return RequiredFromMappedResult(type, options);
  } else {
    return CreateType({ ...RequiredResolve(type), ...options });
  }
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/required/required-from-mapped-result.mjs
function FromProperties18(P, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Required(P[K2], options);
  return Acc;
}
function FromMappedResult12(R, options) {
  return FromProperties18(R.properties, options);
}
function RequiredFromMappedResult(R, options) {
  const P = FromMappedResult12(R, options);
  return MappedResult(P);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/module/compute.mjs
function DerefParameters(moduleProperties, types) {
  return types.map((type) => {
    return IsRef(type) ? Deref(moduleProperties, type.$ref) : FromType(moduleProperties, type);
  });
}
function Deref(moduleProperties, ref) {
  return ref in moduleProperties ? IsRef(moduleProperties[ref]) ? Deref(moduleProperties, moduleProperties[ref].$ref) : FromType(moduleProperties, moduleProperties[ref]) : Never();
}
function FromAwaited(parameters) {
  return Awaited(parameters[0]);
}
function FromIndex(parameters) {
  return Index(parameters[0], parameters[1]);
}
function FromKeyOf(parameters) {
  return KeyOf(parameters[0]);
}
function FromPartial(parameters) {
  return Partial(parameters[0]);
}
function FromOmit(parameters) {
  return Omit(parameters[0], parameters[1]);
}
function FromPick(parameters) {
  return Pick(parameters[0], parameters[1]);
}
function FromRecord2(parameters) {
  return Record(parameters[0], parameters[1]);
}
function FromRequired(parameters) {
  return Required(parameters[0]);
}
function FromComputed5(moduleProperties, target, parameters) {
  const dereferenced = DerefParameters(moduleProperties, parameters);
  return target === "Awaited" ? FromAwaited(dereferenced) : target === "Index" ? FromIndex(dereferenced) : target === "KeyOf" ? FromKeyOf(dereferenced) : target === "Partial" ? FromPartial(dereferenced) : target === "Omit" ? FromOmit(dereferenced) : target === "Pick" ? FromPick(dereferenced) : target === "Record" ? FromRecord2(dereferenced) : target === "Required" ? FromRequired(dereferenced) : Never();
}
function FromObject6(moduleProperties, properties) {
  return Object2(globalThis.Object.keys(properties).reduce((result, key) => {
    return { ...result, [key]: FromType(moduleProperties, properties[key]) };
  }, {}));
}
function FromConstructor2(moduleProperties, parameters, instanceType) {
  return Constructor(FromRest8(moduleProperties, parameters), FromType(moduleProperties, instanceType));
}
function FromFunction2(moduleProperties, parameters, returnType) {
  return Function2(FromRest8(moduleProperties, parameters), FromType(moduleProperties, returnType));
}
function FromTuple4(moduleProperties, types) {
  return Tuple(FromRest8(moduleProperties, types));
}
function FromIntersect7(moduleProperties, types) {
  return Intersect(FromRest8(moduleProperties, types));
}
function FromUnion9(moduleProperties, types) {
  return Union(FromRest8(moduleProperties, types));
}
function FromArray5(moduleProperties, type) {
  return Array2(FromType(moduleProperties, type));
}
function FromAsyncIterator2(moduleProperties, type) {
  return AsyncIterator(FromType(moduleProperties, type));
}
function FromIterator2(moduleProperties, type) {
  return Iterator(FromType(moduleProperties, type));
}
function FromRest8(moduleProperties, types) {
  return types.map((type) => FromType(moduleProperties, type));
}
function FromType(moduleProperties, type) {
  return IsOptional(type) ? CreateType(FromType(moduleProperties, Discard(type, [OptionalKind])), type) : IsReadonly(type) ? CreateType(FromType(moduleProperties, Discard(type, [ReadonlyKind])), type) : IsArray3(type) ? CreateType(FromArray5(moduleProperties, type.items), type) : IsAsyncIterator3(type) ? CreateType(FromAsyncIterator2(moduleProperties, type.items), type) : IsComputed(type) ? CreateType(FromComputed5(moduleProperties, type.target, type.parameters)) : IsConstructor(type) ? CreateType(FromConstructor2(moduleProperties, type.parameters, type.returns), type) : IsFunction3(type) ? CreateType(FromFunction2(moduleProperties, type.parameters, type.returns), type) : IsIntersect(type) ? CreateType(FromIntersect7(moduleProperties, type.allOf), type) : IsIterator3(type) ? CreateType(FromIterator2(moduleProperties, type.items), type) : IsObject3(type) ? CreateType(FromObject6(moduleProperties, type.properties), type) : IsTuple(type) ? CreateType(FromTuple4(moduleProperties, type.items || []), type) : IsUnion(type) ? CreateType(FromUnion9(moduleProperties, type.anyOf), type) : type;
}
function ComputeType(moduleProperties, key) {
  return key in moduleProperties ? FromType(moduleProperties, moduleProperties[key]) : Never();
}
function ComputeModuleProperties(moduleProperties) {
  return globalThis.Object.getOwnPropertyNames(moduleProperties).reduce((result, key) => {
    return { ...result, [key]: ComputeType(moduleProperties, key) };
  }, {});
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/module/module.mjs
class TModule {
  constructor($defs) {
    const computed = ComputeModuleProperties($defs);
    const identified = this.WithIdentifiers(computed);
    this.$defs = identified;
  }
  Import(key, options) {
    const $defs = { ...this.$defs, [key]: CreateType(this.$defs[key], options) };
    return CreateType({ [Kind]: "Import", $defs, $ref: key });
  }
  WithIdentifiers($defs) {
    return globalThis.Object.getOwnPropertyNames($defs).reduce((result, key) => {
      return { ...result, [key]: { ...$defs[key], $id: key } };
    }, {});
  }
}
function Module(properties) {
  return new TModule(properties);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/not/not.mjs
function Not2(type, options) {
  return CreateType({ [Kind]: "Not", not: type }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/parameters/parameters.mjs
function Parameters(schema, options) {
  return Tuple(schema.parameters, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/readonly-optional/readonly-optional.mjs
function ReadonlyOptional(schema) {
  return Readonly(Optional(schema));
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/recursive/recursive.mjs
var Ordinal = 0;
function Recursive(callback, options = {}) {
  if (IsUndefined(options.$id))
    options.$id = `T${Ordinal++}`;
  const thisType = CloneType(callback({ [Kind]: "This", $ref: `${options.$id}` }));
  thisType.$id = options.$id;
  return CreateType({ [Hint]: "Recursive", ...thisType }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/regexp/regexp.mjs
function RegExp2(unresolved, options) {
  const expr = IsString(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;
  return CreateType({ [Kind]: "RegExp", type: "RegExp", source: expr.source, flags: expr.flags }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/rest/rest.mjs
function RestResolve(T) {
  return IsIntersect(T) ? T.allOf : IsUnion(T) ? T.anyOf : IsTuple(T) ? T.items ?? [] : [];
}
function Rest(T) {
  return RestResolve(T);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/return-type/return-type.mjs
function ReturnType(schema, options) {
  return CreateType(schema.returns, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/transform/transform.mjs
class TransformDecodeBuilder {
  constructor(schema) {
    this.schema = schema;
  }
  Decode(decode) {
    return new TransformEncodeBuilder(this.schema, decode);
  }
}

class TransformEncodeBuilder {
  constructor(schema, decode) {
    this.schema = schema;
    this.decode = decode;
  }
  EncodeTransform(encode, schema) {
    const Encode = (value) => schema[TransformKind].Encode(encode(value));
    const Decode = (value) => this.decode(schema[TransformKind].Decode(value));
    const Codec = { Encode, Decode };
    return { ...schema, [TransformKind]: Codec };
  }
  EncodeSchema(encode, schema) {
    const Codec = { Decode: this.decode, Encode: encode };
    return { ...schema, [TransformKind]: Codec };
  }
  Encode(encode) {
    return IsTransform(this.schema) ? this.EncodeTransform(encode, this.schema) : this.EncodeSchema(encode, this.schema);
  }
}
function Transform(schema) {
  return new TransformDecodeBuilder(schema);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/unsafe/unsafe.mjs
function Unsafe(options = {}) {
  return CreateType({ [Kind]: options[Kind] ?? "Unsafe" }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/void/void.mjs
function Void(options) {
  return CreateType({ [Kind]: "Void", type: "void" }, options);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/type/type.mjs
var exports_type3 = {};
__export(exports_type3, {
  Void: () => Void,
  Uppercase: () => Uppercase,
  Unsafe: () => Unsafe,
  Unknown: () => Unknown,
  Union: () => Union,
  Undefined: () => Undefined,
  Uncapitalize: () => Uncapitalize,
  Uint8Array: () => Uint8Array2,
  Tuple: () => Tuple,
  Transform: () => Transform,
  TemplateLiteral: () => TemplateLiteral,
  Symbol: () => Symbol2,
  String: () => String2,
  ReturnType: () => ReturnType,
  Rest: () => Rest,
  Required: () => Required,
  RegExp: () => RegExp2,
  Ref: () => Ref,
  Recursive: () => Recursive,
  Record: () => Record,
  ReadonlyOptional: () => ReadonlyOptional,
  Readonly: () => Readonly,
  Promise: () => Promise2,
  Pick: () => Pick,
  Partial: () => Partial,
  Parameters: () => Parameters,
  Optional: () => Optional,
  Omit: () => Omit,
  Object: () => Object2,
  Number: () => Number2,
  Null: () => Null,
  Not: () => Not2,
  Never: () => Never,
  Module: () => Module,
  Mapped: () => Mapped,
  Lowercase: () => Lowercase,
  Literal: () => Literal,
  KeyOf: () => KeyOf,
  Iterator: () => Iterator,
  Intersect: () => Intersect,
  Integer: () => Integer,
  InstanceType: () => InstanceType,
  Index: () => Index,
  Function: () => Function2,
  Extract: () => Extract,
  Extends: () => Extends,
  Exclude: () => Exclude,
  Enum: () => Enum,
  Date: () => Date2,
  ConstructorParameters: () => ConstructorParameters,
  Constructor: () => Constructor,
  Const: () => Const,
  Composite: () => Composite,
  Capitalize: () => Capitalize,
  Boolean: () => Boolean2,
  BigInt: () => BigInt2,
  Awaited: () => Awaited,
  AsyncIterator: () => AsyncIterator,
  Array: () => Array2,
  Any: () => Any
});

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/type/type/index.mjs
var Type = exports_type3;

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/system/system.mjs
class TypeSystemDuplicateTypeKind extends TypeBoxError {
  constructor(kind) {
    super(`Duplicate type kind '${kind}' detected`);
  }
}

class TypeSystemDuplicateFormat extends TypeBoxError {
  constructor(kind) {
    super(`Duplicate string format '${kind}' detected`);
  }
}
var TypeSystem;
(function(TypeSystem2) {
  function Type2(kind, check) {
    if (exports_type2.Has(kind))
      throw new TypeSystemDuplicateTypeKind(kind);
    exports_type2.Set(kind, check);
    return (options = {}) => Unsafe({ ...options, [Kind]: kind });
  }
  TypeSystem2.Type = Type2;
  function Format(format, check) {
    if (exports_format.Has(format))
      throw new TypeSystemDuplicateFormat(format);
    exports_format.Set(format, check);
    return format;
  }
  TypeSystem2.Format = Format;
})(TypeSystem || (TypeSystem = {}));

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/errors/function.mjs
function DefaultErrorFunction(error) {
  switch (error.errorType) {
    case ValueErrorType.ArrayContains:
      return "Expected array to contain at least one matching value";
    case ValueErrorType.ArrayMaxContains:
      return `Expected array to contain no more than ${error.schema.maxContains} matching values`;
    case ValueErrorType.ArrayMinContains:
      return `Expected array to contain at least ${error.schema.minContains} matching values`;
    case ValueErrorType.ArrayMaxItems:
      return `Expected array length to be less or equal to ${error.schema.maxItems}`;
    case ValueErrorType.ArrayMinItems:
      return `Expected array length to be greater or equal to ${error.schema.minItems}`;
    case ValueErrorType.ArrayUniqueItems:
      return "Expected array elements to be unique";
    case ValueErrorType.Array:
      return "Expected array";
    case ValueErrorType.AsyncIterator:
      return "Expected AsyncIterator";
    case ValueErrorType.BigIntExclusiveMaximum:
      return `Expected bigint to be less than ${error.schema.exclusiveMaximum}`;
    case ValueErrorType.BigIntExclusiveMinimum:
      return `Expected bigint to be greater than ${error.schema.exclusiveMinimum}`;
    case ValueErrorType.BigIntMaximum:
      return `Expected bigint to be less or equal to ${error.schema.maximum}`;
    case ValueErrorType.BigIntMinimum:
      return `Expected bigint to be greater or equal to ${error.schema.minimum}`;
    case ValueErrorType.BigIntMultipleOf:
      return `Expected bigint to be a multiple of ${error.schema.multipleOf}`;
    case ValueErrorType.BigInt:
      return "Expected bigint";
    case ValueErrorType.Boolean:
      return "Expected boolean";
    case ValueErrorType.DateExclusiveMinimumTimestamp:
      return `Expected Date timestamp to be greater than ${error.schema.exclusiveMinimumTimestamp}`;
    case ValueErrorType.DateExclusiveMaximumTimestamp:
      return `Expected Date timestamp to be less than ${error.schema.exclusiveMaximumTimestamp}`;
    case ValueErrorType.DateMinimumTimestamp:
      return `Expected Date timestamp to be greater or equal to ${error.schema.minimumTimestamp}`;
    case ValueErrorType.DateMaximumTimestamp:
      return `Expected Date timestamp to be less or equal to ${error.schema.maximumTimestamp}`;
    case ValueErrorType.DateMultipleOfTimestamp:
      return `Expected Date timestamp to be a multiple of ${error.schema.multipleOfTimestamp}`;
    case ValueErrorType.Date:
      return "Expected Date";
    case ValueErrorType.Function:
      return "Expected function";
    case ValueErrorType.IntegerExclusiveMaximum:
      return `Expected integer to be less than ${error.schema.exclusiveMaximum}`;
    case ValueErrorType.IntegerExclusiveMinimum:
      return `Expected integer to be greater than ${error.schema.exclusiveMinimum}`;
    case ValueErrorType.IntegerMaximum:
      return `Expected integer to be less or equal to ${error.schema.maximum}`;
    case ValueErrorType.IntegerMinimum:
      return `Expected integer to be greater or equal to ${error.schema.minimum}`;
    case ValueErrorType.IntegerMultipleOf:
      return `Expected integer to be a multiple of ${error.schema.multipleOf}`;
    case ValueErrorType.Integer:
      return "Expected integer";
    case ValueErrorType.IntersectUnevaluatedProperties:
      return "Unexpected property";
    case ValueErrorType.Intersect:
      return "Expected all values to match";
    case ValueErrorType.Iterator:
      return "Expected Iterator";
    case ValueErrorType.Literal:
      return `Expected ${typeof error.schema.const === "string" ? `'${error.schema.const}'` : error.schema.const}`;
    case ValueErrorType.Never:
      return "Never";
    case ValueErrorType.Not:
      return "Value should not match";
    case ValueErrorType.Null:
      return "Expected null";
    case ValueErrorType.NumberExclusiveMaximum:
      return `Expected number to be less than ${error.schema.exclusiveMaximum}`;
    case ValueErrorType.NumberExclusiveMinimum:
      return `Expected number to be greater than ${error.schema.exclusiveMinimum}`;
    case ValueErrorType.NumberMaximum:
      return `Expected number to be less or equal to ${error.schema.maximum}`;
    case ValueErrorType.NumberMinimum:
      return `Expected number to be greater or equal to ${error.schema.minimum}`;
    case ValueErrorType.NumberMultipleOf:
      return `Expected number to be a multiple of ${error.schema.multipleOf}`;
    case ValueErrorType.Number:
      return "Expected number";
    case ValueErrorType.Object:
      return "Expected object";
    case ValueErrorType.ObjectAdditionalProperties:
      return "Unexpected property";
    case ValueErrorType.ObjectMaxProperties:
      return `Expected object to have no more than ${error.schema.maxProperties} properties`;
    case ValueErrorType.ObjectMinProperties:
      return `Expected object to have at least ${error.schema.minProperties} properties`;
    case ValueErrorType.ObjectRequiredProperty:
      return "Expected required property";
    case ValueErrorType.Promise:
      return "Expected Promise";
    case ValueErrorType.RegExp:
      return "Expected string to match regular expression";
    case ValueErrorType.StringFormatUnknown:
      return `Unknown format '${error.schema.format}'`;
    case ValueErrorType.StringFormat:
      return `Expected string to match '${error.schema.format}' format`;
    case ValueErrorType.StringMaxLength:
      return `Expected string length less or equal to ${error.schema.maxLength}`;
    case ValueErrorType.StringMinLength:
      return `Expected string length greater or equal to ${error.schema.minLength}`;
    case ValueErrorType.StringPattern:
      return `Expected string to match '${error.schema.pattern}'`;
    case ValueErrorType.String:
      return "Expected string";
    case ValueErrorType.Symbol:
      return "Expected symbol";
    case ValueErrorType.TupleLength:
      return `Expected tuple to have ${error.schema.maxItems || 0} elements`;
    case ValueErrorType.Tuple:
      return "Expected tuple";
    case ValueErrorType.Uint8ArrayMaxByteLength:
      return `Expected byte length less or equal to ${error.schema.maxByteLength}`;
    case ValueErrorType.Uint8ArrayMinByteLength:
      return `Expected byte length greater or equal to ${error.schema.minByteLength}`;
    case ValueErrorType.Uint8Array:
      return "Expected Uint8Array";
    case ValueErrorType.Undefined:
      return "Expected undefined";
    case ValueErrorType.Union:
      return "Expected union value";
    case ValueErrorType.Void:
      return "Expected void";
    case ValueErrorType.Kind:
      return `Expected kind '${error.schema[Kind]}'`;
    default:
      return "Unknown error type";
  }
}
var errorFunction = DefaultErrorFunction;
function GetErrorFunction() {
  return errorFunction;
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/value/deref/deref.mjs
class TypeDereferenceError extends TypeBoxError {
  constructor(schema) {
    super(`Unable to dereference schema with $id '${schema.$ref}'`);
    this.schema = schema;
  }
}
function Resolve(schema, references) {
  const target = references.find((target2) => target2.$id === schema.$ref);
  if (target === undefined)
    throw new TypeDereferenceError(schema);
  return Deref2(target, references);
}
function Pushref(schema, references) {
  if (!IsString2(schema.$id) || references.some((target) => target.$id === schema.$id))
    return references;
  references.push(schema);
  return references;
}
function Deref2(schema, references) {
  return schema[Kind] === "This" || schema[Kind] === "Ref" ? Resolve(schema, references) : schema;
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/value/hash/hash.mjs
class ValueHashError extends TypeBoxError {
  constructor(value) {
    super(`Unable to hash value`);
    this.value = value;
  }
}
var ByteMarker;
(function(ByteMarker2) {
  ByteMarker2[ByteMarker2["Undefined"] = 0] = "Undefined";
  ByteMarker2[ByteMarker2["Null"] = 1] = "Null";
  ByteMarker2[ByteMarker2["Boolean"] = 2] = "Boolean";
  ByteMarker2[ByteMarker2["Number"] = 3] = "Number";
  ByteMarker2[ByteMarker2["String"] = 4] = "String";
  ByteMarker2[ByteMarker2["Object"] = 5] = "Object";
  ByteMarker2[ByteMarker2["Array"] = 6] = "Array";
  ByteMarker2[ByteMarker2["Date"] = 7] = "Date";
  ByteMarker2[ByteMarker2["Uint8Array"] = 8] = "Uint8Array";
  ByteMarker2[ByteMarker2["Symbol"] = 9] = "Symbol";
  ByteMarker2[ByteMarker2["BigInt"] = 10] = "BigInt";
})(ByteMarker || (ByteMarker = {}));
var Accumulator = BigInt("14695981039346656037");
var [Prime, Size] = [BigInt("1099511628211"), BigInt("18446744073709551616")];
var Bytes = Array.from({ length: 256 }).map((_2, i) => BigInt(i));
var F64 = new Float64Array(1);
var F64In = new DataView(F64.buffer);
var F64Out = new Uint8Array(F64.buffer);
function* NumberToBytes(value) {
  const byteCount = value === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value) + 1) / 8);
  for (let i = 0;i < byteCount; i++) {
    yield value >> 8 * (byteCount - 1 - i) & 255;
  }
}
function ArrayType2(value) {
  FNV1A64(ByteMarker.Array);
  for (const item of value) {
    Visit4(item);
  }
}
function BooleanType(value) {
  FNV1A64(ByteMarker.Boolean);
  FNV1A64(value ? 1 : 0);
}
function BigIntType(value) {
  FNV1A64(ByteMarker.BigInt);
  F64In.setBigInt64(0, value);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
}
function DateType2(value) {
  FNV1A64(ByteMarker.Date);
  Visit4(value.getTime());
}
function NullType(value) {
  FNV1A64(ByteMarker.Null);
}
function NumberType(value) {
  FNV1A64(ByteMarker.Number);
  F64In.setFloat64(0, value);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
}
function ObjectType2(value) {
  FNV1A64(ByteMarker.Object);
  for (const key of globalThis.Object.getOwnPropertyNames(value).sort()) {
    Visit4(key);
    Visit4(value[key]);
  }
}
function StringType(value) {
  FNV1A64(ByteMarker.String);
  for (let i = 0;i < value.length; i++) {
    for (const byte of NumberToBytes(value.charCodeAt(i))) {
      FNV1A64(byte);
    }
  }
}
function SymbolType(value) {
  FNV1A64(ByteMarker.Symbol);
  Visit4(value.description);
}
function Uint8ArrayType2(value) {
  FNV1A64(ByteMarker.Uint8Array);
  for (let i = 0;i < value.length; i++) {
    FNV1A64(value[i]);
  }
}
function UndefinedType(value) {
  return FNV1A64(ByteMarker.Undefined);
}
function Visit4(value) {
  if (IsArray2(value))
    return ArrayType2(value);
  if (IsBoolean2(value))
    return BooleanType(value);
  if (IsBigInt2(value))
    return BigIntType(value);
  if (IsDate2(value))
    return DateType2(value);
  if (IsNull2(value))
    return NullType(value);
  if (IsNumber2(value))
    return NumberType(value);
  if (IsObject2(value))
    return ObjectType2(value);
  if (IsString2(value))
    return StringType(value);
  if (IsSymbol2(value))
    return SymbolType(value);
  if (IsUint8Array2(value))
    return Uint8ArrayType2(value);
  if (IsUndefined2(value))
    return UndefinedType(value);
  throw new ValueHashError(value);
}
function FNV1A64(byte) {
  Accumulator = Accumulator ^ Bytes[byte];
  Accumulator = Accumulator * Prime % Size;
}
function Hash(value) {
  Accumulator = BigInt("14695981039346656037");
  Visit4(value);
  return Accumulator;
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/value/check/check.mjs
class ValueCheckUnknownTypeError extends TypeBoxError {
  constructor(schema) {
    super(`Unknown type`);
    this.schema = schema;
  }
}
function IsAnyOrUnknown(schema) {
  return schema[Kind] === "Any" || schema[Kind] === "Unknown";
}
function IsDefined(value) {
  return value !== undefined;
}
function FromAny2(schema, references, value) {
  return true;
}
function FromArray6(schema, references, value) {
  if (!IsArray2(value))
    return false;
  if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {
    return false;
  }
  if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {
    return false;
  }
  if (!value.every((value2) => Visit5(schema.items, references, value2))) {
    return false;
  }
  if (schema.uniqueItems === true && !function() {
    const set2 = new Set;
    for (const element of value) {
      const hashed = Hash(element);
      if (set2.has(hashed)) {
        return false;
      } else {
        set2.add(hashed);
      }
    }
    return true;
  }()) {
    return false;
  }
  if (!(IsDefined(schema.contains) || IsNumber2(schema.minContains) || IsNumber2(schema.maxContains))) {
    return true;
  }
  const containsSchema = IsDefined(schema.contains) ? schema.contains : Never();
  const containsCount = value.reduce((acc, value2) => Visit5(containsSchema, references, value2) ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    return false;
  }
  if (IsNumber2(schema.minContains) && containsCount < schema.minContains) {
    return false;
  }
  if (IsNumber2(schema.maxContains) && containsCount > schema.maxContains) {
    return false;
  }
  return true;
}
function FromAsyncIterator3(schema, references, value) {
  return IsAsyncIterator2(value);
}
function FromBigInt2(schema, references, value) {
  if (!IsBigInt2(value))
    return false;
  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
    return false;
  }
  return true;
}
function FromBoolean2(schema, references, value) {
  return IsBoolean2(value);
}
function FromConstructor3(schema, references, value) {
  return Visit5(schema.returns, references, value.prototype);
}
function FromDate2(schema, references, value) {
  if (!IsDate2(value))
    return false;
  if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
    return false;
  }
  return true;
}
function FromFunction3(schema, references, value) {
  return IsFunction2(value);
}
function FromImport(schema, references, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit5(target, [...references, ...definitions], value);
}
function FromInteger2(schema, references, value) {
  if (!IsInteger(value)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    return false;
  }
  return true;
}
function FromIntersect8(schema, references, value) {
  const check1 = schema.allOf.every((schema2) => Visit5(schema2, references, value));
  if (schema.unevaluatedProperties === false) {
    const keyPattern = new RegExp(KeyOfPattern(schema));
    const check2 = Object.getOwnPropertyNames(value).every((key) => keyPattern.test(key));
    return check1 && check2;
  } else if (IsSchema(schema.unevaluatedProperties)) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    const check2 = Object.getOwnPropertyNames(value).every((key) => keyCheck.test(key) || Visit5(schema.unevaluatedProperties, references, value[key]));
    return check1 && check2;
  } else {
    return check1;
  }
}
function FromIterator3(schema, references, value) {
  return IsIterator2(value);
}
function FromLiteral3(schema, references, value) {
  return value === schema.const;
}
function FromNever2(schema, references, value) {
  return false;
}
function FromNot2(schema, references, value) {
  return !Visit5(schema.not, references, value);
}
function FromNull2(schema, references, value) {
  return IsNull2(value);
}
function FromNumber2(schema, references, value) {
  if (!TypeSystemPolicy.IsNumberLike(value))
    return false;
  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    return false;
  }
  return true;
}
function FromObject7(schema, references, value) {
  if (!TypeSystemPolicy.IsObjectLike(value))
    return false;
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    return false;
  }
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      if (!Visit5(property, references, value[knownKey])) {
        return false;
      }
      if ((ExtendsUndefinedCheck(property) || IsAnyOrUnknown(property)) && !(knownKey in value)) {
        return false;
      }
    } else {
      if (TypeSystemPolicy.IsExactOptionalProperty(value, knownKey) && !Visit5(property, references, value[knownKey])) {
        return false;
      }
    }
  }
  if (schema.additionalProperties === false) {
    const valueKeys = Object.getOwnPropertyNames(value);
    if (schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {
      return true;
    } else {
      return valueKeys.every((valueKey) => knownKeys.includes(valueKey));
    }
  } else if (typeof schema.additionalProperties === "object") {
    const valueKeys = Object.getOwnPropertyNames(value);
    return valueKeys.every((key) => knownKeys.includes(key) || Visit5(schema.additionalProperties, references, value[key]));
  } else {
    return true;
  }
}
function FromPromise3(schema, references, value) {
  return IsPromise(value);
}
function FromRecord3(schema, references, value) {
  if (!TypeSystemPolicy.IsRecordLike(value)) {
    return false;
  }
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    return false;
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  const check1 = Object.entries(value).every(([key, value2]) => {
    return regex.test(key) ? Visit5(patternSchema, references, value2) : true;
  });
  const check2 = typeof schema.additionalProperties === "object" ? Object.entries(value).every(([key, value2]) => {
    return !regex.test(key) ? Visit5(schema.additionalProperties, references, value2) : true;
  }) : true;
  const check3 = schema.additionalProperties === false ? Object.getOwnPropertyNames(value).every((key) => {
    return regex.test(key);
  }) : true;
  return check1 && check2 && check3;
}
function FromRef5(schema, references, value) {
  return Visit5(Deref2(schema, references), references, value);
}
function FromRegExp2(schema, references, value) {
  const regex = new RegExp(schema.source, schema.flags);
  if (IsDefined(schema.minLength)) {
    if (!(value.length >= schema.minLength))
      return false;
  }
  if (IsDefined(schema.maxLength)) {
    if (!(value.length <= schema.maxLength))
      return false;
  }
  return regex.test(value);
}
function FromString2(schema, references, value) {
  if (!IsString2(value)) {
    return false;
  }
  if (IsDefined(schema.minLength)) {
    if (!(value.length >= schema.minLength))
      return false;
  }
  if (IsDefined(schema.maxLength)) {
    if (!(value.length <= schema.maxLength))
      return false;
  }
  if (IsDefined(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value))
      return false;
  }
  if (IsDefined(schema.format)) {
    if (!exports_format.Has(schema.format))
      return false;
    const func = exports_format.Get(schema.format);
    return func(value);
  }
  return true;
}
function FromSymbol2(schema, references, value) {
  return IsSymbol2(value);
}
function FromTemplateLiteral4(schema, references, value) {
  return IsString2(value) && new RegExp(schema.pattern).test(value);
}
function FromThis(schema, references, value) {
  return Visit5(Deref2(schema, references), references, value);
}
function FromTuple5(schema, references, value) {
  if (!IsArray2(value)) {
    return false;
  }
  if (schema.items === undefined && !(value.length === 0)) {
    return false;
  }
  if (!(value.length === schema.maxItems)) {
    return false;
  }
  if (!schema.items) {
    return true;
  }
  for (let i = 0;i < schema.items.length; i++) {
    if (!Visit5(schema.items[i], references, value[i]))
      return false;
  }
  return true;
}
function FromUndefined2(schema, references, value) {
  return IsUndefined2(value);
}
function FromUnion10(schema, references, value) {
  return schema.anyOf.some((inner) => Visit5(inner, references, value));
}
function FromUint8Array2(schema, references, value) {
  if (!IsUint8Array2(value)) {
    return false;
  }
  if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
    return false;
  }
  if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
    return false;
  }
  return true;
}
function FromUnknown2(schema, references, value) {
  return true;
}
function FromVoid2(schema, references, value) {
  return TypeSystemPolicy.IsVoidLike(value);
}
function FromKind(schema, references, value) {
  if (!exports_type2.Has(schema[Kind]))
    return false;
  const func = exports_type2.Get(schema[Kind]);
  return func(schema, value);
}
function Visit5(schema, references, value) {
  const references_ = IsDefined(schema.$id) ? Pushref(schema, references) : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny2(schema_, references_, value);
    case "Array":
      return FromArray6(schema_, references_, value);
    case "AsyncIterator":
      return FromAsyncIterator3(schema_, references_, value);
    case "BigInt":
      return FromBigInt2(schema_, references_, value);
    case "Boolean":
      return FromBoolean2(schema_, references_, value);
    case "Constructor":
      return FromConstructor3(schema_, references_, value);
    case "Date":
      return FromDate2(schema_, references_, value);
    case "Function":
      return FromFunction3(schema_, references_, value);
    case "Import":
      return FromImport(schema_, references_, value);
    case "Integer":
      return FromInteger2(schema_, references_, value);
    case "Intersect":
      return FromIntersect8(schema_, references_, value);
    case "Iterator":
      return FromIterator3(schema_, references_, value);
    case "Literal":
      return FromLiteral3(schema_, references_, value);
    case "Never":
      return FromNever2(schema_, references_, value);
    case "Not":
      return FromNot2(schema_, references_, value);
    case "Null":
      return FromNull2(schema_, references_, value);
    case "Number":
      return FromNumber2(schema_, references_, value);
    case "Object":
      return FromObject7(schema_, references_, value);
    case "Promise":
      return FromPromise3(schema_, references_, value);
    case "Record":
      return FromRecord3(schema_, references_, value);
    case "Ref":
      return FromRef5(schema_, references_, value);
    case "RegExp":
      return FromRegExp2(schema_, references_, value);
    case "String":
      return FromString2(schema_, references_, value);
    case "Symbol":
      return FromSymbol2(schema_, references_, value);
    case "TemplateLiteral":
      return FromTemplateLiteral4(schema_, references_, value);
    case "This":
      return FromThis(schema_, references_, value);
    case "Tuple":
      return FromTuple5(schema_, references_, value);
    case "Undefined":
      return FromUndefined2(schema_, references_, value);
    case "Union":
      return FromUnion10(schema_, references_, value);
    case "Uint8Array":
      return FromUint8Array2(schema_, references_, value);
    case "Unknown":
      return FromUnknown2(schema_, references_, value);
    case "Void":
      return FromVoid2(schema_, references_, value);
    default:
      if (!exports_type2.Has(schema_[Kind]))
        throw new ValueCheckUnknownTypeError(schema_);
      return FromKind(schema_, references_, value);
  }
}
function Check(...args) {
  return args.length === 3 ? Visit5(args[0], args[1], args[2]) : Visit5(args[0], [], args[1]);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/errors/errors.mjs
var ValueErrorType;
(function(ValueErrorType2) {
  ValueErrorType2[ValueErrorType2["ArrayContains"] = 0] = "ArrayContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxContains"] = 1] = "ArrayMaxContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxItems"] = 2] = "ArrayMaxItems";
  ValueErrorType2[ValueErrorType2["ArrayMinContains"] = 3] = "ArrayMinContains";
  ValueErrorType2[ValueErrorType2["ArrayMinItems"] = 4] = "ArrayMinItems";
  ValueErrorType2[ValueErrorType2["ArrayUniqueItems"] = 5] = "ArrayUniqueItems";
  ValueErrorType2[ValueErrorType2["Array"] = 6] = "Array";
  ValueErrorType2[ValueErrorType2["AsyncIterator"] = 7] = "AsyncIterator";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMaximum"] = 8] = "BigIntExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMinimum"] = 9] = "BigIntExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMaximum"] = 10] = "BigIntMaximum";
  ValueErrorType2[ValueErrorType2["BigIntMinimum"] = 11] = "BigIntMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMultipleOf"] = 12] = "BigIntMultipleOf";
  ValueErrorType2[ValueErrorType2["BigInt"] = 13] = "BigInt";
  ValueErrorType2[ValueErrorType2["Boolean"] = 14] = "Boolean";
  ValueErrorType2[ValueErrorType2["DateExclusiveMaximumTimestamp"] = 15] = "DateExclusiveMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateExclusiveMinimumTimestamp"] = 16] = "DateExclusiveMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMaximumTimestamp"] = 17] = "DateMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMinimumTimestamp"] = 18] = "DateMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMultipleOfTimestamp"] = 19] = "DateMultipleOfTimestamp";
  ValueErrorType2[ValueErrorType2["Date"] = 20] = "Date";
  ValueErrorType2[ValueErrorType2["Function"] = 21] = "Function";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMaximum"] = 22] = "IntegerExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMinimum"] = 23] = "IntegerExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMaximum"] = 24] = "IntegerMaximum";
  ValueErrorType2[ValueErrorType2["IntegerMinimum"] = 25] = "IntegerMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMultipleOf"] = 26] = "IntegerMultipleOf";
  ValueErrorType2[ValueErrorType2["Integer"] = 27] = "Integer";
  ValueErrorType2[ValueErrorType2["IntersectUnevaluatedProperties"] = 28] = "IntersectUnevaluatedProperties";
  ValueErrorType2[ValueErrorType2["Intersect"] = 29] = "Intersect";
  ValueErrorType2[ValueErrorType2["Iterator"] = 30] = "Iterator";
  ValueErrorType2[ValueErrorType2["Kind"] = 31] = "Kind";
  ValueErrorType2[ValueErrorType2["Literal"] = 32] = "Literal";
  ValueErrorType2[ValueErrorType2["Never"] = 33] = "Never";
  ValueErrorType2[ValueErrorType2["Not"] = 34] = "Not";
  ValueErrorType2[ValueErrorType2["Null"] = 35] = "Null";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMaximum"] = 36] = "NumberExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMinimum"] = 37] = "NumberExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["NumberMaximum"] = 38] = "NumberMaximum";
  ValueErrorType2[ValueErrorType2["NumberMinimum"] = 39] = "NumberMinimum";
  ValueErrorType2[ValueErrorType2["NumberMultipleOf"] = 40] = "NumberMultipleOf";
  ValueErrorType2[ValueErrorType2["Number"] = 41] = "Number";
  ValueErrorType2[ValueErrorType2["ObjectAdditionalProperties"] = 42] = "ObjectAdditionalProperties";
  ValueErrorType2[ValueErrorType2["ObjectMaxProperties"] = 43] = "ObjectMaxProperties";
  ValueErrorType2[ValueErrorType2["ObjectMinProperties"] = 44] = "ObjectMinProperties";
  ValueErrorType2[ValueErrorType2["ObjectRequiredProperty"] = 45] = "ObjectRequiredProperty";
  ValueErrorType2[ValueErrorType2["Object"] = 46] = "Object";
  ValueErrorType2[ValueErrorType2["Promise"] = 47] = "Promise";
  ValueErrorType2[ValueErrorType2["RegExp"] = 48] = "RegExp";
  ValueErrorType2[ValueErrorType2["StringFormatUnknown"] = 49] = "StringFormatUnknown";
  ValueErrorType2[ValueErrorType2["StringFormat"] = 50] = "StringFormat";
  ValueErrorType2[ValueErrorType2["StringMaxLength"] = 51] = "StringMaxLength";
  ValueErrorType2[ValueErrorType2["StringMinLength"] = 52] = "StringMinLength";
  ValueErrorType2[ValueErrorType2["StringPattern"] = 53] = "StringPattern";
  ValueErrorType2[ValueErrorType2["String"] = 54] = "String";
  ValueErrorType2[ValueErrorType2["Symbol"] = 55] = "Symbol";
  ValueErrorType2[ValueErrorType2["TupleLength"] = 56] = "TupleLength";
  ValueErrorType2[ValueErrorType2["Tuple"] = 57] = "Tuple";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMaxByteLength"] = 58] = "Uint8ArrayMaxByteLength";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMinByteLength"] = 59] = "Uint8ArrayMinByteLength";
  ValueErrorType2[ValueErrorType2["Uint8Array"] = 60] = "Uint8Array";
  ValueErrorType2[ValueErrorType2["Undefined"] = 61] = "Undefined";
  ValueErrorType2[ValueErrorType2["Union"] = 62] = "Union";
  ValueErrorType2[ValueErrorType2["Void"] = 63] = "Void";
})(ValueErrorType || (ValueErrorType = {}));

class ValueErrorsUnknownTypeError extends TypeBoxError {
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
}
function EscapeKey(key) {
  return key.replace(/~/g, "~0").replace(/\//g, "~1");
}
function IsDefined2(value) {
  return value !== undefined;
}

class ValueErrorIterator {
  constructor(iterator) {
    this.iterator = iterator;
  }
  [Symbol.iterator]() {
    return this.iterator;
  }
  First() {
    const next = this.iterator.next();
    return next.done ? undefined : next.value;
  }
}
function Create(errorType, schema, path, value, errors = []) {
  return {
    type: errorType,
    schema,
    path,
    value,
    message: GetErrorFunction()({ errorType, path, schema, value, errors }),
    errors
  };
}
function* FromAny3(schema, references, path, value) {
}
function* FromArray7(schema, references, path, value) {
  if (!IsArray2(value)) {
    return yield Create(ValueErrorType.Array, schema, path, value);
  }
  if (IsDefined2(schema.minItems) && !(value.length >= schema.minItems)) {
    yield Create(ValueErrorType.ArrayMinItems, schema, path, value);
  }
  if (IsDefined2(schema.maxItems) && !(value.length <= schema.maxItems)) {
    yield Create(ValueErrorType.ArrayMaxItems, schema, path, value);
  }
  for (let i = 0;i < value.length; i++) {
    yield* Visit6(schema.items, references, `${path}/${i}`, value[i]);
  }
  if (schema.uniqueItems === true && !function() {
    const set2 = new Set;
    for (const element of value) {
      const hashed = Hash(element);
      if (set2.has(hashed)) {
        return false;
      } else {
        set2.add(hashed);
      }
    }
    return true;
  }()) {
    yield Create(ValueErrorType.ArrayUniqueItems, schema, path, value);
  }
  if (!(IsDefined2(schema.contains) || IsDefined2(schema.minContains) || IsDefined2(schema.maxContains))) {
    return;
  }
  const containsSchema = IsDefined2(schema.contains) ? schema.contains : Never();
  const containsCount = value.reduce((acc, value2, index) => Visit6(containsSchema, references, `${path}${index}`, value2).next().done === true ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    yield Create(ValueErrorType.ArrayContains, schema, path, value);
  }
  if (IsNumber2(schema.minContains) && containsCount < schema.minContains) {
    yield Create(ValueErrorType.ArrayMinContains, schema, path, value);
  }
  if (IsNumber2(schema.maxContains) && containsCount > schema.maxContains) {
    yield Create(ValueErrorType.ArrayMaxContains, schema, path, value);
  }
}
function* FromAsyncIterator4(schema, references, path, value) {
  if (!IsAsyncIterator2(value))
    yield Create(ValueErrorType.AsyncIterator, schema, path, value);
}
function* FromBigInt3(schema, references, path, value) {
  if (!IsBigInt2(value))
    return yield Create(ValueErrorType.BigInt, schema, path, value);
  if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path, value);
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path, value);
  }
  if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
    yield Create(ValueErrorType.BigIntMaximum, schema, path, value);
  }
  if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
    yield Create(ValueErrorType.BigIntMinimum, schema, path, value);
  }
  if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
    yield Create(ValueErrorType.BigIntMultipleOf, schema, path, value);
  }
}
function* FromBoolean3(schema, references, path, value) {
  if (!IsBoolean2(value))
    yield Create(ValueErrorType.Boolean, schema, path, value);
}
function* FromConstructor4(schema, references, path, value) {
  yield* Visit6(schema.returns, references, path, value.prototype);
}
function* FromDate3(schema, references, path, value) {
  if (!IsDate2(value))
    return yield Create(ValueErrorType.Date, schema, path, value);
  if (IsDefined2(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value);
  }
  if (IsDefined2(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value);
  }
  if (IsDefined2(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
    yield Create(ValueErrorType.DateMaximumTimestamp, schema, path, value);
  }
  if (IsDefined2(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
    yield Create(ValueErrorType.DateMinimumTimestamp, schema, path, value);
  }
  if (IsDefined2(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
    yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path, value);
  }
}
function* FromFunction4(schema, references, path, value) {
  if (!IsFunction2(value))
    yield Create(ValueErrorType.Function, schema, path, value);
}
function* FromImport2(schema, references, path, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  yield* Visit6(target, [...references, ...definitions], path, value);
}
function* FromInteger3(schema, references, path, value) {
  if (!IsInteger(value))
    return yield Create(ValueErrorType.Integer, schema, path, value);
  if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path, value);
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path, value);
  }
  if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
    yield Create(ValueErrorType.IntegerMaximum, schema, path, value);
  }
  if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
    yield Create(ValueErrorType.IntegerMinimum, schema, path, value);
  }
  if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.IntegerMultipleOf, schema, path, value);
  }
}
function* FromIntersect9(schema, references, path, value) {
  let hasError = false;
  for (const inner of schema.allOf) {
    for (const error of Visit6(inner, references, path, value)) {
      hasError = true;
      yield error;
    }
  }
  if (hasError) {
    return yield Create(ValueErrorType.Intersect, schema, path, value);
  }
  if (schema.unevaluatedProperties === false) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value)) {
      if (!keyCheck.test(valueKey)) {
        yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value);
      }
    }
  }
  if (typeof schema.unevaluatedProperties === "object") {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value)) {
      if (!keyCheck.test(valueKey)) {
        const next = Visit6(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value[valueKey]).next();
        if (!next.done)
          yield next.value;
      }
    }
  }
}
function* FromIterator4(schema, references, path, value) {
  if (!IsIterator2(value))
    yield Create(ValueErrorType.Iterator, schema, path, value);
}
function* FromLiteral4(schema, references, path, value) {
  if (!(value === schema.const))
    yield Create(ValueErrorType.Literal, schema, path, value);
}
function* FromNever3(schema, references, path, value) {
  yield Create(ValueErrorType.Never, schema, path, value);
}
function* FromNot3(schema, references, path, value) {
  if (Visit6(schema.not, references, path, value).next().done === true)
    yield Create(ValueErrorType.Not, schema, path, value);
}
function* FromNull3(schema, references, path, value) {
  if (!IsNull2(value))
    yield Create(ValueErrorType.Null, schema, path, value);
}
function* FromNumber3(schema, references, path, value) {
  if (!TypeSystemPolicy.IsNumberLike(value))
    return yield Create(ValueErrorType.Number, schema, path, value);
  if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path, value);
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path, value);
  }
  if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
    yield Create(ValueErrorType.NumberMaximum, schema, path, value);
  }
  if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
    yield Create(ValueErrorType.NumberMinimum, schema, path, value);
  }
  if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.NumberMultipleOf, schema, path, value);
  }
}
function* FromObject8(schema, references, path, value) {
  if (!TypeSystemPolicy.IsObjectLike(value))
    return yield Create(ValueErrorType.Object, schema, path, value);
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);
  }
  const requiredKeys = Array.isArray(schema.required) ? schema.required : [];
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  const unknownKeys = Object.getOwnPropertyNames(value);
  for (const requiredKey of requiredKeys) {
    if (unknownKeys.includes(requiredKey))
      continue;
    yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey(requiredKey)}`, undefined);
  }
  if (schema.additionalProperties === false) {
    for (const valueKey of unknownKeys) {
      if (!knownKeys.includes(valueKey)) {
        yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);
      }
    }
  }
  if (typeof schema.additionalProperties === "object") {
    for (const valueKey of unknownKeys) {
      if (knownKeys.includes(valueKey))
        continue;
      yield* Visit6(schema.additionalProperties, references, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);
    }
  }
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      yield* Visit6(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);
      if (ExtendsUndefinedCheck(schema) && !(knownKey in value)) {
        yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path}/${EscapeKey(knownKey)}`, undefined);
      }
    } else {
      if (TypeSystemPolicy.IsExactOptionalProperty(value, knownKey)) {
        yield* Visit6(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);
      }
    }
  }
}
function* FromPromise4(schema, references, path, value) {
  if (!IsPromise(value))
    yield Create(ValueErrorType.Promise, schema, path, value);
}
function* FromRecord4(schema, references, path, value) {
  if (!TypeSystemPolicy.IsRecordLike(value))
    return yield Create(ValueErrorType.Object, schema, path, value);
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  for (const [propertyKey, propertyValue] of Object.entries(value)) {
    if (regex.test(propertyKey))
      yield* Visit6(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
  }
  if (typeof schema.additionalProperties === "object") {
    for (const [propertyKey, propertyValue] of Object.entries(value)) {
      if (!regex.test(propertyKey))
        yield* Visit6(schema.additionalProperties, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
  if (schema.additionalProperties === false) {
    for (const [propertyKey, propertyValue] of Object.entries(value)) {
      if (regex.test(propertyKey))
        continue;
      return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
}
function* FromRef6(schema, references, path, value) {
  yield* Visit6(Deref2(schema, references), references, path, value);
}
function* FromRegExp3(schema, references, path, value) {
  if (!IsString2(value))
    return yield Create(ValueErrorType.String, schema, path, value);
  if (IsDefined2(schema.minLength) && !(value.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path, value);
  }
  if (IsDefined2(schema.maxLength) && !(value.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path, value);
  }
  const regex = new RegExp(schema.source, schema.flags);
  if (!regex.test(value)) {
    return yield Create(ValueErrorType.RegExp, schema, path, value);
  }
}
function* FromString3(schema, references, path, value) {
  if (!IsString2(value))
    return yield Create(ValueErrorType.String, schema, path, value);
  if (IsDefined2(schema.minLength) && !(value.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path, value);
  }
  if (IsDefined2(schema.maxLength) && !(value.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path, value);
  }
  if (IsString2(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value)) {
      yield Create(ValueErrorType.StringPattern, schema, path, value);
    }
  }
  if (IsString2(schema.format)) {
    if (!exports_format.Has(schema.format)) {
      yield Create(ValueErrorType.StringFormatUnknown, schema, path, value);
    } else {
      const format = exports_format.Get(schema.format);
      if (!format(value)) {
        yield Create(ValueErrorType.StringFormat, schema, path, value);
      }
    }
  }
}
function* FromSymbol3(schema, references, path, value) {
  if (!IsSymbol2(value))
    yield Create(ValueErrorType.Symbol, schema, path, value);
}
function* FromTemplateLiteral5(schema, references, path, value) {
  if (!IsString2(value))
    return yield Create(ValueErrorType.String, schema, path, value);
  const regex = new RegExp(schema.pattern);
  if (!regex.test(value)) {
    yield Create(ValueErrorType.StringPattern, schema, path, value);
  }
}
function* FromThis2(schema, references, path, value) {
  yield* Visit6(Deref2(schema, references), references, path, value);
}
function* FromTuple6(schema, references, path, value) {
  if (!IsArray2(value))
    return yield Create(ValueErrorType.Tuple, schema, path, value);
  if (schema.items === undefined && !(value.length === 0)) {
    return yield Create(ValueErrorType.TupleLength, schema, path, value);
  }
  if (!(value.length === schema.maxItems)) {
    return yield Create(ValueErrorType.TupleLength, schema, path, value);
  }
  if (!schema.items) {
    return;
  }
  for (let i = 0;i < schema.items.length; i++) {
    yield* Visit6(schema.items[i], references, `${path}/${i}`, value[i]);
  }
}
function* FromUndefined3(schema, references, path, value) {
  if (!IsUndefined2(value))
    yield Create(ValueErrorType.Undefined, schema, path, value);
}
function* FromUnion11(schema, references, path, value) {
  if (Check(schema, references, value))
    return;
  const errors = schema.anyOf.map((variant) => new ValueErrorIterator(Visit6(variant, references, path, value)));
  yield Create(ValueErrorType.Union, schema, path, value, errors);
}
function* FromUint8Array3(schema, references, path, value) {
  if (!IsUint8Array2(value))
    return yield Create(ValueErrorType.Uint8Array, schema, path, value);
  if (IsDefined2(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value);
  }
  if (IsDefined2(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value);
  }
}
function* FromUnknown3(schema, references, path, value) {
}
function* FromVoid3(schema, references, path, value) {
  if (!TypeSystemPolicy.IsVoidLike(value))
    yield Create(ValueErrorType.Void, schema, path, value);
}
function* FromKind2(schema, references, path, value) {
  const check = exports_type2.Get(schema[Kind]);
  if (!check(schema, value))
    yield Create(ValueErrorType.Kind, schema, path, value);
}
function* Visit6(schema, references, path, value) {
  const references_ = IsDefined2(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return yield* FromAny3(schema_, references_, path, value);
    case "Array":
      return yield* FromArray7(schema_, references_, path, value);
    case "AsyncIterator":
      return yield* FromAsyncIterator4(schema_, references_, path, value);
    case "BigInt":
      return yield* FromBigInt3(schema_, references_, path, value);
    case "Boolean":
      return yield* FromBoolean3(schema_, references_, path, value);
    case "Constructor":
      return yield* FromConstructor4(schema_, references_, path, value);
    case "Date":
      return yield* FromDate3(schema_, references_, path, value);
    case "Function":
      return yield* FromFunction4(schema_, references_, path, value);
    case "Import":
      return yield* FromImport2(schema_, references_, path, value);
    case "Integer":
      return yield* FromInteger3(schema_, references_, path, value);
    case "Intersect":
      return yield* FromIntersect9(schema_, references_, path, value);
    case "Iterator":
      return yield* FromIterator4(schema_, references_, path, value);
    case "Literal":
      return yield* FromLiteral4(schema_, references_, path, value);
    case "Never":
      return yield* FromNever3(schema_, references_, path, value);
    case "Not":
      return yield* FromNot3(schema_, references_, path, value);
    case "Null":
      return yield* FromNull3(schema_, references_, path, value);
    case "Number":
      return yield* FromNumber3(schema_, references_, path, value);
    case "Object":
      return yield* FromObject8(schema_, references_, path, value);
    case "Promise":
      return yield* FromPromise4(schema_, references_, path, value);
    case "Record":
      return yield* FromRecord4(schema_, references_, path, value);
    case "Ref":
      return yield* FromRef6(schema_, references_, path, value);
    case "RegExp":
      return yield* FromRegExp3(schema_, references_, path, value);
    case "String":
      return yield* FromString3(schema_, references_, path, value);
    case "Symbol":
      return yield* FromSymbol3(schema_, references_, path, value);
    case "TemplateLiteral":
      return yield* FromTemplateLiteral5(schema_, references_, path, value);
    case "This":
      return yield* FromThis2(schema_, references_, path, value);
    case "Tuple":
      return yield* FromTuple6(schema_, references_, path, value);
    case "Undefined":
      return yield* FromUndefined3(schema_, references_, path, value);
    case "Union":
      return yield* FromUnion11(schema_, references_, path, value);
    case "Uint8Array":
      return yield* FromUint8Array3(schema_, references_, path, value);
    case "Unknown":
      return yield* FromUnknown3(schema_, references_, path, value);
    case "Void":
      return yield* FromVoid3(schema_, references_, path, value);
    default:
      if (!exports_type2.Has(schema_[Kind]))
        throw new ValueErrorsUnknownTypeError(schema);
      return yield* FromKind2(schema_, references_, path, value);
  }
}
function Errors(...args) {
  const iterator = args.length === 3 ? Visit6(args[0], args[1], "", args[2]) : Visit6(args[0], [], "", args[1]);
  return new ValueErrorIterator(iterator);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/value/transform/decode.mjs
class TransformDecodeCheckError extends TypeBoxError {
  constructor(schema, value, error) {
    super(`Unable to decode value as it does not match the expected schema`);
    this.schema = schema;
    this.value = value;
    this.error = error;
  }
}

class TransformDecodeError extends TypeBoxError {
  constructor(schema, path, value, error) {
    super(error instanceof Error ? error.message : "Unknown error");
    this.schema = schema;
    this.path = path;
    this.value = value;
    this.error = error;
  }
}
function Default(schema, path, value) {
  try {
    return IsTransform(schema) ? schema[TransformKind].Decode(value) : value;
  } catch (error) {
    throw new TransformDecodeError(schema, path, value, error);
  }
}
function FromArray8(schema, references, path, value) {
  return IsArray2(value) ? Default(schema, path, value.map((value2, index) => Visit7(schema.items, references, `${path}/${index}`, value2))) : Default(schema, path, value);
}
function FromIntersect10(schema, references, path, value) {
  if (!IsObject2(value) || IsValueType(value))
    return Default(schema, path, value);
  const knownEntries = KeyOfPropertyEntries(schema);
  const knownKeys = knownEntries.map((entry) => entry[0]);
  const knownProperties = { ...value };
  for (const [knownKey, knownSchema] of knownEntries)
    if (knownKey in knownProperties) {
      knownProperties[knownKey] = Visit7(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);
    }
  if (!IsTransform(schema.unevaluatedProperties)) {
    return Default(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      unknownProperties[key] = Default(unevaluatedProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default(schema, path, unknownProperties);
}
function FromImport3(schema, references, path, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  const transform = schema[TransformKind];
  const transformTarget = { [TransformKind]: transform, ...target };
  return Visit7(transformTarget, [...references, ...definitions], path, value);
}
function FromNot4(schema, references, path, value) {
  return Default(schema, path, Visit7(schema.not, references, path, value));
}
function FromObject9(schema, references, path, value) {
  if (!IsObject2(value))
    return Default(schema, path, value);
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = { ...value };
  for (const key of knownKeys) {
    if (!HasPropertyKey2(knownProperties, key))
      continue;
    if (IsUndefined2(knownProperties[key]) && (!IsUndefined3(schema.properties[key]) || TypeSystemPolicy.IsExactOptionalProperty(knownProperties, key)))
      continue;
    knownProperties[key] = Visit7(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);
  }
  if (!IsSchema(schema.additionalProperties)) {
    return Default(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      unknownProperties[key] = Default(additionalProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default(schema, path, unknownProperties);
}
function FromRecord5(schema, references, path, value) {
  if (!IsObject2(value))
    return Default(schema, path, value);
  const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern);
  const knownProperties = { ...value };
  for (const key of Object.getOwnPropertyNames(value))
    if (knownKeys.test(key)) {
      knownProperties[key] = Visit7(schema.patternProperties[pattern], references, `${path}/${key}`, knownProperties[key]);
    }
  if (!IsSchema(schema.additionalProperties)) {
    return Default(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.test(key)) {
      unknownProperties[key] = Default(additionalProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default(schema, path, unknownProperties);
}
function FromRef7(schema, references, path, value) {
  const target = Deref2(schema, references);
  return Default(schema, path, Visit7(target, references, path, value));
}
function FromThis3(schema, references, path, value) {
  const target = Deref2(schema, references);
  return Default(schema, path, Visit7(target, references, path, value));
}
function FromTuple7(schema, references, path, value) {
  return IsArray2(value) && IsArray2(schema.items) ? Default(schema, path, schema.items.map((schema2, index) => Visit7(schema2, references, `${path}/${index}`, value[index]))) : Default(schema, path, value);
}
function FromUnion12(schema, references, path, value) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value))
      continue;
    const decoded = Visit7(subschema, references, path, value);
    return Default(schema, path, decoded);
  }
  return Default(schema, path, value);
}
function Visit7(schema, references, path, value) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray8(schema_, references_, path, value);
    case "Import":
      return FromImport3(schema_, references_, path, value);
    case "Intersect":
      return FromIntersect10(schema_, references_, path, value);
    case "Not":
      return FromNot4(schema_, references_, path, value);
    case "Object":
      return FromObject9(schema_, references_, path, value);
    case "Record":
      return FromRecord5(schema_, references_, path, value);
    case "Ref":
      return FromRef7(schema_, references_, path, value);
    case "Symbol":
      return Default(schema_, path, value);
    case "This":
      return FromThis3(schema_, references_, path, value);
    case "Tuple":
      return FromTuple7(schema_, references_, path, value);
    case "Union":
      return FromUnion12(schema_, references_, path, value);
    default:
      return Default(schema_, path, value);
  }
}
function TransformDecode(schema, references, value) {
  return Visit7(schema, references, "", value);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/value/transform/encode.mjs
class TransformEncodeCheckError extends TypeBoxError {
  constructor(schema, value, error) {
    super(`The encoded value does not match the expected schema`);
    this.schema = schema;
    this.value = value;
    this.error = error;
  }
}

class TransformEncodeError extends TypeBoxError {
  constructor(schema, path, value, error) {
    super(`${error instanceof Error ? error.message : "Unknown error"}`);
    this.schema = schema;
    this.path = path;
    this.value = value;
    this.error = error;
  }
}
function Default2(schema, path, value) {
  try {
    return IsTransform(schema) ? schema[TransformKind].Encode(value) : value;
  } catch (error) {
    throw new TransformEncodeError(schema, path, value, error);
  }
}
function FromArray9(schema, references, path, value) {
  const defaulted = Default2(schema, path, value);
  return IsArray2(defaulted) ? defaulted.map((value2, index) => Visit8(schema.items, references, `${path}/${index}`, value2)) : defaulted;
}
function FromImport4(schema, references, path, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  const transform = schema[TransformKind];
  const transformTarget = { [TransformKind]: transform, ...target };
  return Visit8(transformTarget, [...references, ...definitions], path, value);
}
function FromIntersect11(schema, references, path, value) {
  const defaulted = Default2(schema, path, value);
  if (!IsObject2(value) || IsValueType(value))
    return defaulted;
  const knownEntries = KeyOfPropertyEntries(schema);
  const knownKeys = knownEntries.map((entry) => entry[0]);
  const knownProperties = { ...defaulted };
  for (const [knownKey, knownSchema] of knownEntries)
    if (knownKey in knownProperties) {
      knownProperties[knownKey] = Visit8(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);
    }
  if (!IsTransform(schema.unevaluatedProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      properties[key] = Default2(unevaluatedProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
}
function FromNot5(schema, references, path, value) {
  return Default2(schema.not, path, Default2(schema, path, value));
}
function FromObject10(schema, references, path, value) {
  const defaulted = Default2(schema, path, value);
  if (!IsObject2(defaulted))
    return defaulted;
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = { ...defaulted };
  for (const key of knownKeys) {
    if (!HasPropertyKey2(knownProperties, key))
      continue;
    if (IsUndefined2(knownProperties[key]) && (!IsUndefined3(schema.properties[key]) || TypeSystemPolicy.IsExactOptionalProperty(knownProperties, key)))
      continue;
    knownProperties[key] = Visit8(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);
  }
  if (!IsSchema(schema.additionalProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      properties[key] = Default2(additionalProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
}
function FromRecord6(schema, references, path, value) {
  const defaulted = Default2(schema, path, value);
  if (!IsObject2(value))
    return defaulted;
  const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern);
  const knownProperties = { ...defaulted };
  for (const key of Object.getOwnPropertyNames(value))
    if (knownKeys.test(key)) {
      knownProperties[key] = Visit8(schema.patternProperties[pattern], references, `${path}/${key}`, knownProperties[key]);
    }
  if (!IsSchema(schema.additionalProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.test(key)) {
      properties[key] = Default2(additionalProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
}
function FromRef8(schema, references, path, value) {
  const target = Deref2(schema, references);
  const resolved = Visit8(target, references, path, value);
  return Default2(schema, path, resolved);
}
function FromThis4(schema, references, path, value) {
  const target = Deref2(schema, references);
  const resolved = Visit8(target, references, path, value);
  return Default2(schema, path, resolved);
}
function FromTuple8(schema, references, path, value) {
  const value1 = Default2(schema, path, value);
  return IsArray2(schema.items) ? schema.items.map((schema2, index) => Visit8(schema2, references, `${path}/${index}`, value1[index])) : [];
}
function FromUnion13(schema, references, path, value) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value))
      continue;
    const value1 = Visit8(subschema, references, path, value);
    return Default2(schema, path, value1);
  }
  for (const subschema of schema.anyOf) {
    const value1 = Visit8(subschema, references, path, value);
    if (!Check(schema, references, value1))
      continue;
    return Default2(schema, path, value1);
  }
  return Default2(schema, path, value);
}
function Visit8(schema, references, path, value) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray9(schema_, references_, path, value);
    case "Import":
      return FromImport4(schema_, references_, path, value);
    case "Intersect":
      return FromIntersect11(schema_, references_, path, value);
    case "Not":
      return FromNot5(schema_, references_, path, value);
    case "Object":
      return FromObject10(schema_, references_, path, value);
    case "Record":
      return FromRecord6(schema_, references_, path, value);
    case "Ref":
      return FromRef8(schema_, references_, path, value);
    case "This":
      return FromThis4(schema_, references_, path, value);
    case "Tuple":
      return FromTuple8(schema_, references_, path, value);
    case "Union":
      return FromUnion13(schema_, references_, path, value);
    default:
      return Default2(schema_, path, value);
  }
}
function TransformEncode(schema, references, value) {
  return Visit8(schema, references, "", value);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/value/transform/has.mjs
function FromArray10(schema, references) {
  return IsTransform(schema) || Visit9(schema.items, references);
}
function FromAsyncIterator5(schema, references) {
  return IsTransform(schema) || Visit9(schema.items, references);
}
function FromConstructor5(schema, references) {
  return IsTransform(schema) || Visit9(schema.returns, references) || schema.parameters.some((schema2) => Visit9(schema2, references));
}
function FromFunction5(schema, references) {
  return IsTransform(schema) || Visit9(schema.returns, references) || schema.parameters.some((schema2) => Visit9(schema2, references));
}
function FromIntersect12(schema, references) {
  return IsTransform(schema) || IsTransform(schema.unevaluatedProperties) || schema.allOf.some((schema2) => Visit9(schema2, references));
}
function FromIterator5(schema, references) {
  return IsTransform(schema) || Visit9(schema.items, references);
}
function FromNot6(schema, references) {
  return IsTransform(schema) || Visit9(schema.not, references);
}
function FromObject11(schema, references) {
  return IsTransform(schema) || Object.values(schema.properties).some((schema2) => Visit9(schema2, references)) || IsSchema(schema.additionalProperties) && Visit9(schema.additionalProperties, references);
}
function FromPromise5(schema, references) {
  return IsTransform(schema) || Visit9(schema.item, references);
}
function FromRecord7(schema, references) {
  const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[pattern];
  return IsTransform(schema) || Visit9(property, references) || IsSchema(schema.additionalProperties) && IsTransform(schema.additionalProperties);
}
function FromRef9(schema, references) {
  if (IsTransform(schema))
    return true;
  return Visit9(Deref2(schema, references), references);
}
function FromThis5(schema, references) {
  if (IsTransform(schema))
    return true;
  return Visit9(Deref2(schema, references), references);
}
function FromTuple9(schema, references) {
  return IsTransform(schema) || !IsUndefined2(schema.items) && schema.items.some((schema2) => Visit9(schema2, references));
}
function FromUnion14(schema, references) {
  return IsTransform(schema) || schema.anyOf.some((schema2) => Visit9(schema2, references));
}
function Visit9(schema, references) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  if (schema.$id && visited.has(schema.$id))
    return false;
  if (schema.$id)
    visited.add(schema.$id);
  switch (schema[Kind]) {
    case "Array":
      return FromArray10(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator5(schema_, references_);
    case "Constructor":
      return FromConstructor5(schema_, references_);
    case "Function":
      return FromFunction5(schema_, references_);
    case "Intersect":
      return FromIntersect12(schema_, references_);
    case "Iterator":
      return FromIterator5(schema_, references_);
    case "Not":
      return FromNot6(schema_, references_);
    case "Object":
      return FromObject11(schema_, references_);
    case "Promise":
      return FromPromise5(schema_, references_);
    case "Record":
      return FromRecord7(schema_, references_);
    case "Ref":
      return FromRef9(schema_, references_);
    case "This":
      return FromThis5(schema_, references_);
    case "Tuple":
      return FromTuple9(schema_, references_);
    case "Union":
      return FromUnion14(schema_, references_);
    default:
      return IsTransform(schema);
  }
}
var visited = new Set;
function HasTransform(schema, references) {
  visited.clear();
  return Visit9(schema, references);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/compiler/compiler.mjs
class TypeCheck {
  constructor(schema, references, checkFunc, code) {
    this.schema = schema;
    this.references = references;
    this.checkFunc = checkFunc;
    this.code = code;
    this.hasTransform = HasTransform(schema, references);
  }
  Code() {
    return this.code;
  }
  Schema() {
    return this.schema;
  }
  References() {
    return this.references;
  }
  Errors(value) {
    return Errors(this.schema, this.references, value);
  }
  Check(value) {
    return this.checkFunc(value);
  }
  Decode(value) {
    if (!this.checkFunc(value))
      throw new TransformDecodeCheckError(this.schema, value, this.Errors(value).First());
    return this.hasTransform ? TransformDecode(this.schema, this.references, value) : value;
  }
  Encode(value) {
    const encoded = this.hasTransform ? TransformEncode(this.schema, this.references, value) : value;
    if (!this.checkFunc(encoded))
      throw new TransformEncodeCheckError(this.schema, value, this.Errors(value).First());
    return encoded;
  }
}
var Character;
(function(Character2) {
  function DollarSign(code) {
    return code === 36;
  }
  Character2.DollarSign = DollarSign;
  function IsUnderscore(code) {
    return code === 95;
  }
  Character2.IsUnderscore = IsUnderscore;
  function IsAlpha(code) {
    return code >= 65 && code <= 90 || code >= 97 && code <= 122;
  }
  Character2.IsAlpha = IsAlpha;
  function IsNumeric(code) {
    return code >= 48 && code <= 57;
  }
  Character2.IsNumeric = IsNumeric;
})(Character || (Character = {}));
var MemberExpression;
(function(MemberExpression2) {
  function IsFirstCharacterNumeric(value) {
    if (value.length === 0)
      return false;
    return Character.IsNumeric(value.charCodeAt(0));
  }
  function IsAccessor(value) {
    if (IsFirstCharacterNumeric(value))
      return false;
    for (let i = 0;i < value.length; i++) {
      const code = value.charCodeAt(i);
      const check = Character.IsAlpha(code) || Character.IsNumeric(code) || Character.DollarSign(code) || Character.IsUnderscore(code);
      if (!check)
        return false;
    }
    return true;
  }
  function EscapeHyphen(key) {
    return key.replace(/'/g, "\\'");
  }
  function Encode(object, key) {
    return IsAccessor(key) ? `${object}.${key}` : `${object}['${EscapeHyphen(key)}']`;
  }
  MemberExpression2.Encode = Encode;
})(MemberExpression || (MemberExpression = {}));
var Identifier;
(function(Identifier2) {
  function Encode($id) {
    const buffer = [];
    for (let i = 0;i < $id.length; i++) {
      const code = $id.charCodeAt(i);
      if (Character.IsNumeric(code) || Character.IsAlpha(code)) {
        buffer.push($id.charAt(i));
      } else {
        buffer.push(`_${code}_`);
      }
    }
    return buffer.join("").replace(/__/g, "_");
  }
  Identifier2.Encode = Encode;
})(Identifier || (Identifier = {}));
var LiteralString;
(function(LiteralString2) {
  function Escape2(content) {
    return content.replace(/'/g, "\\'");
  }
  LiteralString2.Escape = Escape2;
})(LiteralString || (LiteralString = {}));

class TypeCompilerUnknownTypeError extends TypeBoxError {
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
}

class TypeCompilerTypeGuardError extends TypeBoxError {
  constructor(schema) {
    super("Preflight validation check failed to guard for the given schema");
    this.schema = schema;
  }
}
var Policy;
(function(Policy2) {
  function IsExactOptionalProperty(value, key, expression) {
    return TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${key}' in ${value} ? ${expression} : true)` : `(${MemberExpression.Encode(value, key)} !== undefined ? ${expression} : true)`;
  }
  Policy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value) {
    return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}))` : `(typeof ${value} === 'object' && ${value} !== null)`;
  }
  Policy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value) {
    return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}) && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))` : `(typeof ${value} === 'object' && ${value} !== null && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))`;
  }
  Policy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value) {
    return TypeSystemPolicy.AllowNaN ? `typeof ${value} === 'number'` : `Number.isFinite(${value})`;
  }
  Policy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value) {
    return TypeSystemPolicy.AllowNullVoid ? `(${value} === undefined || ${value} === null)` : `${value} === undefined`;
  }
  Policy2.IsVoidLike = IsVoidLike;
})(Policy || (Policy = {}));
var TypeCompiler;
(function(TypeCompiler2) {
  function IsAnyOrUnknown2(schema) {
    return schema[Kind] === "Any" || schema[Kind] === "Unknown";
  }
  function* FromAny4(schema, references, value) {
    yield "true";
  }
  function* FromArray11(schema, references, value) {
    yield `Array.isArray(${value})`;
    const [parameter, accumulator] = [CreateParameter("value", "any"), CreateParameter("acc", "number")];
    if (IsNumber2(schema.maxItems))
      yield `${value}.length <= ${schema.maxItems}`;
    if (IsNumber2(schema.minItems))
      yield `${value}.length >= ${schema.minItems}`;
    const elementExpression = CreateExpression(schema.items, references, "value");
    yield `${value}.every((${parameter}) => ${elementExpression})`;
    if (IsSchema2(schema.contains) || IsNumber2(schema.minContains) || IsNumber2(schema.maxContains)) {
      const containsSchema = IsSchema2(schema.contains) ? schema.contains : Never();
      const checkExpression = CreateExpression(containsSchema, references, "value");
      const checkMinContains = IsNumber2(schema.minContains) ? [`(count >= ${schema.minContains})`] : [];
      const checkMaxContains = IsNumber2(schema.maxContains) ? [`(count <= ${schema.maxContains})`] : [];
      const checkCount = `const count = value.reduce((${accumulator}, ${parameter}) => ${checkExpression} ? acc + 1 : acc, 0)`;
      const check = [`(count > 0)`, ...checkMinContains, ...checkMaxContains].join(" && ");
      yield `((${parameter}) => { ${checkCount}; return ${check}})(${value})`;
    }
    if (schema.uniqueItems === true) {
      const check = `const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true`;
      const block = `const set = new Set(); for(const element of value) { ${check} }`;
      yield `((${parameter}) => { ${block} )(${value})`;
    }
  }
  function* FromAsyncIterator6(schema, references, value) {
    yield `(typeof value === 'object' && Symbol.asyncIterator in ${value})`;
  }
  function* FromBigInt4(schema, references, value) {
    yield `(typeof ${value} === 'bigint')`;
    if (IsBigInt2(schema.exclusiveMaximum))
      yield `${value} < BigInt(${schema.exclusiveMaximum})`;
    if (IsBigInt2(schema.exclusiveMinimum))
      yield `${value} > BigInt(${schema.exclusiveMinimum})`;
    if (IsBigInt2(schema.maximum))
      yield `${value} <= BigInt(${schema.maximum})`;
    if (IsBigInt2(schema.minimum))
      yield `${value} >= BigInt(${schema.minimum})`;
    if (IsBigInt2(schema.multipleOf))
      yield `(${value} % BigInt(${schema.multipleOf})) === 0`;
  }
  function* FromBoolean4(schema, references, value) {
    yield `(typeof ${value} === 'boolean')`;
  }
  function* FromConstructor6(schema, references, value) {
    yield* Visit10(schema.returns, references, `${value}.prototype`);
  }
  function* FromDate4(schema, references, value) {
    yield `(${value} instanceof Date) && Number.isFinite(${value}.getTime())`;
    if (IsNumber2(schema.exclusiveMaximumTimestamp))
      yield `${value}.getTime() < ${schema.exclusiveMaximumTimestamp}`;
    if (IsNumber2(schema.exclusiveMinimumTimestamp))
      yield `${value}.getTime() > ${schema.exclusiveMinimumTimestamp}`;
    if (IsNumber2(schema.maximumTimestamp))
      yield `${value}.getTime() <= ${schema.maximumTimestamp}`;
    if (IsNumber2(schema.minimumTimestamp))
      yield `${value}.getTime() >= ${schema.minimumTimestamp}`;
    if (IsNumber2(schema.multipleOfTimestamp))
      yield `(${value}.getTime() % ${schema.multipleOfTimestamp}) === 0`;
  }
  function* FromFunction6(schema, references, value) {
    yield `(typeof ${value} === 'function')`;
  }
  function* FromImport5(schema, references, value) {
    const members = globalThis.Object.getOwnPropertyNames(schema.$defs).reduce((result, key) => {
      return [...result, schema.$defs[key]];
    }, []);
    yield* Visit10(Ref(schema.$ref), [...references, ...members], value);
  }
  function* FromInteger4(schema, references, value) {
    yield `Number.isInteger(${value})`;
    if (IsNumber2(schema.exclusiveMaximum))
      yield `${value} < ${schema.exclusiveMaximum}`;
    if (IsNumber2(schema.exclusiveMinimum))
      yield `${value} > ${schema.exclusiveMinimum}`;
    if (IsNumber2(schema.maximum))
      yield `${value} <= ${schema.maximum}`;
    if (IsNumber2(schema.minimum))
      yield `${value} >= ${schema.minimum}`;
    if (IsNumber2(schema.multipleOf))
      yield `(${value} % ${schema.multipleOf}) === 0`;
  }
  function* FromIntersect13(schema, references, value) {
    const check1 = schema.allOf.map((schema2) => CreateExpression(schema2, references, value)).join(" && ");
    if (schema.unevaluatedProperties === false) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema))};`);
      const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key))`;
      yield `(${check1} && ${check2})`;
    } else if (IsSchema2(schema.unevaluatedProperties)) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema))};`);
      const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key) || ${CreateExpression(schema.unevaluatedProperties, references, `${value}[key]`)})`;
      yield `(${check1} && ${check2})`;
    } else {
      yield `(${check1})`;
    }
  }
  function* FromIterator6(schema, references, value) {
    yield `(typeof value === 'object' && Symbol.iterator in ${value})`;
  }
  function* FromLiteral5(schema, references, value) {
    if (typeof schema.const === "number" || typeof schema.const === "boolean") {
      yield `(${value} === ${schema.const})`;
    } else {
      yield `(${value} === '${LiteralString.Escape(schema.const)}')`;
    }
  }
  function* FromNever4(schema, references, value) {
    yield `false`;
  }
  function* FromNot7(schema, references, value) {
    const expression = CreateExpression(schema.not, references, value);
    yield `(!${expression})`;
  }
  function* FromNull4(schema, references, value) {
    yield `(${value} === null)`;
  }
  function* FromNumber4(schema, references, value) {
    yield Policy.IsNumberLike(value);
    if (IsNumber2(schema.exclusiveMaximum))
      yield `${value} < ${schema.exclusiveMaximum}`;
    if (IsNumber2(schema.exclusiveMinimum))
      yield `${value} > ${schema.exclusiveMinimum}`;
    if (IsNumber2(schema.maximum))
      yield `${value} <= ${schema.maximum}`;
    if (IsNumber2(schema.minimum))
      yield `${value} >= ${schema.minimum}`;
    if (IsNumber2(schema.multipleOf))
      yield `(${value} % ${schema.multipleOf}) === 0`;
  }
  function* FromObject12(schema, references, value) {
    yield Policy.IsObjectLike(value);
    if (IsNumber2(schema.minProperties))
      yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;
    if (IsNumber2(schema.maxProperties))
      yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;
    const knownKeys = Object.getOwnPropertyNames(schema.properties);
    for (const knownKey of knownKeys) {
      const memberExpression = MemberExpression.Encode(value, knownKey);
      const property = schema.properties[knownKey];
      if (schema.required && schema.required.includes(knownKey)) {
        yield* Visit10(property, references, memberExpression);
        if (ExtendsUndefinedCheck(property) || IsAnyOrUnknown2(property))
          yield `('${knownKey}' in ${value})`;
      } else {
        const expression = CreateExpression(property, references, memberExpression);
        yield Policy.IsExactOptionalProperty(value, knownKey, expression);
      }
    }
    if (schema.additionalProperties === false) {
      if (schema.required && schema.required.length === knownKeys.length) {
        yield `Object.getOwnPropertyNames(${value}).length === ${knownKeys.length}`;
      } else {
        const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
        yield `Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key))`;
      }
    }
    if (typeof schema.additionalProperties === "object") {
      const expression = CreateExpression(schema.additionalProperties, references, `${value}[key]`);
      const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
      yield `(Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key) || ${expression}))`;
    }
  }
  function* FromPromise6(schema, references, value) {
    yield `(typeof value === 'object' && typeof ${value}.then === 'function')`;
  }
  function* FromRecord8(schema, references, value) {
    yield Policy.IsRecordLike(value);
    if (IsNumber2(schema.minProperties))
      yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;
    if (IsNumber2(schema.maxProperties))
      yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;
    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
    const variable = CreateVariable(`${new RegExp(patternKey)}`);
    const check1 = CreateExpression(patternSchema, references, "value");
    const check2 = IsSchema2(schema.additionalProperties) ? CreateExpression(schema.additionalProperties, references, value) : schema.additionalProperties === false ? "false" : "true";
    const expression = `(${variable}.test(key) ? ${check1} : ${check2})`;
    yield `(Object.entries(${value}).every(([key, value]) => ${expression}))`;
  }
  function* FromRef10(schema, references, value) {
    const target = Deref2(schema, references);
    if (state.functions.has(schema.$ref))
      return yield `${CreateFunctionName(schema.$ref)}(${value})`;
    yield* Visit10(target, references, value);
  }
  function* FromRegExp4(schema, references, value) {
    const variable = CreateVariable(`${new RegExp(schema.source, schema.flags)};`);
    yield `(typeof ${value} === 'string')`;
    if (IsNumber2(schema.maxLength))
      yield `${value}.length <= ${schema.maxLength}`;
    if (IsNumber2(schema.minLength))
      yield `${value}.length >= ${schema.minLength}`;
    yield `${variable}.test(${value})`;
  }
  function* FromString4(schema, references, value) {
    yield `(typeof ${value} === 'string')`;
    if (IsNumber2(schema.maxLength))
      yield `${value}.length <= ${schema.maxLength}`;
    if (IsNumber2(schema.minLength))
      yield `${value}.length >= ${schema.minLength}`;
    if (schema.pattern !== undefined) {
      const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
      yield `${variable}.test(${value})`;
    }
    if (schema.format !== undefined) {
      yield `format('${schema.format}', ${value})`;
    }
  }
  function* FromSymbol4(schema, references, value) {
    yield `(typeof ${value} === 'symbol')`;
  }
  function* FromTemplateLiteral6(schema, references, value) {
    yield `(typeof ${value} === 'string')`;
    const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
    yield `${variable}.test(${value})`;
  }
  function* FromThis6(schema, references, value) {
    yield `${CreateFunctionName(schema.$ref)}(${value})`;
  }
  function* FromTuple10(schema, references, value) {
    yield `Array.isArray(${value})`;
    if (schema.items === undefined)
      return yield `${value}.length === 0`;
    yield `(${value}.length === ${schema.maxItems})`;
    for (let i = 0;i < schema.items.length; i++) {
      const expression = CreateExpression(schema.items[i], references, `${value}[${i}]`);
      yield `${expression}`;
    }
  }
  function* FromUndefined4(schema, references, value) {
    yield `${value} === undefined`;
  }
  function* FromUnion15(schema, references, value) {
    const expressions = schema.anyOf.map((schema2) => CreateExpression(schema2, references, value));
    yield `(${expressions.join(" || ")})`;
  }
  function* FromUint8Array4(schema, references, value) {
    yield `${value} instanceof Uint8Array`;
    if (IsNumber2(schema.maxByteLength))
      yield `(${value}.length <= ${schema.maxByteLength})`;
    if (IsNumber2(schema.minByteLength))
      yield `(${value}.length >= ${schema.minByteLength})`;
  }
  function* FromUnknown4(schema, references, value) {
    yield "true";
  }
  function* FromVoid4(schema, references, value) {
    yield Policy.IsVoidLike(value);
  }
  function* FromKind3(schema, references, value) {
    const instance = state.instances.size;
    state.instances.set(instance, schema);
    yield `kind('${schema[Kind]}', ${instance}, ${value})`;
  }
  function* Visit10(schema, references, value, useHoisting = true) {
    const references_ = IsString2(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    if (useHoisting && IsString2(schema.$id)) {
      const functionName = CreateFunctionName(schema.$id);
      if (state.functions.has(functionName)) {
        return yield `${functionName}(${value})`;
      } else {
        state.functions.set(functionName, "<deferred>");
        const functionCode = CreateFunction(functionName, schema, references, "value", false);
        state.functions.set(functionName, functionCode);
        return yield `${functionName}(${value})`;
      }
    }
    switch (schema_[Kind]) {
      case "Any":
        return yield* FromAny4(schema_, references_, value);
      case "Array":
        return yield* FromArray11(schema_, references_, value);
      case "AsyncIterator":
        return yield* FromAsyncIterator6(schema_, references_, value);
      case "BigInt":
        return yield* FromBigInt4(schema_, references_, value);
      case "Boolean":
        return yield* FromBoolean4(schema_, references_, value);
      case "Constructor":
        return yield* FromConstructor6(schema_, references_, value);
      case "Date":
        return yield* FromDate4(schema_, references_, value);
      case "Function":
        return yield* FromFunction6(schema_, references_, value);
      case "Import":
        return yield* FromImport5(schema_, references_, value);
      case "Integer":
        return yield* FromInteger4(schema_, references_, value);
      case "Intersect":
        return yield* FromIntersect13(schema_, references_, value);
      case "Iterator":
        return yield* FromIterator6(schema_, references_, value);
      case "Literal":
        return yield* FromLiteral5(schema_, references_, value);
      case "Never":
        return yield* FromNever4(schema_, references_, value);
      case "Not":
        return yield* FromNot7(schema_, references_, value);
      case "Null":
        return yield* FromNull4(schema_, references_, value);
      case "Number":
        return yield* FromNumber4(schema_, references_, value);
      case "Object":
        return yield* FromObject12(schema_, references_, value);
      case "Promise":
        return yield* FromPromise6(schema_, references_, value);
      case "Record":
        return yield* FromRecord8(schema_, references_, value);
      case "Ref":
        return yield* FromRef10(schema_, references_, value);
      case "RegExp":
        return yield* FromRegExp4(schema_, references_, value);
      case "String":
        return yield* FromString4(schema_, references_, value);
      case "Symbol":
        return yield* FromSymbol4(schema_, references_, value);
      case "TemplateLiteral":
        return yield* FromTemplateLiteral6(schema_, references_, value);
      case "This":
        return yield* FromThis6(schema_, references_, value);
      case "Tuple":
        return yield* FromTuple10(schema_, references_, value);
      case "Undefined":
        return yield* FromUndefined4(schema_, references_, value);
      case "Union":
        return yield* FromUnion15(schema_, references_, value);
      case "Uint8Array":
        return yield* FromUint8Array4(schema_, references_, value);
      case "Unknown":
        return yield* FromUnknown4(schema_, references_, value);
      case "Void":
        return yield* FromVoid4(schema_, references_, value);
      default:
        if (!exports_type2.Has(schema_[Kind]))
          throw new TypeCompilerUnknownTypeError(schema);
        return yield* FromKind3(schema_, references_, value);
    }
  }
  const state = {
    language: "javascript",
    functions: new Map,
    variables: new Map,
    instances: new Map
  };
  function CreateExpression(schema, references, value, useHoisting = true) {
    return `(${[...Visit10(schema, references, value, useHoisting)].join(" && ")})`;
  }
  function CreateFunctionName($id) {
    return `check_${Identifier.Encode($id)}`;
  }
  function CreateVariable(expression) {
    const variableName = `local_${state.variables.size}`;
    state.variables.set(variableName, `const ${variableName} = ${expression}`);
    return variableName;
  }
  function CreateFunction(name, schema, references, value, useHoisting = true) {
    const [newline, pad] = [`
`, (length) => "".padStart(length, " ")];
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const expression = [...Visit10(schema, references, value, useHoisting)].map((expression2) => `${pad(4)}${expression2}`).join(` &&${newline}`);
    return `function ${name}(${parameter})${returns} {${newline}${pad(2)}return (${newline}${expression}${newline}${pad(2)})
}`;
  }
  function CreateParameter(name, type) {
    const annotation = state.language === "typescript" ? `: ${type}` : "";
    return `${name}${annotation}`;
  }
  function CreateReturns(type) {
    return state.language === "typescript" ? `: ${type}` : "";
  }
  function Build(schema, references, options) {
    const functionCode = CreateFunction("check", schema, references, "value");
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const functions = [...state.functions.values()];
    const variables = [...state.variables.values()];
    const checkFunction = IsString2(schema.$id) ? `return function check(${parameter})${returns} {
  return ${CreateFunctionName(schema.$id)}(value)
}` : `return ${functionCode}`;
    return [...variables, ...functions, checkFunction].join(`
`);
  }
  function Code(...args) {
    const defaults = { language: "javascript" };
    const [schema, references, options] = args.length === 2 && IsArray2(args[1]) ? [args[0], args[1], defaults] : args.length === 2 && !IsArray2(args[1]) ? [args[0], [], args[1]] : args.length === 3 ? [args[0], args[1], args[2]] : args.length === 1 ? [args[0], [], defaults] : [null, [], defaults];
    state.language = options.language;
    state.variables.clear();
    state.functions.clear();
    state.instances.clear();
    if (!IsSchema2(schema))
      throw new TypeCompilerTypeGuardError(schema);
    for (const schema2 of references)
      if (!IsSchema2(schema2))
        throw new TypeCompilerTypeGuardError(schema2);
    return Build(schema, references, options);
  }
  TypeCompiler2.Code = Code;
  function Compile(schema, references = []) {
    const generatedCode = Code(schema, references, { language: "javascript" });
    const compiledFunction = globalThis.Function("kind", "format", "hash", generatedCode);
    const instances = new Map(state.instances);
    function typeRegistryFunction(kind, instance, value) {
      if (!exports_type2.Has(kind) || !instances.has(instance))
        return false;
      const checkFunc = exports_type2.Get(kind);
      const schema2 = instances.get(instance);
      return checkFunc(schema2, value);
    }
    function formatRegistryFunction(format, value) {
      if (!exports_format.Has(format))
        return false;
      const checkFunc = exports_format.Get(format);
      return checkFunc(value);
    }
    function hashFunction(value) {
      return Hash(value);
    }
    const checkFunction = compiledFunction(typeRegistryFunction, formatRegistryFunction, hashFunction);
    return new TypeCheck(schema, references, checkFunction, generatedCode);
  }
  TypeCompiler2.Compile = Compile;
})(TypeCompiler || (TypeCompiler = {}));
// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/value/assert/assert.mjs
var __classPrivateFieldSet = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AssertError_instances;
var _AssertError_iterator;
var _AssertError_Iterator;

class AssertError extends TypeBoxError {
  constructor(iterator) {
    const error = iterator.First();
    super(error === undefined ? "Invalid Value" : error.message);
    _AssertError_instances.add(this);
    _AssertError_iterator.set(this, undefined);
    __classPrivateFieldSet(this, _AssertError_iterator, iterator, "f");
    this.error = error;
  }
  Errors() {
    return new ValueErrorIterator(__classPrivateFieldGet(this, _AssertError_instances, "m", _AssertError_Iterator).call(this));
  }
}
_AssertError_iterator = new WeakMap, _AssertError_instances = new WeakSet, _AssertError_Iterator = function* _AssertError_Iterator2() {
  if (this.error)
    yield this.error;
  yield* __classPrivateFieldGet(this, _AssertError_iterator, "f");
};
function AssertValue(schema, references, value) {
  if (Check(schema, references, value))
    return;
  throw new AssertError(Errors(schema, references, value));
}
function Assert(...args) {
  return args.length === 3 ? AssertValue(args[0], args[1], args[2]) : AssertValue(args[0], [], args[1]);
}
// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/value/clone/clone.mjs
function FromObject12(value) {
  const Acc = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    Acc[key] = Clone2(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    Acc[key] = Clone2(value[key]);
  }
  return Acc;
}
function FromArray11(value) {
  return value.map((element) => Clone2(element));
}
function FromTypedArray(value) {
  return value.slice();
}
function FromMap(value) {
  return new Map(Clone2([...value.entries()]));
}
function FromSet(value) {
  return new Set(Clone2([...value.entries()]));
}
function FromDate4(value) {
  return new Date(value.toISOString());
}
function FromValue2(value) {
  return value;
}
function Clone2(value) {
  if (IsArray2(value))
    return FromArray11(value);
  if (IsDate2(value))
    return FromDate4(value);
  if (IsTypedArray(value))
    return FromTypedArray(value);
  if (IsMap(value))
    return FromMap(value);
  if (IsSet(value))
    return FromSet(value);
  if (IsObject2(value))
    return FromObject12(value);
  if (IsValueType(value))
    return FromValue2(value);
  throw new Error("ValueClone: Unable to clone value");
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/value/create/create.mjs
class ValueCreateError extends TypeBoxError {
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
}
function FromDefault(value) {
  return IsFunction2(value) ? value() : Clone2(value);
}
function FromAny4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
}
function FromArray12(schema, references) {
  if (schema.uniqueItems === true && !HasPropertyKey2(schema, "default")) {
    throw new ValueCreateError(schema, "Array with the uniqueItems constraint requires a default value");
  } else if ("contains" in schema && !HasPropertyKey2(schema, "default")) {
    throw new ValueCreateError(schema, "Array with the contains constraint requires a default value");
  } else if ("default" in schema) {
    return FromDefault(schema.default);
  } else if (schema.minItems !== undefined) {
    return Array.from({ length: schema.minItems }).map((item) => {
      return Visit10(schema.items, references);
    });
  } else {
    return [];
  }
}
function FromAsyncIterator6(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return async function* () {
    }();
  }
}
function FromBigInt4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return BigInt(0);
  }
}
function FromBoolean4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return false;
  }
}
function FromConstructor6(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const value = Visit10(schema.returns, references);
    if (typeof value === "object" && !Array.isArray(value)) {
      return class {
        constructor() {
          for (const [key, val] of Object.entries(value)) {
            const self = this;
            self[key] = val;
          }
        }
      };
    } else {
      return class {
      };
    }
  }
}
function FromDate5(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimumTimestamp !== undefined) {
    return new Date(schema.minimumTimestamp);
  } else {
    return new Date;
  }
}
function FromFunction6(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return () => Visit10(schema.returns, references);
  }
}
function FromImport5(schema, references) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit10(target, [...references, ...definitions]);
}
function FromInteger4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimum !== undefined) {
    return schema.minimum;
  } else {
    return 0;
  }
}
function FromIntersect13(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const value = schema.allOf.reduce((acc, schema2) => {
      const next = Visit10(schema2, references);
      return typeof next === "object" ? { ...acc, ...next } : next;
    }, {});
    if (!Check(schema, references, value))
      throw new ValueCreateError(schema, "Intersect produced invalid value. Consider using a default value.");
    return value;
  }
}
function FromIterator6(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return function* () {
    }();
  }
}
function FromLiteral5(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return schema.const;
  }
}
function FromNever4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "Never types cannot be created. Consider using a default value.");
  }
}
function FromNot7(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "Not types must have a default value");
  }
}
function FromNull4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return null;
  }
}
function FromNumber4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimum !== undefined) {
    return schema.minimum;
  } else {
    return 0;
  }
}
function FromObject13(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const required = new Set(schema.required);
    const Acc = {};
    for (const [key, subschema] of Object.entries(schema.properties)) {
      if (!required.has(key))
        continue;
      Acc[key] = Visit10(subschema, references);
    }
    return Acc;
  }
}
function FromPromise6(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Promise.resolve(Visit10(schema.item, references));
  }
}
function FromRecord8(schema, references) {
  const [keyPattern, valueSchema] = Object.entries(schema.patternProperties)[0];
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (!(keyPattern === PatternStringExact || keyPattern === PatternNumberExact)) {
    const propertyKeys = keyPattern.slice(1, keyPattern.length - 1).split("|");
    const Acc = {};
    for (const key of propertyKeys)
      Acc[key] = Visit10(valueSchema, references);
    return Acc;
  } else {
    return {};
  }
}
function FromRef10(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Visit10(Deref2(schema, references), references);
  }
}
function FromRegExp4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "RegExp types cannot be created. Consider using a default value.");
  }
}
function FromString4(schema, references) {
  if (schema.pattern !== undefined) {
    if (!HasPropertyKey2(schema, "default")) {
      throw new ValueCreateError(schema, "String types with patterns must specify a default value");
    } else {
      return FromDefault(schema.default);
    }
  } else if (schema.format !== undefined) {
    if (!HasPropertyKey2(schema, "default")) {
      throw new ValueCreateError(schema, "String types with formats must specify a default value");
    } else {
      return FromDefault(schema.default);
    }
  } else {
    if (HasPropertyKey2(schema, "default")) {
      return FromDefault(schema.default);
    } else if (schema.minLength !== undefined) {
      return Array.from({ length: schema.minLength }).map(() => " ").join("");
    } else {
      return "";
    }
  }
}
function FromSymbol4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if ("value" in schema) {
    return Symbol.for(schema.value);
  } else {
    return Symbol();
  }
}
function FromTemplateLiteral6(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  }
  if (!IsTemplateLiteralFinite(schema))
    throw new ValueCreateError(schema, "Can only create template literals that produce a finite variants. Consider using a default value.");
  const generated = TemplateLiteralGenerate(schema);
  return generated[0];
}
function FromThis6(schema, references) {
  if (recursiveDepth++ > recursiveMaxDepth)
    throw new ValueCreateError(schema, "Cannot create recursive type as it appears possibly infinite. Consider using a default.");
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Visit10(Deref2(schema, references), references);
  }
}
function FromTuple10(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  }
  if (schema.items === undefined) {
    return [];
  } else {
    return Array.from({ length: schema.minItems }).map((_2, index) => Visit10(schema.items[index], references));
  }
}
function FromUndefined4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return;
  }
}
function FromUnion15(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.anyOf.length === 0) {
    throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
  } else {
    return Visit10(schema.anyOf[0], references);
  }
}
function FromUint8Array4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minByteLength !== undefined) {
    return new Uint8Array(schema.minByteLength);
  } else {
    return new Uint8Array(0);
  }
}
function FromUnknown4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
}
function FromVoid4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return;
  }
}
function FromKind3(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new Error("User defined types must specify a default value");
  }
}
function Visit10(schema, references) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny4(schema_, references_);
    case "Array":
      return FromArray12(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator6(schema_, references_);
    case "BigInt":
      return FromBigInt4(schema_, references_);
    case "Boolean":
      return FromBoolean4(schema_, references_);
    case "Constructor":
      return FromConstructor6(schema_, references_);
    case "Date":
      return FromDate5(schema_, references_);
    case "Function":
      return FromFunction6(schema_, references_);
    case "Import":
      return FromImport5(schema_, references_);
    case "Integer":
      return FromInteger4(schema_, references_);
    case "Intersect":
      return FromIntersect13(schema_, references_);
    case "Iterator":
      return FromIterator6(schema_, references_);
    case "Literal":
      return FromLiteral5(schema_, references_);
    case "Never":
      return FromNever4(schema_, references_);
    case "Not":
      return FromNot7(schema_, references_);
    case "Null":
      return FromNull4(schema_, references_);
    case "Number":
      return FromNumber4(schema_, references_);
    case "Object":
      return FromObject13(schema_, references_);
    case "Promise":
      return FromPromise6(schema_, references_);
    case "Record":
      return FromRecord8(schema_, references_);
    case "Ref":
      return FromRef10(schema_, references_);
    case "RegExp":
      return FromRegExp4(schema_, references_);
    case "String":
      return FromString4(schema_, references_);
    case "Symbol":
      return FromSymbol4(schema_, references_);
    case "TemplateLiteral":
      return FromTemplateLiteral6(schema_, references_);
    case "This":
      return FromThis6(schema_, references_);
    case "Tuple":
      return FromTuple10(schema_, references_);
    case "Undefined":
      return FromUndefined4(schema_, references_);
    case "Union":
      return FromUnion15(schema_, references_);
    case "Uint8Array":
      return FromUint8Array4(schema_, references_);
    case "Unknown":
      return FromUnknown4(schema_, references_);
    case "Void":
      return FromVoid4(schema_, references_);
    default:
      if (!exports_type2.Has(schema_[Kind]))
        throw new ValueCreateError(schema_, "Unknown type");
      return FromKind3(schema_, references_);
  }
}
var recursiveMaxDepth = 512;
var recursiveDepth = 0;
function Create2(...args) {
  recursiveDepth = 0;
  return args.length === 2 ? Visit10(args[0], args[1]) : Visit10(args[0], []);
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/value/cast/cast.mjs
class ValueCastError extends TypeBoxError {
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
}
function ScoreUnion(schema, references, value) {
  if (schema[Kind] === "Object" && typeof value === "object" && !IsNull2(value)) {
    const object = schema;
    const keys = Object.getOwnPropertyNames(value);
    const entries = Object.entries(object.properties);
    const [point, max] = [1 / entries.length, entries.length];
    return entries.reduce((acc, [key, schema2]) => {
      const literal = schema2[Kind] === "Literal" && schema2.const === value[key] ? max : 0;
      const checks = Check(schema2, references, value[key]) ? point : 0;
      const exists = keys.includes(key) ? point : 0;
      return acc + (literal + checks + exists);
    }, 0);
  } else {
    return Check(schema, references, value) ? 1 : 0;
  }
}
function SelectUnion(union, references, value) {
  const schemas = union.anyOf.map((schema) => Deref2(schema, references));
  let [select, best] = [schemas[0], 0];
  for (const schema of schemas) {
    const score = ScoreUnion(schema, references, value);
    if (score > best) {
      select = schema;
      best = score;
    }
  }
  return select;
}
function CastUnion(union, references, value) {
  if ("default" in union) {
    return typeof value === "function" ? union.default : Clone2(union.default);
  } else {
    const schema = SelectUnion(union, references, value);
    return Cast(schema, references, value);
  }
}
function DefaultClone(schema, references, value) {
  return Check(schema, references, value) ? Clone2(value) : Create2(schema, references);
}
function Default3(schema, references, value) {
  return Check(schema, references, value) ? value : Create2(schema, references);
}
function FromArray13(schema, references, value) {
  if (Check(schema, references, value))
    return Clone2(value);
  const created = IsArray2(value) ? Clone2(value) : Create2(schema, references);
  const minimum = IsNumber2(schema.minItems) && created.length < schema.minItems ? [...created, ...Array.from({ length: schema.minItems - created.length }, () => null)] : created;
  const maximum = IsNumber2(schema.maxItems) && minimum.length > schema.maxItems ? minimum.slice(0, schema.maxItems) : minimum;
  const casted = maximum.map((value2) => Visit11(schema.items, references, value2));
  if (schema.uniqueItems !== true)
    return casted;
  const unique = [...new Set(casted)];
  if (!Check(schema, references, unique))
    throw new ValueCastError(schema, "Array cast produced invalid data due to uniqueItems constraint");
  return unique;
}
function FromConstructor7(schema, references, value) {
  if (Check(schema, references, value))
    return Create2(schema, references);
  const required = new Set(schema.returns.required || []);
  const result = function() {
  };
  for (const [key, property] of Object.entries(schema.returns.properties)) {
    if (!required.has(key) && value.prototype[key] === undefined)
      continue;
    result.prototype[key] = Visit11(property, references, value.prototype[key]);
  }
  return result;
}
function FromImport6(schema, references, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit11(target, [...references, ...definitions], value);
}
function FromIntersect14(schema, references, value) {
  const created = Create2(schema, references);
  const mapped = IsObject2(created) && IsObject2(value) ? { ...created, ...value } : value;
  return Check(schema, references, mapped) ? mapped : Create2(schema, references);
}
function FromNever5(schema, references, value) {
  throw new ValueCastError(schema, "Never types cannot be cast");
}
function FromObject14(schema, references, value) {
  if (Check(schema, references, value))
    return value;
  if (value === null || typeof value !== "object")
    return Create2(schema, references);
  const required = new Set(schema.required || []);
  const result = {};
  for (const [key, property] of Object.entries(schema.properties)) {
    if (!required.has(key) && value[key] === undefined)
      continue;
    result[key] = Visit11(property, references, value[key]);
  }
  if (typeof schema.additionalProperties === "object") {
    const propertyNames = Object.getOwnPropertyNames(schema.properties);
    for (const propertyName of Object.getOwnPropertyNames(value)) {
      if (propertyNames.includes(propertyName))
        continue;
      result[propertyName] = Visit11(schema.additionalProperties, references, value[propertyName]);
    }
  }
  return result;
}
function FromRecord9(schema, references, value) {
  if (Check(schema, references, value))
    return Clone2(value);
  if (value === null || typeof value !== "object" || Array.isArray(value) || value instanceof Date)
    return Create2(schema, references);
  const subschemaPropertyName = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const subschema = schema.patternProperties[subschemaPropertyName];
  const result = {};
  for (const [propKey, propValue] of Object.entries(value)) {
    result[propKey] = Visit11(subschema, references, propValue);
  }
  return result;
}
function FromRef11(schema, references, value) {
  return Visit11(Deref2(schema, references), references, value);
}
function FromThis7(schema, references, value) {
  return Visit11(Deref2(schema, references), references, value);
}
function FromTuple11(schema, references, value) {
  if (Check(schema, references, value))
    return Clone2(value);
  if (!IsArray2(value))
    return Create2(schema, references);
  if (schema.items === undefined)
    return [];
  return schema.items.map((schema2, index) => Visit11(schema2, references, value[index]));
}
function FromUnion16(schema, references, value) {
  return Check(schema, references, value) ? Clone2(value) : CastUnion(schema, references, value);
}
function Visit11(schema, references, value) {
  const references_ = IsString2(schema.$id) ? Pushref(schema, references) : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray13(schema_, references_, value);
    case "Constructor":
      return FromConstructor7(schema_, references_, value);
    case "Import":
      return FromImport6(schema_, references_, value);
    case "Intersect":
      return FromIntersect14(schema_, references_, value);
    case "Never":
      return FromNever5(schema_, references_, value);
    case "Object":
      return FromObject14(schema_, references_, value);
    case "Record":
      return FromRecord9(schema_, references_, value);
    case "Ref":
      return FromRef11(schema_, references_, value);
    case "This":
      return FromThis7(schema_, references_, value);
    case "Tuple":
      return FromTuple11(schema_, references_, value);
    case "Union":
      return FromUnion16(schema_, references_, value);
    case "Date":
    case "Symbol":
    case "Uint8Array":
      return DefaultClone(schema, references, value);
    default:
      return Default3(schema_, references_, value);
  }
}
function Cast(...args) {
  return args.length === 3 ? Visit11(args[0], args[1], args[2]) : Visit11(args[0], [], args[1]);
}
// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/value/clean/clean.mjs
function IsCheckable(schema) {
  return IsKind(schema) && schema[Kind] !== "Unsafe";
}
function FromArray14(schema, references, value) {
  if (!IsArray2(value))
    return value;
  return value.map((value2) => Visit12(schema.items, references, value2));
}
function FromImport7(schema, references, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit12(target, [...references, ...definitions], value);
}
function FromIntersect15(schema, references, value) {
  const unevaluatedProperties = schema.unevaluatedProperties;
  const intersections = schema.allOf.map((schema2) => Visit12(schema2, references, Clone2(value)));
  const composite = intersections.reduce((acc, value2) => IsObject2(value2) ? { ...acc, ...value2 } : value2, {});
  if (!IsObject2(value) || !IsObject2(composite) || !IsKind(unevaluatedProperties))
    return composite;
  const knownkeys = KeyOfPropertyKeys(schema);
  for (const key of Object.getOwnPropertyNames(value)) {
    if (knownkeys.includes(key))
      continue;
    if (Check(unevaluatedProperties, references, value[key])) {
      composite[key] = Visit12(unevaluatedProperties, references, value[key]);
    }
  }
  return composite;
}
function FromObject15(schema, references, value) {
  if (!IsObject2(value) || IsArray2(value))
    return value;
  const additionalProperties = schema.additionalProperties;
  for (const key of Object.getOwnPropertyNames(value)) {
    if (HasPropertyKey2(schema.properties, key)) {
      value[key] = Visit12(schema.properties[key], references, value[key]);
      continue;
    }
    if (IsKind(additionalProperties) && Check(additionalProperties, references, value[key])) {
      value[key] = Visit12(additionalProperties, references, value[key]);
      continue;
    }
    delete value[key];
  }
  return value;
}
function FromRecord10(schema, references, value) {
  if (!IsObject2(value))
    return value;
  const additionalProperties = schema.additionalProperties;
  const propertyKeys = Object.getOwnPropertyNames(value);
  const [propertyKey, propertySchema] = Object.entries(schema.patternProperties)[0];
  const propertyKeyTest = new RegExp(propertyKey);
  for (const key of propertyKeys) {
    if (propertyKeyTest.test(key)) {
      value[key] = Visit12(propertySchema, references, value[key]);
      continue;
    }
    if (IsKind(additionalProperties) && Check(additionalProperties, references, value[key])) {
      value[key] = Visit12(additionalProperties, references, value[key]);
      continue;
    }
    delete value[key];
  }
  return value;
}
function FromRef12(schema, references, value) {
  return Visit12(Deref2(schema, references), references, value);
}
function FromThis8(schema, references, value) {
  return Visit12(Deref2(schema, references), references, value);
}
function FromTuple12(schema, references, value) {
  if (!IsArray2(value))
    return value;
  if (IsUndefined2(schema.items))
    return [];
  const length = Math.min(value.length, schema.items.length);
  for (let i = 0;i < length; i++) {
    value[i] = Visit12(schema.items[i], references, value[i]);
  }
  return value.length > length ? value.slice(0, length) : value;
}
function FromUnion17(schema, references, value) {
  for (const inner of schema.anyOf) {
    if (IsCheckable(inner) && Check(inner, references, value)) {
      return Visit12(inner, references, value);
    }
  }
  return value;
}
function Visit12(schema, references, value) {
  const references_ = IsString2(schema.$id) ? Pushref(schema, references) : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Array":
      return FromArray14(schema_, references_, value);
    case "Import":
      return FromImport7(schema_, references_, value);
    case "Intersect":
      return FromIntersect15(schema_, references_, value);
    case "Object":
      return FromObject15(schema_, references_, value);
    case "Record":
      return FromRecord10(schema_, references_, value);
    case "Ref":
      return FromRef12(schema_, references_, value);
    case "This":
      return FromThis8(schema_, references_, value);
    case "Tuple":
      return FromTuple12(schema_, references_, value);
    case "Union":
      return FromUnion17(schema_, references_, value);
    default:
      return value;
  }
}
function Clean(...args) {
  return args.length === 3 ? Visit12(args[0], args[1], args[2]) : Visit12(args[0], [], args[1]);
}
// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/value/convert/convert.mjs
function IsStringNumeric(value) {
  return IsString2(value) && !isNaN(value) && !isNaN(parseFloat(value));
}
function IsValueToString(value) {
  return IsBigInt2(value) || IsBoolean2(value) || IsNumber2(value);
}
function IsValueTrue(value) {
  return value === true || IsNumber2(value) && value === 1 || IsBigInt2(value) && value === BigInt("1") || IsString2(value) && (value.toLowerCase() === "true" || value === "1");
}
function IsValueFalse(value) {
  return value === false || IsNumber2(value) && (value === 0 || Object.is(value, -0)) || IsBigInt2(value) && value === BigInt("0") || IsString2(value) && (value.toLowerCase() === "false" || value === "0" || value === "-0");
}
function IsTimeStringWithTimeZone(value) {
  return IsString2(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
}
function IsTimeStringWithoutTimeZone(value) {
  return IsString2(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
}
function IsDateTimeStringWithTimeZone(value) {
  return IsString2(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
}
function IsDateTimeStringWithoutTimeZone(value) {
  return IsString2(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
}
function IsDateString(value) {
  return IsString2(value) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test(value);
}
function TryConvertLiteralString(value, target) {
  const conversion = TryConvertString(value);
  return conversion === target ? conversion : value;
}
function TryConvertLiteralNumber(value, target) {
  const conversion = TryConvertNumber(value);
  return conversion === target ? conversion : value;
}
function TryConvertLiteralBoolean(value, target) {
  const conversion = TryConvertBoolean(value);
  return conversion === target ? conversion : value;
}
function TryConvertLiteral(schema, value) {
  return IsString2(schema.const) ? TryConvertLiteralString(value, schema.const) : IsNumber2(schema.const) ? TryConvertLiteralNumber(value, schema.const) : IsBoolean2(schema.const) ? TryConvertLiteralBoolean(value, schema.const) : value;
}
function TryConvertBoolean(value) {
  return IsValueTrue(value) ? true : IsValueFalse(value) ? false : value;
}
function TryConvertBigInt(value) {
  const truncateInteger = (value2) => value2.split(".")[0];
  return IsStringNumeric(value) ? BigInt(truncateInteger(value)) : IsNumber2(value) ? BigInt(Math.trunc(value)) : IsValueFalse(value) ? BigInt(0) : IsValueTrue(value) ? BigInt(1) : value;
}
function TryConvertString(value) {
  return IsSymbol2(value) && value.description !== undefined ? value.description.toString() : IsValueToString(value) ? value.toString() : value;
}
function TryConvertNumber(value) {
  return IsStringNumeric(value) ? parseFloat(value) : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
}
function TryConvertInteger(value) {
  return IsStringNumeric(value) ? parseInt(value) : IsNumber2(value) ? value | 0 : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
}
function TryConvertNull(value) {
  return IsString2(value) && value.toLowerCase() === "null" ? null : value;
}
function TryConvertUndefined(value) {
  return IsString2(value) && value === "undefined" ? undefined : value;
}
function TryConvertDate(value) {
  return IsDate2(value) ? value : IsNumber2(value) ? new Date(value) : IsValueTrue(value) ? new Date(1) : IsValueFalse(value) ? new Date(0) : IsStringNumeric(value) ? new Date(parseInt(value)) : IsTimeStringWithoutTimeZone(value) ? new Date(`1970-01-01T${value}.000Z`) : IsTimeStringWithTimeZone(value) ? new Date(`1970-01-01T${value}`) : IsDateTimeStringWithoutTimeZone(value) ? new Date(`${value}.000Z`) : IsDateTimeStringWithTimeZone(value) ? new Date(value) : IsDateString(value) ? new Date(`${value}T00:00:00.000Z`) : value;
}
function Default4(value) {
  return value;
}
function FromArray15(schema, references, value) {
  const elements = IsArray2(value) ? value : [value];
  return elements.map((element) => Visit13(schema.items, references, element));
}
function FromBigInt5(schema, references, value) {
  return TryConvertBigInt(value);
}
function FromBoolean5(schema, references, value) {
  return TryConvertBoolean(value);
}
function FromDate6(schema, references, value) {
  return TryConvertDate(value);
}
function FromImport8(schema, references, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit13(target, [...references, ...definitions], value);
}
function FromInteger5(schema, references, value) {
  return TryConvertInteger(value);
}
function FromIntersect16(schema, references, value) {
  return schema.allOf.reduce((value2, schema2) => Visit13(schema2, references, value2), value);
}
function FromLiteral6(schema, references, value) {
  return TryConvertLiteral(schema, value);
}
function FromNull5(schema, references, value) {
  return TryConvertNull(value);
}
function FromNumber5(schema, references, value) {
  return TryConvertNumber(value);
}
function FromObject16(schema, references, value) {
  if (!IsObject2(value))
    return value;
  for (const propertyKey of Object.getOwnPropertyNames(schema.properties)) {
    if (!HasPropertyKey2(value, propertyKey))
      continue;
    value[propertyKey] = Visit13(schema.properties[propertyKey], references, value[propertyKey]);
  }
  return value;
}
function FromRecord11(schema, references, value) {
  const isConvertable = IsObject2(value);
  if (!isConvertable)
    return value;
  const propertyKey = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[propertyKey];
  for (const [propKey, propValue] of Object.entries(value)) {
    value[propKey] = Visit13(property, references, propValue);
  }
  return value;
}
function FromRef13(schema, references, value) {
  return Visit13(Deref2(schema, references), references, value);
}
function FromString5(schema, references, value) {
  return TryConvertString(value);
}
function FromSymbol5(schema, references, value) {
  return IsString2(value) || IsNumber2(value) ? Symbol(value) : value;
}
function FromThis9(schema, references, value) {
  return Visit13(Deref2(schema, references), references, value);
}
function FromTuple13(schema, references, value) {
  const isConvertable = IsArray2(value) && !IsUndefined2(schema.items);
  if (!isConvertable)
    return value;
  return value.map((value2, index) => {
    return index < schema.items.length ? Visit13(schema.items[index], references, value2) : value2;
  });
}
function FromUndefined5(schema, references, value) {
  return TryConvertUndefined(value);
}
function FromUnion18(schema, references, value) {
  for (const subschema of schema.anyOf) {
    const converted = Visit13(subschema, references, Clone2(value));
    if (!Check(subschema, references, converted))
      continue;
    return converted;
  }
  return value;
}
function Visit13(schema, references, value) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray15(schema_, references_, value);
    case "BigInt":
      return FromBigInt5(schema_, references_, value);
    case "Boolean":
      return FromBoolean5(schema_, references_, value);
    case "Date":
      return FromDate6(schema_, references_, value);
    case "Import":
      return FromImport8(schema_, references_, value);
    case "Integer":
      return FromInteger5(schema_, references_, value);
    case "Intersect":
      return FromIntersect16(schema_, references_, value);
    case "Literal":
      return FromLiteral6(schema_, references_, value);
    case "Null":
      return FromNull5(schema_, references_, value);
    case "Number":
      return FromNumber5(schema_, references_, value);
    case "Object":
      return FromObject16(schema_, references_, value);
    case "Record":
      return FromRecord11(schema_, references_, value);
    case "Ref":
      return FromRef13(schema_, references_, value);
    case "String":
      return FromString5(schema_, references_, value);
    case "Symbol":
      return FromSymbol5(schema_, references_, value);
    case "This":
      return FromThis9(schema_, references_, value);
    case "Tuple":
      return FromTuple13(schema_, references_, value);
    case "Undefined":
      return FromUndefined5(schema_, references_, value);
    case "Union":
      return FromUnion18(schema_, references_, value);
    default:
      return Default4(value);
  }
}
function Convert(...args) {
  return args.length === 3 ? Visit13(args[0], args[1], args[2]) : Visit13(args[0], [], args[1]);
}
// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/value/decode/decode.mjs
function Decode(...args) {
  const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  if (!Check(schema, references, value))
    throw new TransformDecodeCheckError(schema, value, Errors(schema, references, value).First());
  return HasTransform(schema, references) ? TransformDecode(schema, references, value) : value;
}
// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/value/default/default.mjs
function ValueOrDefault(schema, value) {
  const defaultValue = HasPropertyKey2(schema, "default") ? schema.default : undefined;
  const clone = IsFunction2(defaultValue) ? defaultValue() : Clone2(defaultValue);
  return IsUndefined2(value) ? clone : IsObject2(value) && IsObject2(clone) ? Object.assign(clone, value) : value;
}
function HasDefaultProperty(schema) {
  return IsKind(schema) && "default" in schema;
}
function FromArray16(schema, references, value) {
  if (IsArray2(value)) {
    for (let i = 0;i < value.length; i++) {
      value[i] = Visit14(schema.items, references, value[i]);
    }
    return value;
  }
  const defaulted = ValueOrDefault(schema, value);
  if (!IsArray2(defaulted))
    return defaulted;
  for (let i = 0;i < defaulted.length; i++) {
    defaulted[i] = Visit14(schema.items, references, defaulted[i]);
  }
  return defaulted;
}
function FromDate7(schema, references, value) {
  return IsDate2(value) ? value : ValueOrDefault(schema, value);
}
function FromImport9(schema, references, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit14(target, [...references, ...definitions], value);
}
function FromIntersect17(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  return schema.allOf.reduce((acc, schema2) => {
    const next = Visit14(schema2, references, defaulted);
    return IsObject2(next) ? { ...acc, ...next } : next;
  }, {});
}
function FromObject17(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsObject2(defaulted))
    return defaulted;
  const knownPropertyKeys = Object.getOwnPropertyNames(schema.properties);
  for (const key of knownPropertyKeys) {
    const propertyValue = Visit14(schema.properties[key], references, defaulted[key]);
    if (IsUndefined2(propertyValue))
      continue;
    defaulted[key] = Visit14(schema.properties[key], references, defaulted[key]);
  }
  if (!HasDefaultProperty(schema.additionalProperties))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKeys.includes(key))
      continue;
    defaulted[key] = Visit14(schema.additionalProperties, references, defaulted[key]);
  }
  return defaulted;
}
function FromRecord12(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsObject2(defaulted))
    return defaulted;
  const additionalPropertiesSchema = schema.additionalProperties;
  const [propertyKeyPattern, propertySchema] = Object.entries(schema.patternProperties)[0];
  const knownPropertyKey = new RegExp(propertyKeyPattern);
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (!(knownPropertyKey.test(key) && HasDefaultProperty(propertySchema)))
      continue;
    defaulted[key] = Visit14(propertySchema, references, defaulted[key]);
  }
  if (!HasDefaultProperty(additionalPropertiesSchema))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKey.test(key))
      continue;
    defaulted[key] = Visit14(additionalPropertiesSchema, references, defaulted[key]);
  }
  return defaulted;
}
function FromRef14(schema, references, value) {
  return Visit14(Deref2(schema, references), references, ValueOrDefault(schema, value));
}
function FromThis10(schema, references, value) {
  return Visit14(Deref2(schema, references), references, value);
}
function FromTuple14(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsArray2(defaulted) || IsUndefined2(schema.items))
    return defaulted;
  const [items, max] = [schema.items, Math.max(schema.items.length, defaulted.length)];
  for (let i = 0;i < max; i++) {
    if (i < items.length)
      defaulted[i] = Visit14(items[i], references, defaulted[i]);
  }
  return defaulted;
}
function FromUnion19(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  for (const inner of schema.anyOf) {
    const result = Visit14(inner, references, Clone2(defaulted));
    if (Check(inner, references, result)) {
      return result;
    }
  }
  return defaulted;
}
function Visit14(schema, references, value) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Array":
      return FromArray16(schema_, references_, value);
    case "Date":
      return FromDate7(schema_, references_, value);
    case "Import":
      return FromImport9(schema_, references_, value);
    case "Intersect":
      return FromIntersect17(schema_, references_, value);
    case "Object":
      return FromObject17(schema_, references_, value);
    case "Record":
      return FromRecord12(schema_, references_, value);
    case "Ref":
      return FromRef14(schema_, references_, value);
    case "This":
      return FromThis10(schema_, references_, value);
    case "Tuple":
      return FromTuple14(schema_, references_, value);
    case "Union":
      return FromUnion19(schema_, references_, value);
    default:
      return ValueOrDefault(schema_, value);
  }
}
function Default5(...args) {
  return args.length === 3 ? Visit14(args[0], args[1], args[2]) : Visit14(args[0], [], args[1]);
}
// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/value/pointer/pointer.mjs
var exports_pointer = {};
__export(exports_pointer, {
  ValuePointerRootSetError: () => ValuePointerRootSetError,
  ValuePointerRootDeleteError: () => ValuePointerRootDeleteError,
  Set: () => Set4,
  Has: () => Has3,
  Get: () => Get3,
  Format: () => Format,
  Delete: () => Delete3
});
class ValuePointerRootSetError extends TypeBoxError {
  constructor(value, path, update) {
    super("Cannot set root value");
    this.value = value;
    this.path = path;
    this.update = update;
  }
}

class ValuePointerRootDeleteError extends TypeBoxError {
  constructor(value, path) {
    super("Cannot delete root value");
    this.value = value;
    this.path = path;
  }
}
function Escape2(component) {
  return component.indexOf("~") === -1 ? component : component.replace(/~1/g, "/").replace(/~0/g, "~");
}
function* Format(pointer) {
  if (pointer === "")
    return;
  let [start, end] = [0, 0];
  for (let i = 0;i < pointer.length; i++) {
    const char = pointer.charAt(i);
    if (char === "/") {
      if (i === 0) {
        start = i + 1;
      } else {
        end = i;
        yield Escape2(pointer.slice(start, end));
        start = i + 1;
      }
    } else {
      end = i;
    }
  }
  yield Escape2(pointer.slice(start));
}
function Set4(value, pointer, update) {
  if (pointer === "")
    throw new ValuePointerRootSetError(value, pointer, update);
  let [owner, next, key] = [null, value, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined)
      next[component] = {};
    owner = next;
    next = next[component];
    key = component;
  }
  owner[key] = update;
}
function Delete3(value, pointer) {
  if (pointer === "")
    throw new ValuePointerRootDeleteError(value, pointer);
  let [owner, next, key] = [null, value, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined || next[component] === null)
      return;
    owner = next;
    next = next[component];
    key = component;
  }
  if (Array.isArray(owner)) {
    const index = parseInt(key);
    owner.splice(index, 1);
  } else {
    delete owner[key];
  }
}
function Has3(value, pointer) {
  if (pointer === "")
    return true;
  let [owner, next, key] = [null, value, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined)
      return false;
    owner = next;
    next = next[component];
    key = component;
  }
  return Object.getOwnPropertyNames(owner).includes(key);
}
function Get3(value, pointer) {
  if (pointer === "")
    return value;
  let current = value;
  for (const component of Format(pointer)) {
    if (current[component] === undefined)
      return;
    current = current[component];
  }
  return current;
}
// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/value/equal/equal.mjs
function ObjectType3(left, right) {
  if (!IsObject2(right))
    return false;
  const leftKeys = [...Object.keys(left), ...Object.getOwnPropertySymbols(left)];
  const rightKeys = [...Object.keys(right), ...Object.getOwnPropertySymbols(right)];
  if (leftKeys.length !== rightKeys.length)
    return false;
  return leftKeys.every((key) => Equal(left[key], right[key]));
}
function DateType3(left, right) {
  return IsDate2(right) && left.getTime() === right.getTime();
}
function ArrayType3(left, right) {
  if (!IsArray2(right) || left.length !== right.length)
    return false;
  return left.every((value, index) => Equal(value, right[index]));
}
function TypedArrayType(left, right) {
  if (!IsTypedArray(right) || left.length !== right.length || Object.getPrototypeOf(left).constructor.name !== Object.getPrototypeOf(right).constructor.name)
    return false;
  return left.every((value, index) => Equal(value, right[index]));
}
function ValueType(left, right) {
  return left === right;
}
function Equal(left, right) {
  if (IsDate2(left))
    return DateType3(left, right);
  if (IsTypedArray(left))
    return TypedArrayType(left, right);
  if (IsArray2(left))
    return ArrayType3(left, right);
  if (IsObject2(left))
    return ObjectType3(left, right);
  if (IsValueType(left))
    return ValueType(left, right);
  throw new Error("ValueEquals: Unable to compare value");
}

// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/value/delta/delta.mjs
var Insert = Object2({
  type: Literal("insert"),
  path: String2(),
  value: Unknown()
});
var Update = Object2({
  type: Literal("update"),
  path: String2(),
  value: Unknown()
});
var Delete4 = Object2({
  type: Literal("delete"),
  path: String2()
});
var Edit = Union([Insert, Update, Delete4]);

class ValueDiffError extends TypeBoxError {
  constructor(value, message) {
    super(message);
    this.value = value;
  }
}
function CreateUpdate(path, value) {
  return { type: "update", path, value };
}
function CreateInsert(path, value) {
  return { type: "insert", path, value };
}
function CreateDelete(path) {
  return { type: "delete", path };
}
function AssertDiffable(value) {
  if (globalThis.Object.getOwnPropertySymbols(value).length > 0)
    throw new ValueDiffError(value, "Cannot diff objects with symbols");
}
function* ObjectType4(path, current, next) {
  AssertDiffable(current);
  AssertDiffable(next);
  if (!IsStandardObject(next))
    return yield CreateUpdate(path, next);
  const currentKeys = globalThis.Object.getOwnPropertyNames(current);
  const nextKeys = globalThis.Object.getOwnPropertyNames(next);
  for (const key of nextKeys) {
    if (HasPropertyKey2(current, key))
      continue;
    yield CreateInsert(`${path}/${key}`, next[key]);
  }
  for (const key of currentKeys) {
    if (!HasPropertyKey2(next, key))
      continue;
    if (Equal(current, next))
      continue;
    yield* Visit15(`${path}/${key}`, current[key], next[key]);
  }
  for (const key of currentKeys) {
    if (HasPropertyKey2(next, key))
      continue;
    yield CreateDelete(`${path}/${key}`);
  }
}
function* ArrayType4(path, current, next) {
  if (!IsArray2(next))
    return yield CreateUpdate(path, next);
  for (let i = 0;i < Math.min(current.length, next.length); i++) {
    yield* Visit15(`${path}/${i}`, current[i], next[i]);
  }
  for (let i = 0;i < next.length; i++) {
    if (i < current.length)
      continue;
    yield CreateInsert(`${path}/${i}`, next[i]);
  }
  for (let i = current.length - 1;i >= 0; i--) {
    if (i < next.length)
      continue;
    yield CreateDelete(`${path}/${i}`);
  }
}
function* TypedArrayType2(path, current, next) {
  if (!IsTypedArray(next) || current.length !== next.length || globalThis.Object.getPrototypeOf(current).constructor.name !== globalThis.Object.getPrototypeOf(next).constructor.name)
    return yield CreateUpdate(path, next);
  for (let i = 0;i < Math.min(current.length, next.length); i++) {
    yield* Visit15(`${path}/${i}`, current[i], next[i]);
  }
}
function* ValueType2(path, current, next) {
  if (current === next)
    return;
  yield CreateUpdate(path, next);
}
function* Visit15(path, current, next) {
  if (IsStandardObject(current))
    return yield* ObjectType4(path, current, next);
  if (IsArray2(current))
    return yield* ArrayType4(path, current, next);
  if (IsTypedArray(current))
    return yield* TypedArrayType2(path, current, next);
  if (IsValueType(current))
    return yield* ValueType2(path, current, next);
  throw new ValueDiffError(current, "Unable to diff value");
}
function Diff(current, next) {
  return [...Visit15("", current, next)];
}
function IsRootUpdate(edits) {
  return edits.length > 0 && edits[0].path === "" && edits[0].type === "update";
}
function IsIdentity(edits) {
  return edits.length === 0;
}
function Patch(current, edits) {
  if (IsRootUpdate(edits)) {
    return Clone2(edits[0].value);
  }
  if (IsIdentity(edits)) {
    return Clone2(current);
  }
  const clone = Clone2(current);
  for (const edit of edits) {
    switch (edit.type) {
      case "insert": {
        exports_pointer.Set(clone, edit.path, edit.value);
        break;
      }
      case "update": {
        exports_pointer.Set(clone, edit.path, edit.value);
        break;
      }
      case "delete": {
        exports_pointer.Delete(clone, edit.path);
        break;
      }
    }
  }
  return clone;
}
// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/value/encode/encode.mjs
function Encode(...args) {
  const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  const encoded = HasTransform(schema, references) ? TransformEncode(schema, references, value) : value;
  if (!Check(schema, references, encoded))
    throw new TransformEncodeCheckError(schema, encoded, Errors(schema, references, encoded).First());
  return encoded;
}
// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/value/mutate/mutate.mjs
function IsStandardObject2(value) {
  return IsObject2(value) && !IsArray2(value);
}

class ValueMutateError extends TypeBoxError {
  constructor(message) {
    super(message);
  }
}
function ObjectType5(root, path, current, next) {
  if (!IsStandardObject2(current)) {
    exports_pointer.Set(root, path, Clone2(next));
  } else {
    const currentKeys = Object.getOwnPropertyNames(current);
    const nextKeys = Object.getOwnPropertyNames(next);
    for (const currentKey of currentKeys) {
      if (!nextKeys.includes(currentKey)) {
        delete current[currentKey];
      }
    }
    for (const nextKey of nextKeys) {
      if (!currentKeys.includes(nextKey)) {
        current[nextKey] = null;
      }
    }
    for (const nextKey of nextKeys) {
      Visit16(root, `${path}/${nextKey}`, current[nextKey], next[nextKey]);
    }
  }
}
function ArrayType5(root, path, current, next) {
  if (!IsArray2(current)) {
    exports_pointer.Set(root, path, Clone2(next));
  } else {
    for (let index = 0;index < next.length; index++) {
      Visit16(root, `${path}/${index}`, current[index], next[index]);
    }
    current.splice(next.length);
  }
}
function TypedArrayType3(root, path, current, next) {
  if (IsTypedArray(current) && current.length === next.length) {
    for (let i = 0;i < current.length; i++) {
      current[i] = next[i];
    }
  } else {
    exports_pointer.Set(root, path, Clone2(next));
  }
}
function ValueType3(root, path, current, next) {
  if (current === next)
    return;
  exports_pointer.Set(root, path, next);
}
function Visit16(root, path, current, next) {
  if (IsArray2(next))
    return ArrayType5(root, path, current, next);
  if (IsTypedArray(next))
    return TypedArrayType3(root, path, current, next);
  if (IsStandardObject2(next))
    return ObjectType5(root, path, current, next);
  if (IsValueType(next))
    return ValueType3(root, path, current, next);
}
function IsNonMutableValue(value) {
  return IsTypedArray(value) || IsValueType(value);
}
function IsMismatchedValue(current, next) {
  return IsStandardObject2(current) && IsArray2(next) || IsArray2(current) && IsStandardObject2(next);
}
function Mutate(current, next) {
  if (IsNonMutableValue(current) || IsNonMutableValue(next))
    throw new ValueMutateError("Only object and array types can be mutated at the root level");
  if (IsMismatchedValue(current, next))
    throw new ValueMutateError("Cannot assign due type mismatch of assignable values");
  Visit16(current, "", current, next);
}
// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/value/parse/parse.mjs
class ParseError extends TypeBoxError {
  constructor(message) {
    super(message);
  }
}
var ParseRegistry;
(function(ParseRegistry2) {
  const registry = new Map([
    ["Clone", (_type, _references, value) => Clone2(value)],
    ["Clean", (type, references, value) => Clean(type, references, value)],
    ["Default", (type, references, value) => Default5(type, references, value)],
    ["Convert", (type, references, value) => Convert(type, references, value)],
    ["Assert", (type, references, value) => {
      Assert(type, references, value);
      return value;
    }],
    ["Decode", (type, references, value) => HasTransform(type, references) ? TransformDecode(type, references, value) : value],
    ["Encode", (type, references, value) => HasTransform(type, references) ? TransformEncode(type, references, value) : value]
  ]);
  function Delete5(key) {
    registry.delete(key);
  }
  ParseRegistry2.Delete = Delete5;
  function Set5(key, callback) {
    registry.set(key, callback);
  }
  ParseRegistry2.Set = Set5;
  function Get4(key) {
    return registry.get(key);
  }
  ParseRegistry2.Get = Get4;
})(ParseRegistry || (ParseRegistry = {}));
var ParseDefault = [
  "Clone",
  "Clean",
  "Default",
  "Convert",
  "Assert",
  "Decode"
];
function ParseValue(operations, type, references, value) {
  return operations.reduce((value2, operationKey) => {
    const operation = ParseRegistry.Get(operationKey);
    if (IsUndefined2(operation))
      throw new ParseError(`Unable to find Parse operation '${operationKey}'`);
    return operation(type, references, value2);
  }, value);
}
function Parse(...args) {
  const [operations, schema, references, value] = args.length === 4 ? [args[0], args[1], args[2], args[3]] : args.length === 3 ? IsArray2(args[0]) ? [args[0], args[1], [], args[2]] : [ParseDefault, args[0], args[1], args[2]] : args.length === 2 ? [ParseDefault, args[0], [], args[1]] : (() => {
    throw new ParseError("Invalid Arguments");
  })();
  return ParseValue(operations, schema, references, value);
}
// node_modules/.pnpm/@sinclair+typebox@0.34.13/node_modules/@sinclair/typebox/build/esm/value/value/value.mjs
var exports_value2 = {};
__export(exports_value2, {
  ValueErrorIterator: () => ValueErrorIterator,
  Patch: () => Patch,
  Parse: () => Parse,
  Mutate: () => Mutate,
  Hash: () => Hash,
  Errors: () => Errors,
  Equal: () => Equal,
  Encode: () => Encode,
  Edit: () => Edit,
  Diff: () => Diff,
  Default: () => Default5,
  Decode: () => Decode,
  Create: () => Create2,
  Convert: () => Convert,
  Clone: () => Clone2,
  Clean: () => Clean,
  Check: () => Check,
  Cast: () => Cast,
  Assert: () => Assert
});
// node_modules/.pnpm/elysia@1.2.9_@sinclair+typebox@0.34.13_openapi-types@12.1.3/node_modules/elysia/dist/bun/index.js
var import_cookie = __toESM(require_dist(), 1);
var import_fast_decode_uri_component = __toESM(require_fast_decode_uri_component(), 1);
var import_fast_decode_uri_component2 = __toESM(require_fast_decode_uri_component(), 1);
var import_fast_decode_uri_component3 = __toESM(require_fast_decode_uri_component(), 1);
var fullFormats = { date, time: getTime(true), "date-time": getDateTime(true), "iso-time": getTime(false), "iso-date-time": getDateTime(false), duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/, uri, "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i, "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i, url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu, email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i, hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i, ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/, ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i, regex, uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i, "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/, "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i, "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/, byte, int32: { type: "number", validate: validateInt32 }, int64: { type: "number", validate: validateInt64 }, float: { type: "number", validate: validateNumber }, double: { type: "number", validate: validateNumber }, password: true, binary: true };
function isLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function date(str) {
  let matches = DATE.exec(str);
  if (!matches)
    return false;
  let year = +matches[1], month = +matches[2], day = +matches[3];
  return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
}
var TIME = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
function getTime(strictTimeZone) {
  return function time(str) {
    let matches = TIME.exec(str);
    if (!matches)
      return false;
    let hr = +matches[1], min = +matches[2], sec = +matches[3], tz = matches[4], tzSign = matches[5] === "-" ? -1 : 1, tzH = +(matches[6] || 0), tzM = +(matches[7] || 0);
    if (tzH > 23 || tzM > 59 || strictTimeZone && !tz)
      return false;
    if (hr <= 23 && min <= 59 && sec < 60)
      return true;
    let utcMin = min - tzM * tzSign, utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
    return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
  };
}
var DATE_TIME_SEPARATOR = /t|\s/i;
function getDateTime(strictTimeZone) {
  let time = getTime(strictTimeZone);
  return function date_time(str) {
    let dateTime = str.split(DATE_TIME_SEPARATOR);
    return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1]);
  };
}
var NOT_URI_FRAGMENT = /\/|:/;
var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
function uri(str) {
  return NOT_URI_FRAGMENT.test(str) && URI.test(str);
}
var BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
function byte(str) {
  return BYTE.lastIndex = 0, BYTE.test(str);
}
var MIN_INT32 = -2147483648;
var MAX_INT32 = 2147483647;
function validateInt32(value) {
  return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
}
function validateInt64(value) {
  return Number.isInteger(value);
}
function validateNumber() {
  return true;
}
var Z_ANCHOR = /[^\\]\\Z/;
function regex(str) {
  if (Z_ANCHOR.test(str))
    return false;
  try {
    return new RegExp(str), true;
  } catch (e) {
    return false;
  }
}
var hasHeaderShorthand = "toJSON" in new Headers;
var replaceUrlPath = (url, pathname) => {
  let urlObject = new URL(url);
  return urlObject.pathname = pathname, urlObject.toString();
};
var isClass = (v) => typeof v === "function" && /^\s*class\s+/.test(v.toString()) || v.toString().startsWith("[object ") && v.toString() !== "[object Object]" || isNotEmpty(Object.getPrototypeOf(v));
var isObject = (item) => item && typeof item === "object" && !Array.isArray(item);
var mergeDeep = (target, source, { skipKeys, override = true } = {}) => {
  if (!isObject(target) || !isObject(source))
    return target;
  for (let [key, value] of Object.entries(source)) {
    if (skipKeys?.includes(key))
      continue;
    if (!isObject(value) || !(key in target) || isClass(value)) {
      if (override || !(key in target))
        target[key] = value;
      continue;
    }
    target[key] = mergeDeep(target[key], value, { skipKeys, override });
  }
  return target;
};
var mergeCookie = (a, b) => {
  let { properties: _2, ...target } = a ?? {}, { properties: __, ...source } = b ?? {};
  return mergeDeep(target, source);
};
var mergeObjectArray = (a = [], b = []) => {
  if (!a)
    return [];
  if (!b)
    return a;
  let array = [], checksums = [];
  if (!Array.isArray(a))
    a = [a];
  if (!Array.isArray(b))
    b = [b];
  for (let item of a)
    if (array.push(item), item.checksum)
      checksums.push(item.checksum);
  for (let item of b)
    if (!checksums.includes(item.checksum))
      array.push(item);
  return array;
};
var primitiveHooks = ["start", "request", "parse", "transform", "resolve", "beforeHandle", "afterHandle", "mapResponse", "afterResponse", "trace", "error", "stop", "body", "headers", "params", "query", "response", "type", "detail"];
var primitiveHookMap = primitiveHooks.reduce((acc, x) => (acc[x] = true, acc), {});
var mergeResponse = (a, b) => {
  let isRecordNumber = (x) => typeof x === "object" && Object.keys(x).every(isNumericString);
  if (isRecordNumber(a) && isRecordNumber(b))
    return { ...a, ...b };
  else if (a && !isRecordNumber(a) && isRecordNumber(b))
    return { 200: a, ...b };
  return b ?? a;
};
var mergeSchemaValidator = (a, b) => {
  return { body: b?.body ?? a?.body, headers: b?.headers ?? a?.headers, params: b?.params ?? a?.params, query: b?.query ?? a?.query, cookie: b?.cookie ?? a?.cookie, response: mergeResponse(a?.response, b?.response) };
};
var mergeHook = (a, b) => {
  let { resolve: resolveA, ...restA } = a ?? {}, { resolve: resolveB, ...restB } = b ?? {};
  return { ...restA, ...restB, body: b?.body ?? a?.body, headers: b?.headers ?? a?.headers, params: b?.params ?? a?.params, query: b?.query ?? a?.query, cookie: b?.cookie ?? a?.cookie, response: mergeResponse(a?.response, b?.response), type: a?.type || b?.type, detail: mergeDeep(b?.detail ?? {}, a?.detail ?? {}), parse: mergeObjectArray(a?.parse, b?.parse), transform: mergeObjectArray(a?.transform, b?.transform), beforeHandle: mergeObjectArray(mergeObjectArray(fnToContainer(resolveA, "resolve"), a?.beforeHandle), mergeObjectArray(fnToContainer(resolveB, "resolve"), b?.beforeHandle)), afterHandle: mergeObjectArray(a?.afterHandle, b?.afterHandle), mapResponse: mergeObjectArray(a?.mapResponse, b?.mapResponse), afterResponse: mergeObjectArray(a?.afterResponse, b?.afterResponse), trace: mergeObjectArray(a?.trace, b?.trace), error: mergeObjectArray(a?.error, b?.error) };
};
var replaceSchemaType = (schema, options, root = true) => {
  if (!Array.isArray(options))
    return _replaceSchemaType(schema, options, root);
  for (let option of options)
    schema = _replaceSchemaType(schema, option, root);
  return schema;
};
var _replaceSchemaType = (schema, options, root = true) => {
  if (!schema)
    return schema;
  if (options.untilObjectFound && !root && schema.type === "object")
    return schema;
  let fromSymbol = options.from[Kind];
  if (schema.oneOf) {
    for (let i = 0;i < schema.oneOf.length; i++)
      schema.oneOf[i] = _replaceSchemaType(schema.oneOf[i], options, root);
    return schema;
  }
  if (schema.anyOf) {
    for (let i = 0;i < schema.anyOf.length; i++)
      schema.anyOf[i] = _replaceSchemaType(schema.anyOf[i], options, root);
    return schema;
  }
  if (schema.allOf) {
    for (let i = 0;i < schema.allOf.length; i++)
      schema.allOf[i] = _replaceSchemaType(schema.allOf[i], options, root);
    return schema;
  }
  if (schema.not) {
    for (let i = 0;i < schema.not.length; i++)
      schema.not[i] = _replaceSchemaType(schema.not[i], options, root);
    return schema;
  }
  let isRoot = root && !!options.excludeRoot;
  if (schema[Kind] === fromSymbol) {
    let { anyOf, oneOf, allOf, not, properties: properties2, items, ...rest } = schema, to = options.to(rest), transform2, composeProperties = (v) => {
      if (properties2 && v.type === "object") {
        let newProperties = {};
        for (let [key, value2] of Object.entries(properties2))
          newProperties[key] = _replaceSchemaType(value2, options, false);
        return { ...rest, ...v, properties: newProperties };
      }
      if (items && v.type === "array")
        return { ...rest, ...v, items: _replaceSchemaType(items, options, false) };
      let value = { ...rest, ...v };
      if (delete value.required, properties2 && v.type === "string" && v.format === "ObjectString" && v.default === "{}")
        transform2 = t.ObjectString(properties2, rest), value.default = JSON.stringify(exports_value2.Create(t.Object(properties2))), value.properties = properties2;
      if (items && v.type === "string" && v.format === "ArrayString" && v.default === "[]")
        transform2 = t.ArrayString(items, rest), value.default = JSON.stringify(exports_value2.Create(t.Array(items))), value.items = items;
      return value;
    };
    if (isRoot) {
      if (properties2) {
        let newProperties = {};
        for (let [key, value] of Object.entries(properties2))
          newProperties[key] = _replaceSchemaType(value, options, false);
        return { ...rest, properties: newProperties };
      } else if (items?.map)
        return { ...rest, items: items.map((v) => _replaceSchemaType(v, options, false)) };
      return rest;
    }
    if (to.anyOf)
      for (let i = 0;i < to.anyOf.length; i++)
        to.anyOf[i] = composeProperties(to.anyOf[i]);
    else if (to.oneOf)
      for (let i = 0;i < to.oneOf.length; i++)
        to.oneOf[i] = composeProperties(to.oneOf[i]);
    else if (to.allOf)
      for (let i = 0;i < to.allOf.length; i++)
        to.allOf[i] = composeProperties(to.allOf[i]);
    else if (to.not)
      for (let i = 0;i < to.not.length; i++)
        to.not[i] = composeProperties(to.not[i]);
    if (transform2)
      to[TransformKind] = transform2[TransformKind];
    if (to.anyOf || to.oneOf || to.allOf || to.not)
      return to;
    if (properties2) {
      let newProperties = {};
      for (let [key, value] of Object.entries(properties2))
        newProperties[key] = _replaceSchemaType(value, options, false);
      return { ...rest, ...to, properties: newProperties };
    } else if (items?.map)
      return { ...rest, ...to, items: items.map((v) => _replaceSchemaType(v, options, false)) };
    return { ...rest, ...to };
  }
  let properties = schema?.properties;
  if (properties && root && options.rootOnly !== true)
    for (let [key, value] of Object.entries(properties))
      switch (value[Kind]) {
        case fromSymbol:
          let { anyOf, oneOf, allOf, not, type, ...rest } = value, to = options.to(rest);
          if (to.anyOf)
            for (let i = 0;i < to.anyOf.length; i++)
              to.anyOf[i] = { ...rest, ...to.anyOf[i] };
          else if (to.oneOf)
            for (let i = 0;i < to.oneOf.length; i++)
              to.oneOf[i] = { ...rest, ...to.oneOf[i] };
          else if (to.allOf)
            for (let i = 0;i < to.allOf.length; i++)
              to.allOf[i] = { ...rest, ...to.allOf[i] };
          else if (to.not)
            for (let i = 0;i < to.not.length; i++)
              to.not[i] = { ...rest, ...to.not[i] };
          properties[key] = { ...rest, ..._replaceSchemaType(rest, options, false) };
          break;
        case "Object":
        case "Union":
          properties[key] = _replaceSchemaType(value, options, false);
          break;
        default:
          if (value.items)
            for (let i = 0;i < value.items.length; i++)
              value.items[i] = _replaceSchemaType(value.items[i], options, false);
          else if (value.anyOf || value.oneOf || value.allOf || value.not)
            properties[key] = _replaceSchemaType(value, options, false);
          break;
      }
  return schema;
};
var createCleaner = (schema) => (value) => {
  if (typeof value === "object")
    try {
      return exports_value2.Clean(schema, structuredClone(value));
    } catch {
      try {
        return exports_value2.Clean(schema, value);
      } catch {
        return value;
      }
    }
  return value;
};
var getSchemaValidator = (s, { models = {}, dynamic = false, modules, normalize = false, additionalProperties = false, coerce = false, additionalCoerce = [] } = { modules: t.Module({}) }) => {
  if (!s)
    return;
  if (typeof s === "string" && !(s in models))
    return;
  let schema = typeof s === "string" ? modules.Import(s) ?? models[s] : s;
  if (coerce || additionalCoerce)
    if (coerce)
      schema = replaceSchemaType(schema, [{ from: t.Ref(""), to: (options) => modules.Import(options.$ref) }, { from: t.Number(), to: (options) => t.Numeric(options), untilObjectFound: true }, { from: t.Boolean(), to: (options) => t.BooleanString(options), untilObjectFound: true }, ...Array.isArray(additionalCoerce) ? additionalCoerce : [additionalCoerce]]);
    else
      schema = replaceSchemaType(schema, [{ from: t.Ref(""), to: (options) => modules.Import(options.$ref) }, ...Array.isArray(additionalCoerce) ? additionalCoerce : [additionalCoerce]]);
  if (schema.type === "object" && "additionalProperties" in schema === false)
    schema.additionalProperties = additionalProperties;
  if (dynamic) {
    let validator = { schema, references: "", checkFunc: () => {
    }, code: "", Check: (value) => exports_value2.Check(schema, value), Errors: (value) => exports_value2.Errors(schema, value), Code: () => "", Clean: createCleaner(schema), Decode: (value) => exports_value2.Decode(schema, value), Encode: (value) => exports_value2.Encode(schema, value) };
    if (normalize && schema.additionalProperties === false)
      validator.Clean = createCleaner(schema);
    if (schema.config) {
      if (validator.config = schema.config, validator?.schema?.config)
        delete validator.schema.config;
    }
    return validator.parse = (v) => {
      try {
        return validator.Decode(v);
      } catch (error) {
        throw [...validator.Errors(v)].map(mapValueError);
      }
    }, validator.safeParse = (v) => {
      try {
        return { success: true, data: validator.Decode(v), error: null };
      } catch (error) {
        let errors = [...compiled.Errors(v)].map(mapValueError);
        return { success: false, data: null, error: errors[0]?.summary, errors };
      }
    }, validator;
  }
  let compiled = TypeCompiler.Compile(schema, Object.values(models));
  if (compiled.Clean = createCleaner(schema), schema.config) {
    if (compiled.config = schema.config, compiled?.schema?.config)
      delete compiled.schema.config;
  }
  return compiled.parse = (v) => {
    try {
      return compiled.Decode(v);
    } catch (error) {
      throw [...compiled.Errors(v)].map(mapValueError);
    }
  }, compiled.safeParse = (v) => {
    try {
      return { success: true, data: compiled.Decode(v), error: null };
    } catch (error) {
      let errors = [...compiled.Errors(v)].map(mapValueError);
      return { success: false, data: null, error: errors[0]?.summary, errors };
    }
  }, compiled;
};
var getResponseSchemaValidator = (s, { models = {}, modules, dynamic = false, normalize = false, additionalProperties = false }) => {
  if (!s)
    return;
  if (typeof s === "string" && !(s in models))
    return;
  let maybeSchemaOrRecord = typeof s === "string" ? modules.Import(s) ?? models[s] : s, compile = (schema, references) => {
    if (dynamic)
      return { schema, references: "", checkFunc: () => {
      }, code: "", Check: (value) => exports_value2.Check(schema, value), Errors: (value) => exports_value2.Errors(schema, value), Code: () => "", Clean: createCleaner(schema), Decode: (value) => exports_value2.Decode(schema, value), Encode: (value) => exports_value2.Encode(schema, value) };
    let compiledValidator = TypeCompiler.Compile(schema, references);
    if (normalize && schema.additionalProperties === false)
      compiledValidator.Clean = createCleaner(schema);
    return compiledValidator;
  };
  if (Kind in maybeSchemaOrRecord) {
    if ("additionalProperties" in maybeSchemaOrRecord === false)
      maybeSchemaOrRecord.additionalProperties = additionalProperties;
    return { 200: compile(maybeSchemaOrRecord, Object.values(models)) };
  }
  let record = {};
  return Object.keys(maybeSchemaOrRecord).forEach((status) => {
    let maybeNameOrSchema = maybeSchemaOrRecord[+status];
    if (typeof maybeNameOrSchema === "string") {
      if (maybeNameOrSchema in models) {
        let schema = models[maybeNameOrSchema];
        schema.type === "object" && "additionalProperties" in schema, record[+status] = Kind in schema ? compile(schema, Object.values(models)) : schema;
      }
      return;
    }
    if (maybeNameOrSchema.type === "object" && "additionalProperties" in maybeNameOrSchema === false)
      maybeNameOrSchema.additionalProperties = additionalProperties;
    record[+status] = Kind in maybeNameOrSchema ? compile(maybeNameOrSchema, Object.values(models)) : maybeNameOrSchema;
  }), record;
};
var isBun = typeof Bun !== "undefined";
var hasHash = isBun && typeof Bun.hash === "function";
var checksum = (s) => {
  if (hasHash)
    return Bun.hash(s);
  let h = 9;
  for (let i = 0;i < s.length; )
    h = Math.imul(h ^ s.charCodeAt(i++), 387420489);
  return h = h ^ h >>> 9;
};
var _stringToStructureCoercions;
var stringToStructureCoercions = () => {
  if (!_stringToStructureCoercions)
    _stringToStructureCoercions = [{ from: t.Object({}), to: () => t.ObjectString({}), excludeRoot: true }, { from: t.Array(t.Any()), to: () => t.ArrayString(t.Any()) }];
  return _stringToStructureCoercions;
};
var _coercePrimitiveRoot;
var coercePrimitiveRoot = () => {
  if (!_coercePrimitiveRoot)
    _coercePrimitiveRoot = [{ from: t.Number(), to: (options) => t.Numeric(options), rootOnly: true }, { from: t.Boolean(), to: (options) => t.BooleanString(options), rootOnly: true }];
  return _coercePrimitiveRoot;
};
var getCookieValidator = ({ validator, modules, defaultConfig = {}, config: config2, dynamic, models }) => {
  let cookieValidator = getSchemaValidator(validator, { modules, dynamic, models, additionalProperties: true, coerce: true, additionalCoerce: stringToStructureCoercions() });
  if (isNotEmpty(defaultConfig))
    if (cookieValidator)
      cookieValidator.config = mergeCookie(cookieValidator.config, config2);
    else
      cookieValidator = getSchemaValidator(t.Cookie({}), { modules, dynamic, models, additionalProperties: true }), cookieValidator.config = defaultConfig;
  return cookieValidator;
};
var injectChecksum = (checksum2, x) => {
  if (!x)
    return;
  if (!Array.isArray(x)) {
    let fn = x;
    if (checksum2 && !fn.checksum)
      fn.checksum = checksum2;
    if (fn.scope === "scoped")
      fn.scope = "local";
    return fn;
  }
  let fns = [...x];
  for (let fn of fns) {
    if (checksum2 && !fn.checksum)
      fn.checksum = checksum2;
    if (fn.scope === "scoped")
      fn.scope = "local";
  }
  return fns;
};
var mergeLifeCycle = (a, b, checksum2) => {
  return { start: mergeObjectArray(a.start, injectChecksum(checksum2, b?.start)), request: mergeObjectArray(a.request, injectChecksum(checksum2, b?.request)), parse: mergeObjectArray(a.parse, injectChecksum(checksum2, b?.parse)), transform: mergeObjectArray(a.transform, injectChecksum(checksum2, b?.transform)), beforeHandle: mergeObjectArray(mergeObjectArray(fnToContainer(a.resolve, "resolve"), a.beforeHandle), injectChecksum(checksum2, mergeObjectArray(fnToContainer(b?.resolve, "resolve"), b?.beforeHandle))), afterHandle: mergeObjectArray(a.afterHandle, injectChecksum(checksum2, b?.afterHandle)), mapResponse: mergeObjectArray(a.mapResponse, injectChecksum(checksum2, b?.mapResponse)), afterResponse: mergeObjectArray(a.afterResponse, injectChecksum(checksum2, b?.afterResponse)), trace: mergeObjectArray(a.trace, injectChecksum(checksum2, b?.trace)), error: mergeObjectArray(a.error, injectChecksum(checksum2, b?.error)), stop: mergeObjectArray(a.stop, injectChecksum(checksum2, b?.stop)) };
};
var asHookType = (fn, inject, { skipIfHasType = false } = {}) => {
  if (!fn)
    return fn;
  if (!Array.isArray(fn)) {
    if (skipIfHasType)
      fn.scope ??= inject;
    else
      fn.scope = inject;
    return fn;
  }
  for (let x of fn)
    if (skipIfHasType)
      x.scope ??= inject;
    else
      x.scope = inject;
  return fn;
};
var filterGlobal = (fn) => {
  if (!fn)
    return fn;
  if (!Array.isArray(fn))
    switch (fn.scope) {
      case "global":
      case "scoped":
        return { ...fn };
      default:
        return { fn };
    }
  let array = [];
  for (let x of fn)
    switch (x.scope) {
      case "global":
      case "scoped":
        array.push({ ...x });
        break;
    }
  return array;
};
var filterGlobalHook = (hook) => {
  return { ...hook, type: hook?.type, detail: hook?.detail, parse: filterGlobal(hook?.parse), transform: filterGlobal(hook?.transform), beforeHandle: filterGlobal(hook?.beforeHandle), afterHandle: filterGlobal(hook?.afterHandle), mapResponse: filterGlobal(hook?.mapResponse), afterResponse: filterGlobal(hook?.afterResponse), error: filterGlobal(hook?.error), trace: filterGlobal(hook?.trace) };
};
var StatusMap = { Continue: 100, "Switching Protocols": 101, Processing: 102, "Early Hints": 103, OK: 200, Created: 201, Accepted: 202, "Non-Authoritative Information": 203, "No Content": 204, "Reset Content": 205, "Partial Content": 206, "Multi-Status": 207, "Already Reported": 208, "Multiple Choices": 300, "Moved Permanently": 301, Found: 302, "See Other": 303, "Not Modified": 304, "Temporary Redirect": 307, "Permanent Redirect": 308, "Bad Request": 400, Unauthorized: 401, "Payment Required": 402, Forbidden: 403, "Not Found": 404, "Method Not Allowed": 405, "Not Acceptable": 406, "Proxy Authentication Required": 407, "Request Timeout": 408, Conflict: 409, Gone: 410, "Length Required": 411, "Precondition Failed": 412, "Payload Too Large": 413, "URI Too Long": 414, "Unsupported Media Type": 415, "Range Not Satisfiable": 416, "Expectation Failed": 417, "I'm a teapot": 418, "Misdirected Request": 421, "Unprocessable Content": 422, Locked: 423, "Failed Dependency": 424, "Too Early": 425, "Upgrade Required": 426, "Precondition Required": 428, "Too Many Requests": 429, "Request Header Fields Too Large": 431, "Unavailable For Legal Reasons": 451, "Internal Server Error": 500, "Not Implemented": 501, "Bad Gateway": 502, "Service Unavailable": 503, "Gateway Timeout": 504, "HTTP Version Not Supported": 505, "Variant Also Negotiates": 506, "Insufficient Storage": 507, "Loop Detected": 508, "Not Extended": 510, "Network Authentication Required": 511 };
var InvertedStatusMap = Object.fromEntries(Object.entries(StatusMap).map(([k, v]) => [v, k]));
function removeTrailingEquals(digest) {
  let trimmedDigest = digest;
  while (trimmedDigest.endsWith("="))
    trimmedDigest = trimmedDigest.slice(0, -1);
  return trimmedDigest;
}
var encoder = new TextEncoder;
var signCookie = async (val, secret) => {
  if (typeof val !== "string")
    throw new TypeError("Cookie value must be provided as a string.");
  if (secret === null)
    throw new TypeError("Secret key must be provided.");
  let secretKey = await crypto.subtle.importKey("raw", encoder.encode(secret), { name: "HMAC", hash: "SHA-256" }, false, ["sign"]), hmacBuffer = await crypto.subtle.sign("HMAC", secretKey, encoder.encode(val));
  return val + "." + removeTrailingEquals(Buffer.from(hmacBuffer).toString("base64"));
};
var unsignCookie = async (input, secret) => {
  if (typeof input !== "string")
    throw new TypeError("Signed cookie string must be provided.");
  if (secret === null)
    throw new TypeError("Secret key must be provided.");
  let tentativeValue = input.slice(0, input.lastIndexOf("."));
  return await signCookie(tentativeValue, secret) === input ? tentativeValue : false;
};
var traceBackMacro = (extension, property, manage) => {
  if (!extension || typeof extension !== "object" || !property)
    return;
  for (let [key, value] of Object.entries(property)) {
    if (key in primitiveHookMap || !(key in extension))
      continue;
    let v = extension[key];
    if (typeof v === "function") {
      let hook = v(value);
      if (typeof hook === "object")
        for (let [k, v2] of Object.entries(hook))
          manage(k)({ fn: v2 });
      delete property[key];
    }
  }
};
var createMacroManager = ({ globalHook, localHook }) => (stackName) => (type, fn) => {
  if (typeof type === "function")
    type = { fn: type };
  if (stackName === "resolve")
    type = { ...type, subType: "resolve" };
  if ("fn" in type || Array.isArray(type)) {
    if (!localHook[stackName])
      localHook[stackName] = [];
    if (typeof localHook[stackName] === "function")
      localHook[stackName] = [localHook[stackName]];
    if (Array.isArray(type))
      localHook[stackName] = localHook[stackName].concat(type);
    else
      localHook[stackName].push(type);
    return;
  }
  let { insert = "after", stack = "local" } = type;
  if (typeof fn === "function")
    fn = { fn };
  if (stack === "global")
    if (!Array.isArray(fn))
      if (insert === "before")
        globalHook[stackName].unshift(fn);
      else
        globalHook[stackName].push(fn);
    else if (insert === "before")
      globalHook[stackName] = fn.concat(globalHook[stackName]);
    else
      globalHook[stackName] = globalHook[stackName].concat(fn);
  else {
    if (!localHook[stackName])
      localHook[stackName] = [];
    if (typeof localHook[stackName] === "function")
      localHook[stackName] = [localHook[stackName]];
    if (!Array.isArray(fn))
      if (insert === "before")
        localHook[stackName].unshift(fn);
      else
        localHook[stackName].push(fn);
    else if (insert === "before")
      localHook[stackName] = fn.concat(localHook[stackName]);
    else
      localHook[stackName] = localHook[stackName].concat(fn);
  }
};
var parseNumericString = (message) => {
  if (typeof message === "number")
    return message;
  if (message.length < 16) {
    if (message.trim().length === 0)
      return null;
    let length = Number(message);
    if (Number.isNaN(length))
      return null;
    return length;
  }
  if (message.length === 16) {
    if (message.trim().length === 0)
      return null;
    let number = Number(message);
    if (Number.isNaN(number) || number.toString() !== message)
      return null;
    return number;
  }
  return null;
};
var isNumericString = (message) => parseNumericString(message) !== null;

class PromiseGroup {
  onError;
  root = null;
  promises = [];
  constructor(onError = console.error) {
    this.onError = onError;
  }
  get size() {
    return this.promises.length;
  }
  add(promise) {
    return this.promises.push(promise), this.root ||= this.drain(), promise;
  }
  async drain() {
    while (this.promises.length > 0) {
      try {
        await this.promises[0];
      } catch (error) {
        this.onError(error);
      }
      this.promises.shift();
    }
    this.root = null;
  }
  then(onfulfilled, onrejected) {
    return (this.root ?? Promise.resolve()).then(onfulfilled, onrejected);
  }
}
var fnToContainer = (fn, subType) => {
  if (!fn)
    return fn;
  if (!Array.isArray(fn)) {
    if (typeof fn === "function" || typeof fn === "string")
      return subType ? { fn, subType } : { fn };
    else if ("fn" in fn)
      return fn;
  }
  let fns = [];
  for (let x of fn)
    if (typeof x === "function" || typeof x === "string")
      fns.push(subType ? { fn: x, subType } : { fn: x });
    else if ("fn" in x)
      fns.push(x);
  return fns;
};
var localHookToLifeCycleStore = (a) => {
  return { ...a, start: fnToContainer(a?.start), request: fnToContainer(a?.request), parse: fnToContainer(a?.parse), transform: fnToContainer(a?.transform), beforeHandle: fnToContainer(a?.beforeHandle), afterHandle: fnToContainer(a?.afterHandle), mapResponse: fnToContainer(a?.mapResponse), afterResponse: fnToContainer(a?.afterResponse), trace: fnToContainer(a?.trace), error: fnToContainer(a?.error), stop: fnToContainer(a?.stop) };
};
var lifeCycleToFn = (a) => {
  return { ...a, start: a.start?.map((x) => x.fn), request: a.request?.map((x) => x.fn), parse: a.parse?.map((x) => x.fn), transform: a.transform?.map((x) => x.fn), beforeHandle: a.beforeHandle?.map((x) => x.fn), afterHandle: a.afterHandle?.map((x) => x.fn), afterResponse: a.afterResponse?.map((x) => x.fn), mapResponse: a.mapResponse?.map((x) => x.fn), trace: a.trace?.map((x) => x.fn), error: a.error?.map((x) => x.fn), stop: a.stop?.map((x) => x.fn) };
};
var cloneInference = (inference) => ({ body: inference.body, cookie: inference.cookie, headers: inference.headers, query: inference.query, set: inference.set, server: inference.server, request: inference.request, route: inference.route });
var redirect = (url, status = 302) => Response.redirect(url, status);
var ELYSIA_FORM_DATA = Symbol("ElysiaFormData");
var ELYSIA_REQUEST_ID = Symbol("ElysiaRequestId");
var randomId = () => {
  let uuid = crypto.randomUUID();
  return uuid.slice(0, 8) + uuid.slice(24, 32);
};
var deduplicateChecksum = (array) => {
  let hashes = [];
  for (let i = 0;i < array.length; i++) {
    let item = array[i];
    if (item.checksum) {
      if (hashes.includes(item.checksum))
        array.splice(i, 1), i--;
      hashes.push(item.checksum);
    }
  }
  return array;
};
var promoteEvent = (events, as = "scoped") => {
  if (as === "scoped") {
    for (let event of events)
      if ("scope" in event && event.scope === "local")
        event.scope = "scoped";
    return;
  }
  for (let event of events)
    if ("scope" in event)
      event.scope = "global";
};
var getLoosePath = (path) => {
  if (path.charCodeAt(path.length - 1) === 47)
    return path.slice(0, path.length - 1);
  return path + "/";
};
var isNotEmpty = (obj) => {
  if (!obj)
    return false;
  for (let x in obj)
    return true;
  return false;
};
var env = typeof Bun !== "undefined" ? Bun.env : typeof process !== "undefined" ? process?.env : undefined;
var ERROR_CODE = Symbol("ElysiaErrorCode");
var isProduction = (env?.NODE_ENV ?? env?.ENV) === "production";

class ElysiaCustomStatusResponse {
  code;
  response;
  constructor(code, response) {
    let res = response ?? (code in InvertedStatusMap ? InvertedStatusMap[code] : code);
    this.code = StatusMap[code] ?? code, this.response = res;
  }
}
var error = (code, response) => new ElysiaCustomStatusResponse(code, response);

class InternalServerError extends Error {
  code = "INTERNAL_SERVER_ERROR";
  status = 500;
  constructor(message) {
    super(message ?? "INTERNAL_SERVER_ERROR");
  }
}

class NotFoundError extends Error {
  code = "NOT_FOUND";
  status = 404;
  constructor(message) {
    super(message ?? "NOT_FOUND");
  }
}

class ParseError2 extends Error {
  code = "PARSE";
  status = 400;
  constructor() {
    super("Bad Request");
  }
}

class InvalidCookieSignature extends Error {
  key;
  code = "INVALID_COOKIE_SIGNATURE";
  status = 400;
  constructor(key, message) {
    super(message ?? `"${key}" has invalid cookie signature`);
    this.key = key;
  }
}
var mapValueError = (error2) => {
  if (!error2)
    return { summary: undefined };
  let { message, path, value, type } = error2, property = path.slice(1).replaceAll("/", "."), isRoot = path === "";
  switch (type) {
    case 42:
      return { ...error2, summary: isRoot ? "Value should not be provided" : `Property '${property}' should not be provided` };
    case 45:
      return { ...error2, summary: isRoot ? "Value is missing" : `Property '${property}' is missing` };
    case 50:
      let quoteIndex = message.indexOf("'"), format = message.slice(quoteIndex + 1, message.indexOf("'", quoteIndex + 1));
      return { ...error2, summary: isRoot ? "Value should be an email" : `Property '${property}' should be ${format}` };
    case 54:
      return { ...error2, summary: `${message.slice(0, 9)} property '${property}' to be ${message.slice(8)} but found: ${value}` };
    case 62:
      let union = error2.schema.anyOf.map((x) => `'${x?.format ?? x.type}'`).join(", ");
      return { ...error2, summary: isRoot ? `Value should be one of ${union}` : `Property '${property}' should be one of: ${union}` };
    default:
      return { summary: message, ...error2 };
  }
};

class ValidationError extends Error {
  type;
  validator;
  value;
  code = "VALIDATION";
  status = 422;
  constructor(type, validator, value) {
    if (value && typeof value === "object" && value instanceof ElysiaCustomStatusResponse)
      value = value.response;
    let error2 = isProduction ? undefined : ("Errors" in validator) ? validator.Errors(value).First() : exports_value2.Errors(validator, value).First(), customError = error2.schema.message || error2?.schema.error !== undefined ? typeof error2.schema.error === "function" ? error2.schema.error({ type, validator, value, get errors() {
      return [...validator.Errors(value)].map(mapValueError);
    } }) : error2.schema.error : undefined, accessor = error2?.path || "root", message = "";
    if (customError !== undefined)
      message = typeof customError === "object" ? JSON.stringify(customError) : customError + "";
    else if (isProduction)
      message = JSON.stringify({ type: "validation", on: type, summary: mapValueError(error2).summary, message: error2?.message, found: value });
    else {
      let schema = validator?.schema ?? validator, errors = "Errors" in validator ? [...validator.Errors(value)].map(mapValueError) : [...exports_value2.Errors(validator, value)].map(mapValueError), expected;
      try {
        expected = exports_value2.Create(schema);
      } catch (error3) {
        expected = { type: "Could not create expected value", message: error3?.message, error: error3 };
      }
      message = JSON.stringify({ type: "validation", on: type, summary: mapValueError(error2).summary, property: accessor, message: error2?.message, expected, found: value, errors }, null, 2);
    }
    super(message);
    this.type = type;
    this.validator = validator;
    this.value = value;
    Object.setPrototypeOf(this, ValidationError.prototype);
  }
  get all() {
    return "Errors" in this.validator ? [...this.validator.Errors(this.value)].map(mapValueError) : [...exports_value2.Errors(this.validator, this.value)].map(mapValueError);
  }
  static simplifyModel(validator) {
    let model = "schema" in validator ? validator.schema : validator;
    try {
      return exports_value2.Create(model);
    } catch {
      return model;
    }
  }
  get model() {
    return ValidationError.simplifyModel(this.validator);
  }
  toResponse(headers) {
    return new Response(this.message, { status: 400, headers: { ...headers, "content-type": "application/json" } });
  }
}
var isISO8601 = /(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))/;
var isFormalDate = /(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s\d{2}\s\d{4}\s\d{2}:\d{2}:\d{2}\sGMT(?:\+|-)\d{4}\s\([^)]+\)/;
var isShortenDate = /^(?:(?:(?:(?:0?[1-9]|[12][0-9]|3[01])[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:19|20)\d{2})|(?:(?:19|20)\d{2}[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:0?[1-9]|[12][0-9]|3[01]))))(?:\s(?:1[012]|0?[1-9]):[0-5][0-9](?::[0-5][0-9])?(?:\s[AP]M)?)?$/;
var _validateDate = fullFormats.date;
var _validateDateTime = fullFormats["date-time"];
if (!exports_format.Has("date"))
  TypeSystem.Format("date", (value) => {
    let temp = value.replace(/"/g, "");
    if (isISO8601.test(temp) || isFormalDate.test(temp) || isShortenDate.test(temp) || _validateDate(temp)) {
      let date2 = new Date(temp);
      if (!Number.isNaN(date2.getTime()))
        return true;
    }
    return false;
  });
if (!exports_format.Has("date-time"))
  TypeSystem.Format("date-time", (value) => {
    let temp = value.replace(/"/g, "");
    if (isISO8601.test(temp) || isFormalDate.test(temp) || isShortenDate.test(temp) || _validateDateTime(temp)) {
      let date2 = new Date(temp);
      if (!Number.isNaN(date2.getTime()))
        return true;
    }
    return false;
  });
Object.entries(fullFormats).forEach((formatEntry) => {
  let [formatName, formatValue] = formatEntry;
  if (!exports_format.Has(formatName)) {
    if (formatValue instanceof RegExp)
      TypeSystem.Format(formatName, (value) => formatValue.test(value));
    else if (typeof formatValue === "function")
      TypeSystem.Format(formatName, formatValue);
  }
});
var t = Object.assign({}, Type);
var parseFileUnit = (size) => {
  if (typeof size === "string")
    switch (size.slice(-1)) {
      case "k":
        return +size.slice(0, size.length - 1) * 1024;
      case "m":
        return +size.slice(0, size.length - 1) * 1048576;
      default:
        return +size;
    }
  return size;
};
var validateFile = (options, value) => {
  if (!(value instanceof Blob))
    return false;
  if (options.minSize && value.size < parseFileUnit(options.minSize))
    return false;
  if (options.maxSize && value.size > parseFileUnit(options.maxSize))
    return false;
  if (options.extension)
    if (typeof options.extension === "string") {
      if (!value.type.startsWith(options.extension))
        return false;
    } else {
      for (let i = 0;i < options.extension.length; i++)
        if (value.type.startsWith(options.extension[i]))
          return true;
      return false;
    }
  return true;
};
var File2 = exports_type2.Get("Files") ?? TypeSystem.Type("File", validateFile);
var Files = exports_type2.Get("Files") ?? TypeSystem.Type("Files", (options, value) => {
  if (!Array.isArray(value))
    return validateFile(options, value);
  if (options.minItems && value.length < options.minItems)
    return false;
  if (options.maxItems && value.length > options.maxItems)
    return false;
  for (let i = 0;i < value.length; i++)
    if (!validateFile(options, value[i]))
      return false;
  return true;
});
if (!exports_format.Has("numeric"))
  exports_format.Set("numeric", (value) => !!value && !isNaN(+value));
if (!exports_format.Has("integer"))
  exports_format.Set("integer", (value) => !!value && Number.isInteger(+value));
if (!exports_format.Has("boolean"))
  exports_format.Set("boolean", (value) => value === "true" || value === "false");
if (!exports_format.Has("ObjectString"))
  exports_format.Set("ObjectString", (value) => {
    let start = value.charCodeAt(0);
    if (start === 9 || start === 10 || start === 32)
      start = value.trimStart().charCodeAt(0);
    if (start !== 123 && start !== 91)
      return false;
    try {
      return JSON.parse(value), true;
    } catch {
      return false;
    }
  });
if (!exports_format.Has("ArrayString"))
  exports_format.Set("ArrayString", (value) => {
    let start = value.charCodeAt(0);
    if (start === 9 || start === 10 || start === 32)
      start = value.trimStart().charCodeAt(0);
    if (start !== 123 && start !== 91)
      return false;
    try {
      return JSON.parse(value), true;
    } catch {
      return false;
    }
  });
exports_type2.Set("UnionEnum", (schema, value) => {
  return (typeof value === "number" || typeof value === "string" || value === null) && schema.enum.includes(value);
});
var ElysiaType = { Numeric: (property) => {
  let schema = Type.Number(property);
  return t.Transform(t.Union([t.String({ format: "numeric", default: 0 }), t.Number(property)], property)).Decode((value) => {
    let number = +value;
    if (isNaN(number))
      return value;
    if (property && !exports_value2.Check(schema, number))
      throw new ValidationError("property", schema, number);
    return number;
  }).Encode((value) => value);
}, Integer: (property) => {
  let schema = Type.Integer(property);
  return t.Transform(t.Union([t.String({ format: "integer", default: 0 }), t.Number(property)], property)).Decode((value) => {
    let number = +value;
    if (!exports_value2.Check(schema, number))
      throw new ValidationError("property", schema, number);
    return number;
  }).Encode((value) => value);
}, Date: (property) => {
  let schema = Type.Date(property);
  return t.Transform(t.Union([Type.Date(property), t.String({ format: "date", default: new Date().toISOString() }), t.String({ format: "date-time", default: new Date().toISOString() }), t.Number()], property)).Decode((value) => {
    if (typeof value === "number") {
      let date3 = new Date(value);
      if (!exports_value2.Check(schema, date3))
        throw new ValidationError("property", schema, date3);
      return date3;
    }
    if (value instanceof Date)
      return value;
    let date2 = new Date(value);
    if (!exports_value2.Check(schema, date2))
      throw new ValidationError("property", schema, date2);
    return date2;
  }).Encode((value) => {
    if (typeof value === "string")
      return new Date(value);
    return value;
  });
}, BooleanString: (property) => {
  let schema = Type.Boolean(property);
  return t.Transform(t.Union([t.Boolean(property), t.String({ format: "boolean", default: false })], property)).Decode((value) => {
    if (typeof value === "string")
      return value === "true";
    if (value !== undefined && !exports_value2.Check(schema, value))
      throw new ValidationError("property", schema, value);
    return value;
  }).Encode((value) => value);
}, ObjectString: (properties, options) => {
  let schema = t.Object(properties, options), defaultValue = JSON.stringify(exports_value2.Create(schema)), compiler;
  try {
    compiler = TypeCompiler.Compile(schema);
  } catch {
  }
  return t.Transform(t.Union([t.String({ format: "ObjectString", default: defaultValue }), schema])).Decode((value) => {
    if (typeof value === "string") {
      if (value.charCodeAt(0) !== 123)
        throw new ValidationError("property", schema, value);
      try {
        value = JSON.parse(value);
      } catch {
        throw new ValidationError("property", schema, value);
      }
      if (compiler) {
        if (!compiler.Check(value))
          throw new ValidationError("property", schema, value);
        return compiler.Decode(value);
      }
      if (!exports_value2.Check(schema, value))
        throw new ValidationError("property", schema, value);
      return exports_value2.Decode(schema, value);
    }
    return value;
  }).Encode((value) => {
    if (typeof value === "string")
      try {
        value = JSON.parse(value);
      } catch {
        throw new ValidationError("property", schema, value);
      }
    if (!exports_value2.Check(schema, value))
      throw new ValidationError("property", schema, value);
    return JSON.stringify(value);
  });
}, ArrayString: (children = {}, options) => {
  let schema = t.Array(children, options), defaultValue = JSON.stringify(exports_value2.Create(schema)), compiler;
  try {
    compiler = TypeCompiler.Compile(schema);
  } catch {
  }
  return t.Transform(t.Union([t.String({ format: "ArrayString", default: defaultValue }), schema])).Decode((value) => {
    if (typeof value === "string") {
      if (value.charCodeAt(0) !== 91)
        throw new ValidationError("property", schema, value);
      try {
        value = JSON.parse(value);
      } catch {
        throw new ValidationError("property", schema, value);
      }
      if (compiler) {
        if (!compiler.Check(value))
          throw new ValidationError("property", schema, value);
        return compiler.Decode(value);
      }
      if (!exports_value2.Check(schema, value))
        throw new ValidationError("property", schema, value);
      return exports_value2.Decode(schema, value);
    }
    return value;
  }).Encode((value) => {
    if (typeof value === "string")
      try {
        value = JSON.parse(value);
      } catch {
        throw new ValidationError("property", schema, value);
      }
    if (!exports_value2.Check(schema, value))
      throw new ValidationError("property", schema, value);
    return JSON.stringify(value);
  });
}, File: File2, Files: (options = {}) => t.Transform(Files(options)).Decode((value) => {
  if (Array.isArray(value))
    return value;
  return [value];
}).Encode((value) => value), Nullable: (schema) => t.Union([schema, t.Null()]), MaybeEmpty: (schema) => t.Union([schema, t.Null(), t.Undefined()]), Cookie: (properties, { domain, expires, httpOnly, maxAge, path, priority, sameSite, secure, secrets, sign, ...options } = {}) => {
  let v = t.Object(properties, options);
  return v.config = { domain, expires, httpOnly, maxAge, path, priority, sameSite, secure, secrets, sign }, v;
}, UnionEnum: (values, options = {}) => {
  let type = values.every((value) => typeof value === "string") ? { type: "string" } : values.every((value) => typeof value === "number") ? { type: "number" } : values.every((value) => value === null) ? { type: "null" } : {};
  if (values.some((x) => typeof x === "object" && x !== null))
    throw new Error("This type does not support objects or arrays");
  return { default: values[0], ...options, [Kind]: "UnionEnum", ...type, enum: values };
} };
t.BooleanString = ElysiaType.BooleanString;
t.ObjectString = ElysiaType.ObjectString;
t.ArrayString = ElysiaType.ArrayString;
t.Numeric = ElysiaType.Numeric;
t.Integer = ElysiaType.Integer;
t.File = (arg = {}) => ElysiaType.File({ default: "File", ...arg, extension: arg?.type, type: "string", format: "binary" });
t.Files = (arg = {}) => ElysiaType.Files({ ...arg, elysiaMeta: "Files", default: "Files", extension: arg?.type, type: "array", items: { ...arg, default: "Files", type: "string", format: "binary" } });
t.Nullable = (schema) => ElysiaType.Nullable(schema);
t.MaybeEmpty = ElysiaType.MaybeEmpty;
t.Cookie = ElysiaType.Cookie;
t.Date = ElysiaType.Date;
t.UnionEnum = ElysiaType.UnionEnum;
var hasReturn = (fn) => {
  let fnLiteral = typeof fn === "object" ? fn.fn.toString() : typeof fn === "string" ? fn.toString() : fn, parenthesisEnd = fnLiteral.indexOf(")");
  if (fnLiteral.charCodeAt(parenthesisEnd + 2) === 61 && fnLiteral.charCodeAt(parenthesisEnd + 5) !== 123)
    return true;
  return fnLiteral.includes("return");
};
var separateFunction = (code) => {
  if (code.startsWith("async"))
    code = code.slice(5);
  code = code.trimStart();
  let index = -1;
  if (code.charCodeAt(0) === 40) {
    if (index = code.indexOf("=>", code.indexOf(")")), index !== -1) {
      let bracketEndIndex = index;
      while (bracketEndIndex > 0)
        if (code.charCodeAt(--bracketEndIndex) === 41)
          break;
      let body = code.slice(index + 2);
      if (body.charCodeAt(0) === 32)
        body = body.trimStart();
      return [code.slice(1, bracketEndIndex), body, { isArrowReturn: body.charCodeAt(0) !== 123 }];
    }
  }
  if (/^(\w+)=>/g.test(code)) {
    if (index = code.indexOf("=>"), index !== -1) {
      let body = code.slice(index + 2);
      if (body.charCodeAt(0) === 32)
        body = body.trimStart();
      return [code.slice(0, index), body, { isArrowReturn: body.charCodeAt(0) !== 123 }];
    }
  }
  if (code.startsWith("function")) {
    index = code.indexOf("(");
    let end = code.indexOf(")");
    return [code.slice(index + 1, end), code.slice(end + 2), { isArrowReturn: false }];
  }
  let start = code.indexOf("(");
  if (start !== -1) {
    let sep = code.indexOf(`
`, 2), parameter = code.slice(0, sep), end = parameter.lastIndexOf(")") + 1, body = code.slice(sep + 1);
    return [parameter.slice(start, end), "{" + body, { isArrowReturn: false }];
  }
  let x = code.split(`
`, 2);
  return [x[0], x[1], { isArrowReturn: false }];
};
var bracketPairRange = (parameter) => {
  let start = parameter.indexOf("{");
  if (start === -1)
    return [-1, 0];
  let end = start + 1, deep = 1;
  for (;end < parameter.length; end++) {
    let char = parameter.charCodeAt(end);
    if (char === 123)
      deep++;
    else if (char === 125)
      deep--;
    if (deep === 0)
      break;
  }
  if (deep !== 0)
    return [0, parameter.length];
  return [start, end + 1];
};
var bracketPairRangeReverse = (parameter) => {
  let end = parameter.lastIndexOf("}");
  if (end === -1)
    return [-1, 0];
  let start = end - 1, deep = 1;
  for (;start >= 0; start--) {
    let char = parameter.charCodeAt(start);
    if (char === 125)
      deep++;
    else if (char === 123)
      deep--;
    if (deep === 0)
      break;
  }
  if (deep !== 0)
    return [-1, 0];
  return [start, end + 1];
};
var removeColonAlias = (parameter) => {
  while (true) {
    let start = parameter.indexOf(":");
    if (start === -1)
      break;
    let end = parameter.indexOf(",", start);
    if (end === -1)
      end = parameter.indexOf("}", start) - 1;
    if (end === -2)
      end = parameter.length;
    parameter = parameter.slice(0, start) + parameter.slice(end);
  }
  return parameter;
};
var retrieveRootParamters = (parameter) => {
  let hasParenthesis = false;
  if (parameter.charCodeAt(0) === 40)
    parameter = parameter.slice(1, -1);
  if (parameter.charCodeAt(0) === 123)
    hasParenthesis = true, parameter = parameter.slice(1, -1);
  parameter = parameter.replace(/( |\t|\n)/g, "").trim();
  let parameters = [];
  while (true) {
    let [start, end] = bracketPairRange(parameter);
    if (start === -1)
      break;
    if (parameters.push(parameter.slice(0, start - 1)), parameter.charCodeAt(end) === 44)
      end++;
    parameter = parameter.slice(end);
  }
  if (parameter = removeColonAlias(parameter), parameter)
    parameters = parameters.concat(parameter.split(","));
  let newParameters = [];
  for (let p of parameters) {
    if (p.indexOf(",") === -1) {
      newParameters.push(p);
      continue;
    }
    for (let q of p.split(","))
      newParameters.push(q.trim());
  }
  return parameters = newParameters, { hasParenthesis, parameters };
};
var findParameterReference = (parameter, inference) => {
  let { parameters, hasParenthesis } = retrieveRootParamters(parameter);
  if (!inference.query && parameters.includes("query"))
    inference.query = true;
  if (!inference.headers && parameters.includes("headers"))
    inference.headers = true;
  if (!inference.body && parameters.includes("body"))
    inference.body = true;
  if (!inference.cookie && parameters.includes("cookie"))
    inference.cookie = true;
  if (!inference.set && parameters.includes("set"))
    inference.set = true;
  if (!inference.server && parameters.includes("server"))
    inference.server = true;
  if (!inference.request && parameters.includes("request"))
    inference.request = true;
  if (!inference.route && parameters.includes("route"))
    inference.route = true;
  if (hasParenthesis)
    return `{ ${parameters.join(", ")} }`;
  return parameters.join(", ");
};
var findEndIndex = (type, content, index) => {
  let newLineIndex = content.indexOf(type + `
`, index), newTabIndex = content.indexOf(type + "\t", index), commaIndex = content.indexOf(type + ",", index), semicolonIndex = content.indexOf(type + ";", index), emptyIndex = content.indexOf(type + " ", index);
  return [newLineIndex, newTabIndex, commaIndex, semicolonIndex, emptyIndex].filter((i) => i > 0).sort((a, b) => a - b)[0] || -1;
};
var findAlias = (type, body, depth = 0) => {
  if (depth > 5)
    return [];
  let aliases = [], content = body;
  while (true) {
    let index = findEndIndex(" = " + type, content);
    if (index === -1)
      index = findEndIndex("=" + type, content);
    if (index === -1) {
      let lastIndex = content.indexOf(" = " + type);
      if (lastIndex === -1)
        lastIndex = content.indexOf("=" + type);
      if (lastIndex + 3 + type.length !== content.length)
        break;
      index = lastIndex;
    }
    let part = content.slice(0, index), lastPart = part.lastIndexOf(" "), variable = part.slice(lastPart !== -1 ? lastPart + 1 : -1);
    if (variable === "}") {
      let [start, end] = bracketPairRangeReverse(part);
      aliases.push(removeColonAlias(content.slice(start, end))), content = content.slice(index + 3 + type.length);
      continue;
    }
    while (variable.charCodeAt(0) === 44)
      variable = variable.slice(1);
    while (variable.charCodeAt(0) === 9)
      variable = variable.slice(1);
    if (!variable.includes("("))
      aliases.push(variable);
    content = content.slice(index + 3 + type.length);
  }
  for (let alias of aliases) {
    if (alias.charCodeAt(0) === 123)
      continue;
    let deepAlias = findAlias(alias, body);
    if (deepAlias.length > 0)
      aliases.push(...deepAlias);
  }
  return aliases;
};
var extractMainParameter = (parameter) => {
  if (!parameter)
    return;
  if (parameter.charCodeAt(0) !== 123)
    return parameter;
  if (parameter = parameter.slice(2, -2), !parameter.includes(",")) {
    if (parameter.includes("..."))
      return parameter.slice(parameter.indexOf("...") + 3);
    return;
  }
  let spreadIndex = parameter.indexOf("...");
  if (spreadIndex === -1)
    return;
  return parameter.slice(spreadIndex + 3).trimEnd();
};
var inferBodyReference = (code, aliases, inference) => {
  let access = (type, alias) => code.includes(alias + "." + type) || code.includes(alias + '["' + type + '"]') || code.includes(alias + "['" + type + "']");
  for (let alias of aliases) {
    if (!alias)
      continue;
    if (alias.charCodeAt(0) === 123) {
      let parameters = retrieveRootParamters(alias).parameters;
      if (!inference.query && parameters.includes("query"))
        inference.query = true;
      if (!inference.headers && parameters.includes("headers"))
        inference.headers = true;
      if (!inference.body && parameters.includes("body"))
        inference.body = true;
      if (!inference.cookie && parameters.includes("cookie"))
        inference.cookie = true;
      if (!inference.set && parameters.includes("set"))
        inference.set = true;
      if (!inference.query && parameters.includes("server"))
        inference.server = true;
      if (!inference.request && parameters.includes("request"))
        inference.request = true;
      if (!inference.route && parameters.includes("route"))
        inference.route = true;
      continue;
    }
    if (!inference.query && access("query", alias))
      inference.query = true;
    if (code.includes("return " + alias) || code.includes("return " + alias + ".query"))
      inference.query = true;
    if (!inference.headers && access("headers", alias))
      inference.headers = true;
    if (!inference.body && access("body", alias))
      inference.body = true;
    if (!inference.cookie && access("cookie", alias))
      inference.cookie = true;
    if (!inference.set && access("set", alias))
      inference.set = true;
    if (!inference.server && access("server", alias))
      inference.server = true;
    if (inference.query && inference.headers && inference.body && inference.cookie && inference.set && inference.server && inference.server && inference.route)
      break;
  }
  return aliases;
};
var isContextPassToFunction = (context, body, inference) => {
  try {
    let captureFunction = new RegExp(`(?:\\w)\\((?:.*)?${context}`, "gs");
    captureFunction.test(body);
    let nextChar = body.charCodeAt(captureFunction.lastIndex);
    if (nextChar === 41 || nextChar === 44)
      return inference.query = true, inference.headers = true, inference.body = true, inference.cookie = true, inference.set = true, inference.server = true, inference.route = true, inference.request = true, true;
    return false;
  } catch (error2) {
    return console.log("[Sucrose] warning: unexpected isContextPassToFunction error, you may continue development as usual but please report the following to maintainers:"), console.log("--- body ---"), console.log(body), console.log("--- context ---"), console.log(context), true;
  }
};
var sucrose = (lifeCycle, inference = { query: false, headers: false, body: false, cookie: false, set: false, server: false, request: false, route: false }) => {
  let events = [];
  if (lifeCycle.handler && typeof lifeCycle.handler === "function")
    events.push(lifeCycle.handler);
  if (lifeCycle.request?.length)
    events.push(...lifeCycle.request);
  if (lifeCycle.beforeHandle?.length)
    events.push(...lifeCycle.beforeHandle);
  if (lifeCycle.parse?.length)
    events.push(...lifeCycle.parse);
  if (lifeCycle.error?.length)
    events.push(...lifeCycle.error);
  if (lifeCycle.transform?.length)
    events.push(...lifeCycle.transform);
  if (lifeCycle.afterHandle?.length)
    events.push(...lifeCycle.afterHandle);
  if (lifeCycle.mapResponse?.length)
    events.push(...lifeCycle.mapResponse);
  if (lifeCycle.afterResponse?.length)
    events.push(...lifeCycle.afterResponse);
  for (let e of events) {
    if (!e)
      continue;
    let event = "fn" in e ? e.fn : e;
    if (typeof event !== "function")
      continue;
    let [parameter, body, { isArrowReturn }] = separateFunction(event.toString()), rootParameters = findParameterReference(parameter, inference), mainParameter = extractMainParameter(rootParameters);
    if (mainParameter) {
      let aliases = findAlias(mainParameter, body);
      if (aliases.splice(0, -1, mainParameter), !isContextPassToFunction(mainParameter, body, inference))
        inferBodyReference(body, aliases, inference);
      if (!inference.query && body.includes("return " + mainParameter + ".query"))
        inference.query = true;
    }
    if (inference.query && inference.headers && inference.body && inference.cookie && inference.set && inference.server && inference.request && inference.route)
      break;
  }
  return inference;
};

class Cookie {
  name;
  jar;
  initial;
  constructor(name, jar, initial = {}) {
    this.name = name;
    this.jar = jar;
    this.initial = initial;
  }
  get cookie() {
    return this.jar[this.name] ?? this.initial;
  }
  set cookie(jar) {
    if (!(this.name in this.jar))
      this.jar[this.name] = this.initial;
    this.jar[this.name] = jar;
  }
  get setCookie() {
    if (!(this.name in this.jar))
      this.jar[this.name] = this.initial;
    return this.jar[this.name];
  }
  set setCookie(jar) {
    this.cookie = jar;
  }
  get value() {
    return this.cookie.value;
  }
  set value(value) {
    this.setCookie.value = value;
  }
  get expires() {
    return this.cookie.expires;
  }
  set expires(expires) {
    this.setCookie.expires = expires;
  }
  get maxAge() {
    return this.cookie.maxAge;
  }
  set maxAge(maxAge) {
    this.setCookie.maxAge = maxAge;
  }
  get domain() {
    return this.cookie.domain;
  }
  set domain(domain) {
    this.setCookie.domain = domain;
  }
  get path() {
    return this.cookie.path;
  }
  set path(path) {
    this.setCookie.path = path;
  }
  get secure() {
    return this.cookie.secure;
  }
  set secure(secure) {
    this.setCookie.secure = secure;
  }
  get httpOnly() {
    return this.cookie.httpOnly;
  }
  set httpOnly(httpOnly) {
    this.setCookie.httpOnly = httpOnly;
  }
  get sameSite() {
    return this.cookie.sameSite;
  }
  set sameSite(sameSite) {
    this.setCookie.sameSite = sameSite;
  }
  get priority() {
    return this.cookie.priority;
  }
  set priority(priority) {
    this.setCookie.priority = priority;
  }
  get partitioned() {
    return this.cookie.partitioned;
  }
  set partitioned(partitioned) {
    this.setCookie.partitioned = partitioned;
  }
  get secrets() {
    return this.cookie.secrets;
  }
  set secrets(secrets) {
    this.setCookie.secrets = secrets;
  }
  update(config2) {
    return this.setCookie = Object.assign(this.cookie, typeof config2 === "function" ? config2(this.cookie) : config2), this;
  }
  set(config2) {
    return this.setCookie = Object.assign({ ...this.initial, value: this.value }, typeof config2 === "function" ? config2(this.cookie) : config2), this;
  }
  remove() {
    if (this.value === undefined)
      return;
    return this.set({ expires: new Date(0), maxAge: 0, value: "" }), this;
  }
  toString() {
    return typeof this.value === "object" ? JSON.stringify(this.value) : this.value?.toString() ?? "";
  }
}
var createCookieJar = (set2, store, initial) => {
  if (!set2.cookie)
    set2.cookie = {};
  return new Proxy(store, { get(_2, key) {
    if (key in store)
      return new Cookie(key, set2.cookie, Object.assign({}, initial ?? {}, store[key]));
    return new Cookie(key, set2.cookie, Object.assign({}, initial));
  } });
};
var parseCookie = async (set2, cookieString, { secrets, sign, ...initial } = {}) => {
  if (!cookieString)
    return createCookieJar(set2, {}, initial);
  let isStringKey = typeof secrets === "string";
  if (sign && sign !== true && !Array.isArray(sign))
    sign = [sign];
  let jar = {}, cookies = import_cookie.parse(cookieString);
  for (let [name, v] of Object.entries(cookies)) {
    let value = import_fast_decode_uri_component.default(v);
    if (sign === true || sign?.includes(name)) {
      if (!secrets)
        throw new Error("No secret is provided to cookie plugin");
      if (isStringKey) {
        let temp = await unsignCookie(value, secrets);
        if (temp === false)
          throw new InvalidCookieSignature(name);
        value = temp;
      } else {
        let decoded = true;
        for (let i = 0;i < secrets.length; i++) {
          let temp = await unsignCookie(value, secrets[i]);
          if (temp !== false) {
            decoded = true, value = temp;
            break;
          }
        }
        if (!decoded)
          throw new InvalidCookieSignature(name);
      }
    }
    jar[name] = { value };
  }
  return createCookieJar(set2, jar, initial);
};
var serializeCookie = (cookies) => {
  if (!cookies || !isNotEmpty(cookies))
    return;
  let set2 = [];
  for (let [key, property] of Object.entries(cookies)) {
    if (!key || !property)
      continue;
    let value = property.value;
    if (value === undefined || value === null)
      continue;
    set2.push(import_cookie.serialize(key, typeof value === "object" ? JSON.stringify(value) : value + "", property));
  }
  if (set2.length === 0)
    return;
  if (set2.length === 1)
    return set2[0];
  return set2;
};
var handleFile = (response, set2) => {
  let size = response.size;
  if (!set2 && size || size && set2 && set2.status !== 206 && set2.status !== 304 && set2.status !== 412 && set2.status !== 416) {
    if (set2) {
      if (set2.headers instanceof Headers) {
        let setHeaders = { "accept-ranges": "bytes", "content-range": `bytes 0-${size - 1}/${size}`, "transfer-encoding": "chunked" };
        if (hasHeaderShorthand)
          setHeaders = set2.headers.toJSON();
        else {
          setHeaders = {};
          for (let [key, value] of set2.headers.entries())
            if (key in set2.headers)
              setHeaders[key] = value;
        }
        return new Response(response, { status: set2.status, headers: setHeaders });
      }
      if (isNotEmpty(set2.headers))
        return new Response(response, { status: set2.status, headers: Object.assign({ "accept-ranges": "bytes", "content-range": `bytes 0-${size - 1}/${size}`, "transfer-encoding": "chunked" }, set2.headers) });
    }
    return new Response(response, { headers: { "accept-ranges": "bytes", "content-range": `bytes 0-${size - 1}/${size}`, "transfer-encoding": "chunked" } });
  }
  return new Response(response);
};
var parseSetCookies = (headers, setCookie) => {
  if (!headers)
    return headers;
  headers.delete("set-cookie");
  for (let i = 0;i < setCookie.length; i++) {
    let index = setCookie[i].indexOf("=");
    headers.append("set-cookie", `${setCookie[i].slice(0, index)}=${setCookie[i].slice(index + 1) || ""}`);
  }
  return headers;
};
var handleStream = async (generator, set2, request) => {
  let init = generator.next();
  if (init instanceof Promise)
    init = await init;
  if (init.done) {
    if (set2)
      return mapResponse(init.value, set2, request);
    return mapCompactResponse(init.value, request);
  }
  return new Response(new ReadableStream({ async start(controller) {
    let end = false;
    if (request?.signal?.addEventListener("abort", () => {
      end = true;
      try {
        controller.close();
      } catch {
      }
    }), init.value !== undefined && init.value !== null)
      if (typeof init.value === "object")
        try {
          controller.enqueue(Buffer.from(JSON.stringify(init.value)));
        } catch {
          controller.enqueue(Buffer.from(init.value.toString()));
        }
      else
        controller.enqueue(Buffer.from(init.value.toString()));
    for await (let chunk of generator) {
      if (end)
        break;
      if (chunk === undefined || chunk === null)
        continue;
      if (typeof chunk === "object")
        try {
          controller.enqueue(Buffer.from(JSON.stringify(chunk)));
        } catch {
          controller.enqueue(Buffer.from(chunk.toString()));
        }
      else
        controller.enqueue(Buffer.from(chunk.toString()));
      await new Promise((resolve) => setTimeout(() => resolve(), 0));
    }
    try {
      controller.close();
    } catch {
    }
  } }), { ...set2, headers: { "transfer-encoding": "chunked", "content-type": "text/event-stream; charset=utf-8", ...set2?.headers } });
};
async function* streamResponse(response) {
  let body = response.body;
  if (!body)
    return;
  let reader = body.getReader(), decoder = new TextDecoder;
  try {
    while (true) {
      let { done, value } = await reader.read();
      if (done)
        break;
      yield decoder.decode(value);
    }
  } finally {
    reader.releaseLock();
  }
}
var handleSet = (set2) => {
  if (typeof set2.status === "string")
    set2.status = StatusMap[set2.status];
  if (set2.cookie && isNotEmpty(set2.cookie)) {
    let cookie = serializeCookie(set2.cookie);
    if (cookie)
      set2.headers["set-cookie"] = cookie;
  }
  if (set2.headers["set-cookie"] && Array.isArray(set2.headers["set-cookie"]))
    set2.headers = parseSetCookies(new Headers(set2.headers), set2.headers["set-cookie"]);
};
var mergeResponseWithSetHeaders = (response, set2) => {
  if (response.status !== set2.status && set2.status !== 200 && (response.status <= 300 || response.status > 400))
    response = new Response(response.body, { headers: response.headers, status: set2.status });
  let isCookieSet = false;
  if (set2.headers instanceof Headers)
    for (let key of set2.headers.keys())
      if (key === "set-cookie") {
        if (isCookieSet)
          continue;
        isCookieSet = true;
        for (let cookie of set2.headers.getSetCookie())
          response.headers.append("set-cookie", cookie);
      } else
        response.headers.append(key, set2.headers?.get(key) ?? "");
  else
    for (let key in set2.headers)
      response.headers.append(key, set2.headers[key]);
  return response;
};
var mapResponse = (response, set2, request) => {
  if (isNotEmpty(set2.headers) || set2.status !== 200 || set2.cookie)
    switch (handleSet(set2), response?.constructor?.name) {
      case "String":
        return new Response(response, set2);
      case "Array":
      case "Object":
        return Response.json(response, set2);
      case "ElysiaFile":
        return handleFile(response.value);
      case "Blob":
        return handleFile(response, set2);
      case "ElysiaCustomStatusResponse":
        return set2.status = response.code, mapResponse(response.response, set2, request);
      case "ReadableStream":
        if (!set2.headers["content-type"]?.startsWith("text/event-stream"))
          set2.headers["content-type"] = "text/event-stream; charset=utf-8";
        return request?.signal?.addEventListener("abort", { handleEvent() {
          if (request?.signal && !request?.signal?.aborted)
            response.cancel();
        } }, { once: true }), new Response(response, set2);
      case undefined:
        if (!response)
          return new Response("", set2);
        return Response.json(response, set2);
      case "Response":
        if (response = mergeResponseWithSetHeaders(response, set2), response.headers.get("transfer-encoding") === "chunked")
          return handleStream(streamResponse(response), set2, request);
        return response;
      case "Error":
        return errorToResponse(response, set2);
      case "Promise":
        return response.then((x) => mapResponse(x, set2, request));
      case "Function":
        return mapResponse(response(), set2, request);
      case "Number":
      case "Boolean":
        return new Response(response.toString(), set2);
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set2);
        return new Response(response?.toString(), set2);
      case "FormData":
        return new Response(response, set2);
      default:
        if (response instanceof Response) {
          if (response = mergeResponseWithSetHeaders(response, set2), response.headers.get("transfer-encoding") === "chunked")
            return handleStream(streamResponse(response), set2, request);
          return response;
        }
        if (response instanceof Promise)
          return response.then((x) => mapResponse(x, set2));
        if (response instanceof Error)
          return errorToResponse(response, set2);
        if (response instanceof ElysiaCustomStatusResponse)
          return set2.status = response.code, mapResponse(response.response, set2, request);
        if (typeof response?.next === "function")
          return handleStream(response, set2, request);
        if (typeof response?.then === "function")
          return response.then((x) => mapResponse(x, set2));
        if (typeof response?.toResponse === "function")
          return mapResponse(response.toResponse(), set2);
        if ("charCodeAt" in response) {
          let code = response.charCodeAt(0);
          if (code === 123 || code === 91) {
            if (!set2.headers["Content-Type"])
              set2.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set2);
          }
        }
        return new Response(response, set2);
    }
  if (typeof response?.next === "function" || response instanceof ReadableStream || response instanceof Response && response.headers.get("transfer-encoding") === "chunked")
    return handleStream(response, set2, request);
  return mapCompactResponse(response, request);
};
var mapEarlyResponse = (response, set2, request) => {
  if (response === undefined || response === null)
    return;
  if (isNotEmpty(set2.headers) || set2.status !== 200 || set2.cookie)
    switch (handleSet(set2), response?.constructor?.name) {
      case "String":
        return new Response(response, set2);
      case "Array":
      case "Object":
        return Response.json(response, set2);
      case "ElysiaFile":
        return handleFile(response.value);
      case "Blob":
        return handleFile(response, set2);
      case "ElysiaCustomStatusResponse":
        return set2.status = response.code, mapEarlyResponse(response.response, set2, request);
      case "ReadableStream":
        if (!set2.headers["content-type"]?.startsWith("text/event-stream"))
          set2.headers["content-type"] = "text/event-stream; charset=utf-8";
        return request?.signal?.addEventListener("abort", { handleEvent() {
          if (request?.signal && !request?.signal?.aborted)
            response.cancel();
        } }, { once: true }), new Response(response, set2);
      case undefined:
        if (!response)
          return;
        return Response.json(response, set2);
      case "Response":
        if (response = mergeResponseWithSetHeaders(response, set2), response.headers.get("transfer-encoding") === "chunked")
          return handleStream(streamResponse(response), set2, request);
        return response;
      case "Promise":
        return response.then((x) => mapEarlyResponse(x, set2));
      case "Error":
        return errorToResponse(response, set2);
      case "Function":
        return mapEarlyResponse(response(), set2);
      case "Number":
      case "Boolean":
        return new Response(response.toString(), set2);
      case "FormData":
        return new Response(response);
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set2);
        return new Response(response?.toString(), set2);
      default:
        if (response instanceof Response) {
          if (response = mergeResponseWithSetHeaders(response, set2), response.headers.get("transfer-encoding") === "chunked")
            return handleStream(streamResponse(response), set2, request);
          return response;
        }
        if (response instanceof Promise)
          return response.then((x) => mapEarlyResponse(x, set2));
        if (response instanceof Error)
          return errorToResponse(response, set2);
        if (response instanceof ElysiaCustomStatusResponse)
          return set2.status = response.code, mapEarlyResponse(response.response, set2, request);
        if (typeof response?.next === "function")
          return handleStream(response, set2, request);
        if (typeof response?.then === "function")
          return response.then((x) => mapEarlyResponse(x, set2));
        if (typeof response?.toResponse === "function")
          return mapEarlyResponse(response.toResponse(), set2);
        if ("charCodeAt" in response) {
          let code = response.charCodeAt(0);
          if (code === 123 || code === 91) {
            if (!set2.headers["Content-Type"])
              set2.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set2);
          }
        }
        return new Response(response, set2);
    }
  else
    switch (response?.constructor?.name) {
      case "String":
        return new Response(response);
      case "Array":
      case "Object":
        return Response.json(response, set2);
      case "ElysiaFile":
        return handleFile(response.value);
      case "Blob":
        return handleFile(response, set2);
      case "ElysiaCustomStatusResponse":
        return set2.status = response.code, mapEarlyResponse(response.response, set2, request);
      case "ReadableStream":
        return request?.signal?.addEventListener("abort", { handleEvent() {
          if (request?.signal && !request?.signal?.aborted)
            response.cancel();
        } }, { once: true }), new Response(response, { headers: { "Content-Type": "text/event-stream; charset=utf-8" } });
      case undefined:
        if (!response)
          return new Response("");
        return new Response(JSON.stringify(response), { headers: { "content-type": "application/json" } });
      case "Response":
        if (response.headers.get("transfer-encoding") === "chunked")
          return handleStream(streamResponse(response));
        return response;
      case "Promise":
        return response.then((x) => {
          let r = mapEarlyResponse(x, set2);
          if (r !== undefined)
            return r;
        });
      case "Error":
        return errorToResponse(response, set2);
      case "Function":
        return mapCompactResponse(response(), request);
      case "Number":
      case "Boolean":
        return new Response(response.toString());
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set2);
        return new Response(response?.toString(), set2);
      case "FormData":
        return new Response(response);
      default:
        if (response instanceof Response)
          return response;
        if (response instanceof Promise)
          return response.then((x) => mapEarlyResponse(x, set2));
        if (response instanceof Error)
          return errorToResponse(response, set2);
        if (response instanceof ElysiaCustomStatusResponse)
          return set2.status = response.code, mapEarlyResponse(response.response, set2, request);
        if (typeof response?.next === "function")
          return handleStream(response, set2, request);
        if (typeof response?.then === "function")
          return response.then((x) => mapEarlyResponse(x, set2));
        if (typeof response?.toResponse === "function")
          return mapEarlyResponse(response.toResponse(), set2);
        if ("charCodeAt" in response) {
          let code = response.charCodeAt(0);
          if (code === 123 || code === 91) {
            if (!set2.headers["Content-Type"])
              set2.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set2);
          }
        }
        return new Response(response);
    }
};
var mapCompactResponse = (response, request) => {
  switch (response?.constructor?.name) {
    case "String":
      return new Response(response);
    case "Object":
    case "Array":
      return Response.json(response);
    case "ElysiaFile":
      return handleFile(response.value);
    case "Blob":
      return handleFile(response);
    case "ElysiaCustomStatusResponse":
      return mapResponse(response.response, { status: response.code, headers: {} });
    case "ReadableStream":
      return request?.signal?.addEventListener("abort", { handleEvent() {
        if (request?.signal && !request?.signal?.aborted)
          response.cancel();
      } }, { once: true }), new Response(response, { headers: { "Content-Type": "text/event-stream; charset=utf-8" } });
    case undefined:
      if (!response)
        return new Response("");
      return new Response(JSON.stringify(response), { headers: { "content-type": "application/json" } });
    case "Response":
      if (response.headers.get("transfer-encoding") === "chunked")
        return handleStream(streamResponse(response));
      return response;
    case "Error":
      return errorToResponse(response);
    case "Promise":
      return response.then((x) => mapCompactResponse(x, request));
    case "Function":
      return mapCompactResponse(response(), request);
    case "Number":
    case "Boolean":
      return new Response(response.toString());
    case "FormData":
      return new Response(response);
    default:
      if (response instanceof Response)
        return response;
      if (response instanceof Promise)
        return response.then((x) => mapCompactResponse(x, request));
      if (response instanceof Error)
        return errorToResponse(response);
      if (response instanceof ElysiaCustomStatusResponse)
        return mapResponse(response.response, { status: response.code, headers: {} });
      if (typeof response?.next === "function")
        return handleStream(response, undefined, request);
      if (typeof response?.then === "function")
        return response.then((x) => mapResponse(x, set));
      if (typeof response?.toResponse === "function")
        return mapCompactResponse(response.toResponse());
      if ("charCodeAt" in response) {
        let code = response.charCodeAt(0);
        if (code === 123 || code === 91)
          return new Response(JSON.stringify(response), { headers: { "Content-Type": "application/json" } });
      }
      return new Response(response);
  }
};
var errorToResponse = (error2, set2) => new Response(JSON.stringify({ name: error2?.name, message: error2?.message, cause: error2?.cause }), { status: set2?.status !== 200 ? set2?.status ?? 500 : 500, headers: set2?.headers });
var createStaticHandler = (handle, hooks, setHeaders = {}) => {
  if (typeof handle === "function")
    return;
  let response = mapResponse(handle, { headers: setHeaders });
  if (hooks.parse.length === 0 && hooks.transform.length === 0 && hooks.beforeHandle.length === 0 && hooks.afterHandle.length === 0)
    return response.clone.bind(response);
};
var WebStandardAdapter = { name: "web-standard", isWebStandard: true, handler: { mapResponse, mapEarlyResponse, mapCompactResponse, createStaticHandler }, composeHandler: { mapResponseContext: "c.request", preferWebstandardHeaders: true, headers: `c.headers = {}
for (const [key, value] of c.request.headers.entries())c.headers[key] = value
`, parser: { json(isOptional) {
  if (isOptional)
    return `try{c.body=await c.request.json()}catch{}
`;
  return `c.body=await c.request.json()
`;
}, text() {
  return `c.body=await c.request.text()
`;
}, urlencoded() {
  return `c.body=parseQuery(await c.request.text())
`;
}, arrayBuffer() {
  return `c.body=await c.request.arrayBuffer()
`;
}, formData(isOptional) {
  let fnLiteral = `
c.body={}
`;
  if (isOptional)
    fnLiteral += "let form;try{form=await c.request.formData()}catch{}";
  else
    fnLiteral += `const form=await c.request.formData()
`;
  return fnLiteral + `for(const key of form.keys()){if(c.body[key]) continue
const value=form.getAll(key)
if(value.length===1)c.body[key]=value[0]
else c.body[key]=value}`;
} } }, composeGeneralHandler: { parameters: "r", createContext(app) {
  let decoratorsLiteral = "", fnLiteral = "", defaultHeaders = app.setHeaders;
  for (let key of Object.keys(app.singleton.decorator))
    decoratorsLiteral += `,${key}: decorator['${key}']`;
  let standardHostname = app.config.handler?.standardHostname ?? true, hasTrace = app.event.trace.length > 0;
  if (fnLiteral += `const u=r.url,s=u.indexOf('/',${standardHostname ? 11 : 7}),qi=u.indexOf('?', s + 1)
let p
if(qi===-1)p=u.substring(s)
else p=u.substring(s, qi)
`, hasTrace)
    fnLiteral += `const id=randomId()
`;
  if (fnLiteral += "const c={request:r,store,qi,path:p,url:u,redirect,error,set:{headers:", fnLiteral += Object.keys(defaultHeaders ?? {}).length ? "Object.assign({}, app.setHeaders)" : "{}", fnLiteral += ",status:200}", app.inference.server)
    fnLiteral += ",get server(){return getServer()}";
  if (hasTrace)
    fnLiteral += ",[ELYSIA_REQUEST_ID]:id";
  return fnLiteral += decoratorsLiteral, fnLiteral += `}
`, fnLiteral;
}, websocket(app) {
  let fnLiteral = "", wsPaths = app.router.static.ws, wsRouter = app.router.ws;
  if (Object.keys(wsPaths).length || wsRouter.history.length) {
    fnLiteral += "if(r.method==='GET'){switch(p){";
    for (let [path, index] of Object.entries(wsPaths))
      fnLiteral += `case'${path}':` + (app.config.strictPath !== true ? `case'${getLoosePath(path)}':` : "") + `if(r.headers.get('upgrade')==='websocket')return ht[${index}].composed(c)
`;
    fnLiteral += `default:if(r.headers.get('upgrade')==='websocket'){const route=wsRouter.find('ws',p)
if(route){c.params=route.params
if(route.store.handler)return route.store.handler(c)
return (route.store.handler=route.store.compile())(c)}}break}}`;
  }
  return fnLiteral;
}, error404(hasEventHook, hasErrorHook) {
  let findDynamicRoute = "if(route===null)return ";
  if (hasErrorHook)
    findDynamicRoute += `app.handleError(c,notFound,false,${this.parameters})`;
  else
    findDynamicRoute += hasEventHook ? "new Response(error404Message,{status:c.set.status===200?404:c.set.status,headers:c.set.headers})" : "error404.clone()";
  return { declare: hasErrorHook ? "" : `const error404Message=notFound.message.toString()
const error404=new Response(error404Message,{status:404})
`, code: findDynamicRoute };
} }, composeError: { mapResponseContext: "", validationError: "return new Response(error.message,{headers:Object.assign({'content-type':'application/json'},set.headers),status:set.status})", unknownError: "return new Response(error.message,{headers:set.headers,status:error.status??set.status??500})" }, listen() {
  return () => {
    throw new Error("WebStandard does not support listen, you might want to export default Elysia.fetch instead");
  };
} };
var createNativeStaticHandler = (handle, hooks, setHeaders = {}) => {
  if (typeof handle === "function" || handle instanceof Blob)
    return;
  let response = mapResponse(handle, { headers: setHeaders });
  if (hooks.parse.length === 0 && hooks.transform.length === 0 && hooks.beforeHandle.length === 0 && hooks.afterHandle.length === 0) {
    if (!response.headers.has("content-type"))
      response.headers.append("content-type", "text/plain;charset=utf-8");
    return response.clone.bind(response);
  }
};
var websocket = { open(ws) {
  ws.data.open?.(ws);
}, message(ws, message) {
  ws.data.message?.(ws, message);
}, drain(ws) {
  ws.data.drain?.(ws);
}, close(ws, code, reason) {
  ws.data.close?.(ws, code, reason);
} };

class ElysiaWS {
  raw;
  data;
  body;
  validator;
  ["~types"];
  get id() {
    return this.data.id;
  }
  constructor(raw2, data, body = undefined) {
    this.raw = raw2;
    this.data = data;
    this.body = body;
    this.validator = raw2.data?.validator, this.sendText = raw2.sendText.bind(raw2), this.sendBinary = raw2.sendBinary.bind(raw2), this.close = raw2.close.bind(raw2), this.terminate = raw2.terminate.bind(raw2), this.publishText = raw2.publishText.bind(raw2), this.publishBinary = raw2.publishBinary.bind(raw2), this.subscribe = raw2.subscribe.bind(raw2), this.unsubscribe = raw2.unsubscribe.bind(raw2), this.isSubscribed = raw2.isSubscribed.bind(raw2), this.cork = raw2.cork.bind(raw2), this.remoteAddress = raw2.remoteAddress, this.binaryType = raw2.binaryType, this.data = raw2.data, this.send = this.send.bind(this), this.ping = this.ping.bind(this), this.pong = this.pong.bind(this), this.publish = this.publish.bind(this);
  }
  send(data, compress) {
    if (Buffer.isBuffer(data))
      return this.raw.send(data, compress);
    if (this.validator?.Check(data) === false)
      return this.raw.send(new ValidationError("message", this.validator, data).message);
    if (typeof data === "object")
      data = JSON.stringify(data);
    return this.raw.send(data, compress);
  }
  ping(data) {
    if (Buffer.isBuffer(data))
      return this.raw.ping(data);
    if (this.validator?.Check(data) === false)
      return this.raw.send(new ValidationError("message", this.validator, data).message);
    if (typeof data === "object")
      data = JSON.stringify(data);
    return this.raw.ping(data);
  }
  pong(data) {
    if (Buffer.isBuffer(data))
      return this.raw.pong(data);
    if (this.validator?.Check(data) === false)
      return this.raw.send(new ValidationError("message", this.validator, data).message);
    if (typeof data === "object")
      data = JSON.stringify(data);
    return this.raw.pong(data);
  }
  publish(topic, data, compress) {
    if (Buffer.isBuffer(data))
      return this.raw.publish(topic, data, compress);
    if (this.validator?.Check(data) === false)
      return this.raw.send(new ValidationError("message", this.validator, data).message);
    if (typeof data === "object")
      data = JSON.stringify(data);
    return this.raw.publish(topic, data, compress);
  }
  sendText;
  sendBinary;
  close;
  terminate;
  publishText;
  publishBinary;
  subscribe;
  unsubscribe;
  isSubscribed;
  cork;
  remoteAddress;
  binaryType;
  get readyState() {
    return this.raw.readyState;
  }
}
var createWSMessageParser = (parse22) => {
  let parsers = typeof parse22 === "function" ? [parse22] : parse22;
  return async function parseMessage(ws, message) {
    if (typeof message === "string") {
      let start = message?.charCodeAt(0);
      if (start === 47 || start === 123)
        try {
          message = JSON.parse(message);
        } catch {
        }
      else if (isNumericString(message))
        message = +message;
    }
    if (parsers)
      for (let i = 0;i < parsers.length; i++) {
        let temp = parsers[i](ws, message);
        if (temp instanceof Promise)
          temp = await temp;
        if (temp !== undefined)
          return temp;
      }
    return message;
  };
};
var createHandleWSResponse = (validateResponse) => {
  let handleWSResponse = (ws, data) => {
    if (data instanceof Promise)
      return data.then((data2) => handleWSResponse(ws, data2));
    if (Buffer.isBuffer(data))
      return ws.send(data.toString());
    if (data === undefined)
      return;
    let send = (datum) => {
      if (validateResponse?.Check(datum) === false)
        return ws.send(new ValidationError("message", validateResponse, datum).message);
      if (typeof datum === "object")
        return ws.send(JSON.stringify(datum));
      ws.send(datum);
    };
    if (typeof data?.next !== "function")
      return void send(data);
    let init = data.next();
    if (init instanceof Promise)
      return (async () => {
        let first = await init;
        if (validateResponse?.Check(first) === false)
          return ws.send(new ValidationError("message", validateResponse, first).message);
        if (send(first.value), !first.done)
          for await (let datum of data)
            send(datum);
      })();
    if (send(init.value), !init.done)
      for (let datum of data)
        send(datum);
  };
  return handleWSResponse;
};
var BunAdapter = { ...WebStandardAdapter, name: "bun", handler: { ...WebStandardAdapter.handler, createNativeStaticHandler }, composeHandler: { ...WebStandardAdapter.composeHandler, headers: hasHeaderShorthand ? `c.headers = c.request.headers.toJSON()
` : `c.headers = {}
for (const [key, value] of c.request.headers.entries())c.headers[key] = value
` }, listen(app) {
  return (options, callback) => {
    if (typeof Bun === "undefined")
      throw new Error(".listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch");
    if (app.compile(), typeof options === "string") {
      if (!isNumericString(options))
        throw new Error("Port must be a numeric value");
      options = parseInt(options);
    }
    let fetch2 = app.fetch, serve = typeof options === "object" ? { development: !isProduction, reusePort: true, ...app.config.serve || {}, ...options || {}, static: app.router.static.http.static, websocket: { ...app.config.websocket || {}, ...websocket || {} }, fetch: fetch2, error: app.outerErrorHandler } : { development: !isProduction, reusePort: true, ...app.config.serve || {}, static: app.router.static.http.static, websocket: { ...app.config.websocket || {}, ...websocket || {} }, port: options, fetch: fetch2, error: app.outerErrorHandler };
    app.server = Bun?.serve(serve);
    for (let i = 0;i < app.event.start.length; i++)
      app.event.start[i].fn(app);
    if (callback)
      callback(app.server);
    process.on("beforeExit", () => {
      if (app.server) {
        app.server.stop(), app.server = null;
        for (let i = 0;i < app.event.stop.length; i++)
          app.event.stop[i].fn(app);
      }
    }), app.promisedModules.then(() => {
      Bun?.gc(false);
    });
  };
}, ws(app, path, options) {
  let { parse: parse22, body, response, ...rest } = options, validateMessage = getSchemaValidator(body, { modules: app.definitions.typebox, models: app.definitions.type, normalize: app.config.normalize }), validateResponse = getSchemaValidator(response, { modules: app.definitions.typebox, models: app.definitions.type, normalize: app.config.normalize });
  app.route("$INTERNALWS", path, async (context) => {
    let server = app.getServer(), { set: set2, path: path2, qi, headers, query, params } = context;
    if (context.validator = validateResponse, options.upgrade) {
      if (typeof options.upgrade === "function") {
        let temp = options.upgrade(context);
        if (temp instanceof Promise)
          await temp;
      } else if (options.upgrade)
        Object.assign(set2.headers, options.upgrade);
    }
    if (set2.cookie && isNotEmpty(set2.cookie)) {
      let cookie = serializeCookie(set2.cookie);
      if (cookie)
        set2.headers["set-cookie"] = cookie;
    }
    if (set2.headers["set-cookie"] && Array.isArray(set2.headers["set-cookie"]))
      set2.headers = parseSetCookies(new Headers(set2.headers), set2.headers["set-cookie"]);
    let handleResponse = createHandleWSResponse(validateResponse), parseMessage = createWSMessageParser(parse22), _id;
    if (server?.upgrade(context.request, { headers: isNotEmpty(set2.headers) ? set2.headers : undefined, data: { ...context, get id() {
      if (_id)
        return _id;
      return _id = randomId();
    }, validator: validateResponse, ping(data) {
      options.ping?.(data);
    }, pong(data) {
      options.pong?.(data);
    }, open(ws) {
      handleResponse(ws, options.open?.(new ElysiaWS(ws, context)));
    }, message: async (ws, _message) => {
      let message = await parseMessage(ws, _message);
      if (validateMessage?.Check(message) === false)
        return void ws.send(new ValidationError("message", validateMessage, message).message);
      handleResponse(ws, options.message?.(new ElysiaWS(ws, context, message), message));
    }, drain(ws) {
      handleResponse(ws, options.drain?.(new ElysiaWS(ws, context)));
    }, close(ws, code, reason) {
      handleResponse(ws, options.close?.(new ElysiaWS(ws, context), code, reason));
    } } }))
      return;
    return set2.status = 400, "Expected a websocket connection";
  }, { ...rest, websocket: options });
} };
var isBun2 = typeof Bun !== "undefined";
var env2 = isBun2 ? Bun.env : typeof process !== "undefined" && process?.env ? process.env : {};
var plusRegex = /\+/g;
function parseQueryFromURL(input) {
  let result = {};
  if (typeof input !== "string")
    return result;
  let key = "", value = "", startingIndex = -1, equalityIndex = -1, flags = 0, l = input.length;
  for (let i = 0;i < l; i++)
    switch (input.charCodeAt(i)) {
      case 38:
        let hasBothKeyValuePair = equalityIndex > startingIndex;
        if (!hasBothKeyValuePair)
          equalityIndex = i;
        if (key = input.slice(startingIndex + 1, equalityIndex), hasBothKeyValuePair || key.length > 0) {
          if (flags & 1)
            key = key.replace(plusRegex, " ");
          if (flags & 2)
            key = import_fast_decode_uri_component2.default(key) || key;
          if (!result[key]) {
            if (hasBothKeyValuePair) {
              if (value = input.slice(equalityIndex + 1, i), flags & 4)
                value = value.replace(plusRegex, " ");
              if (flags & 8)
                value = import_fast_decode_uri_component2.default(value) || value;
            }
            result[key] = value;
          }
        }
        key = "", value = "", startingIndex = i, equalityIndex = i, flags = 0;
        break;
      case 61:
        if (equalityIndex <= startingIndex)
          equalityIndex = i;
        else
          flags |= 8;
        break;
      case 43:
        if (equalityIndex > startingIndex)
          flags |= 4;
        else
          flags |= 1;
        break;
      case 37:
        if (equalityIndex > startingIndex)
          flags |= 8;
        else
          flags |= 2;
        break;
    }
  if (startingIndex < l) {
    let hasBothKeyValuePair = equalityIndex > startingIndex;
    if (key = input.slice(startingIndex + 1, hasBothKeyValuePair ? equalityIndex : l), hasBothKeyValuePair || key.length > 0) {
      if (flags & 1)
        key = key.replace(plusRegex, " ");
      if (flags & 2)
        key = import_fast_decode_uri_component2.default(key) || key;
      if (!result[key]) {
        if (hasBothKeyValuePair) {
          if (value = input.slice(equalityIndex + 1, l), flags & 4)
            value = value.replace(plusRegex, " ");
          if (flags & 8)
            value = import_fast_decode_uri_component2.default(value) || value;
        }
        result[key] = value;
      }
    }
  }
  return result;
}
var parseQuery = (input) => {
  let result = {};
  if (typeof input !== "string")
    return result;
  let inputLength = input.length, key = "", value = "", startingIndex = -1, equalityIndex = -1, shouldDecodeKey = false, shouldDecodeValue = false, keyHasPlus = false, valueHasPlus = false, hasBothKeyValuePair = false, c = 0;
  for (let i = 0;i < inputLength + 1; i++) {
    if (i !== inputLength)
      c = input.charCodeAt(i);
    else
      c = 38;
    switch (c) {
      case 38: {
        if (hasBothKeyValuePair = equalityIndex > startingIndex, !hasBothKeyValuePair)
          equalityIndex = i;
        if (key = input.slice(startingIndex + 1, equalityIndex), hasBothKeyValuePair || key.length > 0) {
          if (keyHasPlus)
            key = key.replace(plusRegex, " ");
          if (shouldDecodeKey)
            key = import_fast_decode_uri_component2.default(key) || key;
          if (hasBothKeyValuePair) {
            if (value = input.slice(equalityIndex + 1, i), valueHasPlus)
              value = value.replace(plusRegex, " ");
            if (shouldDecodeValue)
              value = import_fast_decode_uri_component2.default(value) || value;
          }
          let currentValue = result[key];
          if (currentValue === undefined)
            result[key] = value;
          else if (currentValue.pop)
            currentValue.push(value);
          else
            result[key] = [currentValue, value];
        }
        value = "", startingIndex = i, equalityIndex = i, shouldDecodeKey = false, shouldDecodeValue = false, keyHasPlus = false, valueHasPlus = false;
        break;
      }
      case 61:
        if (equalityIndex <= startingIndex)
          equalityIndex = i;
        else
          shouldDecodeValue = true;
        break;
      case 43:
        if (equalityIndex > startingIndex)
          valueHasPlus = true;
        else
          keyHasPlus = true;
        break;
      case 37:
        if (equalityIndex > startingIndex)
          shouldDecodeValue = true;
        else
          shouldDecodeKey = true;
        break;
    }
  }
  return result;
};
var ELYSIA_TRACE = Symbol("ElysiaTrace");
var createProcess = () => {
  let { promise, resolve } = Promise.withResolvers(), { promise: end, resolve: resolveEnd } = Promise.withResolvers(), { promise: error2, resolve: resolveError } = Promise.withResolvers(), callbacks = [], callbacksEnd = [];
  return [(callback) => {
    if (callback)
      callbacks.push(callback);
    return promise;
  }, (process2) => {
    let processes = [], resolvers = [], groupError = null;
    for (let i = 0;i < (process2.total ?? 0); i++) {
      let { promise: promise2, resolve: resolve2 } = Promise.withResolvers(), { promise: end2, resolve: resolveEnd2 } = Promise.withResolvers(), { promise: error3, resolve: resolveError2 } = Promise.withResolvers(), callbacks2 = [], callbacksEnd2 = [];
      processes.push((callback) => {
        if (callback)
          callbacks2.push(callback);
        return promise2;
      }), resolvers.push((process3) => {
        let result2 = { ...process3, end: end2, error: error3, index: i, onStop(callback) {
          if (callback)
            callbacksEnd2.push(callback);
          return end2;
        } };
        resolve2(result2);
        for (let i2 = 0;i2 < callbacks2.length; i2++)
          callbacks2[i2](result2);
        return (error4 = null) => {
          let end3 = performance.now();
          if (error4)
            groupError = error4;
          let detail = { end: end3, error: error4, get elapsed() {
            return end3 - process3.begin;
          } };
          for (let i2 = 0;i2 < callbacksEnd2.length; i2++)
            callbacksEnd2[i2](detail);
          resolveEnd2(end3), resolveError2(error4);
        };
      });
    }
    let result = { ...process2, end, error: error2, onEvent(callback) {
      for (let i = 0;i < processes.length; i++)
        processes[i](callback);
    }, onStop(callback) {
      if (callback)
        callbacksEnd.push(callback);
      return end;
    } };
    resolve(result);
    for (let i = 0;i < callbacks.length; i++)
      callbacks[i](result);
    return { resolveChild: resolvers, resolve(error3 = null) {
      let end2 = performance.now();
      if (!error3 && groupError)
        error3 = groupError;
      let detail = { end: end2, error: error3, get elapsed() {
        return end2 - process2.begin;
      } };
      for (let i = 0;i < callbacksEnd.length; i++)
        callbacksEnd[i](detail);
      resolveEnd(end2), resolveError(error3);
    } };
  }];
};
var createTracer = (traceListener) => {
  return (context) => {
    let [onRequest, resolveRequest] = createProcess(), [onParse, resolveParse] = createProcess(), [onTransform, resolveTransform] = createProcess(), [onBeforeHandle, resolveBeforeHandle] = createProcess(), [onHandle, resolveHandle] = createProcess(), [onAfterHandle, resolveAfterHandle] = createProcess(), [onError, resolveError] = createProcess(), [onMapResponse, resolveMapResponse] = createProcess(), [onAfterResponse, resolveAfterResponse] = createProcess();
    return traceListener({ id: context[ELYSIA_REQUEST_ID], context, set: context.set, onRequest, onParse, onTransform, onBeforeHandle, onHandle, onAfterHandle, onMapResponse, onAfterResponse, onError }), { request: resolveRequest, parse: resolveParse, transform: resolveTransform, beforeHandle: resolveBeforeHandle, handle: resolveHandle, afterHandle: resolveAfterHandle, error: resolveError, mapResponse: resolveMapResponse, afterResponse: resolveAfterResponse };
  };
};
var TypeBoxSymbol = { optional: Symbol.for("TypeBox.Optional"), kind: Symbol.for("TypeBox.Kind") };
var isOptional = (validator) => {
  if (!validator)
    return false;
  let schema = validator?.schema;
  if (schema?.[TypeBoxSymbol.kind] === "Import")
    return validator.References().some(isOptional);
  return !!schema && TypeBoxSymbol.optional in schema;
};
var defaultParsers = ["json", "text", "urlencoded", "arrayBuffer", "formdata", "application/json", "text/plain", "application/x-www-form-urlencoded", "application/octet-stream", "multipart/form-data"];
var hasAdditionalProperties = (_schema) => {
  if (!_schema)
    return false;
  let schema = _schema?.schema ?? _schema;
  if (schema[TypeBoxSymbol.kind] === "Import" && _schema.References())
    return _schema.References().some(hasAdditionalProperties);
  if (schema.anyOf)
    return schema.anyOf.some(hasAdditionalProperties);
  if (schema.someOf)
    return schema.someOf.some(hasAdditionalProperties);
  if (schema.allOf)
    return schema.allOf.some(hasAdditionalProperties);
  if (schema.not)
    return schema.not.some(hasAdditionalProperties);
  if (schema.type === "object") {
    let properties = schema.properties;
    if ("additionalProperties" in schema)
      return schema.additionalProperties;
    if ("patternProperties" in schema)
      return false;
    for (let key of Object.keys(properties)) {
      let property = properties[key];
      if (property.type === "object") {
        if (hasAdditionalProperties(property))
          return true;
      } else if (property.anyOf) {
        for (let i = 0;i < property.anyOf.length; i++)
          if (hasAdditionalProperties(property.anyOf[i]))
            return true;
      }
      return property.additionalProperties;
    }
    return false;
  }
  return false;
};
var createReport = ({ context = "c", trace, addFn }) => {
  if (!trace.length)
    return () => {
      return { resolveChild() {
        return () => {
        };
      }, resolve() {
      } };
    };
  for (let i = 0;i < trace.length; i++)
    addFn(`let report${i}, reportChild${i}, reportErr${i}, reportErrChild${i};let trace${i} = ${context}[ELYSIA_TRACE]?.[${i}] ?? trace[${i}](${context});
`);
  return (event, { name, total = 0 } = {}) => {
    if (!name)
      name = "anonymous";
    let reporter = event === "error" ? "reportErr" : "report";
    for (let i = 0;i < trace.length; i++)
      addFn(`${reporter}${i} = trace${i}.${event}({id,event:'${event}',name:'${name}',begin:performance.now(),total:${total}})
`);
    return { resolve() {
      for (let i = 0;i < trace.length; i++)
        addFn(`${reporter}${i}.resolve()
`);
    }, resolveChild(name2) {
      for (let i = 0;i < trace.length; i++)
        addFn(`${reporter}Child${i}=${reporter}${i}.resolveChild?.shift()?.({id,event:'${event}',name:'${name2}',begin:performance.now()})
`);
      return (binding) => {
        for (let i = 0;i < trace.length; i++)
          if (binding)
            addFn(`if(${binding} instanceof Error){${reporter}Child${i}?.(${binding}) }else{${reporter}Child${i}?.()}`);
          else
            addFn(`${reporter}Child${i}?.()
`);
      };
    } };
  };
};
var composeValidationFactory = ({ injectResponse = "", normalize = false, validator }) => ({ composeValidation: (type, value = `c.${type}`) => `c.set.status=422;throw new ValidationError('${type}',validator.${type},${value})`, composeResponseValidation: (name = "r") => {
  let code = injectResponse + `
`;
  code += `if(${name} instanceof ElysiaCustomStatusResponse){c.set.status=${name}.code
${name}=${name}.response}const isResponse=${name} instanceof Response
switch(c.set.status){`;
  for (let [status, value] of Object.entries(validator.response)) {
    if (code += `
case ${status}:if(!isResponse){`, normalize && "Clean" in value && !hasAdditionalProperties(value))
      code += `${name}=validator.response['${status}'].Clean(${name})
`;
    code += `if(validator.response['${status}'].Check(${name})===false){c.set.status=422
throw new ValidationError('response',validator.response['${status}'],${name})}c.set.status = ${status}}break
`;
  }
  return code + "}";
} });
var KindSymbol = Symbol.for("TypeBox.Kind");
var hasProperty = (expectedProperty, _schema) => {
  if (!_schema)
    return;
  let schema = _schema.schema ?? _schema;
  if (schema[TypeBoxSymbol.kind] === "Import")
    return _schema.References().some((schema2) => hasProperty(expectedProperty, schema2));
  if (schema.type === "object") {
    let properties = schema.properties;
    if (!properties)
      return false;
    for (let key of Object.keys(properties)) {
      let property = properties[key];
      if (expectedProperty in property)
        return true;
      if (property.type === "object") {
        if (hasProperty(expectedProperty, property))
          return true;
      } else if (property.anyOf) {
        for (let i = 0;i < property.anyOf.length; i++)
          if (hasProperty(expectedProperty, property.anyOf[i]))
            return true;
      }
    }
    return false;
  }
  return expectedProperty in schema;
};
var TransformSymbol = Symbol.for("TypeBox.Transform");
var hasTransform = (schema) => {
  if (!schema)
    return;
  if (schema.type === "object" && schema.properties) {
    let properties = schema.properties;
    for (let key of Object.keys(properties)) {
      let property = properties[key];
      if (property.type === "object") {
        if (hasTransform(property))
          return true;
      } else if (property.anyOf) {
        for (let i = 0;i < property.anyOf.length; i++)
          if (hasTransform(property.anyOf[i]))
            return true;
      }
      if (TransformSymbol in property)
        return true;
    }
    return false;
  }
  return TransformSymbol in schema || schema.properties && TransformSymbol in schema.properties;
};
var matchFnReturn = /(?:return|=>) \S+\(/g;
var isAsyncName = (v) => {
  return (v?.fn ?? v).constructor.name === "AsyncFunction";
};
var isAsync = (v) => {
  let fn = v?.fn ?? v;
  if (fn.constructor.name === "AsyncFunction")
    return true;
  let literal = fn.toString();
  if (literal.includes("=> response.clone("))
    return false;
  if (literal.includes("await"))
    return true;
  if (literal.includes("async"))
    return true;
  if (literal.includes("=>response.clone("))
    return false;
  return !!literal.match(matchFnReturn);
};
var isGenerator = (v) => {
  let fn = v?.fn ?? v;
  return fn.constructor.name === "AsyncGeneratorFunction" || fn.constructor.name === "GeneratorFunction";
};
var composeHandler = ({ app, path, method, localHook, hooks, validator, handler, allowMeta = false, inference, asManifest = false }) => {
  let adapter = app["~adapter"].composeHandler, adapterHandler = app["~adapter"].handler, isHandleFn = typeof handler === "function";
  if (!isHandleFn) {
    if (handler = adapterHandler.mapResponse(handler, { headers: app.setHeaders ?? {} }), hooks.parse.length === 0 && hooks.transform.length === 0 && hooks.beforeHandle.length === 0 && hooks.afterHandle.length === 0) {
      if (handler instanceof Response)
        return Function("a", "return function(){return a.clone()}")(handler);
      return Function("a", "return function(){return a}")(handler);
    }
  }
  let handle = isHandleFn ? "handler(c)" : "handler", hasAfterResponse = hooks.afterResponse.length > 0, hasTrace = hooks.trace.length > 0, fnLiteral = "";
  if (inference = sucrose(Object.assign(localHook, { handler }), inference), adapter.declare) {
    let literal = adapter.declare(inference);
    if (literal)
      fnLiteral += literal;
  }
  if (inference.server)
    fnLiteral += `Object.defineProperty(c,'server',{get:function(){return getServer()}})
`;
  validator.createBody?.(), validator.createQuery?.(), validator.createHeaders?.(), validator.createParams?.(), validator.createCookie?.(), validator.createResponse?.();
  let hasQuery = inference.query || !!validator.query, hasBody = method !== "$INTERNALWS" && method !== "GET" && method !== "HEAD" && (inference.body || !!validator.body || hooks.parse.length);
  if (hasBody)
    fnLiteral += `let isParsing=false
`;
  let defaultHeaders = app.setHeaders, hasDefaultHeaders = defaultHeaders && !!Object.keys(defaultHeaders).length, hasHeaders = inference.headers || validator.headers || adapter.preferWebstandardHeaders !== true && inference.body, hasCookie = inference.cookie || !!validator.cookie, cookieValidator = hasCookie ? getCookieValidator({ modules: app.definitions.typebox, validator: validator.cookie, defaultConfig: app.config.cookie, dynamic: !!app.config.aot, config: validator.cookie?.config ?? {}, models: app.definitions.type }) : undefined, cookieMeta = cookieValidator?.config, encodeCookie = "";
  if (cookieMeta?.sign) {
    if (!cookieMeta.secrets)
      throw new Error(`t.Cookie required secret which is not set in (${method}) ${path}.`);
    let secret = !cookieMeta.secrets ? undefined : typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets[0];
    if (encodeCookie += `const _setCookie = c.set.cookie
if(_setCookie){`, cookieMeta.sign === true)
      encodeCookie += `for(const [key, cookie] of Object.entries(_setCookie)){c.set.cookie[key].value=await signCookie(cookie.value,'${secret}')}`;
    else
      for (let name of cookieMeta.sign)
        encodeCookie += `if(_setCookie['${name}']?.value){c.set.cookie['${name}'].value=await signCookie(_setCookie['${name}'].value,'${secret}')}`;
    encodeCookie += `}
`;
  }
  let normalize = app.config.normalize, { composeValidation, composeResponseValidation } = composeValidationFactory({ normalize, validator });
  if (hasHeaders)
    fnLiteral += adapter.headers;
  if (hasTrace)
    fnLiteral += `const id=c[ELYSIA_REQUEST_ID]
`;
  let report = createReport({ trace: hooks.trace, addFn: (word) => {
    fnLiteral += word;
  } });
  if (fnLiteral += "try{", hasCookie) {
    let get = (name, defaultValue) => {
      let value = cookieMeta?.[name] ?? defaultValue;
      if (!value)
        return typeof defaultValue === "string" ? `${name}:"${defaultValue}",` : `${name}:${defaultValue},`;
      if (typeof value === "string")
        return `${name}:'${value}',`;
      if (value instanceof Date)
        return `${name}: new Date(${value.getTime()}),`;
      return `${name}:${value},`;
    }, options = cookieMeta ? `{secrets:${cookieMeta.secrets !== undefined ? typeof cookieMeta.secrets === "string" ? `'${cookieMeta.secrets}'` : "[" + cookieMeta.secrets.reduce((a, b) => a + `'${b}',`, "") + "]" : "undefined"},sign:${cookieMeta.sign === true ? true : cookieMeta.sign !== undefined ? "[" + cookieMeta.sign.reduce((a, b) => a + `'${b}',`, "") + "]" : "undefined"},` + get("domain") + get("expires") + get("httpOnly") + get("maxAge") + get("path", "/") + get("priority") + get("sameSite") + get("secure") + "}" : "undefined";
    if (hasHeaders)
      fnLiteral += `
c.cookie=await parseCookie(c.set,c.headers.cookie,${options})
`;
    else
      fnLiteral += `
c.cookie=await parseCookie(c.set,c.request.headers.get('cookie'),${options})
`;
  }
  if (hasQuery) {
    let destructured = [];
    if (validator.query && validator.query.schema.type === "object") {
      let properties = validator.query.schema.properties;
      if (!hasAdditionalProperties(validator.query))
        for (let [key, _value] of Object.entries(properties)) {
          let value = _value;
          if (value && TypeBoxSymbol.optional in value && value.type === "array" && value.items)
            value = value.items;
          let { type, anyOf } = value, isArray = type === "array" || anyOf?.some((v) => v.type === "string" && v.format === "ArrayString");
          destructured.push({ key, isArray, isNestedObjectArray: isArray && value.items?.type === "object" || !!value.items?.anyOf?.some((x) => x.type === "object" || x.type === "array"), isObject: type === "object" || anyOf?.some((v) => v.type === "string" && v.format === "ArrayString"), anyOf: !!anyOf });
        }
    }
    if (!destructured.length)
      fnLiteral += "if(c.qi===-1){c.query={}}else{c.query=parseQueryFromURL(c.url.slice(c.qi + 1))}";
    else {
      fnLiteral += `if(c.qi!==-1){let url = '&' + decodeURIComponent(c.url.slice(c.qi + 1))
`;
      let index = 0;
      for (let { key, isArray, isObject: isObject2, isNestedObjectArray, anyOf } of destructured) {
        let init2 = (index === 0 ? "let " : "") + `memory=url.indexOf('&${key}=')
let a${index}
`;
        if (isArray)
          if (fnLiteral += init2, isNestedObjectArray)
            fnLiteral += `while(memory!==-1){const start=memory+${key.length + 2}
memory=url.indexOf('&',start)
if(a${index}===undefined)
a${index}=''
else
a${index}+=','
let temp
if(memory===-1)temp=decodeURIComponent(url.slice(start).replace(/\\+|%20/g,' '))
else temp=decodeURIComponent(url.slice(start, memory).replace(/\\+|%20/g,' '))
const charCode = temp.charCodeAt(0)
if(charCode !== 91 && charCode !== 123)
temp='"'+temp+'"'
a${index} += temp
if(memory === -1)break
memory=url.indexOf('&${key}=',memory)
if(memory === -1)break}try{if(a${index}.charCodeAt(0) === 91)a${index} = JSON.parse(a${index})
else
a${index}=JSON.parse('['+a${index}+']')}catch{}
`;
          else
            fnLiteral += `while(memory!==-1){const start=memory+${key.length + 2}
memory=url.indexOf('&',start)
if(a${index}===undefined)a${index}=[]
if(memory===-1){a${index}.push(decodeURIComponent(url.slice(start)).replace(/\\+|%20/g,' '))
break}else a${index}.push(decodeURIComponent(url.slice(start, memory)).replace(/\\+|%20/g,' '))
memory=url.indexOf('&${key}=',memory)
if(memory===-1) break
}`;
        else if (isObject2)
          fnLiteral += init2 + `if(memory!==-1){const start=memory+${key.length + 2}
memory=url.indexOf('&',start)
if(memory===-1)a${index}=decodeURIComponent(url.slice(start).replace(/\\+|%20/g,' '))else a${index}=decodeURIComponent(url.slice(start,memory).replace(/\\+|%20/g,' '))if(a${index}!==undefined)try{a${index}=JSON.parse(a${index})}catch{}}`;
        else {
          if (fnLiteral += init2 + `if(memory!==-1){const start=memory+${key.length + 2}
memory=url.indexOf('&',start)
if(memory===-1)a${index}=decodeURIComponent(url.slice(start).replace(/\\+|%20/g,' '))
else{a${index}=decodeURIComponent(url.slice(start,memory).replace(/\\+|%20/g,' '))`, anyOf)
            fnLiteral += `
let deepMemory=url.indexOf('&${key}=',memory)
if(deepMemory!==-1){a${index}=[a${index}]
let first=true
while(true){const start=deepMemory+${key.length + 2}
if(first)first=false
else deepMemory = url.indexOf('&', start)
let value
if(deepMemory===-1)value=decodeURIComponent(url.slice(start).replace(/\\+|%20/g,' '))
else value=decodeURIComponent(url.slice(start, deepMemory).replace(/\\+|%20/g,' '))
const vStart=value.charCodeAt(0)
const vEnd=value.charCodeAt(value.length - 1)
if((vStart===91&&vEnd===93)||(vStart===123&&vEnd===125))
try{a${index}.push(JSON.parse(value))}catch{a${index}.push(value)}if(deepMemory===-1)break}}`;
          fnLiteral += "}}";
        }
        index++, fnLiteral += `
`;
      }
      fnLiteral += "c.query={" + destructured.map(({ key }, index2) => `'${key}':a${index2}`).join(",") + "}", fnLiteral += `} else c.query = {}
`;
    }
  }
  let isAsyncHandler = typeof handler === "function" && isAsync(handler), saveResponse = hasTrace || hooks.afterResponse.length > 0 ? "c.response= " : "", maybeAsync = hasCookie || hasBody || isAsyncHandler || hooks.parse.length > 0 || hooks.afterHandle.some(isAsync) || hooks.beforeHandle.some(isAsync) || hooks.transform.some(isAsync) || hooks.mapResponse.some(isAsync), maybeStream = (typeof handler === "function" ? isGenerator(handler) : false) || hooks.beforeHandle.some(isGenerator) || hooks.afterHandle.some(isGenerator) || hooks.transform.some(isGenerator), hasSet = inference.cookie || inference.set || hasHeaders || hasTrace || validator.response || isHandleFn && hasDefaultHeaders || maybeStream, mapResponseContext = adapter.mapResponseContext ? `,${adapter.mapResponseContext}` : "";
  if (inference.route)
    fnLiteral += `c.route=\`${path}\`
`;
  let parseReporter = report("parse", { total: hooks.parse.length });
  if (hasBody) {
    let isOptionalBody = isOptional(validator.body), hasBodyInference = hooks.parse.length || inference.body || validator.body;
    if (adapter.parser.declare)
      fnLiteral += adapter.parser.declare;
    fnLiteral += `
isParsing=true`;
    let parser = typeof hooks.parse === "string" ? hooks.parse : Array.isArray(hooks.parse) && hooks.parse.length === 1 ? typeof hooks.parse[0] === "string" ? hooks.parse[0] : typeof hooks.parse[0].fn === "string" ? hooks.parse[0].fn : undefined : undefined;
    if (parser && parser in defaultParsers) {
      let reporter = report("parse", { total: hooks.parse.length });
      switch (parser) {
        case "json":
        case "application/json":
          fnLiteral += adapter.parser.json(isOptionalBody);
          break;
        case "text":
        case "text/plain":
          fnLiteral += adapter.parser.text(isOptionalBody);
          break;
        case "urlencoded":
        case "application/x-www-form-urlencoded":
          fnLiteral += adapter.parser.urlencoded(isOptionalBody);
          break;
        case "arrayBuffer":
        case "application/octet-stream":
          fnLiteral += adapter.parser.arrayBuffer(isOptionalBody);
          break;
        case "formdata":
        case "multipart/form-data":
          fnLiteral += adapter.parser.formData(isOptionalBody);
          break;
        default:
          if (parser[0] in app["~parser"])
            fnLiteral += hasHeaders ? "let contentType = c.headers['content-type']" : "let contentType = c.request.headers.get('content-type')", fnLiteral += `
if(contentType){const index=contentType.indexOf(';')
if(index!==-1)contentType=contentType.substring(0, index)}
else{contentType=''}c.contentType=contentType
`, fnLiteral += `let result=parser['${parser}'](c, contentType)
if(result instanceof Promise)result=await result
if(result instanceof ElysiaCustomStatusResponse)throw result
if(result!==undefined)c.body=result
delete c.contentType
`;
          break;
      }
      reporter.resolve();
    } else if (hasBodyInference) {
      if (fnLiteral += `
`, fnLiteral += hasHeaders ? "let contentType = c.headers['content-type']" : "let contentType = c.request.headers.get('content-type')", fnLiteral += `
if(contentType){const index=contentType.indexOf(';')
if(index!==-1)contentType=contentType.substring(0, index)}
else{contentType=''}c.contentType=contentType
`, hooks.parse.length)
        fnLiteral += `let used=false
`;
      let reporter = report("parse", { total: hooks.parse.length }), hasDefaultParser = false;
      for (let i = 0;i < hooks.parse.length; i++) {
        let name = `bo${i}`;
        if (i !== 0)
          fnLiteral += `
if(!used){`;
        if (typeof hooks.parse[i].fn === "string") {
          let endUnit = reporter.resolveChild(hooks.parse[i].fn);
          switch (hooks.parse[i].fn) {
            case "json":
            case "application/json":
              hasDefaultParser = true, fnLiteral += adapter.parser.json(isOptionalBody);
              break;
            case "text":
            case "text/plain":
              hasDefaultParser = true, fnLiteral += adapter.parser.text(isOptionalBody);
              break;
            case "urlencoded":
            case "application/x-www-form-urlencoded":
              hasDefaultParser = true, fnLiteral += adapter.parser.urlencoded(isOptionalBody);
              break;
            case "arrayBuffer":
            case "application/octet-stream":
              hasDefaultParser = true, fnLiteral += adapter.parser.arrayBuffer(isOptionalBody);
              break;
            case "formdata":
            case "multipart/form-data":
              hasDefaultParser = true, fnLiteral += adapter.parser.formData(isOptionalBody);
              break;
            default:
              fnLiteral += `${name}=parser['${hooks.parse[i].fn}'](c,contentType)
if(${name} instanceof Promise)${name}=await ${name}
if(${name}!==undefined){c.body=${name};used=true}
`;
          }
          endUnit();
        } else {
          let endUnit = reporter.resolveChild(hooks.parse[i].fn.name);
          fnLiteral += `let ${name}=parse[${i}]
${name}=${name}(c,contentType)
if(${name} instanceof Promise)${name}=await ${name}
if(${name}!==undefined){c.body=${name};used=true}`, endUnit();
        }
        if (i !== 0)
          fnLiteral += "}";
        if (hasDefaultParser)
          break;
      }
      if (reporter.resolve(), !hasDefaultParser) {
        if (hooks.parse.length)
          fnLiteral += `
if(!used){
if(!contentType) throw new ParseError()
`;
        fnLiteral += "switch(contentType){", fnLiteral += `case 'application/json':
` + adapter.parser.json(isOptionalBody) + `break
case 'text/plain':` + adapter.parser.text(isOptionalBody) + `break
case 'application/x-www-form-urlencoded':` + adapter.parser.urlencoded(isOptionalBody) + `break
case 'application/octet-stream':` + adapter.parser.arrayBuffer(isOptionalBody) + `break
case 'multipart/form-data':` + adapter.parser.formData(isOptionalBody) + `break
`;
        for (let key of Object.keys(app["~parser"]))
          fnLiteral += `case '${key}':let bo${key}=parser['${key}'](c,contentType)
if(bo${key} instanceof Promise)bo${key}=await bo${key}
if(bo${key} instanceof ElysiaCustomStatusResponse)throw result
if(bo${key}!==undefined)c.body=bo${key}
break
`;
        if (hooks.parse.length)
          fnLiteral += "}";
        fnLiteral += "}";
      }
    }
    fnLiteral += `
delete c.contentType`, fnLiteral += `
isParsing=false
`;
  }
  if (parseReporter.resolve(), hooks?.transform) {
    let reporter = report("transform", { total: hooks.transform.length });
    if (hooks.transform.length)
      fnLiteral += `let transformed
`;
    for (let i = 0;i < hooks.transform.length; i++) {
      let transform2 = hooks.transform[i], endUnit = reporter.resolveChild(transform2.fn.name);
      if (fnLiteral += isAsync(transform2) ? `transformed=await transform[${i}](c)
` : `transformed=transform[${i}](c)
`, transform2.subType === "mapDerive")
        fnLiteral += `if(transformed instanceof ElysiaCustomStatusResponse)throw transformed
else{transformed.request=c.request
transformed.store=c.store
transformed.qi=c.qi
transformed.path=c.path
transformed.url=c.url
transformed.redirect=c.redirect
transformed.set=c.set
transformed.error=c.error
c=transformed}`;
      else
        fnLiteral += `if(transformed instanceof ElysiaCustomStatusResponse)throw transformed
else Object.assign(c,transformed)
`;
      endUnit();
    }
    reporter.resolve();
  }
  if (validator) {
    if (validator.headers) {
      if (normalize && "Clean" in validator.headers && !hasAdditionalProperties(validator.headers))
        fnLiteral += `c.headers=validator.headers.Clean(c.headers);
`;
      if (hasProperty("default", validator.headers))
        for (let [key, value] of Object.entries(exports_value2.Default(validator.headers.schema, {}))) {
          let parsed = typeof value === "object" ? JSON.stringify(value) : typeof value === "string" ? `'${value}'` : value;
          if (parsed !== undefined)
            fnLiteral += `c.headers['${key}']??=${parsed}
`;
        }
      if (isOptional(validator.headers))
        fnLiteral += "if(isNotEmpty(c.headers)){";
      if (fnLiteral += "if(validator.headers.Check(c.headers) === false){" + composeValidation("headers") + "}", hasTransform(validator.headers.schema))
        fnLiteral += `c.headers=validator.headers.Decode(c.headers)
`;
      if (isOptional(validator.headers))
        fnLiteral += "}";
    }
    if (validator.params) {
      if (hasProperty("default", validator.params))
        for (let [key, value] of Object.entries(exports_value2.Default(validator.params.schema, {}))) {
          let parsed = typeof value === "object" ? JSON.stringify(value) : typeof value === "string" ? `'${value}'` : value;
          if (parsed !== undefined)
            fnLiteral += `c.params['${key}']??=${parsed}
`;
        }
      if (fnLiteral += "if(validator.params.Check(c.params)===false){" + composeValidation("params") + "}", hasTransform(validator.params.schema))
        fnLiteral += `c.params=validator.params.Decode(c.params)
`;
    }
    if (validator.query) {
      if (normalize && "Clean" in validator.query && !hasAdditionalProperties(validator.query))
        fnLiteral += `c.query=validator.query.Clean(c.query)
`;
      if (hasProperty("default", validator.query))
        for (let [key, value] of Object.entries(exports_value2.Default(validator.query.schema, {}))) {
          let parsed = typeof value === "object" ? JSON.stringify(value) : typeof value === "string" ? `'${value}'` : value;
          if (parsed !== undefined)
            fnLiteral += `if(c.query['${key}']===undefined)c.query['${key}']=${parsed}
`;
        }
      if (isOptional(validator.query))
        fnLiteral += "if(isNotEmpty(c.query)){";
      if (fnLiteral += "if(validator.query.Check(c.query)===false){" + composeValidation("query") + "}", hasTransform(validator.query.schema))
        fnLiteral += `c.query=validator.query.Decode(Object.assign({},c.query))
`;
      if (isOptional(validator.query))
        fnLiteral += "}";
    }
    if (validator.body) {
      if (normalize && "Clean" in validator.body && !hasAdditionalProperties(validator.body))
        fnLiteral += `c.body=validator.body.Clean(c.body)
`;
      let doesHaveTransform = hasTransform(validator.body.schema);
      if (doesHaveTransform || isOptional(validator.body))
        fnLiteral += `const isNotEmptyObject=c.body&&(typeof c.body==="object"&&isNotEmpty(c.body))
`;
      if (hasProperty("default", validator.body)) {
        let value = exports_value2.Default(validator.body.schema, validator.body.schema.type === "object" ? {} : undefined), parsed = typeof value === "object" ? JSON.stringify(value) : typeof value === "string" ? `'${value}'` : value;
        if (fnLiteral += `if(validator.body.Check(c.body)===false){if(typeof c.body==='object')c.body=Object.assign(${parsed},c.body)
else c.body=${parsed}
`, isOptional(validator.body))
          fnLiteral += "if(isNotEmptyObject&&validator.body.Check(c.body)===false){" + composeValidation("body") + "}";
        else
          fnLiteral += "if(validator.body.Check(c.body)===false){" + composeValidation("body") + "}";
        fnLiteral += "}";
      } else if (isOptional(validator.body))
        fnLiteral += "if(isNotEmptyObject&&validator.body.Check(c.body)===false){" + composeValidation("body") + "}";
      else
        fnLiteral += "if(validator.body.Check(c.body)===false){" + composeValidation("body") + "}";
      if (doesHaveTransform)
        fnLiteral += `if(isNotEmptyObject)c.body=validator.body.Decode(c.body)
`;
    }
    if (cookieValidator && isNotEmpty(cookieValidator?.schema?.properties ?? cookieValidator?.schema?.schema ?? {})) {
      if (fnLiteral += `const cookieValue={}
for(const [key,value] of Object.entries(c.cookie))cookieValue[key]=value.value
`, hasProperty("default", cookieValidator))
        for (let [key, value] of Object.entries(exports_value2.Default(cookieValidator.schema, {})))
          fnLiteral += `cookieValue['${key}'] = ${typeof value === "object" ? JSON.stringify(value) : value}
`;
      if (isOptional(validator.cookie))
        fnLiteral += "if(isNotEmpty(c.cookie)){";
      if (fnLiteral += "if(validator.cookie.Check(cookieValue)===false){" + composeValidation("cookie", "cookieValue") + "}", hasTransform(validator.cookie.schema))
        fnLiteral += `for(const [key,value] of Object.entries(validator.cookie.Decode(cookieValue)))c.cookie[key].value=value
`;
      if (isOptional(validator.cookie))
        fnLiteral += "}";
    }
  }
  if (hooks?.beforeHandle) {
    let reporter = report("beforeHandle", { total: hooks.beforeHandle.length }), hasResolve = false;
    for (let i = 0;i < hooks.beforeHandle.length; i++) {
      let beforeHandle = hooks.beforeHandle[i], endUnit = reporter.resolveChild(beforeHandle.fn.name), returning = hasReturn(beforeHandle);
      if (beforeHandle.subType === "resolve" || beforeHandle.subType === "mapResolve") {
        if (!hasResolve)
          hasResolve = true, fnLiteral += `
let resolved
`;
        if (fnLiteral += isAsync(beforeHandle) ? `resolved=await beforeHandle[${i}](c);
` : `resolved=beforeHandle[${i}](c);
`, beforeHandle.subType === "mapResolve")
          fnLiteral += `if(resolved instanceof ElysiaCustomStatusResponse)throw resolved
else{resolved.request = c.request
resolved.store = c.store
resolved.qi = c.qi
resolved.path = c.path
resolved.url = c.url
resolved.redirect = c.redirect
resolved.set = c.set
resolved.error = c.error
c = resolved}`;
        else
          fnLiteral += `if(resolved instanceof ElysiaCustomStatusResponse)throw resolved
else Object.assign(c, resolved)
`;
      } else if (!returning)
        fnLiteral += isAsync(beforeHandle) ? `await beforeHandle[${i}](c)
` : `beforeHandle[${i}](c)
`, endUnit();
      else {
        if (fnLiteral += isAsync(beforeHandle) ? `be=await beforeHandle[${i}](c)
` : `be=beforeHandle[${i}](c)
`, endUnit("be"), fnLiteral += "if(be!==undefined){", reporter.resolve(), hooks.afterHandle?.length) {
          report("handle", { name: isHandleFn ? handler.name : undefined }).resolve();
          let reporter2 = report("afterHandle", { total: hooks.afterHandle.length });
          for (let i2 = 0;i2 < hooks.afterHandle.length; i2++) {
            let hook = hooks.afterHandle[i2], returning2 = hasReturn(hook), endUnit2 = reporter2.resolveChild(hook.fn.name);
            if (fnLiteral += `c.response = be
`, !returning2)
              fnLiteral += isAsync(hook.fn) ? `await afterHandle[${i2}](c, be)
` : `afterHandle[${i2}](c, be)
`;
            else
              fnLiteral += isAsync(hook.fn) ? `af = await afterHandle[${i2}](c)
` : `af = afterHandle[${i2}](c)
`, fnLiteral += `if(af!==undefined) c.response=be=af
`;
            endUnit2("af");
          }
          reporter2.resolve();
        }
        if (validator.response)
          fnLiteral += composeResponseValidation("be");
        let mapResponseReporter = report("mapResponse", { total: hooks.mapResponse.length });
        if (hooks.mapResponse.length) {
          fnLiteral += `c.response=be
`;
          for (let i2 = 0;i2 < hooks.mapResponse.length; i2++) {
            let mapResponse2 = hooks.mapResponse[i2], endUnit2 = mapResponseReporter.resolveChild(mapResponse2.fn.name);
            fnLiteral += `if(mr===undefined){mr=${isAsyncName(mapResponse2) ? "await" : ""} onMapResponse[${i2}](c)
if(mr!==undefined)be=c.response=mr}`, endUnit2();
          }
        }
        mapResponseReporter.resolve(), fnLiteral += encodeCookie, fnLiteral += `return mapEarlyResponse(${saveResponse}be,c.set${mapResponseContext})}
`;
      }
    }
    reporter.resolve();
  }
  if (hooks?.afterHandle.length) {
    let handleReporter = report("handle", { name: isHandleFn ? handler.name : undefined });
    if (hooks.afterHandle.length)
      fnLiteral += isAsyncHandler ? `let r=c.response=await ${handle}
` : `let r=c.response=${handle}
`;
    else
      fnLiteral += isAsyncHandler ? `let r=await ${handle}
` : `let r=${handle}
`;
    handleReporter.resolve();
    let reporter = report("afterHandle", { total: hooks.afterHandle.length });
    for (let i = 0;i < hooks.afterHandle.length; i++) {
      let hook = hooks.afterHandle[i], returning = hasReturn(hook), endUnit = reporter.resolveChild(hook.fn.name);
      if (!returning)
        fnLiteral += isAsync(hook.fn) ? `await afterHandle[${i}](c)
` : `afterHandle[${i}](c)
`, endUnit();
      else if (fnLiteral += isAsync(hook.fn) ? `af=await afterHandle[${i}](c)
` : `af=afterHandle[${i}](c)
`, endUnit("af"), validator.response)
        fnLiteral += "if(af!==undefined){", reporter.resolve(), fnLiteral += composeResponseValidation("af"), fnLiteral += "c.response=af}";
      else
        fnLiteral += "if(af!==undefined){", reporter.resolve(), fnLiteral += "c.response=af}";
    }
    if (reporter.resolve(), fnLiteral += `r=c.response
`, validator.response)
      fnLiteral += composeResponseValidation();
    fnLiteral += encodeCookie;
    let mapResponseReporter = report("mapResponse", { total: hooks.mapResponse.length });
    if (hooks.mapResponse.length)
      for (let i = 0;i < hooks.mapResponse.length; i++) {
        let mapResponse2 = hooks.mapResponse[i], endUnit = mapResponseReporter.resolveChild(mapResponse2.fn.name);
        fnLiteral += `mr=${isAsyncName(mapResponse2) ? "await" : ""} onMapResponse[${i}](c)
if(mr!==undefined)r=c.response=mr
`, endUnit();
      }
    if (mapResponseReporter.resolve(), hasSet)
      fnLiteral += `return mapResponse(${saveResponse}r,c.set${mapResponseContext})
`;
    else
      fnLiteral += `return mapCompactResponse(${saveResponse}r${mapResponseContext})
`;
  } else {
    let handleReporter = report("handle", { name: isHandleFn ? handler.name : undefined });
    if (validator.response || hooks.mapResponse.length) {
      if (fnLiteral += isAsyncHandler ? `let r=await ${handle}
` : `let r=${handle}
`, handleReporter.resolve(), validator.response)
        fnLiteral += composeResponseValidation();
      report("afterHandle").resolve();
      let mapResponseReporter = report("mapResponse", { total: hooks.mapResponse.length });
      if (hooks.mapResponse.length) {
        fnLiteral += `
c.response=r
`;
        for (let i = 0;i < hooks.mapResponse.length; i++) {
          let mapResponse2 = hooks.mapResponse[i], endUnit = mapResponseReporter.resolveChild(mapResponse2.fn.name);
          fnLiteral += `
if(mr===undefined){mr=${isAsyncName(mapResponse2) ? "await " : ""}onMapResponse[${i}](c)
if(mr!==undefined)r=c.response=mr}
`, endUnit();
        }
      }
      if (mapResponseReporter.resolve(), fnLiteral += encodeCookie, handler instanceof Response)
        fnLiteral += inference.set ? `if(isNotEmpty(c.set.headers)||c.set.status!==200||c.set.redirect||c.set.cookie)return mapResponse(${saveResponse}${handle}.clone(),c.set${mapResponseContext})else return ${handle}.clone()` : `return ${handle}.clone()`, fnLiteral += `
`;
      else if (hasSet)
        fnLiteral += `return mapResponse(${saveResponse}r,c.set${mapResponseContext})
`;
      else
        fnLiteral += `return mapCompactResponse(${saveResponse}r${mapResponseContext})
`;
    } else if (hasCookie || hasTrace) {
      fnLiteral += isAsyncHandler ? `let r=await ${handle}
` : `let r=${handle}
`, handleReporter.resolve(), report("afterHandle").resolve();
      let mapResponseReporter = report("mapResponse", { total: hooks.mapResponse.length });
      if (hooks.mapResponse.length) {
        fnLiteral += `c.response= r
`;
        for (let i = 0;i < hooks.mapResponse.length; i++) {
          let mapResponse2 = hooks.mapResponse[i], endUnit = mapResponseReporter.resolveChild(mapResponse2.fn.name);
          fnLiteral += `if(mr===undefined){mr=${isAsyncName(mapResponse2) ? "await " : ""}onMapResponse[${i}](c)
if(mr!==undefined)r=c.response=mr}`, endUnit();
        }
      }
      if (mapResponseReporter.resolve(), fnLiteral += encodeCookie, hasSet)
        fnLiteral += `return mapResponse(${saveResponse}r,c.set${mapResponseContext})
`;
      else
        fnLiteral += `return mapCompactResponse(${saveResponse}r${mapResponseContext})
`;
    } else {
      handleReporter.resolve();
      let handled = isAsyncHandler ? `await ${handle}` : handle;
      if (report("afterHandle").resolve(), handler instanceof Response)
        fnLiteral += inference.set ? `if(isNotEmpty(c.set.headers)||c.set.status!==200||c.set.redirect||c.set.cookie)return mapResponse(${saveResponse}${handle}.clone(),c.set${mapResponseContext})
else return ${handle}.clone()
` : `return ${handle}.clone()
`;
      else if (hasSet)
        fnLiteral += `return mapResponse(${saveResponse}${handled},c.set${mapResponseContext})
`;
      else
        fnLiteral += `return mapCompactResponse(${saveResponse}${handled}${mapResponseContext})
`;
    }
  }
  if (fnLiteral += `
}catch(error){`, hasBody)
    fnLiteral += `if(isParsing)error=new ParseError()
`;
  if (!maybeAsync)
    fnLiteral += "return(async()=>{";
  if (fnLiteral += `const set=c.set
if(!set.status||set.status<300)set.status=error?.status||500
`, hasTrace)
    for (let i = 0;i < hooks.trace.length; i++)
      fnLiteral += `report${i}?.resolve(error);reportChild${i}?.(error)
`;
  let errorReporter = report("error", { total: hooks.error.length });
  if (hooks.error.length) {
    fnLiteral += `c.error=error
if(error instanceof TypeBoxError){c.code="VALIDATION"
c.set.status=422}else{c.code=error.code??error[ERROR_CODE]??"UNKNOWN"}let er
`;
    for (let i = 0;i < hooks.error.length; i++) {
      let endUnit = errorReporter.resolveChild(hooks.error[i].fn.name);
      if (isAsync(hooks.error[i]))
        fnLiteral += `er=await handleErrors[${i}](c)
`;
      else
        fnLiteral += `er=handleErrors[${i}](c)
if(er instanceof Promise)er=await er
`;
      endUnit();
      let mapResponseReporter = report("mapResponse", { total: hooks.mapResponse.length });
      if (hooks.mapResponse.length)
        for (let i2 = 0;i2 < hooks.mapResponse.length; i2++) {
          let mapResponse2 = hooks.mapResponse[i2], endUnit2 = mapResponseReporter.resolveChild(mapResponse2.fn.name);
          fnLiteral += `c.response=er
er=onMapResponse[${i2}](c)
if(er instanceof Promise)er=await er
`, endUnit2();
        }
      if (mapResponseReporter.resolve(), fnLiteral += `er=mapEarlyResponse(er,set${mapResponseContext})
`, fnLiteral += "if(er){", hasTrace) {
        for (let i2 = 0;i2 < hooks.trace.length; i2++)
          fnLiteral += `report${i2}.resolve()
`;
        errorReporter.resolve();
      }
      fnLiteral += "return er}";
    }
  }
  if (errorReporter.resolve(), fnLiteral += "return handleError(c,error,true)", !maybeAsync)
    fnLiteral += "})()";
  if (fnLiteral += "}", hasAfterResponse || hasTrace) {
    if (fnLiteral += "finally{ ", !maybeAsync)
      fnLiteral += ";(async()=>{";
    let reporter = report("afterResponse", { total: hooks.afterResponse.length });
    if (hasAfterResponse)
      for (let i = 0;i < hooks.afterResponse.length; i++) {
        let endUnit = reporter.resolveChild(hooks.afterResponse[i].fn.name);
        fnLiteral += `
await afterResponse[${i}](c)
`, endUnit();
      }
    if (reporter.resolve(), !maybeAsync)
      fnLiteral += "})()";
    fnLiteral += "}";
  }
  let init = "const {handler,handleError,hooks: {transform,resolve,beforeHandle,afterHandle,mapResponse: onMapResponse,parse,error: handleErrors,afterResponse,trace: _trace},validator,utils: {mapResponse,mapCompactResponse,mapEarlyResponse,parseQuery,parseQueryFromURL,isNotEmpty},error: {NotFoundError,ValidationError,InternalServerError,ParseError},schema,definitions,ERROR_CODE,parseCookie,signCookie,decodeURIComponent,ElysiaCustomStatusResponse,ELYSIA_TRACE,ELYSIA_REQUEST_ID,parser,getServer," + (adapter.inject ? Object.keys(adapter.inject).join(",") + "," : "") + `TypeBoxError}=hooks
const trace=_trace.map(x=>typeof x==='function'?x:x.fn)
return ${maybeAsync ? "async " : ""}function handle(c){`;
  if (hooks.beforeHandle.length)
    init += `let be
`;
  if (hooks.afterHandle.length)
    init += `let af
`;
  if (hooks.mapResponse.length)
    init += `let mr
`;
  if (allowMeta)
    init += `c.schema = schema
c.defs = definitions
`;
  init += fnLiteral + "}";
  try {
    if (asManifest)
      return Function("hooks", init);
    return Function("hooks", init)({ handler, hooks: lifeCycleToFn(hooks), validator, handleError: app.handleError, utils: { mapResponse: adapterHandler.mapResponse, mapCompactResponse: adapterHandler.mapCompactResponse, mapEarlyResponse: adapterHandler.mapEarlyResponse, parseQuery, parseQueryFromURL, isNotEmpty }, error: { NotFoundError, ValidationError, InternalServerError, ParseError: ParseError2 }, schema: app.router.history, definitions: app.definitions.type, ERROR_CODE, parseCookie, signCookie, decodeURIComponent: import_fast_decode_uri_component3.default, ElysiaCustomStatusResponse, ELYSIA_TRACE, ELYSIA_REQUEST_ID, getServer: () => app.getServer(), TypeBoxError, parser: app["~parser"], ...adapter.inject });
  } catch (error2) {
    let debugHooks = lifeCycleToFn(hooks);
    console.log("[Composer] failed to generate optimized handler"), console.log("---"), console.log({ handler: typeof handler === "function" ? handler.toString() : handler, instruction: init, hooks: { ...debugHooks, transform: debugHooks?.transform?.map?.((x) => x.toString()), resolve: debugHooks?.resolve?.map?.((x) => x.toString()), beforeHandle: debugHooks?.beforeHandle?.map?.((x) => x.toString()), afterHandle: debugHooks?.afterHandle?.map?.((x) => x.toString()), mapResponse: debugHooks?.mapResponse?.map?.((x) => x.toString()), parse: debugHooks?.parse?.map?.((x) => x.toString()), error: debugHooks?.error?.map?.((x) => x.toString()), afterResponse: debugHooks?.afterResponse?.map?.((x) => x.toString()), stop: debugHooks?.stop?.map?.((x) => x.toString()) }, validator, definitions: app.definitions.type, error: error2, fnLiteral }), console.log("---"), process.exit(1);
  }
};
var composeGeneralHandler = (app, { asManifest = false } = {}) => {
  let adapter = app["~adapter"].composeGeneralHandler, error404 = adapter.error404(!!app.event.request.length, !!app.event.error.length), fnLiteral = "", router = app.router, findDynamicRoute = "const route=router.find(r.method,p)";
  findDynamicRoute += router.http.root.ALL ? `??router.find("ALL",p)
` : `
`, findDynamicRoute += error404.code, findDynamicRoute += `
c.params=route.params
if(route.store.handler)return route.store.handler(c)
return (route.store.handler=route.store.compile())(c)
`;
  let switchMap = "";
  for (let [path, { code, all }] of Object.entries(router.static.http.map)) {
    if (switchMap += `case'${path}':`, app.config.strictPath !== true)
      switchMap += `case'${getLoosePath(path)}':`;
    switchMap += `switch(r.method){${code}
` + (all ?? "default: break map") + "}";
  }
  let maybeAsync = app.event.request.some(isAsync), adapterVariables = adapter.inject ? Object.keys(adapter.inject).join(",") + "," : "";
  if (fnLiteral += `
const {app,mapEarlyResponse,NotFoundError,randomId,handleError,error,redirect,ELYSIA_TRACE,ELYSIA_REQUEST_ID,` + adapterVariables + `getServer}=data
const store=app.singleton.store
const decorator=app.singleton.decorator
const staticRouter=app.router.static.http
const ht=app.router.history
const wsRouter=app.router.ws
const router=app.router.http
const trace=app.event.trace.map(x=>typeof x==='function'?x:x.fn)
const notFound=new NotFoundError()
const hoc=app.extender.higherOrderFunctions.map(x=>x.fn)
`, app.event.request.length)
    fnLiteral += `const onRequest=app.event.request.map(x=>x.fn)
`;
  if (fnLiteral += error404.declare, app.event.trace.length)
    fnLiteral += "const " + app.event.trace.map((_2, i) => `tr${i}=app.event.trace[${i}].fn`).join(",") + `
`;
  if (fnLiteral += `${maybeAsync ? "async " : ""}function map(${adapter.parameters}){`, app.event.request.length)
    fnLiteral += `let re
`;
  if (fnLiteral += adapter.createContext(app), app.event.trace.length)
    fnLiteral += "c[ELYSIA_TRACE]=[" + app.event.trace.map((_2, i) => `tr${i}(c)`).join(",") + `]
`;
  let reporter = createReport({ trace: app.event.trace, addFn(word) {
    fnLiteral += word;
  } })("request", { total: app.event.request.length });
  if (app.event.request.length) {
    fnLiteral += "try{";
    for (let i = 0;i < app.event.request.length; i++) {
      let hook = app.event.request[i], withReturn = hasReturn(hook), maybeAsync2 = isAsync(hook), endUnit = reporter.resolveChild(app.event.request[i].fn.name);
      if (withReturn)
        fnLiteral += `re=mapEarlyResponse(${maybeAsync2 ? "await " : ""}onRequest[${i}](c),c.set)
`, endUnit("re"), fnLiteral += `if(re!==undefined)return re
`;
      else
        fnLiteral += `${maybeAsync2 ? "await " : ""}onRequest[${i}](c)
`, endUnit();
    }
    fnLiteral += "}catch(error){return app.handleError(c,error,false)}";
  }
  if (reporter.resolve(), fnLiteral += adapter.websocket(app), fnLiteral += `
map:switch(p){
` + switchMap + "default:break}" + findDynamicRoute + `}
`, app.extender.higherOrderFunctions.length) {
    let handler = "map";
    for (let i = 0;i < app.extender.higherOrderFunctions.length; i++)
      handler = `hoc[${i}](${handler},${adapter.parameters})`;
    fnLiteral += `return function hocMap(${adapter.parameters}){return ${handler}(${adapter.parameters})}`;
  } else
    fnLiteral += "return map";
  let handleError = composeErrorHandler(app);
  return app.handleError = handleError, Function("data", fnLiteral)({ app, mapEarlyResponse: app["~adapter"].handler.mapEarlyResponse, NotFoundError, randomId, handleError, error, redirect, ELYSIA_TRACE, ELYSIA_REQUEST_ID, getServer: () => app.getServer(), ...adapter.inject });
};
var composeErrorHandler = (app) => {
  let hooks = app.event, fnLiteral = "", adapter = app["~adapter"].composeError, adapterVariables = adapter.inject ? Object.keys(adapter.inject).join(",") + "," : "";
  fnLiteral += "const {app:{event:{error:onErrorContainer,afterResponse:resContainer,mapResponse:_onMapResponse,trace:_trace}},mapResponse,ERROR_CODE,ElysiaCustomStatusResponse,ELYSIA_TRACE," + adapterVariables + `ELYSIA_REQUEST_ID}=inject
`, fnLiteral += `const trace=_trace.map(x=>typeof x==='function'?x:x.fn)
const onMapResponse=[]
for(let i=0;i<_onMapResponse.length;i++)onMapResponse.push(_onMapResponse[i].fn??_onMapResponse[i])
delete _onMapResponse
const onError=onErrorContainer.map(x=>x.fn)
const res=resContainer.map(x=>x.fn)
return ${app.event.error.find(isAsync) || app.event.mapResponse.find(isAsync) ? "async " : ""}function(context,error,skipGlobal){`;
  let hasTrace = app.event.trace.length > 0;
  if (fnLiteral += "", hasTrace)
    fnLiteral += `const id=context[ELYSIA_REQUEST_ID]
`;
  let report = createReport({ context: "context", trace: hooks.trace, addFn: (word) => {
    fnLiteral += word;
  } });
  if (fnLiteral += `const set=context.set
let _r
if(!context.code)context.code=error.code??error[ERROR_CODE]
if(!(context.error instanceof Error))context.error=error
if(error instanceof ElysiaCustomStatusResponse){set.status=error.status=error.code
error.message=error.response}`, adapter.declare)
    fnLiteral += adapter.declare;
  let saveResponse = hasTrace || hooks.afterResponse.length > 0 || hooks.afterResponse.length > 0 ? "context.response = " : "";
  for (let i = 0;i < app.event.error.length; i++) {
    let handler = app.event.error[i], response = `${isAsync(handler) ? "await " : ""}onError[${i}](context)
`;
    if (fnLiteral += "if(skipGlobal!==true){", hasReturn(handler)) {
      fnLiteral += `_r=${response}
if(_r!==undefined){if(_r instanceof Response)return mapResponse(_r,set${adapter.mapResponseContext})
if(_r instanceof ElysiaCustomStatusResponse){error.status=error.code
error.message = error.response}if(set.status===200||!set.status)set.status=error.status
`;
      let mapResponseReporter2 = report("mapResponse", { total: hooks.mapResponse.length, name: "context" });
      if (hooks.mapResponse.length)
        for (let i2 = 0;i2 < hooks.mapResponse.length; i2++) {
          let mapResponse2 = hooks.mapResponse[i2], endUnit = mapResponseReporter2.resolveChild(mapResponse2.fn.name);
          fnLiteral += `context.response=_r_r=${isAsyncName(mapResponse2) ? "await " : ""}onMapResponse[${i2}](context)
`, endUnit();
        }
      mapResponseReporter2.resolve(), fnLiteral += `return mapResponse(${saveResponse}_r,set${adapter.mapResponseContext})}`;
    } else
      fnLiteral += response;
    fnLiteral += "}";
  }
  fnLiteral += `if(error.constructor.name==="ValidationError"||error.constructor.name==="TransformDecodeError"){if(error.error)error=error.error
set.status=error.status??422
` + adapter.validationError + "}", fnLiteral += "if(error instanceof Error){" + adapter.unknownError + "}";
  let mapResponseReporter = report("mapResponse", { total: hooks.mapResponse.length, name: "context" });
  if (fnLiteral += `
if(!context.response)context.response=error.message??error
`, hooks.mapResponse.length) {
    fnLiteral += `let mr
`;
    for (let i = 0;i < hooks.mapResponse.length; i++) {
      let mapResponse2 = hooks.mapResponse[i], endUnit = mapResponseReporter.resolveChild(mapResponse2.fn.name);
      fnLiteral += `if(mr===undefined){mr=${isAsyncName(mapResponse2) ? "await " : ""}onMapResponse[${i}](context)
if(mr!==undefined)error=context.response=mr}`, endUnit();
    }
  }
  return mapResponseReporter.resolve(), fnLiteral += `
return mapResponse(${saveResponse}error,set${adapter.mapResponseContext})}`, Function("inject", fnLiteral)({ app, mapResponse: app["~adapter"].handler.mapResponse, ERROR_CODE, ElysiaCustomStatusResponse, ELYSIA_TRACE, ELYSIA_REQUEST_ID, ...adapter.inject });
};
var injectDefaultValues = (typeChecker, obj) => {
  for (let [key, keySchema] of Object.entries(typeChecker.schema.properties))
    obj[key] ??= keySchema.default;
};
var createDynamicHandler = (app) => {
  let { mapResponse: mapResponse2, mapEarlyResponse: mapEarlyResponse2 } = app["~adapter"].handler;
  return async (request) => {
    let url = request.url, s = url.indexOf("/", 11), qi = url.indexOf("?", s + 1), path = qi === -1 ? url.substring(s) : url.substring(s, qi), set2 = { cookie: {}, status: 200, headers: {} }, context = Object.assign({}, app.singleton.decorator, { set: set2, store: app.singleton.store, request, path, qi, redirect });
    try {
      for (let i = 0;i < app.event.request.length; i++) {
        let onRequest = app.event.request[i].fn, response2 = onRequest(context);
        if (response2 instanceof Promise)
          response2 = await response2;
        if (response2 = mapEarlyResponse2(response2, set2), response2)
          return context.response = response2;
      }
      let handler = app.router.dynamic.find(request.method, path) ?? app.router.dynamic.find("ALL", path);
      if (!handler)
        throw new NotFoundError;
      let { handle, hooks, validator, content } = handler.store, body;
      if (request.method !== "GET" && request.method !== "HEAD")
        if (content)
          switch (content) {
            case "application/json":
              body = await request.json();
              break;
            case "text/plain":
              body = await request.text();
              break;
            case "application/x-www-form-urlencoded":
              body = parseQuery(await request.text());
              break;
            case "application/octet-stream":
              body = await request.arrayBuffer();
              break;
            case "multipart/form-data":
              body = {};
              let form2 = await request.formData();
              for (let key of form2.keys()) {
                if (body[key])
                  continue;
                let value = form2.getAll(key);
                if (value.length === 1)
                  body[key] = value[0];
                else
                  body[key] = value;
              }
              break;
          }
        else {
          let contentType = request.headers.get("content-type");
          if (contentType) {
            let index = contentType.indexOf(";");
            if (index !== -1)
              contentType = contentType.slice(0, index);
            context.contentType = contentType;
            for (let i = 0;i < hooks.parse.length; i++) {
              let hook = hooks.parse[i].fn, temp = hook(context, contentType);
              if (temp instanceof Promise)
                temp = await temp;
              if (temp) {
                body = temp;
                break;
              }
            }
            if (delete context.contentType, body === undefined)
              switch (contentType) {
                case "application/json":
                  body = await request.json();
                  break;
                case "text/plain":
                  body = await request.text();
                  break;
                case "application/x-www-form-urlencoded":
                  body = parseQuery(await request.text());
                  break;
                case "application/octet-stream":
                  body = await request.arrayBuffer();
                  break;
                case "multipart/form-data":
                  body = {};
                  let form2 = await request.formData();
                  for (let key of form2.keys()) {
                    if (body[key])
                      continue;
                    let value = form2.getAll(key);
                    if (value.length === 1)
                      body[key] = value[0];
                    else
                      body[key] = value;
                  }
                  break;
              }
          }
        }
      context.body = body, context.params = handler?.params || undefined, context.query = qi === -1 ? {} : parseQuery(url.substring(qi + 1)), context.headers = {};
      for (let [key, value] of request.headers.entries())
        context.headers[key] = value;
      let cookieMeta = Object.assign({}, app.config?.cookie, validator?.cookie?.config), cookieHeaderValue = request.headers.get("cookie");
      context.cookie = await parseCookie(context.set, cookieHeaderValue, cookieMeta ? { secrets: cookieMeta.secrets !== undefined ? typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets.join(",") : undefined, sign: cookieMeta.sign === true ? true : cookieMeta.sign !== undefined ? typeof cookieMeta.sign === "string" ? cookieMeta.sign : cookieMeta.sign.join(",") : undefined } : undefined);
      let headerValidator = validator?.createHeaders?.();
      if (headerValidator)
        injectDefaultValues(headerValidator, context.headers);
      let paramsValidator = validator?.createParams?.();
      if (paramsValidator)
        injectDefaultValues(paramsValidator, context.params);
      let queryValidator = validator?.createQuery?.();
      if (queryValidator)
        injectDefaultValues(queryValidator, context.query);
      for (let i = 0;i < hooks.transform.length; i++) {
        let hook = hooks.transform[i], operation = hook.fn(context);
        if (hook.subType === "derive")
          if (operation instanceof Promise)
            Object.assign(context, await operation);
          else
            Object.assign(context, operation);
        else if (operation instanceof Promise)
          await operation;
      }
      if (validator) {
        if (headerValidator) {
          let _header = structuredClone(context.headers);
          for (let [key, value] of request.headers)
            _header[key] = value;
          if (validator.headers.Check(_header) === false)
            throw new ValidationError("header", validator.headers, _header);
        } else if (validator.headers?.Decode)
          context.headers = validator.headers.Decode(context.headers);
        if (paramsValidator?.Check(context.params) === false)
          throw new ValidationError("params", validator.params, context.params);
        else if (validator.params?.Decode)
          context.params = validator.params.Decode(context.params);
        if (queryValidator?.Check(context.query) === false)
          throw new ValidationError("query", validator.query, context.query);
        else if (validator.query?.Decode)
          context.query = validator.query.Decode(context.query);
        if (validator.createCookie?.()) {
          let cookieValue = {};
          for (let [key, value] of Object.entries(context.cookie))
            cookieValue[key] = value.value;
          if (validator.cookie.Check(cookieValue) === false)
            throw new ValidationError("cookie", validator.cookie, cookieValue);
          else if (validator.cookie?.Decode)
            cookieValue = validator.cookie.Decode(cookieValue);
        }
        if (validator.createBody?.()?.Check(body) === false)
          throw new ValidationError("body", validator.body, body);
        else if (validator.body?.Decode)
          context.body = validator.body.Decode(body);
      }
      for (let i = 0;i < hooks.beforeHandle.length; i++) {
        let hook = hooks.beforeHandle[i], response2 = hook.fn(context);
        if (hook.subType === "resolve") {
          if (response2 instanceof ElysiaCustomStatusResponse) {
            let result = mapEarlyResponse2(response2, context.set);
            if (result)
              return context.response = result;
          }
          if (response2 instanceof Promise)
            Object.assign(context, await response2);
          else
            Object.assign(context, response2);
          continue;
        } else if (response2 instanceof Promise)
          response2 = await response2;
        if (response2 !== undefined) {
          context.response = response2;
          for (let i2 = 0;i2 < hooks.afterHandle.length; i2++) {
            let newResponse = hooks.afterHandle[i2].fn(context);
            if (newResponse instanceof Promise)
              newResponse = await newResponse;
            if (newResponse)
              response2 = newResponse;
          }
          let result = mapEarlyResponse2(response2, context.set);
          if (result)
            return context.response = result;
        }
      }
      let response = typeof handle === "function" ? handle(context) : handle;
      if (response instanceof Promise)
        response = await response;
      if (!hooks.afterHandle.length) {
        let status = response instanceof ElysiaCustomStatusResponse ? response.code : set2.status ? typeof set2.status === "string" ? StatusMap[set2.status] : set2.status : 200, responseValidator = validator?.createResponse?.()?.[status];
        if (responseValidator?.Check(response) === false)
          throw new ValidationError("response", responseValidator, response);
        else if (responseValidator?.Decode)
          response = responseValidator.Decode(response);
      } else {
        context.response = response;
        for (let i = 0;i < hooks.afterHandle.length; i++) {
          let newResponse = hooks.afterHandle[i].fn(context);
          if (newResponse instanceof Promise)
            newResponse = await newResponse;
          let result = mapEarlyResponse2(newResponse, context.set);
          if (result !== undefined) {
            let responseValidator = validator?.response?.[result.status];
            if (responseValidator?.Check(result) === false)
              throw new ValidationError("response", responseValidator, result);
            else if (responseValidator?.Decode)
              response = responseValidator.Decode(response);
            return context.response = result;
          }
        }
      }
      if (context.set.cookie && cookieMeta?.sign) {
        let secret = !cookieMeta.secrets ? undefined : typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets[0];
        if (cookieMeta.sign === true)
          for (let [key, cookie] of Object.entries(context.set.cookie))
            context.set.cookie[key].value = await signCookie(cookie.value, "${secret}");
        else {
          let properties = validator?.cookie?.schema?.properties;
          for (let name of cookieMeta.sign) {
            if (!(name in properties))
              continue;
            if (context.set.cookie[name]?.value)
              context.set.cookie[name].value = await signCookie(context.set.cookie[name].value, secret);
          }
        }
      }
      return mapResponse2(context.response = response, context.set);
    } catch (error2) {
      let reportedError = error2 instanceof TransformDecodeError && error2.error ? error2.error : error2;
      return app.handleError(context, reportedError);
    } finally {
      for (let afterResponse of app.event.afterResponse)
        await afterResponse.fn(context);
    }
  };
};
var createDynamicErrorHandler = (app) => {
  let { mapResponse: mapResponse2 } = app["~adapter"].handler;
  return async (context, error2) => {
    let errorContext = Object.assign(context, { error: error2, code: error2.code });
    errorContext.set = context.set;
    for (let i = 0;i < app.event.error.length; i++) {
      let response = app.event.error[i].fn(errorContext);
      if (response instanceof Promise)
        response = await response;
      if (response !== undefined && response !== null)
        return context.response = mapResponse2(response, context.set);
    }
    return new Response(typeof error2.cause === "string" ? error2.cause : error2.message, { headers: context.set.headers, status: error2.status ?? 500 });
  };
};
class Elysia {
  config;
  server = null;
  dependencies = {};
  _routes = {};
  _types = { Prefix: "", Singleton: {}, Definitions: {}, Metadata: {} };
  _ephemeral = {};
  _volatile = {};
  singleton = { decorator: {}, store: {}, derive: {}, resolve: {} };
  get store() {
    return this.singleton.store;
  }
  get decorator() {
    return this.singleton.decorator;
  }
  definitions = { typebox: t.Module({}), type: {}, error: {} };
  extender = { macros: [], higherOrderFunctions: [] };
  validator = { global: null, scoped: null, local: null, getCandidate() {
    return mergeSchemaValidator(mergeSchemaValidator(this.global, this.scoped), this.local);
  } };
  event = { start: [], request: [], parse: [], transform: [], beforeHandle: [], afterHandle: [], mapResponse: [], afterResponse: [], trace: [], error: [], stop: [] };
  telemetry = { stack: undefined };
  router = { http: new Y, ws: new Y, dynamic: new Y, static: { http: { static: {}, map: {}, all: "" }, ws: {} }, history: [] };
  routeTree = new Map;
  get routes() {
    return this.router.history;
  }
  getGlobalRoutes() {
    return this.router.history;
  }
  inference = { body: false, cookie: false, headers: false, query: false, set: false, server: false, request: false, route: false };
  getServer() {
    return this.server;
  }
  "~parser" = {};
  _promisedModules;
  get promisedModules() {
    if (!this._promisedModules)
      this._promisedModules = new PromiseGroup;
    return this._promisedModules;
  }
  constructor(config2 = {}) {
    if (config2.tags)
      if (!config2.detail)
        config2.detail = { tags: config2.tags };
      else
        config2.detail.tags = config2.tags;
    if (config2.nativeStaticResponse === undefined)
      config2.nativeStaticResponse = true;
    if (this.config = {}, this.applyConfig(config2 ?? {}), this["~adapter"] = config2.adapter ?? (typeof Bun !== "undefined" ? BunAdapter : WebStandardAdapter), config2?.analytic && (config2?.name || config2?.seed !== undefined))
      this.telemetry.stack = new Error().stack;
  }
  "~adapter";
  env(model, _env = env2) {
    if (getSchemaValidator(model, { modules: this.definitions.typebox, dynamic: true, additionalProperties: true, coerce: true }).Check(_env) === false) {
      let error2 = new ValidationError("env", model, _env);
      throw new Error(error2.all.map((x) => x.summary).join(`
`));
    }
    return this;
  }
  wrap(fn) {
    return this.extender.higherOrderFunctions.push({ checksum: checksum(JSON.stringify({ name: this.config.name, seed: this.config.seed, content: fn.toString() })), fn }), this;
  }
  applyMacro(localHook) {
    if (this.extender.macros.length) {
      let manage = createMacroManager({ globalHook: this.event, localHook }), manager = { events: { global: this.event, local: localHook }, get onParse() {
        return manage("parse");
      }, get onTransform() {
        return manage("transform");
      }, get onBeforeHandle() {
        return manage("beforeHandle");
      }, get onAfterHandle() {
        return manage("afterHandle");
      }, get mapResponse() {
        return manage("mapResponse");
      }, get onAfterResponse() {
        return manage("afterResponse");
      }, get onError() {
        return manage("error");
      } };
      for (let macro of this.extender.macros)
        traceBackMacro(macro.fn(manager), localHook, manage);
    }
  }
  applyConfig(config2) {
    return this.config = { prefix: "", aot: env2.ELYSIA_AOT !== "false", normalize: true, ...config2, cookie: { path: "/", ...config2?.cookie }, experimental: config2?.experimental ?? {}, seed: config2?.seed === undefined ? "" : config2?.seed }, this;
  }
  get models() {
    let models = {};
    for (let name of Object.keys(this.definitions.type))
      models[name] = getSchemaValidator(this.definitions.typebox.Import(name));
    return models.modules = this.definitions.typebox, models;
  }
  add(method, path, handle, localHook, { allowMeta = false, skipPrefix = false } = { allowMeta: false, skipPrefix: false }) {
    if (localHook = localHookToLifeCycleStore(localHook), path !== "" && path.charCodeAt(0) !== 47)
      path = "/" + path;
    if (this.config.prefix && !skipPrefix)
      path = this.config.prefix + path;
    if (localHook?.type)
      switch (localHook.type) {
        case "text":
          localHook.type = "text/plain";
          break;
        case "json":
          localHook.type = "application/json";
          break;
        case "formdata":
          localHook.type = "multipart/form-data";
          break;
        case "urlencoded":
          localHook.type = "application/x-www-form-urlencoded";
          break;
        case "arrayBuffer":
          localHook.type = "application/octet-stream";
          break;
        default:
          break;
      }
    let models = this.definitions.type, dynamic = !this.config.aot, instanceValidator = { ...this.validator.getCandidate() }, cloned = { body: localHook?.body ?? instanceValidator?.body, headers: localHook?.headers ?? instanceValidator?.headers, params: localHook?.params ?? instanceValidator?.params, query: localHook?.query ?? instanceValidator?.query, cookie: localHook?.cookie ?? instanceValidator?.cookie, response: localHook?.response ?? instanceValidator?.response }, cookieValidator = () => cloned.cookie ? getCookieValidator({ modules, validator: cloned.cookie, defaultConfig: this.config.cookie, config: cloned.cookie?.config ?? {}, dynamic, models }) : undefined, normalize = this.config.normalize, modules = this.definitions.typebox, validator = this.config.precompile === true || typeof this.config.precompile === "object" && this.config.precompile.schema === true ? { body: getSchemaValidator(cloned.body, { modules, dynamic, models, normalize, additionalCoerce: coercePrimitiveRoot() }), headers: getSchemaValidator(cloned.headers, { modules, dynamic, models, additionalProperties: !this.config.normalize, coerce: true, additionalCoerce: stringToStructureCoercions() }), params: getSchemaValidator(cloned.params, { modules, dynamic, models, coerce: true, additionalCoerce: stringToStructureCoercions() }), query: getSchemaValidator(cloned.query, { modules, dynamic, models, normalize, coerce: true, additionalCoerce: stringToStructureCoercions() }), cookie: cookieValidator(), response: getResponseSchemaValidator(cloned.response, { modules, dynamic, models, normalize }) } : { createBody() {
      if (this.body)
        return this.body;
      return this.body = getSchemaValidator(cloned.body, { modules, dynamic, models, normalize, additionalCoerce: coercePrimitiveRoot() });
    }, createHeaders() {
      if (this.headers)
        return this.headers;
      return this.headers = getSchemaValidator(cloned.headers, { modules, dynamic, models, additionalProperties: !normalize, coerce: true, additionalCoerce: stringToStructureCoercions() });
    }, createParams() {
      if (this.params)
        return this.params;
      return this.params = getSchemaValidator(cloned.params, { modules, dynamic, models, coerce: true, additionalCoerce: stringToStructureCoercions() });
    }, createQuery() {
      if (this.query)
        return this.query;
      return this.query = getSchemaValidator(cloned.query, { modules, dynamic, models, coerce: true, additionalCoerce: stringToStructureCoercions() });
    }, createCookie() {
      if (this.cookie)
        return this.cookie;
      return this.cookie = cookieValidator();
    }, createResponse() {
      if (this.response)
        return this.response;
      return this.response = getResponseSchemaValidator(cloned.response, { modules, dynamic, models, normalize });
    } };
    if (localHook = mergeHook(localHook, instanceValidator), localHook.tags)
      if (!localHook.detail)
        localHook.detail = { tags: localHook.tags };
      else
        localHook.detail.tags = localHook.tags;
    if (isNotEmpty(this.config.detail))
      localHook.detail = mergeDeep(Object.assign({}, this.config.detail), localHook.detail);
    this.applyMacro(localHook);
    let hooks = mergeHook(this.event, localHook);
    if (this.config.aot === false) {
      if (this.router.dynamic.add(method, path, { validator, hooks, content: localHook?.type, handle }), this.config.strictPath === false)
        this.router.dynamic.add(method, getLoosePath(path), { validator, hooks, content: localHook?.type, handle });
      this.router.history.push({ method, path, composed: null, handler: handle, hooks, compile: handle });
      return;
    }
    let shouldPrecompile = this.config.precompile === true || typeof this.config.precompile === "object" && this.config.precompile.compose === true, inference = cloneInference(this.inference), adapter = this["~adapter"].handler, staticHandler = typeof handle !== "function" && typeof adapter.createStaticHandler === "function" ? adapter.createStaticHandler(handle, hooks, this.setHeaders) : undefined, nativeStaticHandler = typeof handle !== "function" ? adapter.createNativeStaticHandler?.(handle, hooks, this.setHeaders) : undefined;
    if (this.config.nativeStaticResponse === true && nativeStaticHandler && (method === "GET" || method === "ALL"))
      this.router.static.http.static[path] = nativeStaticHandler();
    let compile = (asManifest = false) => composeHandler({ app: this, path, method, localHook: mergeHook(localHook), hooks, validator, handler: typeof handle !== "function" && typeof adapter.createStaticHandler !== "function" ? () => handle : handle, allowMeta, inference, asManifest });
    if (this.routeTree.has(method + path))
      for (let i = 0;i < this.router.history.length; i++) {
        let route = this.router.history[i];
        if (route.path === path && route.method === method) {
          let removed = this.router.history.splice(i, 1)[0];
          if (removed && this.routeTree.has(removed?.method + removed?.path))
            this.routeTree.delete(removed.method + removed.path);
        }
      }
    else
      this.routeTree.set(method + path, this.router.history.length);
    let history = this.router.history, index = this.router.history.length, mainHandler = shouldPrecompile ? compile() : (ctx) => (history[index].composed = compile())(ctx), isWebSocket = method === "$INTERNALWS";
    this.router.history.push({ method, path, composed: mainHandler, handler: handle, hooks, compile: () => compile(), websocket: localHook.websocket });
    let staticRouter = this.router.static.http, handler = { handler: shouldPrecompile ? mainHandler : undefined, compile };
    if (isWebSocket) {
      let loose = getLoosePath(path);
      if (path.indexOf(":") === -1 && path.indexOf("*") === -1)
        this.router.static.ws[path] = index;
      else if (this.router.ws.add("ws", path, handler), loose)
        this.router.ws.add("ws", loose, handler);
      return;
    }
    if (path.indexOf(":") === -1 && path.indexOf("*") === -1) {
      if (!staticRouter.map[path])
        staticRouter.map[path] = { code: "" };
      let ctx = staticHandler ? "" : "c";
      if (method === "ALL")
        staticRouter.map[path].all = `default:return ht[${index}].composed(${ctx})
`;
      else
        staticRouter.map[path].code = `case '${method}':return ht[${index}].composed(${ctx})
${staticRouter.map[path].code}`;
      if (!this.config.strictPath && this.config.nativeStaticResponse === true && nativeStaticHandler && (method === "GET" || method === "ALL"))
        this.router.static.http.static[getLoosePath(path)] = nativeStaticHandler();
    } else if (this.router.http.add(method, path, handler), !this.config.strictPath) {
      let loosePath = getLoosePath(path);
      if (this.config.nativeStaticResponse === true && staticHandler && (method === "GET" || method === "ALL"))
        this.router.static.http.static[loosePath] = staticHandler();
      this.router.http.add(method, loosePath, handler);
    }
  }
  setHeaders;
  headers(header) {
    if (!header)
      return this;
    if (!this.setHeaders)
      this.setHeaders = {};
    return this.setHeaders = mergeDeep(this.setHeaders, header), this;
  }
  onStart(handler) {
    return this.on("start", handler), this;
  }
  onRequest(handler) {
    return this.on("request", handler), this;
  }
  onParse(options, handler) {
    if (!handler) {
      if (typeof options === "string")
        return this.on("parse", this["~parser"][options]);
      return this.on("parse", options);
    }
    return this.on(options, "parse", handler);
  }
  parser(name, parser) {
    return this["~parser"][name] = parser, this;
  }
  onTransform(options, handler) {
    if (!handler)
      return this.on("transform", options);
    return this.on(options, "transform", handler);
  }
  resolve(optionsOrResolve, resolve) {
    if (!resolve)
      resolve = optionsOrResolve, optionsOrResolve = { as: "local" };
    let hook = { subType: "resolve", fn: resolve };
    return this.onBeforeHandle(optionsOrResolve, hook);
  }
  mapResolve(optionsOrResolve, mapper) {
    if (!mapper)
      mapper = optionsOrResolve, optionsOrResolve = { as: "local" };
    let hook = { subType: "mapResolve", fn: mapper };
    return this.onBeforeHandle(optionsOrResolve, hook);
  }
  onBeforeHandle(options, handler) {
    if (!handler)
      return this.on("beforeHandle", options);
    return this.on(options, "beforeHandle", handler);
  }
  onAfterHandle(options, handler) {
    if (!handler)
      return this.on("afterHandle", options);
    return this.on(options, "afterHandle", handler);
  }
  mapResponse(options, handler) {
    if (!handler)
      return this.on("mapResponse", options);
    return this.on(options, "mapResponse", handler);
  }
  onAfterResponse(options, handler) {
    if (!handler)
      return this.on("afterResponse", options);
    return this.on(options, "afterResponse", handler);
  }
  trace(options, handler) {
    if (!handler)
      handler = options, options = { as: "local" };
    if (!Array.isArray(handler))
      handler = [handler];
    for (let fn of handler)
      this.on(options, "trace", createTracer(fn));
    return this;
  }
  error(name, error2) {
    switch (typeof name) {
      case "string":
        return error2.prototype[ERROR_CODE] = name, this.definitions.error[name] = error2, this;
      case "function":
        return this.definitions.error = name(this.definitions.error), this;
    }
    for (let [code, error3] of Object.entries(name))
      error3.prototype[ERROR_CODE] = code, this.definitions.error[code] = error3;
    return this;
  }
  onError(options, handler) {
    if (!handler)
      return this.on("error", options);
    return this.on(options, "error", handler);
  }
  onStop(handler) {
    return this.on("stop", handler), this;
  }
  on(optionsOrType, typeOrHandlers, handlers) {
    let type;
    switch (typeof optionsOrType) {
      case "string":
        type = optionsOrType, handlers = typeOrHandlers;
        break;
      case "object":
        if (type = typeOrHandlers, !Array.isArray(typeOrHandlers) && typeof typeOrHandlers === "object")
          handlers = typeOrHandlers;
        break;
    }
    if (Array.isArray(handlers))
      handlers = fnToContainer(handlers);
    else if (typeof handlers === "function")
      handlers = [{ fn: handlers }];
    else
      handlers = [handlers];
    let handles = handlers;
    for (let handle of handles)
      if (handle.scope = typeof optionsOrType === "string" ? "local" : optionsOrType?.as ?? "local", type === "resolve" || type === "derive")
        handle.subType = type;
    if (type !== "trace")
      sucrose({ [type]: handles.map((x) => x.fn) }, this.inference);
    for (let handle of handles) {
      let fn = asHookType(handle, "global", { skipIfHasType: true });
      switch (type) {
        case "start":
          this.event.start.push(fn);
          break;
        case "request":
          this.event.request.push(fn);
          break;
        case "parse":
          this.event.parse.push(fn);
          break;
        case "transform":
          this.event.transform.push(fn);
          break;
        case "derive":
          this.event.transform.push(fnToContainer(fn, "derive"));
          break;
        case "beforeHandle":
          this.event.beforeHandle.push(fn);
          break;
        case "resolve":
          this.event.beforeHandle.push(fnToContainer(fn, "resolve"));
          break;
        case "afterHandle":
          this.event.afterHandle.push(fn);
          break;
        case "mapResponse":
          this.event.mapResponse.push(fn);
          break;
        case "afterResponse":
          this.event.afterResponse.push(fn);
          break;
        case "trace":
          this.event.trace.push(fn);
          break;
        case "error":
          this.event.error.push(fn);
          break;
        case "stop":
          this.event.stop.push(fn);
          break;
      }
    }
    return this;
  }
  propagate() {
    return promoteEvent(this.event.parse), promoteEvent(this.event.transform), promoteEvent(this.event.beforeHandle), promoteEvent(this.event.afterHandle), promoteEvent(this.event.mapResponse), promoteEvent(this.event.afterResponse), promoteEvent(this.event.trace), promoteEvent(this.event.error), this;
  }
  as(type) {
    let castType = { plugin: "scoped", scoped: "scoped", global: "global" }[type];
    if (promoteEvent(this.event.parse, castType), promoteEvent(this.event.transform, castType), promoteEvent(this.event.beforeHandle, castType), promoteEvent(this.event.afterHandle, castType), promoteEvent(this.event.mapResponse, castType), promoteEvent(this.event.afterResponse, castType), promoteEvent(this.event.trace, castType), promoteEvent(this.event.error, castType), type === "plugin")
      this.validator.scoped = mergeSchemaValidator(this.validator.scoped, this.validator.local), this.validator.local = null;
    else if (type === "global")
      this.validator.global = mergeSchemaValidator(this.validator.global, mergeSchemaValidator(this.validator.scoped, this.validator.local)), this.validator.scoped = null, this.validator.local = null;
    return this;
  }
  group(prefix, schemaOrRun, run) {
    let instance = new Elysia({ ...this.config, prefix: "" });
    instance.singleton = { ...this.singleton }, instance.definitions = { ...this.definitions }, instance.getServer = () => this.getServer(), instance.inference = cloneInference(this.inference), instance.extender = { ...this.extender };
    let isSchema = typeof schemaOrRun === "object", sandbox = (isSchema ? run : schemaOrRun)(instance);
    if (this.singleton = mergeDeep(this.singleton, instance.singleton), this.definitions = mergeDeep(this.definitions, instance.definitions), sandbox.event.request.length)
      this.event.request = [...this.event.request || [], ...sandbox.event.request || []];
    if (sandbox.event.mapResponse.length)
      this.event.mapResponse = [...this.event.mapResponse || [], ...sandbox.event.mapResponse || []];
    return this.model(sandbox.definitions.type), Object.values(instance.router.history).forEach(({ method, path, handler, hooks }) => {
      if (path = (isSchema ? "" : this.config.prefix) + prefix + path, isSchema) {
        let hook = schemaOrRun, localHook = hooks;
        this.add(method, path, handler, mergeHook(hook, { ...localHook || {}, error: !localHook.error ? sandbox.event.error : Array.isArray(localHook.error) ? [...localHook.error || {}, ...sandbox.event.error || {}] : [localHook.error, ...sandbox.event.error || {}] }));
      } else
        this.add(method, path, handler, mergeHook(hooks, { error: sandbox.event.error }), { skipPrefix: true });
    }), this;
  }
  guard(hook, run) {
    if (!run) {
      if (typeof hook === "object") {
        this.applyMacro(hook);
        let type = hook.as ?? "local";
        if (this.validator[type] = { body: hook.body ?? this.validator[type]?.body, headers: hook.headers ?? this.validator[type]?.headers, params: hook.params ?? this.validator[type]?.params, query: hook.query ?? this.validator[type]?.query, response: hook.response ?? this.validator[type]?.response, cookie: hook.cookie ?? this.validator[type]?.cookie }, hook.parse)
          this.on({ as: type }, "parse", hook.parse);
        if (hook.transform)
          this.on({ as: type }, "transform", hook.transform);
        if (hook.derive)
          this.on({ as: type }, "derive", hook.derive);
        if (hook.beforeHandle)
          this.on({ as: type }, "beforeHandle", hook.beforeHandle);
        if (hook.resolve)
          this.on({ as: type }, "resolve", hook.resolve);
        if (hook.afterHandle)
          this.on({ as: type }, "afterHandle", hook.afterHandle);
        if (hook.mapResponse)
          this.on({ as: type }, "mapResponse", hook.mapResponse);
        if (hook.afterResponse)
          this.on({ as: type }, "afterResponse", hook.afterResponse);
        if (hook.error)
          this.on({ as: type }, "error", hook.error);
        if (hook.detail)
          if (this.config.detail)
            this.config.detail = mergeDeep(Object.assign({}, this.config.detail), hook.detail);
          else
            this.config.detail = hook.detail;
        if (hook?.tags)
          if (!this.config.detail)
            this.config.detail = { tags: hook.tags };
          else
            this.config.detail.tags = hook.tags;
        return this;
      }
      return this.guard({}, hook);
    }
    let instance = new Elysia({ ...this.config, prefix: "" });
    instance.singleton = { ...this.singleton }, instance.definitions = { ...this.definitions }, instance.inference = cloneInference(this.inference), instance.extender = { ...this.extender };
    let sandbox = run(instance);
    if (this.singleton = mergeDeep(this.singleton, instance.singleton), this.definitions = mergeDeep(this.definitions, instance.definitions), sandbox.getServer = () => this.server, sandbox.event.request.length)
      this.event.request = [...this.event.request || [], ...sandbox.event.request || []];
    if (sandbox.event.mapResponse.length)
      this.event.mapResponse = [...this.event.mapResponse || [], ...sandbox.event.mapResponse || []];
    return this.model(sandbox.definitions.type), Object.values(instance.router.history).forEach(({ method, path, handler, hooks: localHook }) => {
      this.add(method, path, handler, mergeHook(hook, { ...localHook || {}, error: !localHook.error ? sandbox.event.error : Array.isArray(localHook.error) ? [...localHook.error || {}, ...sandbox.event.error || []] : [localHook.error, ...sandbox.event.error || []] }));
    }), this;
  }
  use(plugin, options) {
    if (Array.isArray(plugin)) {
      let app = this;
      for (let p of plugin)
        app = app.use(p);
      return app;
    }
    if (options?.scoped)
      return this.guard({}, (app) => app.use(plugin));
    if (Array.isArray(plugin)) {
      let current = this;
      for (let p of plugin)
        current = this.use(p);
      return current;
    }
    if (plugin instanceof Promise)
      return this.promisedModules.add(plugin.then((plugin2) => {
        if (typeof plugin2 === "function")
          return plugin2(this);
        if (plugin2 instanceof Elysia)
          return this._use(plugin2).compile();
        if (plugin2.constructor.name === "Elysia")
          return this._use(plugin2).compile();
        if (typeof plugin2.default === "function")
          return plugin2.default(this);
        if (plugin2.default instanceof Elysia)
          return this._use(plugin2.default);
        if (plugin2.constructor.name === "Elysia")
          return this._use(plugin2.default);
        throw new Error('Invalid plugin type. Expected Elysia instance, function, or module with "default" as Elysia instance or function that returns Elysia instance.');
      }).then((x) => x.compile())), this;
    return this._use(plugin);
  }
  _use(plugin) {
    if (typeof plugin === "function") {
      let instance = plugin(this);
      if (instance instanceof Promise)
        return this.promisedModules.add(instance.then((plugin2) => {
          if (plugin2 instanceof Elysia) {
            plugin2.getServer = () => this.getServer(), plugin2.getGlobalRoutes = () => this.getGlobalRoutes(), plugin2.model(this.definitions.type), plugin2.error(this.definitions.error);
            for (let { method, path, handler, hooks } of Object.values(plugin2.router.history))
              this.add(method, path, handler, mergeHook(hooks, { error: plugin2.event.error }));
            return plugin2.compile(), plugin2;
          }
          if (typeof plugin2 === "function")
            return plugin2(this);
          if (typeof plugin2.default === "function")
            return plugin2.default(this);
          return this._use(plugin2);
        }).then((x) => x.compile())), this;
      return instance;
    }
    let { name, seed } = plugin.config;
    if (plugin.getServer = () => this.getServer(), plugin.getGlobalRoutes = () => this.getGlobalRoutes(), plugin.model(this.definitions.type), plugin.error(this.definitions.error), this["~parser"] = { ...plugin["~parser"], ...this["~parser"] }, this.headers(plugin.setHeaders), name) {
      if (!(name in this.dependencies))
        this.dependencies[name] = [];
      let current = seed !== undefined ? checksum(name + JSON.stringify(seed)) : 0;
      if (!this.dependencies[name].some(({ checksum: checksum2 }) => current === checksum2))
        this.extender.macros = this.extender.macros.concat(plugin.extender.macros), this.extender.higherOrderFunctions = this.extender.higherOrderFunctions.concat(plugin.extender.higherOrderFunctions);
    } else
      this.extender.macros = this.extender.macros.concat(plugin.extender.macros), this.extender.higherOrderFunctions = this.extender.higherOrderFunctions.concat(plugin.extender.higherOrderFunctions);
    deduplicateChecksum(this.extender.macros), deduplicateChecksum(this.extender.higherOrderFunctions);
    let hofHashes = [];
    for (let i = 0;i < this.extender.higherOrderFunctions.length; i++) {
      let hof = this.extender.higherOrderFunctions[i];
      if (hof.checksum) {
        if (hofHashes.includes(hof.checksum))
          this.extender.higherOrderFunctions.splice(i, 1), i--;
        hofHashes.push(hof.checksum);
      }
    }
    this.inference = { body: this.inference.body || plugin.inference.body, cookie: this.inference.cookie || plugin.inference.cookie, headers: this.inference.headers || plugin.inference.headers, query: this.inference.query || plugin.inference.query, set: this.inference.set || plugin.inference.set, server: this.inference.server || plugin.inference.server, request: this.inference.request || plugin.inference.request, route: this.inference.route || plugin.inference.route }, this.decorate(plugin.singleton.decorator), this.state(plugin.singleton.store), this.model(plugin.definitions.type), this.error(plugin.definitions.error), plugin.extender.macros = this.extender.macros.concat(plugin.extender.macros);
    for (let { method, path, handler, hooks } of Object.values(plugin.router.history))
      this.add(method, path, handler, mergeHook(hooks, { error: plugin.event.error }));
    if (name) {
      if (!(name in this.dependencies))
        this.dependencies[name] = [];
      let current = seed !== undefined ? checksum(name + JSON.stringify(seed)) : 0;
      if (this.dependencies[name].some(({ checksum: checksum2 }) => current === checksum2))
        return this;
      this.dependencies[name].push(this.config?.analytic ? { name: plugin.config.name, seed: plugin.config.seed, checksum: current, dependencies: plugin.dependencies, stack: plugin.telemetry.stack, routes: plugin.router.history, decorators: plugin.singleton, store: plugin.singleton.store, error: plugin.definitions.error, derive: plugin.event.transform.filter((x) => x?.subType === "derive").map((x) => ({ fn: x.toString(), stack: new Error().stack ?? "" })), resolve: plugin.event.transform.filter((x) => x?.subType === "resolve").map((x) => ({ fn: x.toString(), stack: new Error().stack ?? "" })) } : { name: plugin.config.name, seed: plugin.config.seed, checksum: current, dependencies: plugin.dependencies }), this.event = mergeLifeCycle(this.event, filterGlobalHook(plugin.event), current);
    } else
      this.event = mergeLifeCycle(this.event, filterGlobalHook(plugin.event));
    return this.validator.global = mergeHook(this.validator.global, { ...plugin.validator.global }), this.validator.local = mergeHook(this.validator.local, { ...plugin.validator.scoped }), this;
  }
  macro(macro) {
    if (typeof macro === "function") {
      let hook = { checksum: checksum(JSON.stringify({ name: this.config.name, seed: this.config.seed, content: macro.toString() })), fn: macro };
      this.extender.macros.push(hook);
    } else if (typeof macro === "object") {
      let hook = { checksum: checksum(JSON.stringify({ name: this.config.name, seed: this.config.seed, content: Object.entries(macro).map(([k, v]) => `${k}+${v}`).join(",") })), fn: () => macro };
      this.extender.macros.push(hook);
    }
    return this;
  }
  mount(path, handle) {
    if (path instanceof Elysia || typeof path === "function" || path.length === 0 || path === "/") {
      let run = typeof path === "function" ? path : path instanceof Elysia ? path.compile().fetch : handle instanceof Elysia ? handle.compile().fetch : handle, handler2 = async ({ request, path: path2 }) => {
        if (request.method === "GET" || request.method === "HEAD" || !request.headers.get("content-type"))
          return run(new Request(replaceUrlPath(request.url, path2 || "/"), request));
        return run(new Request(replaceUrlPath(request.url, path2 || "/"), { ...request, body: await request.arrayBuffer() }));
      };
      return this.all("/*", handler2, { type: "none" }), this;
    }
    let length = path.length;
    if (handle instanceof Elysia)
      handle = handle.compile().fetch;
    let handler = async ({ request, path: path2 }) => {
      if (request.method === "GET" || request.method === "HEAD" || !request.headers.get("content-type"))
        return handle(new Request(replaceUrlPath(request.url, path2.slice(length) || "/"), request));
      return handle(new Request(replaceUrlPath(request.url, path2.slice(length) || "/"), { ...request, body: await request.arrayBuffer() }));
    };
    return this.all(path, handler, { type: "none" }), this.all(path + (path.endsWith("/") ? "*" : "/*"), handler, { type: "none" }), this;
  }
  get(path, handler, hook) {
    return this.add("GET", path, handler, hook), this;
  }
  post(path, handler, hook) {
    return this.add("POST", path, handler, hook), this;
  }
  put(path, handler, hook) {
    return this.add("PUT", path, handler, hook), this;
  }
  patch(path, handler, hook) {
    return this.add("PATCH", path, handler, hook), this;
  }
  delete(path, handler, hook) {
    return this.add("DELETE", path, handler, hook), this;
  }
  options(path, handler, hook) {
    return this.add("OPTIONS", path, handler, hook), this;
  }
  all(path, handler, hook) {
    return this.add("ALL", path, handler, hook), this;
  }
  head(path, handler, hook) {
    return this.add("HEAD", path, handler, hook), this;
  }
  connect(path, handler, hook) {
    return this.add("CONNECT", path, handler, hook), this;
  }
  route(method, path, handler, hook) {
    return this.add(method.toUpperCase(), path, handler, hook, hook?.config), this;
  }
  ws(path, options) {
    if (this["~adapter"].ws)
      this["~adapter"].ws(this, path, options);
    else
      console.warn("Current adapter doesn't support WebSocket");
    return this;
  }
  state(options, name, value) {
    if (name === undefined)
      value = options, options = { as: "append" }, name = "";
    else if (value === undefined) {
      if (typeof options === "string")
        value = name, name = options, options = { as: "append" };
      else if (typeof options === "object")
        value = name, name = "";
    }
    let { as } = options;
    if (typeof name !== "string")
      return this;
    switch (typeof value) {
      case "object":
        if (name) {
          if (name in this.singleton.store)
            this.singleton.store[name] = mergeDeep(this.singleton.store[name], value, { override: as === "override" });
          else
            this.singleton.store[name] = value;
          return this;
        }
        if (value === null)
          return this;
        return this.singleton.store = mergeDeep(this.singleton.store, value, { override: as === "override" }), this;
      case "function":
        if (name) {
          if (as === "override" || !(name in this.singleton.store))
            this.singleton.store[name] = value;
        } else
          this.singleton.store = value(this.singleton.store);
        return this;
      default:
        if (as === "override" || !(name in this.singleton.store))
          this.singleton.store[name] = value;
        return this;
    }
  }
  decorate(options, name, value) {
    if (name === undefined)
      value = options, options = { as: "append" }, name = "";
    else if (value === undefined) {
      if (typeof options === "string")
        value = name, name = options, options = { as: "append" };
      else if (typeof options === "object")
        value = name, name = "";
    }
    let { as } = options;
    if (typeof name !== "string")
      return this;
    switch (typeof value) {
      case "object":
        if (name) {
          if (name in this.singleton.decorator)
            this.singleton.decorator[name] = mergeDeep(this.singleton.decorator[name], value, { override: as === "override" });
          else
            this.singleton.decorator[name] = value;
          return this;
        }
        if (value === null)
          return this;
        return this.singleton.decorator = mergeDeep(this.singleton.decorator, value, { override: as === "override" }), this;
      case "function":
        if (name) {
          if (as === "override" || !(name in this.singleton.decorator))
            this.singleton.decorator[name] = value;
        } else
          this.singleton.decorator = value(this.singleton.decorator);
        return this;
      default:
        if (as === "override" || !(name in this.singleton.decorator))
          this.singleton.decorator[name] = value;
        return this;
    }
  }
  derive(optionsOrTransform, transform2) {
    if (!transform2)
      transform2 = optionsOrTransform, optionsOrTransform = { as: "local" };
    let hook = { subType: "derive", fn: transform2 };
    return this.onTransform(optionsOrTransform, hook);
  }
  model(name, model) {
    let coerce = (schema) => replaceSchemaType(schema, [{ from: t.Number(), to: (options) => t.Numeric(options), untilObjectFound: true }, { from: t.Boolean(), to: (options) => t.BooleanString(options), untilObjectFound: true }]);
    switch (typeof name) {
      case "object":
        let parsedSchemas = {};
        return Object.entries(name).forEach(([key, value]) => {
          if (!(key in this.definitions.type))
            parsedSchemas[key] = this.definitions.type[key] = coerce(value);
        }), this.definitions.typebox = t.Module({ ...this.definitions.typebox.$defs, ...parsedSchemas }), this;
      case "function":
        let result = coerce(name(this.definitions.type));
        return this.definitions.type = result, this.definitions.typebox = t.Module(result), this;
    }
    return this.definitions.type[name] = model, this.definitions.typebox = t.Module({ ...this.definitions.typebox.$defs, [name]: model }), this;
  }
  mapDerive(optionsOrDerive, mapper) {
    if (!mapper)
      mapper = optionsOrDerive, optionsOrDerive = { as: "local" };
    let hook = { subType: "mapDerive", fn: mapper };
    return this.onTransform(optionsOrDerive, hook);
  }
  affix(base, type, word) {
    if (word === "")
      return this;
    let delimieter = ["_", "-", " "], capitalize = (word2) => word2[0].toUpperCase() + word2.slice(1), joinKey = base === "prefix" ? (prefix, word2) => delimieter.includes(prefix.at(-1) ?? "") ? prefix + word2 : prefix + capitalize(word2) : delimieter.includes(word.at(-1) ?? "") ? (suffix, word2) => word2 + suffix : (suffix, word2) => word2 + capitalize(suffix), remap = (type2) => {
      let store = {};
      switch (type2) {
        case "decorator":
          for (let key in this.singleton.decorator)
            store[joinKey(word, key)] = this.singleton.decorator[key];
          this.singleton.decorator = store;
          break;
        case "state":
          for (let key in this.singleton.store)
            store[joinKey(word, key)] = this.singleton.store[key];
          this.singleton.store = store;
          break;
        case "model":
          for (let key in this.definitions.type)
            store[joinKey(word, key)] = this.definitions.type[key];
          this.definitions.type = store;
          break;
        case "error":
          for (let key in this.definitions.error)
            store[joinKey(word, key)] = this.definitions.error[key];
          this.definitions.error = store;
          break;
      }
    }, types = Array.isArray(type) ? type : [type];
    for (let type2 of types.some((x) => x === "all") ? ["decorator", "state", "model", "error"] : types)
      remap(type2);
    return this;
  }
  prefix(type, word) {
    return this.affix("prefix", type, word);
  }
  suffix(type, word) {
    return this.affix("suffix", type, word);
  }
  compile() {
    if (this["~adapter"].isWebStandard) {
      if (this.fetch = this.config.aot ? composeGeneralHandler(this) : createDynamicHandler(this), typeof this.server?.reload === "function")
        this.server.reload({ ...this.server || {}, fetch: this.fetch });
      return this;
    }
    if (typeof this.server?.reload === "function")
      this.server.reload(this.server || {});
    return this._handle = composeGeneralHandler(this), this;
  }
  handle = async (request) => this.fetch(request);
  fetch = (request) => {
    return (this.fetch = this.config.aot ? composeGeneralHandler(this) : createDynamicHandler(this))(request);
  };
  handleError = async (context, error2) => {
    return (this.handleError = this.config.aot ? composeErrorHandler(this) : createDynamicErrorHandler(this))(context, error2);
  };
  outerErrorHandler = (error2) => new Response(error2.message || error2.name || "Error", { status: error2?.status ?? 500 });
  listen = (options, callback) => {
    return this["~adapter"].listen(this)(options, callback), this;
  };
  stop = async (closeActiveConnections) => {
    if (!this.server)
      throw new Error("Elysia isn't running. Call `app.listen` to start the server.");
    if (this.server) {
      if (this.server.stop(closeActiveConnections), this.server = null, this.event.stop.length)
        for (let i = 0;i < this.event.stop.length; i++)
          this.event.stop[i].fn(this);
    }
  };
  get modules() {
    return Promise.all(this.promisedModules.promises);
  }
}

// node_modules/.pnpm/@elysiajs+cors@1.2.0_elysia@1.2.9_@sinclair+typebox@0.34.13_openapi-types@12.1.3_/node_modules/@elysiajs/cors/dist/index.mjs
var isBun3 = typeof new Headers()?.toJSON === "function";
var processHeaders = (headers) => {
  if (isBun3)
    return Object.keys(headers.toJSON()).join(", ");
  let keys = "";
  headers.forEach((_2, key) => {
    keys += key + ", ";
  });
  if (keys)
    keys = keys.slice(0, -1);
  return keys;
};
var processOrigin = (origin, request, from) => {
  if (Array.isArray(origin))
    return origin.some((o) => processOrigin(o, request, from));
  switch (typeof origin) {
    case "string":
      if (origin.indexOf("://") === -1)
        return from.includes(origin);
      return origin === from;
    case "function":
      return origin(request) === true;
    case "object":
      if (origin instanceof RegExp)
        return origin.test(from);
  }
  return false;
};
var cors = (config2) => {
  let {
    aot = true,
    origin = true,
    methods = true,
    allowedHeaders = true,
    exposeHeaders = true,
    credentials = true,
    maxAge = 5,
    preflight = true
  } = config2 ?? {};
  if (Array.isArray(allowedHeaders))
    allowedHeaders = allowedHeaders.join(", ");
  if (Array.isArray(exposeHeaders))
    exposeHeaders = exposeHeaders.join(", ");
  const origins = typeof origin === "boolean" ? undefined : Array.isArray(origin) ? origin : [origin];
  const app = new Elysia({
    name: "@elysiajs/cors",
    seed: config2,
    aot
  });
  const anyOrigin = origins?.some((o) => o === "*");
  const handleOrigin = (set2, request) => {
    if (origin === true) {
      set2.headers.vary = "*";
      set2.headers["access-control-allow-origin"] = request.headers.get("Origin") || "*";
      return;
    }
    if (anyOrigin) {
      set2.headers.vary = "*";
      set2.headers["access-control-allow-origin"] = "*";
      return;
    }
    if (!origins?.length)
      return;
    const headers = [];
    if (origins.length) {
      const from = request.headers.get("Origin") ?? "";
      for (let i = 0;i < origins.length; i++) {
        const value = processOrigin(origins[i], request, from);
        if (value === true) {
          set2.headers.vary = origin ? "Origin" : "*";
          set2.headers["access-control-allow-origin"] = from || "*";
          return;
        }
        if (value)
          headers.push(value);
      }
    }
    set2.headers.vary = "Origin";
    if (headers.length)
      set2.headers["access-control-allow-origin"] = headers.join(", ");
  };
  const handleMethod = (set2, method) => {
    if (!method)
      return;
    if (methods === true)
      return set2.headers["access-control-allow-methods"] = method ?? "*";
    if (methods === false || !methods?.length)
      return;
    if (methods === "*")
      return set2.headers["access-control-allow-methods"] = "*";
    if (!Array.isArray(methods))
      return set2.headers["access-control-allow-methods"] = methods;
    set2.headers["access-control-allow-methods"] = methods.join(", ");
  };
  const defaultHeaders = {};
  if (typeof exposeHeaders === "string")
    defaultHeaders["access-control-expose-headers"] = exposeHeaders;
  if (typeof allowedHeaders === "string")
    defaultHeaders["access-control-allow-headers"] = allowedHeaders;
  if (credentials === true)
    defaultHeaders["access-control-allow-credentials"] = "true";
  app.headers(defaultHeaders);
  function handleOption({ set: set2, request, headers }) {
    handleOrigin(set2, request);
    handleMethod(set2, request.headers.get("access-control-request-method"));
    if (allowedHeaders === true || exposeHeaders === true) {
      if (allowedHeaders === true)
        set2.headers["access-control-allow-headers"] = headers["access-control-request-headers"];
      if (exposeHeaders === true)
        set2.headers["access-control-expose-headers"] = Object.keys(headers).join(",");
    }
    if (maxAge)
      set2.headers["access-control-max-age"] = maxAge.toString();
    return new Response(null, {
      status: 204
    });
  }
  if (preflight)
    app.options("/", handleOption).options("/*", handleOption);
  return app.onRequest(function processCors({ set: set2, request }) {
    handleOrigin(set2, request);
    handleMethod(set2, request.method);
    if (allowedHeaders === true || exposeHeaders === true) {
      const headers = processHeaders(request.headers);
      if (allowedHeaders === true)
        set2.headers["access-control-allow-headers"] = headers;
      if (exposeHeaders === true)
        set2.headers["access-control-expose-headers"] = headers;
    }
  });
};
var index_default = cors;

// node_modules/memoirist/dist/bun/index.js
var U2 = (z, q) => {
  const v = q?.length ? {} : null;
  if (v)
    for (let K of q)
      v[K.part.charCodeAt(0)] = K;
  return { part: z, store: null, inert: v, params: null, wildcardStore: null };
};
var _2 = (z, q) => ({ ...z, part: q });
var $2 = (z) => ({ name: z, store: null, inert: null });

class Y2 {
  root = {};
  history = [];
  static regex = { static: /:.+?(?=\/|$)/, params: /:.+?(?=\/|$)/g, optionalParams: /:.+?\?(?=\/|$)/g };
  add(z, q, v, { ignoreError: K = false, ignoreHistory: V = false } = {}) {
    if (typeof q !== "string")
      throw new TypeError("Route path must be a string");
    if (q === "")
      q = "/";
    else if (q[0] !== "/")
      q = `/${q}`;
    const S = q[q.length - 1] === "*", D = q.match(Y2.regex.optionalParams);
    if (D) {
      const F = q.replaceAll("?", "");
      this.add(z, F, v, { ignoreError: K });
      for (let B = 0;B < D.length; B++) {
        let A = q.replace("/" + D[B], "");
        this.add(z, A, v, { ignoreError: true });
      }
      return v;
    }
    if (D)
      q = q.replaceAll("?", "");
    if (this.history.find(([F, B, A]) => F === z && B === q))
      return v;
    if (S || D && q.charCodeAt(q.length - 1) === 63)
      q = q.slice(0, -1);
    if (!V)
      this.history.push([z, q, v]);
    const G = q.split(Y2.regex.static), J = q.match(Y2.regex.params) || [];
    if (G[G.length - 1] === "")
      G.pop();
    let b;
    if (!this.root[z])
      b = this.root[z] = U2("/");
    else
      b = this.root[z];
    let Q = 0;
    for (let F = 0;F < G.length; ++F) {
      let B = G[F];
      if (F > 0) {
        const A = J[Q++].slice(1);
        if (b.params === null)
          b.params = $2(A);
        else if (b.params.name !== A)
          if (K)
            return v;
          else
            throw new Error(`Cannot create route "${q}" with parameter "${A}" ` + "because a route already exists with a different parameter name " + `("${b.params.name}") in the same location`);
        const O = b.params;
        if (O.inert === null) {
          b = O.inert = U2(B);
          continue;
        }
        b = O.inert;
      }
      for (let A = 0;; ) {
        if (A === B.length) {
          if (A < b.part.length) {
            const O = _2(b, b.part.slice(A));
            Object.assign(b, U2(B, [O]));
          }
          break;
        }
        if (A === b.part.length) {
          if (b.inert === null)
            b.inert = {};
          const O = b.inert[B.charCodeAt(A)];
          if (O) {
            b = O, B = B.slice(A), A = 0;
            continue;
          }
          const X = U2(B.slice(A));
          b.inert[B.charCodeAt(A)] = X, b = X;
          break;
        }
        if (B[A] !== b.part[A]) {
          const O = _2(b, b.part.slice(A)), X = U2(B.slice(A));
          Object.assign(b, U2(b.part.slice(0, A), [O, X])), b = X;
          break;
        }
        ++A;
      }
    }
    if (Q < J.length) {
      const B = J[Q].slice(1);
      if (b.params === null)
        b.params = $2(B);
      else if (b.params.name !== B)
        if (K)
          return v;
        else
          throw new Error(`Cannot create route "${q}" with parameter "${B}" ` + "because a route already exists with a different parameter name " + `("${b.params.name}") in the same location`);
      if (b.params.store === null)
        b.params.store = v;
      return b.params.store;
    }
    if (S) {
      if (b.wildcardStore === null)
        b.wildcardStore = v;
      return b.wildcardStore;
    }
    if (b.store === null)
      b.store = v;
    return b.store;
  }
  find(z, q) {
    const v = this.root[z];
    if (!v)
      return null;
    return Z2(q, q.length, v, 0);
  }
}
var Z2 = (z, q, v, K) => {
  const V = v.part, S = V.length, D = K + S;
  if (S > 1) {
    if (D > q)
      return null;
    if (S < 15) {
      for (let G = 1, J = K + 1;G < S; ++G, ++J)
        if (V.charCodeAt(G) !== z.charCodeAt(J))
          return null;
    } else if (z.slice(K, D) !== V)
      return null;
  }
  if (D === q) {
    if (v.store !== null)
      return { store: v.store, params: {} };
    if (v.wildcardStore !== null)
      return { store: v.wildcardStore, params: { "*": "" } };
    return null;
  }
  if (v.inert !== null) {
    const G = v.inert[z.charCodeAt(D)];
    if (G !== undefined) {
      const J = Z2(z, q, G, D);
      if (J !== null)
        return J;
    }
  }
  if (v.params !== null) {
    const { store: G, name: J, inert: b } = v.params, Q = z.indexOf("/", D);
    if (Q !== D) {
      if (Q === -1 || Q >= q) {
        if (G !== null) {
          const F = {};
          return F[J] = z.substring(D, q), { store: G, params: F };
        }
      } else if (b !== null) {
        const F = Z2(z, q, b, Q);
        if (F !== null)
          return F.params[J] = z.substring(D, Q), F;
      }
    }
  }
  if (v.wildcardStore !== null)
    return { store: v.wildcardStore, params: { "*": z.substring(D, q) } };
  return null;
};

// node_modules/@sinclair/typebox/build/esm/type/guard/value.mjs
var exports_value3 = {};
__export(exports_value3, {
  IsUndefined: () => IsUndefined5,
  IsUint8Array: () => IsUint8Array5,
  IsSymbol: () => IsSymbol5,
  IsString: () => IsString5,
  IsRegExp: () => IsRegExp4,
  IsObject: () => IsObject5,
  IsNumber: () => IsNumber5,
  IsNull: () => IsNull5,
  IsIterator: () => IsIterator5,
  IsFunction: () => IsFunction5,
  IsDate: () => IsDate5,
  IsBoolean: () => IsBoolean5,
  IsBigInt: () => IsBigInt5,
  IsAsyncIterator: () => IsAsyncIterator5,
  IsArray: () => IsArray5,
  HasPropertyKey: () => HasPropertyKey3
});
function HasPropertyKey3(value, key) {
  return key in value;
}
function IsAsyncIterator5(value) {
  return IsObject5(value) && !IsArray5(value) && !IsUint8Array5(value) && Symbol.asyncIterator in value;
}
function IsArray5(value) {
  return Array.isArray(value);
}
function IsBigInt5(value) {
  return typeof value === "bigint";
}
function IsBoolean5(value) {
  return typeof value === "boolean";
}
function IsDate5(value) {
  return value instanceof globalThis.Date;
}
function IsFunction5(value) {
  return typeof value === "function";
}
function IsIterator5(value) {
  return IsObject5(value) && !IsArray5(value) && !IsUint8Array5(value) && Symbol.iterator in value;
}
function IsNull5(value) {
  return value === null;
}
function IsNumber5(value) {
  return typeof value === "number";
}
function IsObject5(value) {
  return typeof value === "object" && value !== null;
}
function IsRegExp4(value) {
  return value instanceof globalThis.RegExp;
}
function IsString5(value) {
  return typeof value === "string";
}
function IsSymbol5(value) {
  return typeof value === "symbol";
}
function IsUint8Array5(value) {
  return value instanceof globalThis.Uint8Array;
}
function IsUndefined5(value) {
  return value === undefined;
}

// node_modules/@sinclair/typebox/build/esm/type/clone/value.mjs
function ArrayType6(value) {
  return value.map((value2) => Visit17(value2));
}
function DateType4(value) {
  return new Date(value.getTime());
}
function Uint8ArrayType3(value) {
  return new Uint8Array(value);
}
function RegExpType2(value) {
  return new RegExp(value.source, value.flags);
}
function ObjectType6(value) {
  const result = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    result[key] = Visit17(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    result[key] = Visit17(value[key]);
  }
  return result;
}
function Visit17(value) {
  return IsArray5(value) ? ArrayType6(value) : IsDate5(value) ? DateType4(value) : IsUint8Array5(value) ? Uint8ArrayType3(value) : IsRegExp4(value) ? RegExpType2(value) : IsObject5(value) ? ObjectType6(value) : value;
}
function Clone3(value) {
  return Visit17(value);
}

// node_modules/@sinclair/typebox/build/esm/type/clone/type.mjs
function CloneType2(schema, options) {
  return options === undefined ? Clone3(schema) : Clone3({ ...options, ...schema });
}

// node_modules/@sinclair/typebox/build/esm/value/guard/guard.mjs
function IsAsyncIterator6(value) {
  return IsObject6(value) && Symbol.asyncIterator in value;
}
function IsIterator6(value) {
  return IsObject6(value) && Symbol.iterator in value;
}
function IsStandardObject3(value) {
  return IsObject6(value) && (Object.getPrototypeOf(value) === Object.prototype || Object.getPrototypeOf(value) === null);
}
function IsPromise4(value) {
  return value instanceof Promise;
}
function IsDate6(value) {
  return value instanceof Date && Number.isFinite(value.getTime());
}
function IsMap2(value) {
  return value instanceof globalThis.Map;
}
function IsSet2(value) {
  return value instanceof globalThis.Set;
}
function IsTypedArray2(value) {
  return ArrayBuffer.isView(value);
}
function IsUint8Array6(value) {
  return value instanceof globalThis.Uint8Array;
}
function HasPropertyKey4(value, key) {
  return key in value;
}
function IsObject6(value) {
  return value !== null && typeof value === "object";
}
function IsArray6(value) {
  return Array.isArray(value) && !ArrayBuffer.isView(value);
}
function IsUndefined6(value) {
  return value === undefined;
}
function IsNull6(value) {
  return value === null;
}
function IsBoolean6(value) {
  return typeof value === "boolean";
}
function IsNumber6(value) {
  return typeof value === "number";
}
function IsInteger4(value) {
  return Number.isInteger(value);
}
function IsBigInt6(value) {
  return typeof value === "bigint";
}
function IsString6(value) {
  return typeof value === "string";
}
function IsFunction6(value) {
  return typeof value === "function";
}
function IsSymbol6(value) {
  return typeof value === "symbol";
}
function IsValueType2(value) {
  return IsBigInt6(value) || IsBoolean6(value) || IsNull6(value) || IsNumber6(value) || IsString6(value) || IsSymbol6(value) || IsUndefined6(value);
}

// node_modules/@sinclair/typebox/build/esm/system/policy.mjs
var TypeSystemPolicy2;
(function(TypeSystemPolicy3) {
  TypeSystemPolicy3.InstanceMode = "default";
  TypeSystemPolicy3.ExactOptionalPropertyTypes = false;
  TypeSystemPolicy3.AllowArrayObject = false;
  TypeSystemPolicy3.AllowNaN = false;
  TypeSystemPolicy3.AllowNullVoid = false;
  function IsExactOptionalProperty(value, key) {
    return TypeSystemPolicy3.ExactOptionalPropertyTypes ? key in value : value[key] !== undefined;
  }
  TypeSystemPolicy3.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value) {
    const isObject2 = IsObject6(value);
    return TypeSystemPolicy3.AllowArrayObject ? isObject2 : isObject2 && !IsArray6(value);
  }
  TypeSystemPolicy3.IsObjectLike = IsObjectLike;
  function IsRecordLike(value) {
    return IsObjectLike(value) && !(value instanceof Date) && !(value instanceof Uint8Array);
  }
  TypeSystemPolicy3.IsRecordLike = IsRecordLike;
  function IsNumberLike(value) {
    return TypeSystemPolicy3.AllowNaN ? IsNumber6(value) : Number.isFinite(value);
  }
  TypeSystemPolicy3.IsNumberLike = IsNumberLike;
  function IsVoidLike(value) {
    const isUndefined = IsUndefined6(value);
    return TypeSystemPolicy3.AllowNullVoid ? isUndefined || value === null : isUndefined;
  }
  TypeSystemPolicy3.IsVoidLike = IsVoidLike;
})(TypeSystemPolicy2 || (TypeSystemPolicy2 = {}));

// node_modules/@sinclair/typebox/build/esm/type/create/immutable.mjs
function ImmutableArray2(value) {
  return globalThis.Object.freeze(value).map((value2) => Immutable2(value2));
}
function ImmutableDate2(value) {
  return value;
}
function ImmutableUint8Array2(value) {
  return value;
}
function ImmutableRegExp2(value) {
  return value;
}
function ImmutableObject2(value) {
  const result = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    result[key] = Immutable2(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    result[key] = Immutable2(value[key]);
  }
  return globalThis.Object.freeze(result);
}
function Immutable2(value) {
  return IsArray5(value) ? ImmutableArray2(value) : IsDate5(value) ? ImmutableDate2(value) : IsUint8Array5(value) ? ImmutableUint8Array2(value) : IsRegExp4(value) ? ImmutableRegExp2(value) : IsObject5(value) ? ImmutableObject2(value) : value;
}

// node_modules/@sinclair/typebox/build/esm/type/create/type.mjs
function CreateType2(schema, options) {
  const result = options !== undefined ? { ...options, ...schema } : schema;
  switch (TypeSystemPolicy2.InstanceMode) {
    case "freeze":
      return Immutable2(result);
    case "clone":
      return Clone3(result);
    default:
      return result;
  }
}

// node_modules/@sinclair/typebox/build/esm/type/error/error.mjs
class TypeBoxError2 extends Error {
  constructor(message) {
    super(message);
  }
}

// node_modules/@sinclair/typebox/build/esm/type/symbols/symbols.mjs
var TransformKind2 = Symbol.for("TypeBox.Transform");
var ReadonlyKind2 = Symbol.for("TypeBox.Readonly");
var OptionalKind2 = Symbol.for("TypeBox.Optional");
var Hint2 = Symbol.for("TypeBox.Hint");
var Kind2 = Symbol.for("TypeBox.Kind");

// node_modules/@sinclair/typebox/build/esm/type/guard/kind.mjs
function IsReadonly3(value) {
  return IsObject5(value) && value[ReadonlyKind2] === "Readonly";
}
function IsOptional3(value) {
  return IsObject5(value) && value[OptionalKind2] === "Optional";
}
function IsAny3(value) {
  return IsKindOf3(value, "Any");
}
function IsArray7(value) {
  return IsKindOf3(value, "Array");
}
function IsAsyncIterator7(value) {
  return IsKindOf3(value, "AsyncIterator");
}
function IsBigInt7(value) {
  return IsKindOf3(value, "BigInt");
}
function IsBoolean7(value) {
  return IsKindOf3(value, "Boolean");
}
function IsComputed3(value) {
  return IsKindOf3(value, "Computed");
}
function IsConstructor3(value) {
  return IsKindOf3(value, "Constructor");
}
function IsDate7(value) {
  return IsKindOf3(value, "Date");
}
function IsFunction7(value) {
  return IsKindOf3(value, "Function");
}
function IsInteger5(value) {
  return IsKindOf3(value, "Integer");
}
function IsIntersect3(value) {
  return IsKindOf3(value, "Intersect");
}
function IsIterator7(value) {
  return IsKindOf3(value, "Iterator");
}
function IsKindOf3(value, kind) {
  return IsObject5(value) && Kind2 in value && value[Kind2] === kind;
}
function IsLiteralValue3(value) {
  return IsBoolean5(value) || IsNumber5(value) || IsString5(value);
}
function IsLiteral3(value) {
  return IsKindOf3(value, "Literal");
}
function IsMappedKey3(value) {
  return IsKindOf3(value, "MappedKey");
}
function IsMappedResult3(value) {
  return IsKindOf3(value, "MappedResult");
}
function IsNever3(value) {
  return IsKindOf3(value, "Never");
}
function IsNot3(value) {
  return IsKindOf3(value, "Not");
}
function IsNull7(value) {
  return IsKindOf3(value, "Null");
}
function IsNumber7(value) {
  return IsKindOf3(value, "Number");
}
function IsObject7(value) {
  return IsKindOf3(value, "Object");
}
function IsPromise5(value) {
  return IsKindOf3(value, "Promise");
}
function IsRecord3(value) {
  return IsKindOf3(value, "Record");
}
function IsRef3(value) {
  return IsKindOf3(value, "Ref");
}
function IsRegExp5(value) {
  return IsKindOf3(value, "RegExp");
}
function IsString7(value) {
  return IsKindOf3(value, "String");
}
function IsSymbol7(value) {
  return IsKindOf3(value, "Symbol");
}
function IsTemplateLiteral3(value) {
  return IsKindOf3(value, "TemplateLiteral");
}
function IsThis3(value) {
  return IsKindOf3(value, "This");
}
function IsTransform3(value) {
  return IsObject5(value) && TransformKind2 in value;
}
function IsTuple3(value) {
  return IsKindOf3(value, "Tuple");
}
function IsUndefined7(value) {
  return IsKindOf3(value, "Undefined");
}
function IsUnion3(value) {
  return IsKindOf3(value, "Union");
}
function IsUint8Array7(value) {
  return IsKindOf3(value, "Uint8Array");
}
function IsUnknown3(value) {
  return IsKindOf3(value, "Unknown");
}
function IsUnsafe3(value) {
  return IsKindOf3(value, "Unsafe");
}
function IsVoid3(value) {
  return IsKindOf3(value, "Void");
}
function IsKind3(value) {
  return IsObject5(value) && Kind2 in value && IsString5(value[Kind2]);
}
function IsSchema3(value) {
  return IsAny3(value) || IsArray7(value) || IsBoolean7(value) || IsBigInt7(value) || IsAsyncIterator7(value) || IsComputed3(value) || IsConstructor3(value) || IsDate7(value) || IsFunction7(value) || IsInteger5(value) || IsIntersect3(value) || IsIterator7(value) || IsLiteral3(value) || IsMappedKey3(value) || IsMappedResult3(value) || IsNever3(value) || IsNot3(value) || IsNull7(value) || IsNumber7(value) || IsObject7(value) || IsPromise5(value) || IsRecord3(value) || IsRef3(value) || IsRegExp5(value) || IsString7(value) || IsSymbol7(value) || IsTemplateLiteral3(value) || IsThis3(value) || IsTuple3(value) || IsUndefined7(value) || IsUnion3(value) || IsUint8Array7(value) || IsUnknown3(value) || IsUnsafe3(value) || IsVoid3(value) || IsKind3(value);
}
// node_modules/@sinclair/typebox/build/esm/type/guard/type.mjs
var exports_type4 = {};
__export(exports_type4, {
  TypeGuardUnknownTypeError: () => TypeGuardUnknownTypeError2,
  IsVoid: () => IsVoid4,
  IsUnsafe: () => IsUnsafe4,
  IsUnknown: () => IsUnknown4,
  IsUnionLiteral: () => IsUnionLiteral2,
  IsUnion: () => IsUnion4,
  IsUndefined: () => IsUndefined8,
  IsUint8Array: () => IsUint8Array8,
  IsTuple: () => IsTuple4,
  IsTransform: () => IsTransform4,
  IsThis: () => IsThis4,
  IsTemplateLiteral: () => IsTemplateLiteral4,
  IsSymbol: () => IsSymbol8,
  IsString: () => IsString8,
  IsSchema: () => IsSchema4,
  IsRegExp: () => IsRegExp6,
  IsRef: () => IsRef4,
  IsRecursive: () => IsRecursive2,
  IsRecord: () => IsRecord4,
  IsReadonly: () => IsReadonly4,
  IsProperties: () => IsProperties2,
  IsPromise: () => IsPromise6,
  IsOptional: () => IsOptional4,
  IsObject: () => IsObject8,
  IsNumber: () => IsNumber8,
  IsNull: () => IsNull8,
  IsNot: () => IsNot4,
  IsNever: () => IsNever4,
  IsMappedResult: () => IsMappedResult4,
  IsMappedKey: () => IsMappedKey4,
  IsLiteralValue: () => IsLiteralValue4,
  IsLiteralString: () => IsLiteralString2,
  IsLiteralNumber: () => IsLiteralNumber2,
  IsLiteralBoolean: () => IsLiteralBoolean2,
  IsLiteral: () => IsLiteral4,
  IsKindOf: () => IsKindOf4,
  IsKind: () => IsKind4,
  IsIterator: () => IsIterator8,
  IsIntersect: () => IsIntersect4,
  IsInteger: () => IsInteger6,
  IsImport: () => IsImport2,
  IsFunction: () => IsFunction8,
  IsDate: () => IsDate8,
  IsConstructor: () => IsConstructor4,
  IsComputed: () => IsComputed4,
  IsBoolean: () => IsBoolean8,
  IsBigInt: () => IsBigInt8,
  IsAsyncIterator: () => IsAsyncIterator8,
  IsArray: () => IsArray8,
  IsAny: () => IsAny4
});
class TypeGuardUnknownTypeError2 extends TypeBoxError2 {
}
var KnownTypes2 = [
  "Any",
  "Array",
  "AsyncIterator",
  "BigInt",
  "Boolean",
  "Computed",
  "Constructor",
  "Date",
  "Enum",
  "Function",
  "Integer",
  "Intersect",
  "Iterator",
  "Literal",
  "MappedKey",
  "MappedResult",
  "Not",
  "Null",
  "Number",
  "Object",
  "Promise",
  "Record",
  "Ref",
  "RegExp",
  "String",
  "Symbol",
  "TemplateLiteral",
  "This",
  "Tuple",
  "Undefined",
  "Union",
  "Uint8Array",
  "Unknown",
  "Void"
];
function IsPattern2(value) {
  try {
    new RegExp(value);
    return true;
  } catch {
    return false;
  }
}
function IsControlCharacterFree2(value) {
  if (!IsString5(value))
    return false;
  for (let i = 0;i < value.length; i++) {
    const code = value.charCodeAt(i);
    if (code >= 7 && code <= 13 || code === 27 || code === 127) {
      return false;
    }
  }
  return true;
}
function IsAdditionalProperties2(value) {
  return IsOptionalBoolean2(value) || IsSchema4(value);
}
function IsOptionalBigInt2(value) {
  return IsUndefined5(value) || IsBigInt5(value);
}
function IsOptionalNumber2(value) {
  return IsUndefined5(value) || IsNumber5(value);
}
function IsOptionalBoolean2(value) {
  return IsUndefined5(value) || IsBoolean5(value);
}
function IsOptionalString2(value) {
  return IsUndefined5(value) || IsString5(value);
}
function IsOptionalPattern2(value) {
  return IsUndefined5(value) || IsString5(value) && IsControlCharacterFree2(value) && IsPattern2(value);
}
function IsOptionalFormat2(value) {
  return IsUndefined5(value) || IsString5(value) && IsControlCharacterFree2(value);
}
function IsOptionalSchema2(value) {
  return IsUndefined5(value) || IsSchema4(value);
}
function IsReadonly4(value) {
  return IsObject5(value) && value[ReadonlyKind2] === "Readonly";
}
function IsOptional4(value) {
  return IsObject5(value) && value[OptionalKind2] === "Optional";
}
function IsAny4(value) {
  return IsKindOf4(value, "Any") && IsOptionalString2(value.$id);
}
function IsArray8(value) {
  return IsKindOf4(value, "Array") && value.type === "array" && IsOptionalString2(value.$id) && IsSchema4(value.items) && IsOptionalNumber2(value.minItems) && IsOptionalNumber2(value.maxItems) && IsOptionalBoolean2(value.uniqueItems) && IsOptionalSchema2(value.contains) && IsOptionalNumber2(value.minContains) && IsOptionalNumber2(value.maxContains);
}
function IsAsyncIterator8(value) {
  return IsKindOf4(value, "AsyncIterator") && value.type === "AsyncIterator" && IsOptionalString2(value.$id) && IsSchema4(value.items);
}
function IsBigInt8(value) {
  return IsKindOf4(value, "BigInt") && value.type === "bigint" && IsOptionalString2(value.$id) && IsOptionalBigInt2(value.exclusiveMaximum) && IsOptionalBigInt2(value.exclusiveMinimum) && IsOptionalBigInt2(value.maximum) && IsOptionalBigInt2(value.minimum) && IsOptionalBigInt2(value.multipleOf);
}
function IsBoolean8(value) {
  return IsKindOf4(value, "Boolean") && value.type === "boolean" && IsOptionalString2(value.$id);
}
function IsComputed4(value) {
  return IsKindOf4(value, "Computed") && IsString5(value.target) && IsArray5(value.parameters) && value.parameters.every((schema) => IsSchema4(schema));
}
function IsConstructor4(value) {
  return IsKindOf4(value, "Constructor") && value.type === "Constructor" && IsOptionalString2(value.$id) && IsArray5(value.parameters) && value.parameters.every((schema) => IsSchema4(schema)) && IsSchema4(value.returns);
}
function IsDate8(value) {
  return IsKindOf4(value, "Date") && value.type === "Date" && IsOptionalString2(value.$id) && IsOptionalNumber2(value.exclusiveMaximumTimestamp) && IsOptionalNumber2(value.exclusiveMinimumTimestamp) && IsOptionalNumber2(value.maximumTimestamp) && IsOptionalNumber2(value.minimumTimestamp) && IsOptionalNumber2(value.multipleOfTimestamp);
}
function IsFunction8(value) {
  return IsKindOf4(value, "Function") && value.type === "Function" && IsOptionalString2(value.$id) && IsArray5(value.parameters) && value.parameters.every((schema) => IsSchema4(schema)) && IsSchema4(value.returns);
}
function IsImport2(value) {
  return IsKindOf4(value, "Import") && HasPropertyKey3(value, "$defs") && IsObject5(value.$defs) && IsProperties2(value.$defs) && HasPropertyKey3(value, "$ref") && IsString5(value.$ref) && value.$ref in value.$defs;
}
function IsInteger6(value) {
  return IsKindOf4(value, "Integer") && value.type === "integer" && IsOptionalString2(value.$id) && IsOptionalNumber2(value.exclusiveMaximum) && IsOptionalNumber2(value.exclusiveMinimum) && IsOptionalNumber2(value.maximum) && IsOptionalNumber2(value.minimum) && IsOptionalNumber2(value.multipleOf);
}
function IsProperties2(value) {
  return IsObject5(value) && Object.entries(value).every(([key, schema]) => IsControlCharacterFree2(key) && IsSchema4(schema));
}
function IsIntersect4(value) {
  return IsKindOf4(value, "Intersect") && (IsString5(value.type) && value.type !== "object" ? false : true) && IsArray5(value.allOf) && value.allOf.every((schema) => IsSchema4(schema) && !IsTransform4(schema)) && IsOptionalString2(value.type) && (IsOptionalBoolean2(value.unevaluatedProperties) || IsOptionalSchema2(value.unevaluatedProperties)) && IsOptionalString2(value.$id);
}
function IsIterator8(value) {
  return IsKindOf4(value, "Iterator") && value.type === "Iterator" && IsOptionalString2(value.$id) && IsSchema4(value.items);
}
function IsKindOf4(value, kind) {
  return IsObject5(value) && Kind2 in value && value[Kind2] === kind;
}
function IsLiteralString2(value) {
  return IsLiteral4(value) && IsString5(value.const);
}
function IsLiteralNumber2(value) {
  return IsLiteral4(value) && IsNumber5(value.const);
}
function IsLiteralBoolean2(value) {
  return IsLiteral4(value) && IsBoolean5(value.const);
}
function IsLiteral4(value) {
  return IsKindOf4(value, "Literal") && IsOptionalString2(value.$id) && IsLiteralValue4(value.const);
}
function IsLiteralValue4(value) {
  return IsBoolean5(value) || IsNumber5(value) || IsString5(value);
}
function IsMappedKey4(value) {
  return IsKindOf4(value, "MappedKey") && IsArray5(value.keys) && value.keys.every((key) => IsNumber5(key) || IsString5(key));
}
function IsMappedResult4(value) {
  return IsKindOf4(value, "MappedResult") && IsProperties2(value.properties);
}
function IsNever4(value) {
  return IsKindOf4(value, "Never") && IsObject5(value.not) && Object.getOwnPropertyNames(value.not).length === 0;
}
function IsNot4(value) {
  return IsKindOf4(value, "Not") && IsSchema4(value.not);
}
function IsNull8(value) {
  return IsKindOf4(value, "Null") && value.type === "null" && IsOptionalString2(value.$id);
}
function IsNumber8(value) {
  return IsKindOf4(value, "Number") && value.type === "number" && IsOptionalString2(value.$id) && IsOptionalNumber2(value.exclusiveMaximum) && IsOptionalNumber2(value.exclusiveMinimum) && IsOptionalNumber2(value.maximum) && IsOptionalNumber2(value.minimum) && IsOptionalNumber2(value.multipleOf);
}
function IsObject8(value) {
  return IsKindOf4(value, "Object") && value.type === "object" && IsOptionalString2(value.$id) && IsProperties2(value.properties) && IsAdditionalProperties2(value.additionalProperties) && IsOptionalNumber2(value.minProperties) && IsOptionalNumber2(value.maxProperties);
}
function IsPromise6(value) {
  return IsKindOf4(value, "Promise") && value.type === "Promise" && IsOptionalString2(value.$id) && IsSchema4(value.item);
}
function IsRecord4(value) {
  return IsKindOf4(value, "Record") && value.type === "object" && IsOptionalString2(value.$id) && IsAdditionalProperties2(value.additionalProperties) && IsObject5(value.patternProperties) && ((schema) => {
    const keys = Object.getOwnPropertyNames(schema.patternProperties);
    return keys.length === 1 && IsPattern2(keys[0]) && IsObject5(schema.patternProperties) && IsSchema4(schema.patternProperties[keys[0]]);
  })(value);
}
function IsRecursive2(value) {
  return IsObject5(value) && Hint2 in value && value[Hint2] === "Recursive";
}
function IsRef4(value) {
  return IsKindOf4(value, "Ref") && IsOptionalString2(value.$id) && IsString5(value.$ref);
}
function IsRegExp6(value) {
  return IsKindOf4(value, "RegExp") && IsOptionalString2(value.$id) && IsString5(value.source) && IsString5(value.flags) && IsOptionalNumber2(value.maxLength) && IsOptionalNumber2(value.minLength);
}
function IsString8(value) {
  return IsKindOf4(value, "String") && value.type === "string" && IsOptionalString2(value.$id) && IsOptionalNumber2(value.minLength) && IsOptionalNumber2(value.maxLength) && IsOptionalPattern2(value.pattern) && IsOptionalFormat2(value.format);
}
function IsSymbol8(value) {
  return IsKindOf4(value, "Symbol") && value.type === "symbol" && IsOptionalString2(value.$id);
}
function IsTemplateLiteral4(value) {
  return IsKindOf4(value, "TemplateLiteral") && value.type === "string" && IsString5(value.pattern) && value.pattern[0] === "^" && value.pattern[value.pattern.length - 1] === "$";
}
function IsThis4(value) {
  return IsKindOf4(value, "This") && IsOptionalString2(value.$id) && IsString5(value.$ref);
}
function IsTransform4(value) {
  return IsObject5(value) && TransformKind2 in value;
}
function IsTuple4(value) {
  return IsKindOf4(value, "Tuple") && value.type === "array" && IsOptionalString2(value.$id) && IsNumber5(value.minItems) && IsNumber5(value.maxItems) && value.minItems === value.maxItems && (IsUndefined5(value.items) && IsUndefined5(value.additionalItems) && value.minItems === 0 || IsArray5(value.items) && value.items.every((schema) => IsSchema4(schema)));
}
function IsUndefined8(value) {
  return IsKindOf4(value, "Undefined") && value.type === "undefined" && IsOptionalString2(value.$id);
}
function IsUnionLiteral2(value) {
  return IsUnion4(value) && value.anyOf.every((schema) => IsLiteralString2(schema) || IsLiteralNumber2(schema));
}
function IsUnion4(value) {
  return IsKindOf4(value, "Union") && IsOptionalString2(value.$id) && IsObject5(value) && IsArray5(value.anyOf) && value.anyOf.every((schema) => IsSchema4(schema));
}
function IsUint8Array8(value) {
  return IsKindOf4(value, "Uint8Array") && value.type === "Uint8Array" && IsOptionalString2(value.$id) && IsOptionalNumber2(value.minByteLength) && IsOptionalNumber2(value.maxByteLength);
}
function IsUnknown4(value) {
  return IsKindOf4(value, "Unknown") && IsOptionalString2(value.$id);
}
function IsUnsafe4(value) {
  return IsKindOf4(value, "Unsafe");
}
function IsVoid4(value) {
  return IsKindOf4(value, "Void") && value.type === "void" && IsOptionalString2(value.$id);
}
function IsKind4(value) {
  return IsObject5(value) && Kind2 in value && IsString5(value[Kind2]) && !KnownTypes2.includes(value[Kind2]);
}
function IsSchema4(value) {
  return IsObject5(value) && (IsAny4(value) || IsArray8(value) || IsBoolean8(value) || IsBigInt8(value) || IsAsyncIterator8(value) || IsComputed4(value) || IsConstructor4(value) || IsDate8(value) || IsFunction8(value) || IsInteger6(value) || IsIntersect4(value) || IsIterator8(value) || IsLiteral4(value) || IsMappedKey4(value) || IsMappedResult4(value) || IsNever4(value) || IsNot4(value) || IsNull8(value) || IsNumber8(value) || IsObject8(value) || IsPromise6(value) || IsRecord4(value) || IsRef4(value) || IsRegExp6(value) || IsString8(value) || IsSymbol8(value) || IsTemplateLiteral4(value) || IsThis4(value) || IsTuple4(value) || IsUndefined8(value) || IsUnion4(value) || IsUint8Array8(value) || IsUnknown4(value) || IsUnsafe4(value) || IsVoid4(value) || IsKind4(value));
}
// node_modules/@sinclair/typebox/build/esm/type/patterns/patterns.mjs
var PatternBoolean2 = "(true|false)";
var PatternNumber2 = "(0|[1-9][0-9]*)";
var PatternString2 = "(.*)";
var PatternNever2 = "(?!.*)";
var PatternBooleanExact2 = `^${PatternBoolean2}$`;
var PatternNumberExact2 = `^${PatternNumber2}$`;
var PatternStringExact2 = `^${PatternString2}$`;
var PatternNeverExact2 = `^${PatternNever2}$`;

// node_modules/@sinclair/typebox/build/esm/type/registry/format.mjs
var exports_format2 = {};
__export(exports_format2, {
  Set: () => Set5,
  Has: () => Has4,
  Get: () => Get4,
  Entries: () => Entries3,
  Delete: () => Delete5,
  Clear: () => Clear3
});
var map3 = new Map;
function Entries3() {
  return new Map(map3);
}
function Clear3() {
  return map3.clear();
}
function Delete5(format) {
  return map3.delete(format);
}
function Has4(format) {
  return map3.has(format);
}
function Set5(format, func) {
  map3.set(format, func);
}
function Get4(format) {
  return map3.get(format);
}
// node_modules/@sinclair/typebox/build/esm/type/registry/type.mjs
var exports_type5 = {};
__export(exports_type5, {
  Set: () => Set6,
  Has: () => Has5,
  Get: () => Get5,
  Entries: () => Entries4,
  Delete: () => Delete6,
  Clear: () => Clear4
});
var map4 = new Map;
function Entries4() {
  return new Map(map4);
}
function Clear4() {
  return map4.clear();
}
function Delete6(kind) {
  return map4.delete(kind);
}
function Has5(kind) {
  return map4.has(kind);
}
function Set6(kind, func) {
  map4.set(kind, func);
}
function Get5(kind) {
  return map4.get(kind);
}
// node_modules/@sinclair/typebox/build/esm/type/sets/set.mjs
function SetIncludes2(T, S) {
  return T.includes(S);
}
function SetDistinct2(T) {
  return [...new Set(T)];
}
function SetIntersect2(T, S) {
  return T.filter((L) => S.includes(L));
}
function SetIntersectManyResolve2(T, Init) {
  return T.reduce((Acc, L) => {
    return SetIntersect2(Acc, L);
  }, Init);
}
function SetIntersectMany2(T) {
  return T.length === 1 ? T[0] : T.length > 1 ? SetIntersectManyResolve2(T.slice(1), T[0]) : [];
}
function SetUnionMany2(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...L);
  return Acc;
}

// node_modules/@sinclair/typebox/build/esm/type/any/any.mjs
function Any2(options) {
  return CreateType2({ [Kind2]: "Any" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/array/array.mjs
function Array3(items, options) {
  return CreateType2({ [Kind2]: "Array", type: "array", items }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/async-iterator/async-iterator.mjs
function AsyncIterator2(items, options) {
  return CreateType2({ [Kind2]: "AsyncIterator", type: "AsyncIterator", items }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/computed/computed.mjs
function Computed2(target, parameters, options) {
  return CreateType2({ [Kind2]: "Computed", target, parameters }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/discard/discard.mjs
function DiscardKey2(value, key) {
  const { [key]: _3, ...rest } = value;
  return rest;
}
function Discard2(value, keys) {
  return keys.reduce((acc, key) => DiscardKey2(acc, key), value);
}

// node_modules/@sinclair/typebox/build/esm/type/never/never.mjs
function Never2(options) {
  return CreateType2({ [Kind2]: "Never", not: {} }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/mapped/mapped-result.mjs
function MappedResult2(properties) {
  return CreateType2({
    [Kind2]: "MappedResult",
    properties
  });
}

// node_modules/@sinclair/typebox/build/esm/type/constructor/constructor.mjs
function Constructor2(parameters, returns, options) {
  return CreateType2({ [Kind2]: "Constructor", type: "Constructor", parameters, returns }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/function/function.mjs
function Function3(parameters, returns, options) {
  return CreateType2({ [Kind2]: "Function", type: "Function", parameters, returns }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/union/union-create.mjs
function UnionCreate2(T, options) {
  return CreateType2({ [Kind2]: "Union", anyOf: T }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/union/union-evaluated.mjs
function IsUnionOptional2(types) {
  return types.some((type) => IsOptional3(type));
}
function RemoveOptionalFromRest3(types) {
  return types.map((left) => IsOptional3(left) ? RemoveOptionalFromType3(left) : left);
}
function RemoveOptionalFromType3(T) {
  return Discard2(T, [OptionalKind2]);
}
function ResolveUnion2(types, options) {
  const isOptional2 = IsUnionOptional2(types);
  return isOptional2 ? Optional2(UnionCreate2(RemoveOptionalFromRest3(types), options)) : UnionCreate2(RemoveOptionalFromRest3(types), options);
}
function UnionEvaluated2(T, options) {
  return T.length === 1 ? CreateType2(T[0], options) : T.length === 0 ? Never2(options) : ResolveUnion2(T, options);
}

// node_modules/@sinclair/typebox/build/esm/type/union/union.mjs
function Union3(types, options) {
  return types.length === 0 ? Never2(options) : types.length === 1 ? CreateType2(types[0], options) : UnionCreate2(types, options);
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/parse.mjs
class TemplateLiteralParserError2 extends TypeBoxError2 {
}
function Unescape2(pattern) {
  return pattern.replace(/\\\$/g, "$").replace(/\\\*/g, "*").replace(/\\\^/g, "^").replace(/\\\|/g, "|").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}
function IsNonEscaped2(pattern, index, char) {
  return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
}
function IsOpenParen2(pattern, index) {
  return IsNonEscaped2(pattern, index, "(");
}
function IsCloseParen2(pattern, index) {
  return IsNonEscaped2(pattern, index, ")");
}
function IsSeparator2(pattern, index) {
  return IsNonEscaped2(pattern, index, "|");
}
function IsGroup2(pattern) {
  if (!(IsOpenParen2(pattern, 0) && IsCloseParen2(pattern, pattern.length - 1)))
    return false;
  let count = 0;
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen2(pattern, index))
      count += 1;
    if (IsCloseParen2(pattern, index))
      count -= 1;
    if (count === 0 && index !== pattern.length - 1)
      return false;
  }
  return true;
}
function InGroup2(pattern) {
  return pattern.slice(1, pattern.length - 1);
}
function IsPrecedenceOr2(pattern) {
  let count = 0;
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen2(pattern, index))
      count += 1;
    if (IsCloseParen2(pattern, index))
      count -= 1;
    if (IsSeparator2(pattern, index) && count === 0)
      return true;
  }
  return false;
}
function IsPrecedenceAnd2(pattern) {
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen2(pattern, index))
      return true;
  }
  return false;
}
function Or2(pattern) {
  let [count, start] = [0, 0];
  const expressions = [];
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen2(pattern, index))
      count += 1;
    if (IsCloseParen2(pattern, index))
      count -= 1;
    if (IsSeparator2(pattern, index) && count === 0) {
      const range2 = pattern.slice(start, index);
      if (range2.length > 0)
        expressions.push(TemplateLiteralParse2(range2));
      start = index + 1;
    }
  }
  const range = pattern.slice(start);
  if (range.length > 0)
    expressions.push(TemplateLiteralParse2(range));
  if (expressions.length === 0)
    return { type: "const", const: "" };
  if (expressions.length === 1)
    return expressions[0];
  return { type: "or", expr: expressions };
}
function And2(pattern) {
  function Group(value, index) {
    if (!IsOpenParen2(value, index))
      throw new TemplateLiteralParserError2(`TemplateLiteralParser: Index must point to open parens`);
    let count = 0;
    for (let scan = index;scan < value.length; scan++) {
      if (IsOpenParen2(value, scan))
        count += 1;
      if (IsCloseParen2(value, scan))
        count -= 1;
      if (count === 0)
        return [index, scan];
    }
    throw new TemplateLiteralParserError2(`TemplateLiteralParser: Unclosed group parens in expression`);
  }
  function Range(pattern2, index) {
    for (let scan = index;scan < pattern2.length; scan++) {
      if (IsOpenParen2(pattern2, scan))
        return [index, scan];
    }
    return [index, pattern2.length];
  }
  const expressions = [];
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen2(pattern, index)) {
      const [start, end] = Group(pattern, index);
      const range = pattern.slice(start, end + 1);
      expressions.push(TemplateLiteralParse2(range));
      index = end;
    } else {
      const [start, end] = Range(pattern, index);
      const range = pattern.slice(start, end);
      if (range.length > 0)
        expressions.push(TemplateLiteralParse2(range));
      index = end - 1;
    }
  }
  return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
}
function TemplateLiteralParse2(pattern) {
  return IsGroup2(pattern) ? TemplateLiteralParse2(InGroup2(pattern)) : IsPrecedenceOr2(pattern) ? Or2(pattern) : IsPrecedenceAnd2(pattern) ? And2(pattern) : { type: "const", const: Unescape2(pattern) };
}
function TemplateLiteralParseExact2(pattern) {
  return TemplateLiteralParse2(pattern.slice(1, pattern.length - 1));
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/finite.mjs
class TemplateLiteralFiniteError2 extends TypeBoxError2 {
}
function IsNumberExpression2(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
}
function IsBooleanExpression2(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
}
function IsStringExpression2(expression) {
  return expression.type === "const" && expression.const === ".*";
}
function IsTemplateLiteralExpressionFinite2(expression) {
  return IsNumberExpression2(expression) || IsStringExpression2(expression) ? false : IsBooleanExpression2(expression) ? true : expression.type === "and" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite2(expr)) : expression.type === "or" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite2(expr)) : expression.type === "const" ? true : (() => {
    throw new TemplateLiteralFiniteError2(`Unknown expression type`);
  })();
}
function IsTemplateLiteralFinite2(schema) {
  const expression = TemplateLiteralParseExact2(schema.pattern);
  return IsTemplateLiteralExpressionFinite2(expression);
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/generate.mjs
class TemplateLiteralGenerateError2 extends TypeBoxError2 {
}
function* GenerateReduce2(buffer) {
  if (buffer.length === 1)
    return yield* buffer[0];
  for (const left of buffer[0]) {
    for (const right of GenerateReduce2(buffer.slice(1))) {
      yield `${left}${right}`;
    }
  }
}
function* GenerateAnd2(expression) {
  return yield* GenerateReduce2(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate2(expr)]));
}
function* GenerateOr2(expression) {
  for (const expr of expression.expr)
    yield* TemplateLiteralExpressionGenerate2(expr);
}
function* GenerateConst2(expression) {
  return yield expression.const;
}
function* TemplateLiteralExpressionGenerate2(expression) {
  return expression.type === "and" ? yield* GenerateAnd2(expression) : expression.type === "or" ? yield* GenerateOr2(expression) : expression.type === "const" ? yield* GenerateConst2(expression) : (() => {
    throw new TemplateLiteralGenerateError2("Unknown expression");
  })();
}
function TemplateLiteralGenerate2(schema) {
  const expression = TemplateLiteralParseExact2(schema.pattern);
  return IsTemplateLiteralExpressionFinite2(expression) ? [...TemplateLiteralExpressionGenerate2(expression)] : [];
}

// node_modules/@sinclair/typebox/build/esm/type/literal/literal.mjs
function Literal2(value, options) {
  return CreateType2({
    [Kind2]: "Literal",
    const: value,
    type: typeof value
  }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/boolean/boolean.mjs
function Boolean3(options) {
  return CreateType2({ [Kind2]: "Boolean", type: "boolean" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/bigint/bigint.mjs
function BigInt3(options) {
  return CreateType2({ [Kind2]: "BigInt", type: "bigint" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/number/number.mjs
function Number3(options) {
  return CreateType2({ [Kind2]: "Number", type: "number" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/string/string.mjs
function String3(options) {
  return CreateType2({ [Kind2]: "String", type: "string" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/syntax.mjs
function* FromUnion20(syntax) {
  const trim = syntax.trim().replace(/"|'/g, "");
  return trim === "boolean" ? yield Boolean3() : trim === "number" ? yield Number3() : trim === "bigint" ? yield BigInt3() : trim === "string" ? yield String3() : yield (() => {
    const literals = trim.split("|").map((literal) => Literal2(literal.trim()));
    return literals.length === 0 ? Never2() : literals.length === 1 ? literals[0] : UnionEvaluated2(literals);
  })();
}
function* FromTerminal2(syntax) {
  if (syntax[1] !== "{") {
    const L = Literal2("$");
    const R = FromSyntax2(syntax.slice(1));
    return yield* [L, ...R];
  }
  for (let i = 2;i < syntax.length; i++) {
    if (syntax[i] === "}") {
      const L = FromUnion20(syntax.slice(2, i));
      const R = FromSyntax2(syntax.slice(i + 1));
      return yield* [...L, ...R];
    }
  }
  yield Literal2(syntax);
}
function* FromSyntax2(syntax) {
  for (let i = 0;i < syntax.length; i++) {
    if (syntax[i] === "$") {
      const L = Literal2(syntax.slice(0, i));
      const R = FromTerminal2(syntax.slice(i));
      return yield* [L, ...R];
    }
  }
  yield Literal2(syntax);
}
function TemplateLiteralSyntax2(syntax) {
  return [...FromSyntax2(syntax)];
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/pattern.mjs
class TemplateLiteralPatternError2 extends TypeBoxError2 {
}
function Escape3(value) {
  return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Visit18(schema, acc) {
  return IsTemplateLiteral3(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) : IsUnion3(schema) ? `(${schema.anyOf.map((schema2) => Visit18(schema2, acc)).join("|")})` : IsNumber7(schema) ? `${acc}${PatternNumber2}` : IsInteger5(schema) ? `${acc}${PatternNumber2}` : IsBigInt7(schema) ? `${acc}${PatternNumber2}` : IsString7(schema) ? `${acc}${PatternString2}` : IsLiteral3(schema) ? `${acc}${Escape3(schema.const.toString())}` : IsBoolean7(schema) ? `${acc}${PatternBoolean2}` : (() => {
    throw new TemplateLiteralPatternError2(`Unexpected Kind '${schema[Kind2]}'`);
  })();
}
function TemplateLiteralPattern2(kinds) {
  return `^${kinds.map((schema) => Visit18(schema, "")).join("")}$`;
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/union.mjs
function TemplateLiteralToUnion2(schema) {
  const R = TemplateLiteralGenerate2(schema);
  const L = R.map((S) => Literal2(S));
  return UnionEvaluated2(L);
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/template-literal.mjs
function TemplateLiteral2(unresolved, options) {
  const pattern = IsString5(unresolved) ? TemplateLiteralPattern2(TemplateLiteralSyntax2(unresolved)) : TemplateLiteralPattern2(unresolved);
  return CreateType2({ [Kind2]: "TemplateLiteral", type: "string", pattern }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-property-keys.mjs
function FromTemplateLiteral7(templateLiteral) {
  const keys = TemplateLiteralGenerate2(templateLiteral);
  return keys.map((key) => key.toString());
}
function FromUnion21(types) {
  const result = [];
  for (const type of types)
    result.push(...IndexPropertyKeys2(type));
  return result;
}
function FromLiteral7(literalValue) {
  return [literalValue.toString()];
}
function IndexPropertyKeys2(type) {
  return [...new Set(IsTemplateLiteral3(type) ? FromTemplateLiteral7(type) : IsUnion3(type) ? FromUnion21(type.anyOf) : IsLiteral3(type) ? FromLiteral7(type.const) : IsNumber7(type) ? ["[number]"] : IsInteger5(type) ? ["[number]"] : [])];
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-result.mjs
function FromProperties19(type, properties, options) {
  const result = {};
  for (const K2 of Object.getOwnPropertyNames(properties)) {
    result[K2] = Index2(type, IndexPropertyKeys2(properties[K2]), options);
  }
  return result;
}
function FromMappedResult13(type, mappedResult, options) {
  return FromProperties19(type, mappedResult.properties, options);
}
function IndexFromMappedResult2(type, mappedResult, options) {
  const properties = FromMappedResult13(type, mappedResult, options);
  return MappedResult2(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed.mjs
function FromRest9(types, key) {
  return types.map((type) => IndexFromPropertyKey2(type, key));
}
function FromIntersectRest2(types) {
  return types.filter((type) => !IsNever3(type));
}
function FromIntersect18(types, key) {
  return IntersectEvaluated2(FromIntersectRest2(FromRest9(types, key)));
}
function FromUnionRest2(types) {
  return types.some((L) => IsNever3(L)) ? [] : types;
}
function FromUnion22(types, key) {
  return UnionEvaluated2(FromUnionRest2(FromRest9(types, key)));
}
function FromTuple15(types, key) {
  return key in types ? types[key] : key === "[number]" ? UnionEvaluated2(types) : Never2();
}
function FromArray17(type, key) {
  return key === "[number]" ? type : Never2();
}
function FromProperty3(properties, propertyKey) {
  return propertyKey in properties ? properties[propertyKey] : Never2();
}
function IndexFromPropertyKey2(type, propertyKey) {
  return IsIntersect3(type) ? FromIntersect18(type.allOf, propertyKey) : IsUnion3(type) ? FromUnion22(type.anyOf, propertyKey) : IsTuple3(type) ? FromTuple15(type.items ?? [], propertyKey) : IsArray7(type) ? FromArray17(type.items, propertyKey) : IsObject7(type) ? FromProperty3(type.properties, propertyKey) : Never2();
}
function IndexFromPropertyKeys2(type, propertyKeys) {
  return propertyKeys.map((propertyKey) => IndexFromPropertyKey2(type, propertyKey));
}
function FromSchema2(type, propertyKeys) {
  return UnionEvaluated2(IndexFromPropertyKeys2(type, propertyKeys));
}
function Index2(type, key, options) {
  if (IsRef3(type) || IsRef3(key)) {
    const error2 = `Index types using Ref parameters require both Type and Key to be of TSchema`;
    if (!IsSchema3(type) || !IsSchema3(key))
      throw new TypeBoxError2(error2);
    return Computed2("Index", [type, key]);
  }
  if (IsMappedResult3(key))
    return IndexFromMappedResult2(type, key, options);
  if (IsMappedKey3(key))
    return IndexFromMappedKey2(type, key, options);
  return CreateType2(IsSchema3(key) ? FromSchema2(type, IndexPropertyKeys2(key)) : FromSchema2(type, key), options);
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-key.mjs
function MappedIndexPropertyKey2(type, key, options) {
  return { [key]: Index2(type, [key], Clone3(options)) };
}
function MappedIndexPropertyKeys2(type, propertyKeys, options) {
  return propertyKeys.reduce((result, left) => {
    return { ...result, ...MappedIndexPropertyKey2(type, left, options) };
  }, {});
}
function MappedIndexProperties2(type, mappedKey, options) {
  return MappedIndexPropertyKeys2(type, mappedKey.keys, options);
}
function IndexFromMappedKey2(type, mappedKey, options) {
  const properties = MappedIndexProperties2(type, mappedKey, options);
  return MappedResult2(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/iterator/iterator.mjs
function Iterator2(items, options) {
  return CreateType2({ [Kind2]: "Iterator", type: "Iterator", items }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/object/object.mjs
function RequiredKeys2(properties) {
  const keys = [];
  for (let key in properties) {
    if (!IsOptional3(properties[key]))
      keys.push(key);
  }
  return keys;
}
function _Object2(properties, options) {
  const required = RequiredKeys2(properties);
  const schematic = required.length > 0 ? { [Kind2]: "Object", type: "object", properties, required } : { [Kind2]: "Object", type: "object", properties };
  return CreateType2(schematic, options);
}
var Object3 = _Object2;

// node_modules/@sinclair/typebox/build/esm/type/promise/promise.mjs
function Promise3(item, options) {
  return CreateType2({ [Kind2]: "Promise", type: "Promise", item }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/readonly/readonly.mjs
function RemoveReadonly2(schema) {
  return CreateType2(Discard2(schema, [ReadonlyKind2]));
}
function AddReadonly2(schema) {
  return CreateType2({ ...schema, [ReadonlyKind2]: "Readonly" });
}
function ReadonlyWithFlag2(schema, F) {
  return F === false ? RemoveReadonly2(schema) : AddReadonly2(schema);
}
function Readonly2(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult3(schema) ? ReadonlyFromMappedResult2(schema, F) : ReadonlyWithFlag2(schema, F);
}

// node_modules/@sinclair/typebox/build/esm/type/readonly/readonly-from-mapped-result.mjs
function FromProperties20(K, F) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Readonly2(K[K2], F);
  return Acc;
}
function FromMappedResult14(R, F) {
  return FromProperties20(R.properties, F);
}
function ReadonlyFromMappedResult2(R, F) {
  const P = FromMappedResult14(R, F);
  return MappedResult2(P);
}

// node_modules/@sinclair/typebox/build/esm/type/tuple/tuple.mjs
function Tuple2(types, options) {
  return CreateType2(types.length > 0 ? { [Kind2]: "Tuple", type: "array", items: types, additionalItems: false, minItems: types.length, maxItems: types.length } : { [Kind2]: "Tuple", type: "array", minItems: types.length, maxItems: types.length }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/mapped/mapped.mjs
function FromMappedResult15(K, P) {
  return K in P ? FromSchemaType2(K, P[K]) : MappedResult2(P);
}
function MappedKeyToKnownMappedResultProperties2(K) {
  return { [K]: Literal2(K) };
}
function MappedKeyToUnknownMappedResultProperties2(P) {
  const Acc = {};
  for (const L of P)
    Acc[L] = Literal2(L);
  return Acc;
}
function MappedKeyToMappedResultProperties2(K, P) {
  return SetIncludes2(P, K) ? MappedKeyToKnownMappedResultProperties2(K) : MappedKeyToUnknownMappedResultProperties2(P);
}
function FromMappedKey5(K, P) {
  const R = MappedKeyToMappedResultProperties2(K, P);
  return FromMappedResult15(K, R);
}
function FromRest10(K, T) {
  return T.map((L) => FromSchemaType2(K, L));
}
function FromProperties21(K, T) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(T))
    Acc[K2] = FromSchemaType2(K, T[K2]);
  return Acc;
}
function FromSchemaType2(K, T) {
  const options = { ...T };
  return IsOptional3(T) ? Optional2(FromSchemaType2(K, Discard2(T, [OptionalKind2]))) : IsReadonly3(T) ? Readonly2(FromSchemaType2(K, Discard2(T, [ReadonlyKind2]))) : IsMappedResult3(T) ? FromMappedResult15(K, T.properties) : IsMappedKey3(T) ? FromMappedKey5(K, T.keys) : IsConstructor3(T) ? Constructor2(FromRest10(K, T.parameters), FromSchemaType2(K, T.returns), options) : IsFunction7(T) ? Function3(FromRest10(K, T.parameters), FromSchemaType2(K, T.returns), options) : IsAsyncIterator7(T) ? AsyncIterator2(FromSchemaType2(K, T.items), options) : IsIterator7(T) ? Iterator2(FromSchemaType2(K, T.items), options) : IsIntersect3(T) ? Intersect3(FromRest10(K, T.allOf), options) : IsUnion3(T) ? Union3(FromRest10(K, T.anyOf), options) : IsTuple3(T) ? Tuple2(FromRest10(K, T.items ?? []), options) : IsObject7(T) ? Object3(FromProperties21(K, T.properties), options) : IsArray7(T) ? Array3(FromSchemaType2(K, T.items), options) : IsPromise5(T) ? Promise3(FromSchemaType2(K, T.item), options) : T;
}
function MappedFunctionReturnType2(K, T) {
  const Acc = {};
  for (const L of K)
    Acc[L] = FromSchemaType2(L, T);
  return Acc;
}
function Mapped2(key, map5, options) {
  const K = IsSchema3(key) ? IndexPropertyKeys2(key) : key;
  const RT = map5({ [Kind2]: "MappedKey", keys: K });
  const R = MappedFunctionReturnType2(K, RT);
  return Object3(R, options);
}

// node_modules/@sinclair/typebox/build/esm/type/optional/optional.mjs
function RemoveOptional2(schema) {
  return CreateType2(Discard2(schema, [OptionalKind2]));
}
function AddOptional2(schema) {
  return CreateType2({ ...schema, [OptionalKind2]: "Optional" });
}
function OptionalWithFlag2(schema, F) {
  return F === false ? RemoveOptional2(schema) : AddOptional2(schema);
}
function Optional2(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult3(schema) ? OptionalFromMappedResult2(schema, F) : OptionalWithFlag2(schema, F);
}

// node_modules/@sinclair/typebox/build/esm/type/optional/optional-from-mapped-result.mjs
function FromProperties22(P, F) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Optional2(P[K2], F);
  return Acc;
}
function FromMappedResult16(R, F) {
  return FromProperties22(R.properties, F);
}
function OptionalFromMappedResult2(R, F) {
  const P = FromMappedResult16(R, F);
  return MappedResult2(P);
}

// node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-create.mjs
function IntersectCreate2(T, options = {}) {
  const allObjects = T.every((schema) => IsObject7(schema));
  const clonedUnevaluatedProperties = IsSchema3(options.unevaluatedProperties) ? { unevaluatedProperties: options.unevaluatedProperties } : {};
  return CreateType2(options.unevaluatedProperties === false || IsSchema3(options.unevaluatedProperties) || allObjects ? { ...clonedUnevaluatedProperties, [Kind2]: "Intersect", type: "object", allOf: T } : { ...clonedUnevaluatedProperties, [Kind2]: "Intersect", allOf: T }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-evaluated.mjs
function IsIntersectOptional2(types) {
  return types.every((left) => IsOptional3(left));
}
function RemoveOptionalFromType4(type) {
  return Discard2(type, [OptionalKind2]);
}
function RemoveOptionalFromRest4(types) {
  return types.map((left) => IsOptional3(left) ? RemoveOptionalFromType4(left) : left);
}
function ResolveIntersect2(types, options) {
  return IsIntersectOptional2(types) ? Optional2(IntersectCreate2(RemoveOptionalFromRest4(types), options)) : IntersectCreate2(RemoveOptionalFromRest4(types), options);
}
function IntersectEvaluated2(types, options = {}) {
  if (types.length === 1)
    return CreateType2(types[0], options);
  if (types.length === 0)
    return Never2(options);
  if (types.some((schema) => IsTransform3(schema)))
    throw new Error("Cannot intersect transform types");
  return ResolveIntersect2(types, options);
}

// node_modules/@sinclair/typebox/build/esm/type/intersect/intersect.mjs
function Intersect3(types, options) {
  if (types.length === 1)
    return CreateType2(types[0], options);
  if (types.length === 0)
    return Never2(options);
  if (types.some((schema) => IsTransform3(schema)))
    throw new Error("Cannot intersect transform types");
  return IntersectCreate2(types, options);
}

// node_modules/@sinclair/typebox/build/esm/type/ref/ref.mjs
function Ref2(...args) {
  const [$ref, options] = typeof args[0] === "string" ? [args[0], args[1]] : [args[0].$id, args[1]];
  if (typeof $ref !== "string")
    throw new TypeBoxError2("Ref: $ref must be a string");
  return CreateType2({ [Kind2]: "Ref", $ref }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/awaited/awaited.mjs
function FromComputed6(target, parameters) {
  return Computed2("Awaited", [Computed2(target, parameters)]);
}
function FromRef15($ref) {
  return Computed2("Awaited", [Ref2($ref)]);
}
function FromIntersect19(types) {
  return Intersect3(FromRest11(types));
}
function FromUnion23(types) {
  return Union3(FromRest11(types));
}
function FromPromise7(type) {
  return Awaited2(type);
}
function FromRest11(types) {
  return types.map((type) => Awaited2(type));
}
function Awaited2(type, options) {
  return CreateType2(IsComputed3(type) ? FromComputed6(type.target, type.parameters) : IsIntersect3(type) ? FromIntersect19(type.allOf) : IsUnion3(type) ? FromUnion23(type.anyOf) : IsPromise5(type) ? FromPromise7(type.item) : IsRef3(type) ? FromRef15(type.$ref) : type, options);
}

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-property-keys.mjs
function FromRest12(types) {
  const result = [];
  for (const L of types)
    result.push(KeyOfPropertyKeys2(L));
  return result;
}
function FromIntersect20(types) {
  const propertyKeysArray = FromRest12(types);
  const propertyKeys = SetUnionMany2(propertyKeysArray);
  return propertyKeys;
}
function FromUnion24(types) {
  const propertyKeysArray = FromRest12(types);
  const propertyKeys = SetIntersectMany2(propertyKeysArray);
  return propertyKeys;
}
function FromTuple16(types) {
  return types.map((_3, indexer) => indexer.toString());
}
function FromArray18(_3) {
  return ["[number]"];
}
function FromProperties23(T) {
  return globalThis.Object.getOwnPropertyNames(T);
}
function FromPatternProperties2(patternProperties) {
  if (!includePatternProperties2)
    return [];
  const patternPropertyKeys = globalThis.Object.getOwnPropertyNames(patternProperties);
  return patternPropertyKeys.map((key) => {
    return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
  });
}
function KeyOfPropertyKeys2(type) {
  return IsIntersect3(type) ? FromIntersect20(type.allOf) : IsUnion3(type) ? FromUnion24(type.anyOf) : IsTuple3(type) ? FromTuple16(type.items ?? []) : IsArray7(type) ? FromArray18(type.items) : IsObject7(type) ? FromProperties23(type.properties) : IsRecord3(type) ? FromPatternProperties2(type.patternProperties) : [];
}
var includePatternProperties2 = false;
function KeyOfPattern2(schema) {
  includePatternProperties2 = true;
  const keys = KeyOfPropertyKeys2(schema);
  includePatternProperties2 = false;
  const pattern = keys.map((key) => `(${key})`);
  return `^(${pattern.join("|")})$`;
}

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof.mjs
function FromComputed7(target, parameters) {
  return Computed2("KeyOf", [Computed2(target, parameters)]);
}
function FromRef16($ref) {
  return Computed2("KeyOf", [Ref2($ref)]);
}
function KeyOfFromType2(type, options) {
  const propertyKeys = KeyOfPropertyKeys2(type);
  const propertyKeyTypes = KeyOfPropertyKeysToRest2(propertyKeys);
  const result = UnionEvaluated2(propertyKeyTypes);
  return CreateType2(result, options);
}
function KeyOfPropertyKeysToRest2(propertyKeys) {
  return propertyKeys.map((L) => L === "[number]" ? Number3() : Literal2(L));
}
function KeyOf2(type, options) {
  return IsComputed3(type) ? FromComputed7(type.target, type.parameters) : IsRef3(type) ? FromRef16(type.$ref) : IsMappedResult3(type) ? KeyOfFromMappedResult2(type, options) : KeyOfFromType2(type, options);
}

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-from-mapped-result.mjs
function FromProperties24(properties, options) {
  const result = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
    result[K2] = KeyOf2(properties[K2], Clone3(options));
  return result;
}
function FromMappedResult17(mappedResult, options) {
  return FromProperties24(mappedResult.properties, options);
}
function KeyOfFromMappedResult2(mappedResult, options) {
  const properties = FromMappedResult17(mappedResult, options);
  return MappedResult2(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-property-entries.mjs
function KeyOfPropertyEntries2(schema) {
  const keys = KeyOfPropertyKeys2(schema);
  const schemas = IndexFromPropertyKeys2(schema, keys);
  return keys.map((_3, index) => [keys[index], schemas[index]]);
}

// node_modules/@sinclair/typebox/build/esm/type/composite/composite.mjs
function CompositeKeys2(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...KeyOfPropertyKeys2(L));
  return SetDistinct2(Acc);
}
function FilterNever2(T) {
  return T.filter((L) => !IsNever3(L));
}
function CompositeProperty2(T, K) {
  const Acc = [];
  for (const L of T)
    Acc.push(...IndexFromPropertyKeys2(L, [K]));
  return FilterNever2(Acc);
}
function CompositeProperties2(T, K) {
  const Acc = {};
  for (const L of K) {
    Acc[L] = IntersectEvaluated2(CompositeProperty2(T, L));
  }
  return Acc;
}
function Composite2(T, options) {
  const K = CompositeKeys2(T);
  const P = CompositeProperties2(T, K);
  const R = Object3(P, options);
  return R;
}

// node_modules/@sinclair/typebox/build/esm/type/date/date.mjs
function Date3(options) {
  return CreateType2({ [Kind2]: "Date", type: "Date" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/null/null.mjs
function Null2(options) {
  return CreateType2({ [Kind2]: "Null", type: "null" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/symbol/symbol.mjs
function Symbol3(options) {
  return CreateType2({ [Kind2]: "Symbol", type: "symbol" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/undefined/undefined.mjs
function Undefined2(options) {
  return CreateType2({ [Kind2]: "Undefined", type: "undefined" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/uint8array/uint8array.mjs
function Uint8Array3(options) {
  return CreateType2({ [Kind2]: "Uint8Array", type: "Uint8Array" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/unknown/unknown.mjs
function Unknown2(options) {
  return CreateType2({ [Kind2]: "Unknown" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/const/const.mjs
function FromArray19(T) {
  return T.map((L) => FromValue3(L, false));
}
function FromProperties25(value) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(value))
    Acc[K] = Readonly2(FromValue3(value[K], false));
  return Acc;
}
function ConditionalReadonly2(T, root) {
  return root === true ? T : Readonly2(T);
}
function FromValue3(value, root) {
  return IsAsyncIterator5(value) ? ConditionalReadonly2(Any2(), root) : IsIterator5(value) ? ConditionalReadonly2(Any2(), root) : IsArray5(value) ? Readonly2(Tuple2(FromArray19(value))) : IsUint8Array5(value) ? Uint8Array3() : IsDate5(value) ? Date3() : IsObject5(value) ? ConditionalReadonly2(Object3(FromProperties25(value)), root) : IsFunction5(value) ? ConditionalReadonly2(Function3([], Unknown2()), root) : IsUndefined5(value) ? Undefined2() : IsNull5(value) ? Null2() : IsSymbol5(value) ? Symbol3() : IsBigInt5(value) ? BigInt3() : IsNumber5(value) ? Literal2(value) : IsBoolean5(value) ? Literal2(value) : IsString5(value) ? Literal2(value) : Object3({});
}
function Const2(T, options) {
  return CreateType2(FromValue3(T, true), options);
}

// node_modules/@sinclair/typebox/build/esm/type/constructor-parameters/constructor-parameters.mjs
function ConstructorParameters2(schema, options) {
  return Tuple2(schema.parameters, options);
}

// node_modules/@sinclair/typebox/build/esm/type/enum/enum.mjs
function Enum2(item, options) {
  if (IsUndefined5(item))
    throw new Error("Enum undefined or empty");
  const values1 = globalThis.Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
  const values2 = [...new Set(values1)];
  const anyOf = values2.map((value) => Literal2(value));
  return Union3(anyOf, { ...options, [Hint2]: "Enum" });
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends-check.mjs
class ExtendsResolverError2 extends TypeBoxError2 {
}
var ExtendsResult2;
(function(ExtendsResult3) {
  ExtendsResult3[ExtendsResult3["Union"] = 0] = "Union";
  ExtendsResult3[ExtendsResult3["True"] = 1] = "True";
  ExtendsResult3[ExtendsResult3["False"] = 2] = "False";
})(ExtendsResult2 || (ExtendsResult2 = {}));
function IntoBooleanResult2(result) {
  return result === ExtendsResult2.False ? result : ExtendsResult2.True;
}
function Throw2(message) {
  throw new ExtendsResolverError2(message);
}
function IsStructuralRight2(right) {
  return exports_type4.IsNever(right) || exports_type4.IsIntersect(right) || exports_type4.IsUnion(right) || exports_type4.IsUnknown(right) || exports_type4.IsAny(right);
}
function StructuralRight2(left, right) {
  return exports_type4.IsNever(right) ? FromNeverRight2(left, right) : exports_type4.IsIntersect(right) ? FromIntersectRight2(left, right) : exports_type4.IsUnion(right) ? FromUnionRight2(left, right) : exports_type4.IsUnknown(right) ? FromUnknownRight2(left, right) : exports_type4.IsAny(right) ? FromAnyRight2(left, right) : Throw2("StructuralRight");
}
function FromAnyRight2(left, right) {
  return ExtendsResult2.True;
}
function FromAny5(left, right) {
  return exports_type4.IsIntersect(right) ? FromIntersectRight2(left, right) : exports_type4.IsUnion(right) && right.anyOf.some((schema) => exports_type4.IsAny(schema) || exports_type4.IsUnknown(schema)) ? ExtendsResult2.True : exports_type4.IsUnion(right) ? ExtendsResult2.Union : exports_type4.IsUnknown(right) ? ExtendsResult2.True : exports_type4.IsAny(right) ? ExtendsResult2.True : ExtendsResult2.Union;
}
function FromArrayRight2(left, right) {
  return exports_type4.IsUnknown(left) ? ExtendsResult2.False : exports_type4.IsAny(left) ? ExtendsResult2.Union : exports_type4.IsNever(left) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromArray20(left, right) {
  return exports_type4.IsObject(right) && IsObjectArrayLike2(right) ? ExtendsResult2.True : IsStructuralRight2(right) ? StructuralRight2(left, right) : !exports_type4.IsArray(right) ? ExtendsResult2.False : IntoBooleanResult2(Visit19(left.items, right.items));
}
function FromAsyncIterator7(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : !exports_type4.IsAsyncIterator(right) ? ExtendsResult2.False : IntoBooleanResult2(Visit19(left.items, right.items));
}
function FromBigInt6(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type4.IsObject(right) ? FromObjectRight2(left, right) : exports_type4.IsRecord(right) ? FromRecordRight2(left, right) : exports_type4.IsBigInt(right) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromBooleanRight2(left, right) {
  return exports_type4.IsLiteralBoolean(left) ? ExtendsResult2.True : exports_type4.IsBoolean(left) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromBoolean6(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type4.IsObject(right) ? FromObjectRight2(left, right) : exports_type4.IsRecord(right) ? FromRecordRight2(left, right) : exports_type4.IsBoolean(right) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromConstructor8(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type4.IsObject(right) ? FromObjectRight2(left, right) : !exports_type4.IsConstructor(right) ? ExtendsResult2.False : left.parameters.length > right.parameters.length ? ExtendsResult2.False : !left.parameters.every((schema, index) => IntoBooleanResult2(Visit19(right.parameters[index], schema)) === ExtendsResult2.True) ? ExtendsResult2.False : IntoBooleanResult2(Visit19(left.returns, right.returns));
}
function FromDate8(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type4.IsObject(right) ? FromObjectRight2(left, right) : exports_type4.IsRecord(right) ? FromRecordRight2(left, right) : exports_type4.IsDate(right) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromFunction7(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type4.IsObject(right) ? FromObjectRight2(left, right) : !exports_type4.IsFunction(right) ? ExtendsResult2.False : left.parameters.length > right.parameters.length ? ExtendsResult2.False : !left.parameters.every((schema, index) => IntoBooleanResult2(Visit19(right.parameters[index], schema)) === ExtendsResult2.True) ? ExtendsResult2.False : IntoBooleanResult2(Visit19(left.returns, right.returns));
}
function FromIntegerRight2(left, right) {
  return exports_type4.IsLiteral(left) && exports_value3.IsNumber(left.const) ? ExtendsResult2.True : exports_type4.IsNumber(left) || exports_type4.IsInteger(left) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromInteger6(left, right) {
  return exports_type4.IsInteger(right) || exports_type4.IsNumber(right) ? ExtendsResult2.True : IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type4.IsObject(right) ? FromObjectRight2(left, right) : exports_type4.IsRecord(right) ? FromRecordRight2(left, right) : ExtendsResult2.False;
}
function FromIntersectRight2(left, right) {
  return right.allOf.every((schema) => Visit19(left, schema) === ExtendsResult2.True) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromIntersect21(left, right) {
  return left.allOf.some((schema) => Visit19(schema, right) === ExtendsResult2.True) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromIterator7(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : !exports_type4.IsIterator(right) ? ExtendsResult2.False : IntoBooleanResult2(Visit19(left.items, right.items));
}
function FromLiteral8(left, right) {
  return exports_type4.IsLiteral(right) && right.const === left.const ? ExtendsResult2.True : IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type4.IsObject(right) ? FromObjectRight2(left, right) : exports_type4.IsRecord(right) ? FromRecordRight2(left, right) : exports_type4.IsString(right) ? FromStringRight2(left, right) : exports_type4.IsNumber(right) ? FromNumberRight2(left, right) : exports_type4.IsInteger(right) ? FromIntegerRight2(left, right) : exports_type4.IsBoolean(right) ? FromBooleanRight2(left, right) : ExtendsResult2.False;
}
function FromNeverRight2(left, right) {
  return ExtendsResult2.False;
}
function FromNever6(left, right) {
  return ExtendsResult2.True;
}
function UnwrapTNot2(schema) {
  let [current, depth] = [schema, 0];
  while (true) {
    if (!exports_type4.IsNot(current))
      break;
    current = current.not;
    depth += 1;
  }
  return depth % 2 === 0 ? current : Unknown2();
}
function FromNot8(left, right) {
  return exports_type4.IsNot(left) ? Visit19(UnwrapTNot2(left), right) : exports_type4.IsNot(right) ? Visit19(left, UnwrapTNot2(right)) : Throw2("Invalid fallthrough for Not");
}
function FromNull6(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type4.IsObject(right) ? FromObjectRight2(left, right) : exports_type4.IsRecord(right) ? FromRecordRight2(left, right) : exports_type4.IsNull(right) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromNumberRight2(left, right) {
  return exports_type4.IsLiteralNumber(left) ? ExtendsResult2.True : exports_type4.IsNumber(left) || exports_type4.IsInteger(left) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromNumber6(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type4.IsObject(right) ? FromObjectRight2(left, right) : exports_type4.IsRecord(right) ? FromRecordRight2(left, right) : exports_type4.IsInteger(right) || exports_type4.IsNumber(right) ? ExtendsResult2.True : ExtendsResult2.False;
}
function IsObjectPropertyCount2(schema, count) {
  return Object.getOwnPropertyNames(schema.properties).length === count;
}
function IsObjectStringLike2(schema) {
  return IsObjectArrayLike2(schema);
}
function IsObjectSymbolLike2(schema) {
  return IsObjectPropertyCount2(schema, 0) || IsObjectPropertyCount2(schema, 1) && "description" in schema.properties && exports_type4.IsUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (exports_type4.IsString(schema.properties.description.anyOf[0]) && exports_type4.IsUndefined(schema.properties.description.anyOf[1]) || exports_type4.IsString(schema.properties.description.anyOf[1]) && exports_type4.IsUndefined(schema.properties.description.anyOf[0]));
}
function IsObjectNumberLike2(schema) {
  return IsObjectPropertyCount2(schema, 0);
}
function IsObjectBooleanLike2(schema) {
  return IsObjectPropertyCount2(schema, 0);
}
function IsObjectBigIntLike2(schema) {
  return IsObjectPropertyCount2(schema, 0);
}
function IsObjectDateLike2(schema) {
  return IsObjectPropertyCount2(schema, 0);
}
function IsObjectUint8ArrayLike2(schema) {
  return IsObjectArrayLike2(schema);
}
function IsObjectFunctionLike2(schema) {
  const length = Number3();
  return IsObjectPropertyCount2(schema, 0) || IsObjectPropertyCount2(schema, 1) && "length" in schema.properties && IntoBooleanResult2(Visit19(schema.properties["length"], length)) === ExtendsResult2.True;
}
function IsObjectConstructorLike2(schema) {
  return IsObjectPropertyCount2(schema, 0);
}
function IsObjectArrayLike2(schema) {
  const length = Number3();
  return IsObjectPropertyCount2(schema, 0) || IsObjectPropertyCount2(schema, 1) && "length" in schema.properties && IntoBooleanResult2(Visit19(schema.properties["length"], length)) === ExtendsResult2.True;
}
function IsObjectPromiseLike2(schema) {
  const then = Function3([Any2()], Any2());
  return IsObjectPropertyCount2(schema, 0) || IsObjectPropertyCount2(schema, 1) && "then" in schema.properties && IntoBooleanResult2(Visit19(schema.properties["then"], then)) === ExtendsResult2.True;
}
function Property2(left, right) {
  return Visit19(left, right) === ExtendsResult2.False ? ExtendsResult2.False : exports_type4.IsOptional(left) && !exports_type4.IsOptional(right) ? ExtendsResult2.False : ExtendsResult2.True;
}
function FromObjectRight2(left, right) {
  return exports_type4.IsUnknown(left) ? ExtendsResult2.False : exports_type4.IsAny(left) ? ExtendsResult2.Union : exports_type4.IsNever(left) || exports_type4.IsLiteralString(left) && IsObjectStringLike2(right) || exports_type4.IsLiteralNumber(left) && IsObjectNumberLike2(right) || exports_type4.IsLiteralBoolean(left) && IsObjectBooleanLike2(right) || exports_type4.IsSymbol(left) && IsObjectSymbolLike2(right) || exports_type4.IsBigInt(left) && IsObjectBigIntLike2(right) || exports_type4.IsString(left) && IsObjectStringLike2(right) || exports_type4.IsSymbol(left) && IsObjectSymbolLike2(right) || exports_type4.IsNumber(left) && IsObjectNumberLike2(right) || exports_type4.IsInteger(left) && IsObjectNumberLike2(right) || exports_type4.IsBoolean(left) && IsObjectBooleanLike2(right) || exports_type4.IsUint8Array(left) && IsObjectUint8ArrayLike2(right) || exports_type4.IsDate(left) && IsObjectDateLike2(right) || exports_type4.IsConstructor(left) && IsObjectConstructorLike2(right) || exports_type4.IsFunction(left) && IsObjectFunctionLike2(right) ? ExtendsResult2.True : exports_type4.IsRecord(left) && exports_type4.IsString(RecordKey2(left)) ? (() => {
    return right[Hint2] === "Record" ? ExtendsResult2.True : ExtendsResult2.False;
  })() : exports_type4.IsRecord(left) && exports_type4.IsNumber(RecordKey2(left)) ? (() => {
    return IsObjectPropertyCount2(right, 0) ? ExtendsResult2.True : ExtendsResult2.False;
  })() : ExtendsResult2.False;
}
function FromObject18(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type4.IsRecord(right) ? FromRecordRight2(left, right) : !exports_type4.IsObject(right) ? ExtendsResult2.False : (() => {
    for (const key of Object.getOwnPropertyNames(right.properties)) {
      if (!(key in left.properties) && !exports_type4.IsOptional(right.properties[key])) {
        return ExtendsResult2.False;
      }
      if (exports_type4.IsOptional(right.properties[key])) {
        return ExtendsResult2.True;
      }
      if (Property2(left.properties[key], right.properties[key]) === ExtendsResult2.False) {
        return ExtendsResult2.False;
      }
    }
    return ExtendsResult2.True;
  })();
}
function FromPromise8(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type4.IsObject(right) && IsObjectPromiseLike2(right) ? ExtendsResult2.True : !exports_type4.IsPromise(right) ? ExtendsResult2.False : IntoBooleanResult2(Visit19(left.item, right.item));
}
function RecordKey2(schema) {
  return PatternNumberExact2 in schema.patternProperties ? Number3() : (PatternStringExact2 in schema.patternProperties) ? String3() : Throw2("Unknown record key pattern");
}
function RecordValue2(schema) {
  return PatternNumberExact2 in schema.patternProperties ? schema.patternProperties[PatternNumberExact2] : (PatternStringExact2 in schema.patternProperties) ? schema.patternProperties[PatternStringExact2] : Throw2("Unable to get record value schema");
}
function FromRecordRight2(left, right) {
  const [Key, Value] = [RecordKey2(right), RecordValue2(right)];
  return exports_type4.IsLiteralString(left) && exports_type4.IsNumber(Key) && IntoBooleanResult2(Visit19(left, Value)) === ExtendsResult2.True ? ExtendsResult2.True : exports_type4.IsUint8Array(left) && exports_type4.IsNumber(Key) ? Visit19(left, Value) : exports_type4.IsString(left) && exports_type4.IsNumber(Key) ? Visit19(left, Value) : exports_type4.IsArray(left) && exports_type4.IsNumber(Key) ? Visit19(left, Value) : exports_type4.IsObject(left) ? (() => {
    for (const key of Object.getOwnPropertyNames(left.properties)) {
      if (Property2(Value, left.properties[key]) === ExtendsResult2.False) {
        return ExtendsResult2.False;
      }
    }
    return ExtendsResult2.True;
  })() : ExtendsResult2.False;
}
function FromRecord13(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type4.IsObject(right) ? FromObjectRight2(left, right) : !exports_type4.IsRecord(right) ? ExtendsResult2.False : Visit19(RecordValue2(left), RecordValue2(right));
}
function FromRegExp5(left, right) {
  const L = exports_type4.IsRegExp(left) ? String3() : left;
  const R = exports_type4.IsRegExp(right) ? String3() : right;
  return Visit19(L, R);
}
function FromStringRight2(left, right) {
  return exports_type4.IsLiteral(left) && exports_value3.IsString(left.const) ? ExtendsResult2.True : exports_type4.IsString(left) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromString6(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type4.IsObject(right) ? FromObjectRight2(left, right) : exports_type4.IsRecord(right) ? FromRecordRight2(left, right) : exports_type4.IsString(right) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromSymbol6(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type4.IsObject(right) ? FromObjectRight2(left, right) : exports_type4.IsRecord(right) ? FromRecordRight2(left, right) : exports_type4.IsSymbol(right) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromTemplateLiteral8(left, right) {
  return exports_type4.IsTemplateLiteral(left) ? Visit19(TemplateLiteralToUnion2(left), right) : exports_type4.IsTemplateLiteral(right) ? Visit19(left, TemplateLiteralToUnion2(right)) : Throw2("Invalid fallthrough for TemplateLiteral");
}
function IsArrayOfTuple2(left, right) {
  return exports_type4.IsArray(right) && left.items !== undefined && left.items.every((schema) => Visit19(schema, right.items) === ExtendsResult2.True);
}
function FromTupleRight2(left, right) {
  return exports_type4.IsNever(left) ? ExtendsResult2.True : exports_type4.IsUnknown(left) ? ExtendsResult2.False : exports_type4.IsAny(left) ? ExtendsResult2.Union : ExtendsResult2.False;
}
function FromTuple17(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type4.IsObject(right) && IsObjectArrayLike2(right) ? ExtendsResult2.True : exports_type4.IsArray(right) && IsArrayOfTuple2(left, right) ? ExtendsResult2.True : !exports_type4.IsTuple(right) ? ExtendsResult2.False : exports_value3.IsUndefined(left.items) && !exports_value3.IsUndefined(right.items) || !exports_value3.IsUndefined(left.items) && exports_value3.IsUndefined(right.items) ? ExtendsResult2.False : exports_value3.IsUndefined(left.items) && !exports_value3.IsUndefined(right.items) ? ExtendsResult2.True : left.items.every((schema, index) => Visit19(schema, right.items[index]) === ExtendsResult2.True) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromUint8Array5(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type4.IsObject(right) ? FromObjectRight2(left, right) : exports_type4.IsRecord(right) ? FromRecordRight2(left, right) : exports_type4.IsUint8Array(right) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromUndefined6(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : exports_type4.IsObject(right) ? FromObjectRight2(left, right) : exports_type4.IsRecord(right) ? FromRecordRight2(left, right) : exports_type4.IsVoid(right) ? FromVoidRight2(left, right) : exports_type4.IsUndefined(right) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromUnionRight2(left, right) {
  return right.anyOf.some((schema) => Visit19(left, schema) === ExtendsResult2.True) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromUnion25(left, right) {
  return left.anyOf.every((schema) => Visit19(schema, right) === ExtendsResult2.True) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromUnknownRight2(left, right) {
  return ExtendsResult2.True;
}
function FromUnknown5(left, right) {
  return exports_type4.IsNever(right) ? FromNeverRight2(left, right) : exports_type4.IsIntersect(right) ? FromIntersectRight2(left, right) : exports_type4.IsUnion(right) ? FromUnionRight2(left, right) : exports_type4.IsAny(right) ? FromAnyRight2(left, right) : exports_type4.IsString(right) ? FromStringRight2(left, right) : exports_type4.IsNumber(right) ? FromNumberRight2(left, right) : exports_type4.IsInteger(right) ? FromIntegerRight2(left, right) : exports_type4.IsBoolean(right) ? FromBooleanRight2(left, right) : exports_type4.IsArray(right) ? FromArrayRight2(left, right) : exports_type4.IsTuple(right) ? FromTupleRight2(left, right) : exports_type4.IsObject(right) ? FromObjectRight2(left, right) : exports_type4.IsUnknown(right) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromVoidRight2(left, right) {
  return exports_type4.IsUndefined(left) ? ExtendsResult2.True : exports_type4.IsUndefined(left) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromVoid5(left, right) {
  return exports_type4.IsIntersect(right) ? FromIntersectRight2(left, right) : exports_type4.IsUnion(right) ? FromUnionRight2(left, right) : exports_type4.IsUnknown(right) ? FromUnknownRight2(left, right) : exports_type4.IsAny(right) ? FromAnyRight2(left, right) : exports_type4.IsObject(right) ? FromObjectRight2(left, right) : exports_type4.IsVoid(right) ? ExtendsResult2.True : ExtendsResult2.False;
}
function Visit19(left, right) {
  return exports_type4.IsTemplateLiteral(left) || exports_type4.IsTemplateLiteral(right) ? FromTemplateLiteral8(left, right) : exports_type4.IsRegExp(left) || exports_type4.IsRegExp(right) ? FromRegExp5(left, right) : exports_type4.IsNot(left) || exports_type4.IsNot(right) ? FromNot8(left, right) : exports_type4.IsAny(left) ? FromAny5(left, right) : exports_type4.IsArray(left) ? FromArray20(left, right) : exports_type4.IsBigInt(left) ? FromBigInt6(left, right) : exports_type4.IsBoolean(left) ? FromBoolean6(left, right) : exports_type4.IsAsyncIterator(left) ? FromAsyncIterator7(left, right) : exports_type4.IsConstructor(left) ? FromConstructor8(left, right) : exports_type4.IsDate(left) ? FromDate8(left, right) : exports_type4.IsFunction(left) ? FromFunction7(left, right) : exports_type4.IsInteger(left) ? FromInteger6(left, right) : exports_type4.IsIntersect(left) ? FromIntersect21(left, right) : exports_type4.IsIterator(left) ? FromIterator7(left, right) : exports_type4.IsLiteral(left) ? FromLiteral8(left, right) : exports_type4.IsNever(left) ? FromNever6(left, right) : exports_type4.IsNull(left) ? FromNull6(left, right) : exports_type4.IsNumber(left) ? FromNumber6(left, right) : exports_type4.IsObject(left) ? FromObject18(left, right) : exports_type4.IsRecord(left) ? FromRecord13(left, right) : exports_type4.IsString(left) ? FromString6(left, right) : exports_type4.IsSymbol(left) ? FromSymbol6(left, right) : exports_type4.IsTuple(left) ? FromTuple17(left, right) : exports_type4.IsPromise(left) ? FromPromise8(left, right) : exports_type4.IsUint8Array(left) ? FromUint8Array5(left, right) : exports_type4.IsUndefined(left) ? FromUndefined6(left, right) : exports_type4.IsUnion(left) ? FromUnion25(left, right) : exports_type4.IsUnknown(left) ? FromUnknown5(left, right) : exports_type4.IsVoid(left) ? FromVoid5(left, right) : Throw2(`Unknown left type operand '${left[Kind2]}'`);
}
function ExtendsCheck2(left, right) {
  return Visit19(left, right);
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-result.mjs
function FromProperties26(P, Right, True, False, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Extends2(P[K2], Right, True, False, Clone3(options));
  return Acc;
}
function FromMappedResult18(Left, Right, True, False, options) {
  return FromProperties26(Left.properties, Right, True, False, options);
}
function ExtendsFromMappedResult2(Left, Right, True, False, options) {
  const P = FromMappedResult18(Left, Right, True, False, options);
  return MappedResult2(P);
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends.mjs
function ExtendsResolve2(left, right, trueType, falseType) {
  const R = ExtendsCheck2(left, right);
  return R === ExtendsResult2.Union ? Union3([trueType, falseType]) : R === ExtendsResult2.True ? trueType : falseType;
}
function Extends2(L, R, T, F, options) {
  return IsMappedResult3(L) ? ExtendsFromMappedResult2(L, R, T, F, options) : IsMappedKey3(L) ? CreateType2(ExtendsFromMappedKey2(L, R, T, F, options)) : CreateType2(ExtendsResolve2(L, R, T, F), options);
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-key.mjs
function FromPropertyKey4(K, U3, L, R, options) {
  return {
    [K]: Extends2(Literal2(K), U3, L, R, Clone3(options))
  };
}
function FromPropertyKeys4(K, U3, L, R, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey4(LK, U3, L, R, options) };
  }, {});
}
function FromMappedKey6(K, U3, L, R, options) {
  return FromPropertyKeys4(K.keys, U3, L, R, options);
}
function ExtendsFromMappedKey2(T, U3, L, R, options) {
  const P = FromMappedKey6(T, U3, L, R, options);
  return MappedResult2(P);
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends-undefined.mjs
function Intersect4(schema) {
  return schema.allOf.every((schema2) => ExtendsUndefinedCheck2(schema2));
}
function Union4(schema) {
  return schema.anyOf.some((schema2) => ExtendsUndefinedCheck2(schema2));
}
function Not3(schema) {
  return !ExtendsUndefinedCheck2(schema.not);
}
function ExtendsUndefinedCheck2(schema) {
  return schema[Kind2] === "Intersect" ? Intersect4(schema) : schema[Kind2] === "Union" ? Union4(schema) : schema[Kind2] === "Not" ? Not3(schema) : schema[Kind2] === "Undefined" ? true : false;
}

// node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-template-literal.mjs
function ExcludeFromTemplateLiteral2(L, R) {
  return Exclude2(TemplateLiteralToUnion2(L), R);
}

// node_modules/@sinclair/typebox/build/esm/type/exclude/exclude.mjs
function ExcludeRest2(L, R) {
  const excluded = L.filter((inner) => ExtendsCheck2(inner, R) === ExtendsResult2.False);
  return excluded.length === 1 ? excluded[0] : Union3(excluded);
}
function Exclude2(L, R, options = {}) {
  if (IsTemplateLiteral3(L))
    return CreateType2(ExcludeFromTemplateLiteral2(L, R), options);
  if (IsMappedResult3(L))
    return CreateType2(ExcludeFromMappedResult2(L, R), options);
  return CreateType2(IsUnion3(L) ? ExcludeRest2(L.anyOf, R) : ExtendsCheck2(L, R) !== ExtendsResult2.False ? Never2() : L, options);
}

// node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-mapped-result.mjs
function FromProperties27(P, U3) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Exclude2(P[K2], U3);
  return Acc;
}
function FromMappedResult19(R, T) {
  return FromProperties27(R.properties, T);
}
function ExcludeFromMappedResult2(R, T) {
  const P = FromMappedResult19(R, T);
  return MappedResult2(P);
}

// node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-template-literal.mjs
function ExtractFromTemplateLiteral2(L, R) {
  return Extract2(TemplateLiteralToUnion2(L), R);
}

// node_modules/@sinclair/typebox/build/esm/type/extract/extract.mjs
function ExtractRest2(L, R) {
  const extracted = L.filter((inner) => ExtendsCheck2(inner, R) !== ExtendsResult2.False);
  return extracted.length === 1 ? extracted[0] : Union3(extracted);
}
function Extract2(L, R, options) {
  if (IsTemplateLiteral3(L))
    return CreateType2(ExtractFromTemplateLiteral2(L, R), options);
  if (IsMappedResult3(L))
    return CreateType2(ExtractFromMappedResult2(L, R), options);
  return CreateType2(IsUnion3(L) ? ExtractRest2(L.anyOf, R) : ExtendsCheck2(L, R) !== ExtendsResult2.False ? L : Never2(), options);
}

// node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-mapped-result.mjs
function FromProperties28(P, T) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Extract2(P[K2], T);
  return Acc;
}
function FromMappedResult20(R, T) {
  return FromProperties28(R.properties, T);
}
function ExtractFromMappedResult2(R, T) {
  const P = FromMappedResult20(R, T);
  return MappedResult2(P);
}

// node_modules/@sinclair/typebox/build/esm/type/instance-type/instance-type.mjs
function InstanceType2(schema, options) {
  return CreateType2(schema.returns, options);
}

// node_modules/@sinclair/typebox/build/esm/type/integer/integer.mjs
function Integer2(options) {
  return CreateType2({ [Kind2]: "Integer", type: "integer" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic-from-mapped-key.mjs
function MappedIntrinsicPropertyKey2(K, M, options) {
  return {
    [K]: Intrinsic2(Literal2(K), M, Clone3(options))
  };
}
function MappedIntrinsicPropertyKeys2(K, M, options) {
  const result = K.reduce((Acc, L) => {
    return { ...Acc, ...MappedIntrinsicPropertyKey2(L, M, options) };
  }, {});
  return result;
}
function MappedIntrinsicProperties2(T, M, options) {
  return MappedIntrinsicPropertyKeys2(T["keys"], M, options);
}
function IntrinsicFromMappedKey2(T, M, options) {
  const P = MappedIntrinsicProperties2(T, M, options);
  return MappedResult2(P);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic.mjs
function ApplyUncapitalize2(value) {
  const [first, rest] = [value.slice(0, 1), value.slice(1)];
  return [first.toLowerCase(), rest].join("");
}
function ApplyCapitalize2(value) {
  const [first, rest] = [value.slice(0, 1), value.slice(1)];
  return [first.toUpperCase(), rest].join("");
}
function ApplyUppercase2(value) {
  return value.toUpperCase();
}
function ApplyLowercase2(value) {
  return value.toLowerCase();
}
function FromTemplateLiteral9(schema, mode, options) {
  const expression = TemplateLiteralParseExact2(schema.pattern);
  const finite = IsTemplateLiteralExpressionFinite2(expression);
  if (!finite)
    return { ...schema, pattern: FromLiteralValue2(schema.pattern, mode) };
  const strings = [...TemplateLiteralExpressionGenerate2(expression)];
  const literals = strings.map((value) => Literal2(value));
  const mapped = FromRest13(literals, mode);
  const union = Union3(mapped);
  return TemplateLiteral2([union], options);
}
function FromLiteralValue2(value, mode) {
  return typeof value === "string" ? mode === "Uncapitalize" ? ApplyUncapitalize2(value) : mode === "Capitalize" ? ApplyCapitalize2(value) : mode === "Uppercase" ? ApplyUppercase2(value) : mode === "Lowercase" ? ApplyLowercase2(value) : value : value.toString();
}
function FromRest13(T, M) {
  return T.map((L) => Intrinsic2(L, M));
}
function Intrinsic2(schema, mode, options = {}) {
  return IsMappedKey3(schema) ? IntrinsicFromMappedKey2(schema, mode, options) : IsTemplateLiteral3(schema) ? FromTemplateLiteral9(schema, mode, options) : IsUnion3(schema) ? Union3(FromRest13(schema.anyOf, mode), options) : IsLiteral3(schema) ? Literal2(FromLiteralValue2(schema.const, mode), options) : CreateType2(schema, options);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/capitalize.mjs
function Capitalize2(T, options = {}) {
  return Intrinsic2(T, "Capitalize", options);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/lowercase.mjs
function Lowercase2(T, options = {}) {
  return Intrinsic2(T, "Lowercase", options);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/uncapitalize.mjs
function Uncapitalize2(T, options = {}) {
  return Intrinsic2(T, "Uncapitalize", options);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/uppercase.mjs
function Uppercase2(T, options = {}) {
  return Intrinsic2(T, "Uppercase", options);
}

// node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-result.mjs
function FromProperties29(properties, propertyKeys, options) {
  const result = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
    result[K2] = Omit2(properties[K2], propertyKeys, Clone3(options));
  return result;
}
function FromMappedResult21(mappedResult, propertyKeys, options) {
  return FromProperties29(mappedResult.properties, propertyKeys, options);
}
function OmitFromMappedResult2(mappedResult, propertyKeys, options) {
  const properties = FromMappedResult21(mappedResult, propertyKeys, options);
  return MappedResult2(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/omit/omit.mjs
function FromIntersect22(types, propertyKeys) {
  return types.map((type) => OmitResolve2(type, propertyKeys));
}
function FromUnion26(types, propertyKeys) {
  return types.map((type) => OmitResolve2(type, propertyKeys));
}
function FromProperty4(properties, key) {
  const { [key]: _3, ...R } = properties;
  return R;
}
function FromProperties30(properties, propertyKeys) {
  return propertyKeys.reduce((T, K2) => FromProperty4(T, K2), properties);
}
function FromObject19(properties, propertyKeys) {
  const options = Discard2(properties, [TransformKind2, "$id", "required", "properties"]);
  const omittedProperties = FromProperties30(properties["properties"], propertyKeys);
  return Object3(omittedProperties, options);
}
function UnionFromPropertyKeys3(propertyKeys) {
  const result = propertyKeys.reduce((result2, key) => IsLiteralValue3(key) ? [...result2, Literal2(key)] : result2, []);
  return Union3(result);
}
function OmitResolve2(properties, propertyKeys) {
  return IsIntersect3(properties) ? Intersect3(FromIntersect22(properties.allOf, propertyKeys)) : IsUnion3(properties) ? Union3(FromUnion26(properties.anyOf, propertyKeys)) : IsObject7(properties) ? FromObject19(properties, propertyKeys) : Object3({});
}
function Omit2(type, key, options) {
  const typeKey = IsArray5(key) ? UnionFromPropertyKeys3(key) : key;
  const propertyKeys = IsSchema3(key) ? IndexPropertyKeys2(key) : key;
  const isTypeRef = IsRef3(type);
  const isKeyRef = IsRef3(key);
  return IsMappedResult3(type) ? OmitFromMappedResult2(type, propertyKeys, options) : IsMappedKey3(key) ? OmitFromMappedKey2(type, key, options) : isTypeRef && isKeyRef ? Computed2("Omit", [type, typeKey], options) : !isTypeRef && isKeyRef ? Computed2("Omit", [type, typeKey], options) : isTypeRef && !isKeyRef ? Computed2("Omit", [type, typeKey], options) : CreateType2({ ...OmitResolve2(type, propertyKeys), ...options });
}

// node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-key.mjs
function FromPropertyKey5(type, key, options) {
  return { [key]: Omit2(type, [key], Clone3(options)) };
}
function FromPropertyKeys5(type, propertyKeys, options) {
  return propertyKeys.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey5(type, LK, options) };
  }, {});
}
function FromMappedKey7(type, mappedKey, options) {
  return FromPropertyKeys5(type, mappedKey.keys, options);
}
function OmitFromMappedKey2(type, mappedKey, options) {
  const properties = FromMappedKey7(type, mappedKey, options);
  return MappedResult2(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-result.mjs
function FromProperties31(properties, propertyKeys, options) {
  const result = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
    result[K2] = Pick2(properties[K2], propertyKeys, Clone3(options));
  return result;
}
function FromMappedResult22(mappedResult, propertyKeys, options) {
  return FromProperties31(mappedResult.properties, propertyKeys, options);
}
function PickFromMappedResult2(mappedResult, propertyKeys, options) {
  const properties = FromMappedResult22(mappedResult, propertyKeys, options);
  return MappedResult2(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/pick/pick.mjs
function FromIntersect23(types, propertyKeys) {
  return types.map((type) => PickResolve2(type, propertyKeys));
}
function FromUnion27(types, propertyKeys) {
  return types.map((type) => PickResolve2(type, propertyKeys));
}
function FromProperties32(properties, propertyKeys) {
  const result = {};
  for (const K2 of propertyKeys)
    if (K2 in properties)
      result[K2] = properties[K2];
  return result;
}
function FromObject20(T, K) {
  const options = Discard2(T, [TransformKind2, "$id", "required", "properties"]);
  const properties = FromProperties32(T["properties"], K);
  return Object3(properties, options);
}
function UnionFromPropertyKeys4(propertyKeys) {
  const result = propertyKeys.reduce((result2, key) => IsLiteralValue3(key) ? [...result2, Literal2(key)] : result2, []);
  return Union3(result);
}
function PickResolve2(properties, propertyKeys) {
  return IsIntersect3(properties) ? Intersect3(FromIntersect23(properties.allOf, propertyKeys)) : IsUnion3(properties) ? Union3(FromUnion27(properties.anyOf, propertyKeys)) : IsObject7(properties) ? FromObject20(properties, propertyKeys) : Object3({});
}
function Pick2(type, key, options) {
  const typeKey = IsArray5(key) ? UnionFromPropertyKeys4(key) : key;
  const propertyKeys = IsSchema3(key) ? IndexPropertyKeys2(key) : key;
  const isTypeRef = IsRef3(type);
  const isKeyRef = IsRef3(key);
  return IsMappedResult3(type) ? PickFromMappedResult2(type, propertyKeys, options) : IsMappedKey3(key) ? PickFromMappedKey2(type, key, options) : isTypeRef && isKeyRef ? Computed2("Pick", [type, typeKey], options) : !isTypeRef && isKeyRef ? Computed2("Pick", [type, typeKey], options) : isTypeRef && !isKeyRef ? Computed2("Pick", [type, typeKey], options) : CreateType2({ ...PickResolve2(type, propertyKeys), ...options });
}

// node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-key.mjs
function FromPropertyKey6(type, key, options) {
  return {
    [key]: Pick2(type, [key], Clone3(options))
  };
}
function FromPropertyKeys6(type, propertyKeys, options) {
  return propertyKeys.reduce((result, leftKey) => {
    return { ...result, ...FromPropertyKey6(type, leftKey, options) };
  }, {});
}
function FromMappedKey8(type, mappedKey, options) {
  return FromPropertyKeys6(type, mappedKey.keys, options);
}
function PickFromMappedKey2(type, mappedKey, options) {
  const properties = FromMappedKey8(type, mappedKey, options);
  return MappedResult2(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/partial/partial.mjs
function FromComputed8(target, parameters) {
  return Computed2("Partial", [Computed2(target, parameters)]);
}
function FromRef17($ref) {
  return Computed2("Partial", [Ref2($ref)]);
}
function FromProperties33(properties) {
  const partialProperties = {};
  for (const K of globalThis.Object.getOwnPropertyNames(properties))
    partialProperties[K] = Optional2(properties[K]);
  return partialProperties;
}
function FromObject21(T) {
  const options = Discard2(T, [TransformKind2, "$id", "required", "properties"]);
  const properties = FromProperties33(T["properties"]);
  return Object3(properties, options);
}
function FromRest14(types) {
  return types.map((type) => PartialResolve2(type));
}
function PartialResolve2(type) {
  return IsComputed3(type) ? FromComputed8(type.target, type.parameters) : IsRef3(type) ? FromRef17(type.$ref) : IsIntersect3(type) ? Intersect3(FromRest14(type.allOf)) : IsUnion3(type) ? Union3(FromRest14(type.anyOf)) : IsObject7(type) ? FromObject21(type) : Object3({});
}
function Partial2(type, options) {
  if (IsMappedResult3(type)) {
    return PartialFromMappedResult2(type, options);
  } else {
    return CreateType2({ ...PartialResolve2(type), ...options });
  }
}

// node_modules/@sinclair/typebox/build/esm/type/partial/partial-from-mapped-result.mjs
function FromProperties34(K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Partial2(K[K2], Clone3(options));
  return Acc;
}
function FromMappedResult23(R, options) {
  return FromProperties34(R.properties, options);
}
function PartialFromMappedResult2(R, options) {
  const P = FromMappedResult23(R, options);
  return MappedResult2(P);
}

// node_modules/@sinclair/typebox/build/esm/type/record/record.mjs
function RecordCreateFromPattern2(pattern, T, options) {
  return CreateType2({ [Kind2]: "Record", type: "object", patternProperties: { [pattern]: T } }, options);
}
function RecordCreateFromKeys2(K, T, options) {
  const result = {};
  for (const K2 of K)
    result[K2] = T;
  return Object3(result, { ...options, [Hint2]: "Record" });
}
function FromTemplateLiteralKey2(K, T, options) {
  return IsTemplateLiteralFinite2(K) ? RecordCreateFromKeys2(IndexPropertyKeys2(K), T, options) : RecordCreateFromPattern2(K.pattern, T, options);
}
function FromUnionKey2(key, type, options) {
  return RecordCreateFromKeys2(IndexPropertyKeys2(Union3(key)), type, options);
}
function FromLiteralKey2(key, type, options) {
  return RecordCreateFromKeys2([key.toString()], type, options);
}
function FromRegExpKey2(key, type, options) {
  return RecordCreateFromPattern2(key.source, type, options);
}
function FromStringKey2(key, type, options) {
  const pattern = IsUndefined5(key.pattern) ? PatternStringExact2 : key.pattern;
  return RecordCreateFromPattern2(pattern, type, options);
}
function FromAnyKey2(_3, type, options) {
  return RecordCreateFromPattern2(PatternStringExact2, type, options);
}
function FromNeverKey2(_key, type, options) {
  return RecordCreateFromPattern2(PatternNeverExact2, type, options);
}
function FromIntegerKey2(_key, type, options) {
  return RecordCreateFromPattern2(PatternNumberExact2, type, options);
}
function FromNumberKey2(_3, type, options) {
  return RecordCreateFromPattern2(PatternNumberExact2, type, options);
}
function Record2(key, type, options = {}) {
  return IsComputed3(type) ? Computed2("Record", [key, Computed2(type.target, type.parameters)], options) : IsComputed3(key) ? Computed2("Record", [Computed2(type.target, type.parameters), type], options) : IsRef3(key) ? Computed2("Record", [Ref2(key.$ref), type]) : IsUnion3(key) ? FromUnionKey2(key.anyOf, type, options) : IsTemplateLiteral3(key) ? FromTemplateLiteralKey2(key, type, options) : IsLiteral3(key) ? FromLiteralKey2(key.const, type, options) : IsInteger5(key) ? FromIntegerKey2(key, type, options) : IsNumber7(key) ? FromNumberKey2(key, type, options) : IsRegExp5(key) ? FromRegExpKey2(key, type, options) : IsString7(key) ? FromStringKey2(key, type, options) : IsAny3(key) ? FromAnyKey2(key, type, options) : IsNever3(key) ? FromNeverKey2(key, type, options) : Never2(options);
}

// node_modules/@sinclair/typebox/build/esm/type/required/required.mjs
function FromComputed9(target, parameters) {
  return Computed2("Required", [Computed2(target, parameters)]);
}
function FromRef18($ref) {
  return Computed2("Required", [Ref2($ref)]);
}
function FromProperties35(properties) {
  const requiredProperties = {};
  for (const K of globalThis.Object.getOwnPropertyNames(properties))
    requiredProperties[K] = Discard2(properties[K], [OptionalKind2]);
  return requiredProperties;
}
function FromObject22(type) {
  const options = Discard2(type, [TransformKind2, "$id", "required", "properties"]);
  const properties = FromProperties35(type["properties"]);
  return Object3(properties, options);
}
function FromRest15(types) {
  return types.map((type) => RequiredResolve2(type));
}
function RequiredResolve2(type) {
  return IsComputed3(type) ? FromComputed9(type.target, type.parameters) : IsRef3(type) ? FromRef18(type.$ref) : IsIntersect3(type) ? Intersect3(FromRest15(type.allOf)) : IsUnion3(type) ? Union3(FromRest15(type.anyOf)) : IsObject7(type) ? FromObject22(type) : Object3({});
}
function Required2(type, options) {
  if (IsMappedResult3(type)) {
    return RequiredFromMappedResult2(type, options);
  } else {
    return CreateType2({ ...RequiredResolve2(type), ...options });
  }
}

// node_modules/@sinclair/typebox/build/esm/type/required/required-from-mapped-result.mjs
function FromProperties36(P, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Required2(P[K2], options);
  return Acc;
}
function FromMappedResult24(R, options) {
  return FromProperties36(R.properties, options);
}
function RequiredFromMappedResult2(R, options) {
  const P = FromMappedResult24(R, options);
  return MappedResult2(P);
}

// node_modules/@sinclair/typebox/build/esm/type/module/compute.mjs
function DerefParameters2(moduleProperties, types) {
  return types.map((type) => {
    return IsRef3(type) ? Deref3(moduleProperties, type.$ref) : FromType2(moduleProperties, type);
  });
}
function Deref3(moduleProperties, ref) {
  return ref in moduleProperties ? IsRef3(moduleProperties[ref]) ? Deref3(moduleProperties, moduleProperties[ref].$ref) : FromType2(moduleProperties, moduleProperties[ref]) : Never2();
}
function FromAwaited2(parameters) {
  return Awaited2(parameters[0]);
}
function FromIndex2(parameters) {
  return Index2(parameters[0], parameters[1]);
}
function FromKeyOf2(parameters) {
  return KeyOf2(parameters[0]);
}
function FromPartial2(parameters) {
  return Partial2(parameters[0]);
}
function FromOmit2(parameters) {
  return Omit2(parameters[0], parameters[1]);
}
function FromPick2(parameters) {
  return Pick2(parameters[0], parameters[1]);
}
function FromRecord14(parameters) {
  return Record2(parameters[0], parameters[1]);
}
function FromRequired2(parameters) {
  return Required2(parameters[0]);
}
function FromComputed10(moduleProperties, target, parameters) {
  const dereferenced = DerefParameters2(moduleProperties, parameters);
  return target === "Awaited" ? FromAwaited2(dereferenced) : target === "Index" ? FromIndex2(dereferenced) : target === "KeyOf" ? FromKeyOf2(dereferenced) : target === "Partial" ? FromPartial2(dereferenced) : target === "Omit" ? FromOmit2(dereferenced) : target === "Pick" ? FromPick2(dereferenced) : target === "Record" ? FromRecord14(dereferenced) : target === "Required" ? FromRequired2(dereferenced) : Never2();
}
function FromObject23(moduleProperties, properties) {
  return Object3(globalThis.Object.keys(properties).reduce((result, key) => {
    return { ...result, [key]: FromType2(moduleProperties, properties[key]) };
  }, {}));
}
function FromConstructor9(moduleProperties, parameters, instanceType) {
  return Constructor2(FromRest16(moduleProperties, parameters), FromType2(moduleProperties, instanceType));
}
function FromFunction8(moduleProperties, parameters, returnType) {
  return Function3(FromRest16(moduleProperties, parameters), FromType2(moduleProperties, returnType));
}
function FromTuple18(moduleProperties, types) {
  return Tuple2(FromRest16(moduleProperties, types));
}
function FromIntersect24(moduleProperties, types) {
  return Intersect3(FromRest16(moduleProperties, types));
}
function FromUnion28(moduleProperties, types) {
  return Union3(FromRest16(moduleProperties, types));
}
function FromArray21(moduleProperties, type) {
  return Array3(FromType2(moduleProperties, type));
}
function FromAsyncIterator8(moduleProperties, type) {
  return AsyncIterator2(FromType2(moduleProperties, type));
}
function FromIterator8(moduleProperties, type) {
  return Iterator2(FromType2(moduleProperties, type));
}
function FromRest16(moduleProperties, types) {
  return types.map((type) => FromType2(moduleProperties, type));
}
function FromType2(moduleProperties, type) {
  return IsOptional3(type) ? CreateType2(FromType2(moduleProperties, Discard2(type, [OptionalKind2])), type) : IsReadonly3(type) ? CreateType2(FromType2(moduleProperties, Discard2(type, [ReadonlyKind2])), type) : IsArray7(type) ? CreateType2(FromArray21(moduleProperties, type.items), type) : IsAsyncIterator7(type) ? CreateType2(FromAsyncIterator8(moduleProperties, type.items), type) : IsComputed3(type) ? CreateType2(FromComputed10(moduleProperties, type.target, type.parameters)) : IsConstructor3(type) ? CreateType2(FromConstructor9(moduleProperties, type.parameters, type.returns), type) : IsFunction7(type) ? CreateType2(FromFunction8(moduleProperties, type.parameters, type.returns), type) : IsIntersect3(type) ? CreateType2(FromIntersect24(moduleProperties, type.allOf), type) : IsIterator7(type) ? CreateType2(FromIterator8(moduleProperties, type.items), type) : IsObject7(type) ? CreateType2(FromObject23(moduleProperties, type.properties), type) : IsTuple3(type) ? CreateType2(FromTuple18(moduleProperties, type.items || []), type) : IsUnion3(type) ? CreateType2(FromUnion28(moduleProperties, type.anyOf), type) : type;
}
function ComputeType2(moduleProperties, key) {
  return key in moduleProperties ? FromType2(moduleProperties, moduleProperties[key]) : Never2();
}
function ComputeModuleProperties2(moduleProperties) {
  return globalThis.Object.getOwnPropertyNames(moduleProperties).reduce((result, key) => {
    return { ...result, [key]: ComputeType2(moduleProperties, key) };
  }, {});
}

// node_modules/@sinclair/typebox/build/esm/type/module/module.mjs
class TModule2 {
  constructor($defs) {
    const computed = ComputeModuleProperties2($defs);
    const identified = this.WithIdentifiers(computed);
    this.$defs = identified;
  }
  Import(key, options) {
    const $defs = { ...this.$defs, [key]: CreateType2(this.$defs[key], options) };
    return CreateType2({ [Kind2]: "Import", $defs, $ref: key });
  }
  WithIdentifiers($defs) {
    return globalThis.Object.getOwnPropertyNames($defs).reduce((result, key) => {
      return { ...result, [key]: { ...$defs[key], $id: key } };
    }, {});
  }
}
function Module2(properties) {
  return new TModule2(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/not/not.mjs
function Not4(type, options) {
  return CreateType2({ [Kind2]: "Not", not: type }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/parameters/parameters.mjs
function Parameters2(schema, options) {
  return Tuple2(schema.parameters, options);
}

// node_modules/@sinclair/typebox/build/esm/type/readonly-optional/readonly-optional.mjs
function ReadonlyOptional2(schema) {
  return Readonly2(Optional2(schema));
}

// node_modules/@sinclair/typebox/build/esm/type/recursive/recursive.mjs
var Ordinal2 = 0;
function Recursive2(callback, options = {}) {
  if (IsUndefined5(options.$id))
    options.$id = `T${Ordinal2++}`;
  const thisType = CloneType2(callback({ [Kind2]: "This", $ref: `${options.$id}` }));
  thisType.$id = options.$id;
  return CreateType2({ [Hint2]: "Recursive", ...thisType }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/regexp/regexp.mjs
function RegExp3(unresolved, options) {
  const expr = IsString5(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;
  return CreateType2({ [Kind2]: "RegExp", type: "RegExp", source: expr.source, flags: expr.flags }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/rest/rest.mjs
function RestResolve2(T) {
  return IsIntersect3(T) ? T.allOf : IsUnion3(T) ? T.anyOf : IsTuple3(T) ? T.items ?? [] : [];
}
function Rest2(T) {
  return RestResolve2(T);
}

// node_modules/@sinclair/typebox/build/esm/type/return-type/return-type.mjs
function ReturnType2(schema, options) {
  return CreateType2(schema.returns, options);
}

// node_modules/@sinclair/typebox/build/esm/type/transform/transform.mjs
class TransformDecodeBuilder2 {
  constructor(schema) {
    this.schema = schema;
  }
  Decode(decode2) {
    return new TransformEncodeBuilder2(this.schema, decode2);
  }
}

class TransformEncodeBuilder2 {
  constructor(schema, decode2) {
    this.schema = schema;
    this.decode = decode2;
  }
  EncodeTransform(encode2, schema) {
    const Encode2 = (value) => schema[TransformKind2].Encode(encode2(value));
    const Decode2 = (value) => this.decode(schema[TransformKind2].Decode(value));
    const Codec = { Encode: Encode2, Decode: Decode2 };
    return { ...schema, [TransformKind2]: Codec };
  }
  EncodeSchema(encode2, schema) {
    const Codec = { Decode: this.decode, Encode: encode2 };
    return { ...schema, [TransformKind2]: Codec };
  }
  Encode(encode2) {
    return IsTransform3(this.schema) ? this.EncodeTransform(encode2, this.schema) : this.EncodeSchema(encode2, this.schema);
  }
}
function Transform2(schema) {
  return new TransformDecodeBuilder2(schema);
}

// node_modules/@sinclair/typebox/build/esm/type/unsafe/unsafe.mjs
function Unsafe2(options = {}) {
  return CreateType2({ [Kind2]: options[Kind2] ?? "Unsafe" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/void/void.mjs
function Void2(options) {
  return CreateType2({ [Kind2]: "Void", type: "void" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/type/type.mjs
var exports_type6 = {};
__export(exports_type6, {
  Void: () => Void2,
  Uppercase: () => Uppercase2,
  Unsafe: () => Unsafe2,
  Unknown: () => Unknown2,
  Union: () => Union3,
  Undefined: () => Undefined2,
  Uncapitalize: () => Uncapitalize2,
  Uint8Array: () => Uint8Array3,
  Tuple: () => Tuple2,
  Transform: () => Transform2,
  TemplateLiteral: () => TemplateLiteral2,
  Symbol: () => Symbol3,
  String: () => String3,
  ReturnType: () => ReturnType2,
  Rest: () => Rest2,
  Required: () => Required2,
  RegExp: () => RegExp3,
  Ref: () => Ref2,
  Recursive: () => Recursive2,
  Record: () => Record2,
  ReadonlyOptional: () => ReadonlyOptional2,
  Readonly: () => Readonly2,
  Promise: () => Promise3,
  Pick: () => Pick2,
  Partial: () => Partial2,
  Parameters: () => Parameters2,
  Optional: () => Optional2,
  Omit: () => Omit2,
  Object: () => Object3,
  Number: () => Number3,
  Null: () => Null2,
  Not: () => Not4,
  Never: () => Never2,
  Module: () => Module2,
  Mapped: () => Mapped2,
  Lowercase: () => Lowercase2,
  Literal: () => Literal2,
  KeyOf: () => KeyOf2,
  Iterator: () => Iterator2,
  Intersect: () => Intersect3,
  Integer: () => Integer2,
  InstanceType: () => InstanceType2,
  Index: () => Index2,
  Function: () => Function3,
  Extract: () => Extract2,
  Extends: () => Extends2,
  Exclude: () => Exclude2,
  Enum: () => Enum2,
  Date: () => Date3,
  ConstructorParameters: () => ConstructorParameters2,
  Constructor: () => Constructor2,
  Const: () => Const2,
  Composite: () => Composite2,
  Capitalize: () => Capitalize2,
  Boolean: () => Boolean3,
  BigInt: () => BigInt3,
  Awaited: () => Awaited2,
  AsyncIterator: () => AsyncIterator2,
  Array: () => Array3,
  Any: () => Any2
});

// node_modules/@sinclair/typebox/build/esm/type/type/index.mjs
var Type2 = exports_type6;

// node_modules/@sinclair/typebox/build/esm/system/system.mjs
class TypeSystemDuplicateTypeKind2 extends TypeBoxError2 {
  constructor(kind) {
    super(`Duplicate type kind '${kind}' detected`);
  }
}

class TypeSystemDuplicateFormat2 extends TypeBoxError2 {
  constructor(kind) {
    super(`Duplicate string format '${kind}' detected`);
  }
}
var TypeSystem2;
(function(TypeSystem3) {
  function Type3(kind, check2) {
    if (exports_type5.Has(kind))
      throw new TypeSystemDuplicateTypeKind2(kind);
    exports_type5.Set(kind, check2);
    return (options = {}) => Unsafe2({ ...options, [Kind2]: kind });
  }
  TypeSystem3.Type = Type3;
  function Format2(format, check2) {
    if (exports_format2.Has(format))
      throw new TypeSystemDuplicateFormat2(format);
    exports_format2.Set(format, check2);
    return format;
  }
  TypeSystem3.Format = Format2;
})(TypeSystem2 || (TypeSystem2 = {}));

// node_modules/@sinclair/typebox/build/esm/errors/function.mjs
function DefaultErrorFunction2(error2) {
  switch (error2.errorType) {
    case ValueErrorType2.ArrayContains:
      return "Expected array to contain at least one matching value";
    case ValueErrorType2.ArrayMaxContains:
      return `Expected array to contain no more than ${error2.schema.maxContains} matching values`;
    case ValueErrorType2.ArrayMinContains:
      return `Expected array to contain at least ${error2.schema.minContains} matching values`;
    case ValueErrorType2.ArrayMaxItems:
      return `Expected array length to be less or equal to ${error2.schema.maxItems}`;
    case ValueErrorType2.ArrayMinItems:
      return `Expected array length to be greater or equal to ${error2.schema.minItems}`;
    case ValueErrorType2.ArrayUniqueItems:
      return "Expected array elements to be unique";
    case ValueErrorType2.Array:
      return "Expected array";
    case ValueErrorType2.AsyncIterator:
      return "Expected AsyncIterator";
    case ValueErrorType2.BigIntExclusiveMaximum:
      return `Expected bigint to be less than ${error2.schema.exclusiveMaximum}`;
    case ValueErrorType2.BigIntExclusiveMinimum:
      return `Expected bigint to be greater than ${error2.schema.exclusiveMinimum}`;
    case ValueErrorType2.BigIntMaximum:
      return `Expected bigint to be less or equal to ${error2.schema.maximum}`;
    case ValueErrorType2.BigIntMinimum:
      return `Expected bigint to be greater or equal to ${error2.schema.minimum}`;
    case ValueErrorType2.BigIntMultipleOf:
      return `Expected bigint to be a multiple of ${error2.schema.multipleOf}`;
    case ValueErrorType2.BigInt:
      return "Expected bigint";
    case ValueErrorType2.Boolean:
      return "Expected boolean";
    case ValueErrorType2.DateExclusiveMinimumTimestamp:
      return `Expected Date timestamp to be greater than ${error2.schema.exclusiveMinimumTimestamp}`;
    case ValueErrorType2.DateExclusiveMaximumTimestamp:
      return `Expected Date timestamp to be less than ${error2.schema.exclusiveMaximumTimestamp}`;
    case ValueErrorType2.DateMinimumTimestamp:
      return `Expected Date timestamp to be greater or equal to ${error2.schema.minimumTimestamp}`;
    case ValueErrorType2.DateMaximumTimestamp:
      return `Expected Date timestamp to be less or equal to ${error2.schema.maximumTimestamp}`;
    case ValueErrorType2.DateMultipleOfTimestamp:
      return `Expected Date timestamp to be a multiple of ${error2.schema.multipleOfTimestamp}`;
    case ValueErrorType2.Date:
      return "Expected Date";
    case ValueErrorType2.Function:
      return "Expected function";
    case ValueErrorType2.IntegerExclusiveMaximum:
      return `Expected integer to be less than ${error2.schema.exclusiveMaximum}`;
    case ValueErrorType2.IntegerExclusiveMinimum:
      return `Expected integer to be greater than ${error2.schema.exclusiveMinimum}`;
    case ValueErrorType2.IntegerMaximum:
      return `Expected integer to be less or equal to ${error2.schema.maximum}`;
    case ValueErrorType2.IntegerMinimum:
      return `Expected integer to be greater or equal to ${error2.schema.minimum}`;
    case ValueErrorType2.IntegerMultipleOf:
      return `Expected integer to be a multiple of ${error2.schema.multipleOf}`;
    case ValueErrorType2.Integer:
      return "Expected integer";
    case ValueErrorType2.IntersectUnevaluatedProperties:
      return "Unexpected property";
    case ValueErrorType2.Intersect:
      return "Expected all values to match";
    case ValueErrorType2.Iterator:
      return "Expected Iterator";
    case ValueErrorType2.Literal:
      return `Expected ${typeof error2.schema.const === "string" ? `'${error2.schema.const}'` : error2.schema.const}`;
    case ValueErrorType2.Never:
      return "Never";
    case ValueErrorType2.Not:
      return "Value should not match";
    case ValueErrorType2.Null:
      return "Expected null";
    case ValueErrorType2.NumberExclusiveMaximum:
      return `Expected number to be less than ${error2.schema.exclusiveMaximum}`;
    case ValueErrorType2.NumberExclusiveMinimum:
      return `Expected number to be greater than ${error2.schema.exclusiveMinimum}`;
    case ValueErrorType2.NumberMaximum:
      return `Expected number to be less or equal to ${error2.schema.maximum}`;
    case ValueErrorType2.NumberMinimum:
      return `Expected number to be greater or equal to ${error2.schema.minimum}`;
    case ValueErrorType2.NumberMultipleOf:
      return `Expected number to be a multiple of ${error2.schema.multipleOf}`;
    case ValueErrorType2.Number:
      return "Expected number";
    case ValueErrorType2.Object:
      return "Expected object";
    case ValueErrorType2.ObjectAdditionalProperties:
      return "Unexpected property";
    case ValueErrorType2.ObjectMaxProperties:
      return `Expected object to have no more than ${error2.schema.maxProperties} properties`;
    case ValueErrorType2.ObjectMinProperties:
      return `Expected object to have at least ${error2.schema.minProperties} properties`;
    case ValueErrorType2.ObjectRequiredProperty:
      return "Expected required property";
    case ValueErrorType2.Promise:
      return "Expected Promise";
    case ValueErrorType2.RegExp:
      return "Expected string to match regular expression";
    case ValueErrorType2.StringFormatUnknown:
      return `Unknown format '${error2.schema.format}'`;
    case ValueErrorType2.StringFormat:
      return `Expected string to match '${error2.schema.format}' format`;
    case ValueErrorType2.StringMaxLength:
      return `Expected string length less or equal to ${error2.schema.maxLength}`;
    case ValueErrorType2.StringMinLength:
      return `Expected string length greater or equal to ${error2.schema.minLength}`;
    case ValueErrorType2.StringPattern:
      return `Expected string to match '${error2.schema.pattern}'`;
    case ValueErrorType2.String:
      return "Expected string";
    case ValueErrorType2.Symbol:
      return "Expected symbol";
    case ValueErrorType2.TupleLength:
      return `Expected tuple to have ${error2.schema.maxItems || 0} elements`;
    case ValueErrorType2.Tuple:
      return "Expected tuple";
    case ValueErrorType2.Uint8ArrayMaxByteLength:
      return `Expected byte length less or equal to ${error2.schema.maxByteLength}`;
    case ValueErrorType2.Uint8ArrayMinByteLength:
      return `Expected byte length greater or equal to ${error2.schema.minByteLength}`;
    case ValueErrorType2.Uint8Array:
      return "Expected Uint8Array";
    case ValueErrorType2.Undefined:
      return "Expected undefined";
    case ValueErrorType2.Union:
      return "Expected union value";
    case ValueErrorType2.Void:
      return "Expected void";
    case ValueErrorType2.Kind:
      return `Expected kind '${error2.schema[Kind2]}'`;
    default:
      return "Unknown error type";
  }
}
var errorFunction2 = DefaultErrorFunction2;
function GetErrorFunction2() {
  return errorFunction2;
}

// node_modules/@sinclair/typebox/build/esm/value/deref/deref.mjs
class TypeDereferenceError2 extends TypeBoxError2 {
  constructor(schema) {
    super(`Unable to dereference schema with $id '${schema.$ref}'`);
    this.schema = schema;
  }
}
function Resolve2(schema, references) {
  const target = references.find((target2) => target2.$id === schema.$ref);
  if (target === undefined)
    throw new TypeDereferenceError2(schema);
  return Deref4(target, references);
}
function Pushref2(schema, references) {
  if (!IsString6(schema.$id) || references.some((target) => target.$id === schema.$id))
    return references;
  references.push(schema);
  return references;
}
function Deref4(schema, references) {
  return schema[Kind2] === "This" || schema[Kind2] === "Ref" ? Resolve2(schema, references) : schema;
}

// node_modules/@sinclair/typebox/build/esm/value/hash/hash.mjs
class ValueHashError2 extends TypeBoxError2 {
  constructor(value) {
    super(`Unable to hash value`);
    this.value = value;
  }
}
var ByteMarker2;
(function(ByteMarker3) {
  ByteMarker3[ByteMarker3["Undefined"] = 0] = "Undefined";
  ByteMarker3[ByteMarker3["Null"] = 1] = "Null";
  ByteMarker3[ByteMarker3["Boolean"] = 2] = "Boolean";
  ByteMarker3[ByteMarker3["Number"] = 3] = "Number";
  ByteMarker3[ByteMarker3["String"] = 4] = "String";
  ByteMarker3[ByteMarker3["Object"] = 5] = "Object";
  ByteMarker3[ByteMarker3["Array"] = 6] = "Array";
  ByteMarker3[ByteMarker3["Date"] = 7] = "Date";
  ByteMarker3[ByteMarker3["Uint8Array"] = 8] = "Uint8Array";
  ByteMarker3[ByteMarker3["Symbol"] = 9] = "Symbol";
  ByteMarker3[ByteMarker3["BigInt"] = 10] = "BigInt";
})(ByteMarker2 || (ByteMarker2 = {}));
var Accumulator2 = BigInt("14695981039346656037");
var [Prime2, Size2] = [BigInt("1099511628211"), BigInt("18446744073709551616")];
var Bytes2 = Array.from({ length: 256 }).map((_3, i) => BigInt(i));
var F642 = new Float64Array(1);
var F64In2 = new DataView(F642.buffer);
var F64Out2 = new Uint8Array(F642.buffer);
function* NumberToBytes2(value) {
  const byteCount = value === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value) + 1) / 8);
  for (let i = 0;i < byteCount; i++) {
    yield value >> 8 * (byteCount - 1 - i) & 255;
  }
}
function ArrayType7(value) {
  FNV1A642(ByteMarker2.Array);
  for (const item of value) {
    Visit20(item);
  }
}
function BooleanType2(value) {
  FNV1A642(ByteMarker2.Boolean);
  FNV1A642(value ? 1 : 0);
}
function BigIntType2(value) {
  FNV1A642(ByteMarker2.BigInt);
  F64In2.setBigInt64(0, value);
  for (const byte2 of F64Out2) {
    FNV1A642(byte2);
  }
}
function DateType5(value) {
  FNV1A642(ByteMarker2.Date);
  Visit20(value.getTime());
}
function NullType2(value) {
  FNV1A642(ByteMarker2.Null);
}
function NumberType2(value) {
  FNV1A642(ByteMarker2.Number);
  F64In2.setFloat64(0, value);
  for (const byte2 of F64Out2) {
    FNV1A642(byte2);
  }
}
function ObjectType7(value) {
  FNV1A642(ByteMarker2.Object);
  for (const key of globalThis.Object.getOwnPropertyNames(value).sort()) {
    Visit20(key);
    Visit20(value[key]);
  }
}
function StringType2(value) {
  FNV1A642(ByteMarker2.String);
  for (let i = 0;i < value.length; i++) {
    for (const byte2 of NumberToBytes2(value.charCodeAt(i))) {
      FNV1A642(byte2);
    }
  }
}
function SymbolType2(value) {
  FNV1A642(ByteMarker2.Symbol);
  Visit20(value.description);
}
function Uint8ArrayType4(value) {
  FNV1A642(ByteMarker2.Uint8Array);
  for (let i = 0;i < value.length; i++) {
    FNV1A642(value[i]);
  }
}
function UndefinedType2(value) {
  return FNV1A642(ByteMarker2.Undefined);
}
function Visit20(value) {
  if (IsArray6(value))
    return ArrayType7(value);
  if (IsBoolean6(value))
    return BooleanType2(value);
  if (IsBigInt6(value))
    return BigIntType2(value);
  if (IsDate6(value))
    return DateType5(value);
  if (IsNull6(value))
    return NullType2(value);
  if (IsNumber6(value))
    return NumberType2(value);
  if (IsObject6(value))
    return ObjectType7(value);
  if (IsString6(value))
    return StringType2(value);
  if (IsSymbol6(value))
    return SymbolType2(value);
  if (IsUint8Array6(value))
    return Uint8ArrayType4(value);
  if (IsUndefined6(value))
    return UndefinedType2(value);
  throw new ValueHashError2(value);
}
function FNV1A642(byte2) {
  Accumulator2 = Accumulator2 ^ Bytes2[byte2];
  Accumulator2 = Accumulator2 * Prime2 % Size2;
}
function Hash2(value) {
  Accumulator2 = BigInt("14695981039346656037");
  Visit20(value);
  return Accumulator2;
}

// node_modules/@sinclair/typebox/build/esm/value/check/check.mjs
class ValueCheckUnknownTypeError2 extends TypeBoxError2 {
  constructor(schema) {
    super(`Unknown type`);
    this.schema = schema;
  }
}
function IsAnyOrUnknown2(schema) {
  return schema[Kind2] === "Any" || schema[Kind2] === "Unknown";
}
function IsDefined3(value) {
  return value !== undefined;
}
function FromAny6(schema, references, value) {
  return true;
}
function FromArray22(schema, references, value) {
  if (!IsArray6(value))
    return false;
  if (IsDefined3(schema.minItems) && !(value.length >= schema.minItems)) {
    return false;
  }
  if (IsDefined3(schema.maxItems) && !(value.length <= schema.maxItems)) {
    return false;
  }
  if (!value.every((value2) => Visit21(schema.items, references, value2))) {
    return false;
  }
  if (schema.uniqueItems === true && !function() {
    const set2 = new Set;
    for (const element of value) {
      const hashed = Hash2(element);
      if (set2.has(hashed)) {
        return false;
      } else {
        set2.add(hashed);
      }
    }
    return true;
  }()) {
    return false;
  }
  if (!(IsDefined3(schema.contains) || IsNumber6(schema.minContains) || IsNumber6(schema.maxContains))) {
    return true;
  }
  const containsSchema = IsDefined3(schema.contains) ? schema.contains : Never2();
  const containsCount = value.reduce((acc, value2) => Visit21(containsSchema, references, value2) ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    return false;
  }
  if (IsNumber6(schema.minContains) && containsCount < schema.minContains) {
    return false;
  }
  if (IsNumber6(schema.maxContains) && containsCount > schema.maxContains) {
    return false;
  }
  return true;
}
function FromAsyncIterator9(schema, references, value) {
  return IsAsyncIterator6(value);
}
function FromBigInt7(schema, references, value) {
  if (!IsBigInt6(value))
    return false;
  if (IsDefined3(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined3(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined3(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined3(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined3(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
    return false;
  }
  return true;
}
function FromBoolean7(schema, references, value) {
  return IsBoolean6(value);
}
function FromConstructor10(schema, references, value) {
  return Visit21(schema.returns, references, value.prototype);
}
function FromDate9(schema, references, value) {
  if (!IsDate6(value))
    return false;
  if (IsDefined3(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
    return false;
  }
  if (IsDefined3(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
    return false;
  }
  if (IsDefined3(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
    return false;
  }
  if (IsDefined3(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
    return false;
  }
  if (IsDefined3(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
    return false;
  }
  return true;
}
function FromFunction9(schema, references, value) {
  return IsFunction6(value);
}
function FromImport10(schema, references, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit21(target, [...references, ...definitions], value);
}
function FromInteger7(schema, references, value) {
  if (!IsInteger4(value)) {
    return false;
  }
  if (IsDefined3(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined3(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined3(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined3(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined3(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    return false;
  }
  return true;
}
function FromIntersect25(schema, references, value) {
  const check1 = schema.allOf.every((schema2) => Visit21(schema2, references, value));
  if (schema.unevaluatedProperties === false) {
    const keyPattern = new RegExp(KeyOfPattern2(schema));
    const check2 = Object.getOwnPropertyNames(value).every((key) => keyPattern.test(key));
    return check1 && check2;
  } else if (IsSchema3(schema.unevaluatedProperties)) {
    const keyCheck = new RegExp(KeyOfPattern2(schema));
    const check2 = Object.getOwnPropertyNames(value).every((key) => keyCheck.test(key) || Visit21(schema.unevaluatedProperties, references, value[key]));
    return check1 && check2;
  } else {
    return check1;
  }
}
function FromIterator9(schema, references, value) {
  return IsIterator6(value);
}
function FromLiteral9(schema, references, value) {
  return value === schema.const;
}
function FromNever7(schema, references, value) {
  return false;
}
function FromNot9(schema, references, value) {
  return !Visit21(schema.not, references, value);
}
function FromNull7(schema, references, value) {
  return IsNull6(value);
}
function FromNumber7(schema, references, value) {
  if (!TypeSystemPolicy2.IsNumberLike(value))
    return false;
  if (IsDefined3(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined3(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined3(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined3(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined3(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    return false;
  }
  return true;
}
function FromObject24(schema, references, value) {
  if (!TypeSystemPolicy2.IsObjectLike(value))
    return false;
  if (IsDefined3(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined3(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    return false;
  }
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      if (!Visit21(property, references, value[knownKey])) {
        return false;
      }
      if ((ExtendsUndefinedCheck2(property) || IsAnyOrUnknown2(property)) && !(knownKey in value)) {
        return false;
      }
    } else {
      if (TypeSystemPolicy2.IsExactOptionalProperty(value, knownKey) && !Visit21(property, references, value[knownKey])) {
        return false;
      }
    }
  }
  if (schema.additionalProperties === false) {
    const valueKeys = Object.getOwnPropertyNames(value);
    if (schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {
      return true;
    } else {
      return valueKeys.every((valueKey) => knownKeys.includes(valueKey));
    }
  } else if (typeof schema.additionalProperties === "object") {
    const valueKeys = Object.getOwnPropertyNames(value);
    return valueKeys.every((key) => knownKeys.includes(key) || Visit21(schema.additionalProperties, references, value[key]));
  } else {
    return true;
  }
}
function FromPromise9(schema, references, value) {
  return IsPromise4(value);
}
function FromRecord15(schema, references, value) {
  if (!TypeSystemPolicy2.IsRecordLike(value)) {
    return false;
  }
  if (IsDefined3(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined3(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    return false;
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex2 = new RegExp(patternKey);
  const check1 = Object.entries(value).every(([key, value2]) => {
    return regex2.test(key) ? Visit21(patternSchema, references, value2) : true;
  });
  const check2 = typeof schema.additionalProperties === "object" ? Object.entries(value).every(([key, value2]) => {
    return !regex2.test(key) ? Visit21(schema.additionalProperties, references, value2) : true;
  }) : true;
  const check3 = schema.additionalProperties === false ? Object.getOwnPropertyNames(value).every((key) => {
    return regex2.test(key);
  }) : true;
  return check1 && check2 && check3;
}
function FromRef19(schema, references, value) {
  return Visit21(Deref4(schema, references), references, value);
}
function FromRegExp6(schema, references, value) {
  const regex2 = new RegExp(schema.source, schema.flags);
  if (IsDefined3(schema.minLength)) {
    if (!(value.length >= schema.minLength))
      return false;
  }
  if (IsDefined3(schema.maxLength)) {
    if (!(value.length <= schema.maxLength))
      return false;
  }
  return regex2.test(value);
}
function FromString7(schema, references, value) {
  if (!IsString6(value)) {
    return false;
  }
  if (IsDefined3(schema.minLength)) {
    if (!(value.length >= schema.minLength))
      return false;
  }
  if (IsDefined3(schema.maxLength)) {
    if (!(value.length <= schema.maxLength))
      return false;
  }
  if (IsDefined3(schema.pattern)) {
    const regex2 = new RegExp(schema.pattern);
    if (!regex2.test(value))
      return false;
  }
  if (IsDefined3(schema.format)) {
    if (!exports_format2.Has(schema.format))
      return false;
    const func = exports_format2.Get(schema.format);
    return func(value);
  }
  return true;
}
function FromSymbol7(schema, references, value) {
  return IsSymbol6(value);
}
function FromTemplateLiteral10(schema, references, value) {
  return IsString6(value) && new RegExp(schema.pattern).test(value);
}
function FromThis11(schema, references, value) {
  return Visit21(Deref4(schema, references), references, value);
}
function FromTuple19(schema, references, value) {
  if (!IsArray6(value)) {
    return false;
  }
  if (schema.items === undefined && !(value.length === 0)) {
    return false;
  }
  if (!(value.length === schema.maxItems)) {
    return false;
  }
  if (!schema.items) {
    return true;
  }
  for (let i = 0;i < schema.items.length; i++) {
    if (!Visit21(schema.items[i], references, value[i]))
      return false;
  }
  return true;
}
function FromUndefined7(schema, references, value) {
  return IsUndefined6(value);
}
function FromUnion29(schema, references, value) {
  return schema.anyOf.some((inner) => Visit21(inner, references, value));
}
function FromUint8Array6(schema, references, value) {
  if (!IsUint8Array6(value)) {
    return false;
  }
  if (IsDefined3(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
    return false;
  }
  if (IsDefined3(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
    return false;
  }
  return true;
}
function FromUnknown6(schema, references, value) {
  return true;
}
function FromVoid6(schema, references, value) {
  return TypeSystemPolicy2.IsVoidLike(value);
}
function FromKind4(schema, references, value) {
  if (!exports_type5.Has(schema[Kind2]))
    return false;
  const func = exports_type5.Get(schema[Kind2]);
  return func(schema, value);
}
function Visit21(schema, references, value) {
  const references_ = IsDefined3(schema.$id) ? Pushref2(schema, references) : references;
  const schema_ = schema;
  switch (schema_[Kind2]) {
    case "Any":
      return FromAny6(schema_, references_, value);
    case "Array":
      return FromArray22(schema_, references_, value);
    case "AsyncIterator":
      return FromAsyncIterator9(schema_, references_, value);
    case "BigInt":
      return FromBigInt7(schema_, references_, value);
    case "Boolean":
      return FromBoolean7(schema_, references_, value);
    case "Constructor":
      return FromConstructor10(schema_, references_, value);
    case "Date":
      return FromDate9(schema_, references_, value);
    case "Function":
      return FromFunction9(schema_, references_, value);
    case "Import":
      return FromImport10(schema_, references_, value);
    case "Integer":
      return FromInteger7(schema_, references_, value);
    case "Intersect":
      return FromIntersect25(schema_, references_, value);
    case "Iterator":
      return FromIterator9(schema_, references_, value);
    case "Literal":
      return FromLiteral9(schema_, references_, value);
    case "Never":
      return FromNever7(schema_, references_, value);
    case "Not":
      return FromNot9(schema_, references_, value);
    case "Null":
      return FromNull7(schema_, references_, value);
    case "Number":
      return FromNumber7(schema_, references_, value);
    case "Object":
      return FromObject24(schema_, references_, value);
    case "Promise":
      return FromPromise9(schema_, references_, value);
    case "Record":
      return FromRecord15(schema_, references_, value);
    case "Ref":
      return FromRef19(schema_, references_, value);
    case "RegExp":
      return FromRegExp6(schema_, references_, value);
    case "String":
      return FromString7(schema_, references_, value);
    case "Symbol":
      return FromSymbol7(schema_, references_, value);
    case "TemplateLiteral":
      return FromTemplateLiteral10(schema_, references_, value);
    case "This":
      return FromThis11(schema_, references_, value);
    case "Tuple":
      return FromTuple19(schema_, references_, value);
    case "Undefined":
      return FromUndefined7(schema_, references_, value);
    case "Union":
      return FromUnion29(schema_, references_, value);
    case "Uint8Array":
      return FromUint8Array6(schema_, references_, value);
    case "Unknown":
      return FromUnknown6(schema_, references_, value);
    case "Void":
      return FromVoid6(schema_, references_, value);
    default:
      if (!exports_type5.Has(schema_[Kind2]))
        throw new ValueCheckUnknownTypeError2(schema_);
      return FromKind4(schema_, references_, value);
  }
}
function Check2(...args) {
  return args.length === 3 ? Visit21(args[0], args[1], args[2]) : Visit21(args[0], [], args[1]);
}

// node_modules/@sinclair/typebox/build/esm/errors/errors.mjs
var ValueErrorType2;
(function(ValueErrorType3) {
  ValueErrorType3[ValueErrorType3["ArrayContains"] = 0] = "ArrayContains";
  ValueErrorType3[ValueErrorType3["ArrayMaxContains"] = 1] = "ArrayMaxContains";
  ValueErrorType3[ValueErrorType3["ArrayMaxItems"] = 2] = "ArrayMaxItems";
  ValueErrorType3[ValueErrorType3["ArrayMinContains"] = 3] = "ArrayMinContains";
  ValueErrorType3[ValueErrorType3["ArrayMinItems"] = 4] = "ArrayMinItems";
  ValueErrorType3[ValueErrorType3["ArrayUniqueItems"] = 5] = "ArrayUniqueItems";
  ValueErrorType3[ValueErrorType3["Array"] = 6] = "Array";
  ValueErrorType3[ValueErrorType3["AsyncIterator"] = 7] = "AsyncIterator";
  ValueErrorType3[ValueErrorType3["BigIntExclusiveMaximum"] = 8] = "BigIntExclusiveMaximum";
  ValueErrorType3[ValueErrorType3["BigIntExclusiveMinimum"] = 9] = "BigIntExclusiveMinimum";
  ValueErrorType3[ValueErrorType3["BigIntMaximum"] = 10] = "BigIntMaximum";
  ValueErrorType3[ValueErrorType3["BigIntMinimum"] = 11] = "BigIntMinimum";
  ValueErrorType3[ValueErrorType3["BigIntMultipleOf"] = 12] = "BigIntMultipleOf";
  ValueErrorType3[ValueErrorType3["BigInt"] = 13] = "BigInt";
  ValueErrorType3[ValueErrorType3["Boolean"] = 14] = "Boolean";
  ValueErrorType3[ValueErrorType3["DateExclusiveMaximumTimestamp"] = 15] = "DateExclusiveMaximumTimestamp";
  ValueErrorType3[ValueErrorType3["DateExclusiveMinimumTimestamp"] = 16] = "DateExclusiveMinimumTimestamp";
  ValueErrorType3[ValueErrorType3["DateMaximumTimestamp"] = 17] = "DateMaximumTimestamp";
  ValueErrorType3[ValueErrorType3["DateMinimumTimestamp"] = 18] = "DateMinimumTimestamp";
  ValueErrorType3[ValueErrorType3["DateMultipleOfTimestamp"] = 19] = "DateMultipleOfTimestamp";
  ValueErrorType3[ValueErrorType3["Date"] = 20] = "Date";
  ValueErrorType3[ValueErrorType3["Function"] = 21] = "Function";
  ValueErrorType3[ValueErrorType3["IntegerExclusiveMaximum"] = 22] = "IntegerExclusiveMaximum";
  ValueErrorType3[ValueErrorType3["IntegerExclusiveMinimum"] = 23] = "IntegerExclusiveMinimum";
  ValueErrorType3[ValueErrorType3["IntegerMaximum"] = 24] = "IntegerMaximum";
  ValueErrorType3[ValueErrorType3["IntegerMinimum"] = 25] = "IntegerMinimum";
  ValueErrorType3[ValueErrorType3["IntegerMultipleOf"] = 26] = "IntegerMultipleOf";
  ValueErrorType3[ValueErrorType3["Integer"] = 27] = "Integer";
  ValueErrorType3[ValueErrorType3["IntersectUnevaluatedProperties"] = 28] = "IntersectUnevaluatedProperties";
  ValueErrorType3[ValueErrorType3["Intersect"] = 29] = "Intersect";
  ValueErrorType3[ValueErrorType3["Iterator"] = 30] = "Iterator";
  ValueErrorType3[ValueErrorType3["Kind"] = 31] = "Kind";
  ValueErrorType3[ValueErrorType3["Literal"] = 32] = "Literal";
  ValueErrorType3[ValueErrorType3["Never"] = 33] = "Never";
  ValueErrorType3[ValueErrorType3["Not"] = 34] = "Not";
  ValueErrorType3[ValueErrorType3["Null"] = 35] = "Null";
  ValueErrorType3[ValueErrorType3["NumberExclusiveMaximum"] = 36] = "NumberExclusiveMaximum";
  ValueErrorType3[ValueErrorType3["NumberExclusiveMinimum"] = 37] = "NumberExclusiveMinimum";
  ValueErrorType3[ValueErrorType3["NumberMaximum"] = 38] = "NumberMaximum";
  ValueErrorType3[ValueErrorType3["NumberMinimum"] = 39] = "NumberMinimum";
  ValueErrorType3[ValueErrorType3["NumberMultipleOf"] = 40] = "NumberMultipleOf";
  ValueErrorType3[ValueErrorType3["Number"] = 41] = "Number";
  ValueErrorType3[ValueErrorType3["ObjectAdditionalProperties"] = 42] = "ObjectAdditionalProperties";
  ValueErrorType3[ValueErrorType3["ObjectMaxProperties"] = 43] = "ObjectMaxProperties";
  ValueErrorType3[ValueErrorType3["ObjectMinProperties"] = 44] = "ObjectMinProperties";
  ValueErrorType3[ValueErrorType3["ObjectRequiredProperty"] = 45] = "ObjectRequiredProperty";
  ValueErrorType3[ValueErrorType3["Object"] = 46] = "Object";
  ValueErrorType3[ValueErrorType3["Promise"] = 47] = "Promise";
  ValueErrorType3[ValueErrorType3["RegExp"] = 48] = "RegExp";
  ValueErrorType3[ValueErrorType3["StringFormatUnknown"] = 49] = "StringFormatUnknown";
  ValueErrorType3[ValueErrorType3["StringFormat"] = 50] = "StringFormat";
  ValueErrorType3[ValueErrorType3["StringMaxLength"] = 51] = "StringMaxLength";
  ValueErrorType3[ValueErrorType3["StringMinLength"] = 52] = "StringMinLength";
  ValueErrorType3[ValueErrorType3["StringPattern"] = 53] = "StringPattern";
  ValueErrorType3[ValueErrorType3["String"] = 54] = "String";
  ValueErrorType3[ValueErrorType3["Symbol"] = 55] = "Symbol";
  ValueErrorType3[ValueErrorType3["TupleLength"] = 56] = "TupleLength";
  ValueErrorType3[ValueErrorType3["Tuple"] = 57] = "Tuple";
  ValueErrorType3[ValueErrorType3["Uint8ArrayMaxByteLength"] = 58] = "Uint8ArrayMaxByteLength";
  ValueErrorType3[ValueErrorType3["Uint8ArrayMinByteLength"] = 59] = "Uint8ArrayMinByteLength";
  ValueErrorType3[ValueErrorType3["Uint8Array"] = 60] = "Uint8Array";
  ValueErrorType3[ValueErrorType3["Undefined"] = 61] = "Undefined";
  ValueErrorType3[ValueErrorType3["Union"] = 62] = "Union";
  ValueErrorType3[ValueErrorType3["Void"] = 63] = "Void";
})(ValueErrorType2 || (ValueErrorType2 = {}));

class ValueErrorsUnknownTypeError2 extends TypeBoxError2 {
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
}
function EscapeKey2(key) {
  return key.replace(/~/g, "~0").replace(/\//g, "~1");
}
function IsDefined4(value) {
  return value !== undefined;
}

class ValueErrorIterator2 {
  constructor(iterator) {
    this.iterator = iterator;
  }
  [Symbol.iterator]() {
    return this.iterator;
  }
  First() {
    const next = this.iterator.next();
    return next.done ? undefined : next.value;
  }
}
function Create3(errorType, schema, path, value, errors = []) {
  return {
    type: errorType,
    schema,
    path,
    value,
    message: GetErrorFunction2()({ errorType, path, schema, value, errors }),
    errors
  };
}
function* FromAny7(schema, references, path, value) {
}
function* FromArray23(schema, references, path, value) {
  if (!IsArray6(value)) {
    return yield Create3(ValueErrorType2.Array, schema, path, value);
  }
  if (IsDefined4(schema.minItems) && !(value.length >= schema.minItems)) {
    yield Create3(ValueErrorType2.ArrayMinItems, schema, path, value);
  }
  if (IsDefined4(schema.maxItems) && !(value.length <= schema.maxItems)) {
    yield Create3(ValueErrorType2.ArrayMaxItems, schema, path, value);
  }
  for (let i = 0;i < value.length; i++) {
    yield* Visit22(schema.items, references, `${path}/${i}`, value[i]);
  }
  if (schema.uniqueItems === true && !function() {
    const set2 = new Set;
    for (const element of value) {
      const hashed = Hash2(element);
      if (set2.has(hashed)) {
        return false;
      } else {
        set2.add(hashed);
      }
    }
    return true;
  }()) {
    yield Create3(ValueErrorType2.ArrayUniqueItems, schema, path, value);
  }
  if (!(IsDefined4(schema.contains) || IsDefined4(schema.minContains) || IsDefined4(schema.maxContains))) {
    return;
  }
  const containsSchema = IsDefined4(schema.contains) ? schema.contains : Never2();
  const containsCount = value.reduce((acc, value2, index) => Visit22(containsSchema, references, `${path}${index}`, value2).next().done === true ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    yield Create3(ValueErrorType2.ArrayContains, schema, path, value);
  }
  if (IsNumber6(schema.minContains) && containsCount < schema.minContains) {
    yield Create3(ValueErrorType2.ArrayMinContains, schema, path, value);
  }
  if (IsNumber6(schema.maxContains) && containsCount > schema.maxContains) {
    yield Create3(ValueErrorType2.ArrayMaxContains, schema, path, value);
  }
}
function* FromAsyncIterator10(schema, references, path, value) {
  if (!IsAsyncIterator6(value))
    yield Create3(ValueErrorType2.AsyncIterator, schema, path, value);
}
function* FromBigInt8(schema, references, path, value) {
  if (!IsBigInt6(value))
    return yield Create3(ValueErrorType2.BigInt, schema, path, value);
  if (IsDefined4(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create3(ValueErrorType2.BigIntExclusiveMaximum, schema, path, value);
  }
  if (IsDefined4(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create3(ValueErrorType2.BigIntExclusiveMinimum, schema, path, value);
  }
  if (IsDefined4(schema.maximum) && !(value <= schema.maximum)) {
    yield Create3(ValueErrorType2.BigIntMaximum, schema, path, value);
  }
  if (IsDefined4(schema.minimum) && !(value >= schema.minimum)) {
    yield Create3(ValueErrorType2.BigIntMinimum, schema, path, value);
  }
  if (IsDefined4(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
    yield Create3(ValueErrorType2.BigIntMultipleOf, schema, path, value);
  }
}
function* FromBoolean8(schema, references, path, value) {
  if (!IsBoolean6(value))
    yield Create3(ValueErrorType2.Boolean, schema, path, value);
}
function* FromConstructor11(schema, references, path, value) {
  yield* Visit22(schema.returns, references, path, value.prototype);
}
function* FromDate10(schema, references, path, value) {
  if (!IsDate6(value))
    return yield Create3(ValueErrorType2.Date, schema, path, value);
  if (IsDefined4(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
    yield Create3(ValueErrorType2.DateExclusiveMaximumTimestamp, schema, path, value);
  }
  if (IsDefined4(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
    yield Create3(ValueErrorType2.DateExclusiveMinimumTimestamp, schema, path, value);
  }
  if (IsDefined4(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
    yield Create3(ValueErrorType2.DateMaximumTimestamp, schema, path, value);
  }
  if (IsDefined4(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
    yield Create3(ValueErrorType2.DateMinimumTimestamp, schema, path, value);
  }
  if (IsDefined4(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
    yield Create3(ValueErrorType2.DateMultipleOfTimestamp, schema, path, value);
  }
}
function* FromFunction10(schema, references, path, value) {
  if (!IsFunction6(value))
    yield Create3(ValueErrorType2.Function, schema, path, value);
}
function* FromImport11(schema, references, path, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  yield* Visit22(target, [...references, ...definitions], path, value);
}
function* FromInteger8(schema, references, path, value) {
  if (!IsInteger4(value))
    return yield Create3(ValueErrorType2.Integer, schema, path, value);
  if (IsDefined4(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create3(ValueErrorType2.IntegerExclusiveMaximum, schema, path, value);
  }
  if (IsDefined4(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create3(ValueErrorType2.IntegerExclusiveMinimum, schema, path, value);
  }
  if (IsDefined4(schema.maximum) && !(value <= schema.maximum)) {
    yield Create3(ValueErrorType2.IntegerMaximum, schema, path, value);
  }
  if (IsDefined4(schema.minimum) && !(value >= schema.minimum)) {
    yield Create3(ValueErrorType2.IntegerMinimum, schema, path, value);
  }
  if (IsDefined4(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    yield Create3(ValueErrorType2.IntegerMultipleOf, schema, path, value);
  }
}
function* FromIntersect26(schema, references, path, value) {
  let hasError = false;
  for (const inner of schema.allOf) {
    for (const error2 of Visit22(inner, references, path, value)) {
      hasError = true;
      yield error2;
    }
  }
  if (hasError) {
    return yield Create3(ValueErrorType2.Intersect, schema, path, value);
  }
  if (schema.unevaluatedProperties === false) {
    const keyCheck = new RegExp(KeyOfPattern2(schema));
    for (const valueKey of Object.getOwnPropertyNames(value)) {
      if (!keyCheck.test(valueKey)) {
        yield Create3(ValueErrorType2.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value);
      }
    }
  }
  if (typeof schema.unevaluatedProperties === "object") {
    const keyCheck = new RegExp(KeyOfPattern2(schema));
    for (const valueKey of Object.getOwnPropertyNames(value)) {
      if (!keyCheck.test(valueKey)) {
        const next = Visit22(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value[valueKey]).next();
        if (!next.done)
          yield next.value;
      }
    }
  }
}
function* FromIterator10(schema, references, path, value) {
  if (!IsIterator6(value))
    yield Create3(ValueErrorType2.Iterator, schema, path, value);
}
function* FromLiteral10(schema, references, path, value) {
  if (!(value === schema.const))
    yield Create3(ValueErrorType2.Literal, schema, path, value);
}
function* FromNever8(schema, references, path, value) {
  yield Create3(ValueErrorType2.Never, schema, path, value);
}
function* FromNot10(schema, references, path, value) {
  if (Visit22(schema.not, references, path, value).next().done === true)
    yield Create3(ValueErrorType2.Not, schema, path, value);
}
function* FromNull8(schema, references, path, value) {
  if (!IsNull6(value))
    yield Create3(ValueErrorType2.Null, schema, path, value);
}
function* FromNumber8(schema, references, path, value) {
  if (!TypeSystemPolicy2.IsNumberLike(value))
    return yield Create3(ValueErrorType2.Number, schema, path, value);
  if (IsDefined4(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create3(ValueErrorType2.NumberExclusiveMaximum, schema, path, value);
  }
  if (IsDefined4(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create3(ValueErrorType2.NumberExclusiveMinimum, schema, path, value);
  }
  if (IsDefined4(schema.maximum) && !(value <= schema.maximum)) {
    yield Create3(ValueErrorType2.NumberMaximum, schema, path, value);
  }
  if (IsDefined4(schema.minimum) && !(value >= schema.minimum)) {
    yield Create3(ValueErrorType2.NumberMinimum, schema, path, value);
  }
  if (IsDefined4(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    yield Create3(ValueErrorType2.NumberMultipleOf, schema, path, value);
  }
}
function* FromObject25(schema, references, path, value) {
  if (!TypeSystemPolicy2.IsObjectLike(value))
    return yield Create3(ValueErrorType2.Object, schema, path, value);
  if (IsDefined4(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    yield Create3(ValueErrorType2.ObjectMinProperties, schema, path, value);
  }
  if (IsDefined4(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    yield Create3(ValueErrorType2.ObjectMaxProperties, schema, path, value);
  }
  const requiredKeys = Array.isArray(schema.required) ? schema.required : [];
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  const unknownKeys = Object.getOwnPropertyNames(value);
  for (const requiredKey of requiredKeys) {
    if (unknownKeys.includes(requiredKey))
      continue;
    yield Create3(ValueErrorType2.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey2(requiredKey)}`, undefined);
  }
  if (schema.additionalProperties === false) {
    for (const valueKey of unknownKeys) {
      if (!knownKeys.includes(valueKey)) {
        yield Create3(ValueErrorType2.ObjectAdditionalProperties, schema, `${path}/${EscapeKey2(valueKey)}`, value[valueKey]);
      }
    }
  }
  if (typeof schema.additionalProperties === "object") {
    for (const valueKey of unknownKeys) {
      if (knownKeys.includes(valueKey))
        continue;
      yield* Visit22(schema.additionalProperties, references, `${path}/${EscapeKey2(valueKey)}`, value[valueKey]);
    }
  }
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      yield* Visit22(property, references, `${path}/${EscapeKey2(knownKey)}`, value[knownKey]);
      if (ExtendsUndefinedCheck2(schema) && !(knownKey in value)) {
        yield Create3(ValueErrorType2.ObjectRequiredProperty, property, `${path}/${EscapeKey2(knownKey)}`, undefined);
      }
    } else {
      if (TypeSystemPolicy2.IsExactOptionalProperty(value, knownKey)) {
        yield* Visit22(property, references, `${path}/${EscapeKey2(knownKey)}`, value[knownKey]);
      }
    }
  }
}
function* FromPromise10(schema, references, path, value) {
  if (!IsPromise4(value))
    yield Create3(ValueErrorType2.Promise, schema, path, value);
}
function* FromRecord16(schema, references, path, value) {
  if (!TypeSystemPolicy2.IsRecordLike(value))
    return yield Create3(ValueErrorType2.Object, schema, path, value);
  if (IsDefined4(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    yield Create3(ValueErrorType2.ObjectMinProperties, schema, path, value);
  }
  if (IsDefined4(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    yield Create3(ValueErrorType2.ObjectMaxProperties, schema, path, value);
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex2 = new RegExp(patternKey);
  for (const [propertyKey, propertyValue] of Object.entries(value)) {
    if (regex2.test(propertyKey))
      yield* Visit22(patternSchema, references, `${path}/${EscapeKey2(propertyKey)}`, propertyValue);
  }
  if (typeof schema.additionalProperties === "object") {
    for (const [propertyKey, propertyValue] of Object.entries(value)) {
      if (!regex2.test(propertyKey))
        yield* Visit22(schema.additionalProperties, references, `${path}/${EscapeKey2(propertyKey)}`, propertyValue);
    }
  }
  if (schema.additionalProperties === false) {
    for (const [propertyKey, propertyValue] of Object.entries(value)) {
      if (regex2.test(propertyKey))
        continue;
      return yield Create3(ValueErrorType2.ObjectAdditionalProperties, schema, `${path}/${EscapeKey2(propertyKey)}`, propertyValue);
    }
  }
}
function* FromRef20(schema, references, path, value) {
  yield* Visit22(Deref4(schema, references), references, path, value);
}
function* FromRegExp7(schema, references, path, value) {
  if (!IsString6(value))
    return yield Create3(ValueErrorType2.String, schema, path, value);
  if (IsDefined4(schema.minLength) && !(value.length >= schema.minLength)) {
    yield Create3(ValueErrorType2.StringMinLength, schema, path, value);
  }
  if (IsDefined4(schema.maxLength) && !(value.length <= schema.maxLength)) {
    yield Create3(ValueErrorType2.StringMaxLength, schema, path, value);
  }
  const regex2 = new RegExp(schema.source, schema.flags);
  if (!regex2.test(value)) {
    return yield Create3(ValueErrorType2.RegExp, schema, path, value);
  }
}
function* FromString8(schema, references, path, value) {
  if (!IsString6(value))
    return yield Create3(ValueErrorType2.String, schema, path, value);
  if (IsDefined4(schema.minLength) && !(value.length >= schema.minLength)) {
    yield Create3(ValueErrorType2.StringMinLength, schema, path, value);
  }
  if (IsDefined4(schema.maxLength) && !(value.length <= schema.maxLength)) {
    yield Create3(ValueErrorType2.StringMaxLength, schema, path, value);
  }
  if (IsString6(schema.pattern)) {
    const regex2 = new RegExp(schema.pattern);
    if (!regex2.test(value)) {
      yield Create3(ValueErrorType2.StringPattern, schema, path, value);
    }
  }
  if (IsString6(schema.format)) {
    if (!exports_format2.Has(schema.format)) {
      yield Create3(ValueErrorType2.StringFormatUnknown, schema, path, value);
    } else {
      const format = exports_format2.Get(schema.format);
      if (!format(value)) {
        yield Create3(ValueErrorType2.StringFormat, schema, path, value);
      }
    }
  }
}
function* FromSymbol8(schema, references, path, value) {
  if (!IsSymbol6(value))
    yield Create3(ValueErrorType2.Symbol, schema, path, value);
}
function* FromTemplateLiteral11(schema, references, path, value) {
  if (!IsString6(value))
    return yield Create3(ValueErrorType2.String, schema, path, value);
  const regex2 = new RegExp(schema.pattern);
  if (!regex2.test(value)) {
    yield Create3(ValueErrorType2.StringPattern, schema, path, value);
  }
}
function* FromThis12(schema, references, path, value) {
  yield* Visit22(Deref4(schema, references), references, path, value);
}
function* FromTuple20(schema, references, path, value) {
  if (!IsArray6(value))
    return yield Create3(ValueErrorType2.Tuple, schema, path, value);
  if (schema.items === undefined && !(value.length === 0)) {
    return yield Create3(ValueErrorType2.TupleLength, schema, path, value);
  }
  if (!(value.length === schema.maxItems)) {
    return yield Create3(ValueErrorType2.TupleLength, schema, path, value);
  }
  if (!schema.items) {
    return;
  }
  for (let i = 0;i < schema.items.length; i++) {
    yield* Visit22(schema.items[i], references, `${path}/${i}`, value[i]);
  }
}
function* FromUndefined8(schema, references, path, value) {
  if (!IsUndefined6(value))
    yield Create3(ValueErrorType2.Undefined, schema, path, value);
}
function* FromUnion30(schema, references, path, value) {
  if (Check2(schema, references, value))
    return;
  const errors = schema.anyOf.map((variant) => new ValueErrorIterator2(Visit22(variant, references, path, value)));
  yield Create3(ValueErrorType2.Union, schema, path, value, errors);
}
function* FromUint8Array7(schema, references, path, value) {
  if (!IsUint8Array6(value))
    return yield Create3(ValueErrorType2.Uint8Array, schema, path, value);
  if (IsDefined4(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
    yield Create3(ValueErrorType2.Uint8ArrayMaxByteLength, schema, path, value);
  }
  if (IsDefined4(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
    yield Create3(ValueErrorType2.Uint8ArrayMinByteLength, schema, path, value);
  }
}
function* FromUnknown7(schema, references, path, value) {
}
function* FromVoid7(schema, references, path, value) {
  if (!TypeSystemPolicy2.IsVoidLike(value))
    yield Create3(ValueErrorType2.Void, schema, path, value);
}
function* FromKind5(schema, references, path, value) {
  const check2 = exports_type5.Get(schema[Kind2]);
  if (!check2(schema, value))
    yield Create3(ValueErrorType2.Kind, schema, path, value);
}
function* Visit22(schema, references, path, value) {
  const references_ = IsDefined4(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind2]) {
    case "Any":
      return yield* FromAny7(schema_, references_, path, value);
    case "Array":
      return yield* FromArray23(schema_, references_, path, value);
    case "AsyncIterator":
      return yield* FromAsyncIterator10(schema_, references_, path, value);
    case "BigInt":
      return yield* FromBigInt8(schema_, references_, path, value);
    case "Boolean":
      return yield* FromBoolean8(schema_, references_, path, value);
    case "Constructor":
      return yield* FromConstructor11(schema_, references_, path, value);
    case "Date":
      return yield* FromDate10(schema_, references_, path, value);
    case "Function":
      return yield* FromFunction10(schema_, references_, path, value);
    case "Import":
      return yield* FromImport11(schema_, references_, path, value);
    case "Integer":
      return yield* FromInteger8(schema_, references_, path, value);
    case "Intersect":
      return yield* FromIntersect26(schema_, references_, path, value);
    case "Iterator":
      return yield* FromIterator10(schema_, references_, path, value);
    case "Literal":
      return yield* FromLiteral10(schema_, references_, path, value);
    case "Never":
      return yield* FromNever8(schema_, references_, path, value);
    case "Not":
      return yield* FromNot10(schema_, references_, path, value);
    case "Null":
      return yield* FromNull8(schema_, references_, path, value);
    case "Number":
      return yield* FromNumber8(schema_, references_, path, value);
    case "Object":
      return yield* FromObject25(schema_, references_, path, value);
    case "Promise":
      return yield* FromPromise10(schema_, references_, path, value);
    case "Record":
      return yield* FromRecord16(schema_, references_, path, value);
    case "Ref":
      return yield* FromRef20(schema_, references_, path, value);
    case "RegExp":
      return yield* FromRegExp7(schema_, references_, path, value);
    case "String":
      return yield* FromString8(schema_, references_, path, value);
    case "Symbol":
      return yield* FromSymbol8(schema_, references_, path, value);
    case "TemplateLiteral":
      return yield* FromTemplateLiteral11(schema_, references_, path, value);
    case "This":
      return yield* FromThis12(schema_, references_, path, value);
    case "Tuple":
      return yield* FromTuple20(schema_, references_, path, value);
    case "Undefined":
      return yield* FromUndefined8(schema_, references_, path, value);
    case "Union":
      return yield* FromUnion30(schema_, references_, path, value);
    case "Uint8Array":
      return yield* FromUint8Array7(schema_, references_, path, value);
    case "Unknown":
      return yield* FromUnknown7(schema_, references_, path, value);
    case "Void":
      return yield* FromVoid7(schema_, references_, path, value);
    default:
      if (!exports_type5.Has(schema_[Kind2]))
        throw new ValueErrorsUnknownTypeError2(schema);
      return yield* FromKind5(schema_, references_, path, value);
  }
}
function Errors2(...args) {
  const iterator = args.length === 3 ? Visit22(args[0], args[1], "", args[2]) : Visit22(args[0], [], "", args[1]);
  return new ValueErrorIterator2(iterator);
}

// node_modules/@sinclair/typebox/build/esm/value/transform/decode.mjs
class TransformDecodeCheckError2 extends TypeBoxError2 {
  constructor(schema, value, error2) {
    super(`Unable to decode value as it does not match the expected schema`);
    this.schema = schema;
    this.value = value;
    this.error = error2;
  }
}

class TransformDecodeError2 extends TypeBoxError2 {
  constructor(schema, path, value, error2) {
    super(error2 instanceof Error ? error2.message : "Unknown error");
    this.schema = schema;
    this.path = path;
    this.value = value;
    this.error = error2;
  }
}
function Default6(schema, path, value) {
  try {
    return IsTransform3(schema) ? schema[TransformKind2].Decode(value) : value;
  } catch (error2) {
    throw new TransformDecodeError2(schema, path, value, error2);
  }
}
function FromArray24(schema, references, path, value) {
  return IsArray6(value) ? Default6(schema, path, value.map((value2, index) => Visit23(schema.items, references, `${path}/${index}`, value2))) : Default6(schema, path, value);
}
function FromIntersect27(schema, references, path, value) {
  if (!IsObject6(value) || IsValueType2(value))
    return Default6(schema, path, value);
  const knownEntries = KeyOfPropertyEntries2(schema);
  const knownKeys = knownEntries.map((entry) => entry[0]);
  const knownProperties = { ...value };
  for (const [knownKey, knownSchema] of knownEntries)
    if (knownKey in knownProperties) {
      knownProperties[knownKey] = Visit23(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);
    }
  if (!IsTransform3(schema.unevaluatedProperties)) {
    return Default6(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      unknownProperties[key] = Default6(unevaluatedProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default6(schema, path, unknownProperties);
}
function FromImport12(schema, references, path, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  const transform2 = schema[TransformKind2];
  const transformTarget = { [TransformKind2]: transform2, ...target };
  return Visit23(transformTarget, [...references, ...definitions], path, value);
}
function FromNot11(schema, references, path, value) {
  return Default6(schema, path, Visit23(schema.not, references, path, value));
}
function FromObject26(schema, references, path, value) {
  if (!IsObject6(value))
    return Default6(schema, path, value);
  const knownKeys = KeyOfPropertyKeys2(schema);
  const knownProperties = { ...value };
  for (const key of knownKeys) {
    if (!HasPropertyKey4(knownProperties, key))
      continue;
    if (IsUndefined6(knownProperties[key]) && (!IsUndefined7(schema.properties[key]) || TypeSystemPolicy2.IsExactOptionalProperty(knownProperties, key)))
      continue;
    knownProperties[key] = Visit23(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);
  }
  if (!IsSchema3(schema.additionalProperties)) {
    return Default6(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      unknownProperties[key] = Default6(additionalProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default6(schema, path, unknownProperties);
}
function FromRecord17(schema, references, path, value) {
  if (!IsObject6(value))
    return Default6(schema, path, value);
  const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern);
  const knownProperties = { ...value };
  for (const key of Object.getOwnPropertyNames(value))
    if (knownKeys.test(key)) {
      knownProperties[key] = Visit23(schema.patternProperties[pattern], references, `${path}/${key}`, knownProperties[key]);
    }
  if (!IsSchema3(schema.additionalProperties)) {
    return Default6(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.test(key)) {
      unknownProperties[key] = Default6(additionalProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default6(schema, path, unknownProperties);
}
function FromRef21(schema, references, path, value) {
  const target = Deref4(schema, references);
  return Default6(schema, path, Visit23(target, references, path, value));
}
function FromThis13(schema, references, path, value) {
  const target = Deref4(schema, references);
  return Default6(schema, path, Visit23(target, references, path, value));
}
function FromTuple21(schema, references, path, value) {
  return IsArray6(value) && IsArray6(schema.items) ? Default6(schema, path, schema.items.map((schema2, index) => Visit23(schema2, references, `${path}/${index}`, value[index]))) : Default6(schema, path, value);
}
function FromUnion31(schema, references, path, value) {
  for (const subschema of schema.anyOf) {
    if (!Check2(subschema, references, value))
      continue;
    const decoded = Visit23(subschema, references, path, value);
    return Default6(schema, path, decoded);
  }
  return Default6(schema, path, value);
}
function Visit23(schema, references, path, value) {
  const references_ = Pushref2(schema, references);
  const schema_ = schema;
  switch (schema[Kind2]) {
    case "Array":
      return FromArray24(schema_, references_, path, value);
    case "Import":
      return FromImport12(schema_, references_, path, value);
    case "Intersect":
      return FromIntersect27(schema_, references_, path, value);
    case "Not":
      return FromNot11(schema_, references_, path, value);
    case "Object":
      return FromObject26(schema_, references_, path, value);
    case "Record":
      return FromRecord17(schema_, references_, path, value);
    case "Ref":
      return FromRef21(schema_, references_, path, value);
    case "Symbol":
      return Default6(schema_, path, value);
    case "This":
      return FromThis13(schema_, references_, path, value);
    case "Tuple":
      return FromTuple21(schema_, references_, path, value);
    case "Union":
      return FromUnion31(schema_, references_, path, value);
    default:
      return Default6(schema_, path, value);
  }
}
function TransformDecode2(schema, references, value) {
  return Visit23(schema, references, "", value);
}

// node_modules/@sinclair/typebox/build/esm/value/transform/encode.mjs
class TransformEncodeCheckError2 extends TypeBoxError2 {
  constructor(schema, value, error2) {
    super(`The encoded value does not match the expected schema`);
    this.schema = schema;
    this.value = value;
    this.error = error2;
  }
}

class TransformEncodeError2 extends TypeBoxError2 {
  constructor(schema, path, value, error2) {
    super(`${error2 instanceof Error ? error2.message : "Unknown error"}`);
    this.schema = schema;
    this.path = path;
    this.value = value;
    this.error = error2;
  }
}
function Default7(schema, path, value) {
  try {
    return IsTransform3(schema) ? schema[TransformKind2].Encode(value) : value;
  } catch (error2) {
    throw new TransformEncodeError2(schema, path, value, error2);
  }
}
function FromArray25(schema, references, path, value) {
  const defaulted = Default7(schema, path, value);
  return IsArray6(defaulted) ? defaulted.map((value2, index) => Visit24(schema.items, references, `${path}/${index}`, value2)) : defaulted;
}
function FromImport13(schema, references, path, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  const transform2 = schema[TransformKind2];
  const transformTarget = { [TransformKind2]: transform2, ...target };
  return Visit24(transformTarget, [...references, ...definitions], path, value);
}
function FromIntersect28(schema, references, path, value) {
  const defaulted = Default7(schema, path, value);
  if (!IsObject6(value) || IsValueType2(value))
    return defaulted;
  const knownEntries = KeyOfPropertyEntries2(schema);
  const knownKeys = knownEntries.map((entry) => entry[0]);
  const knownProperties = { ...defaulted };
  for (const [knownKey, knownSchema] of knownEntries)
    if (knownKey in knownProperties) {
      knownProperties[knownKey] = Visit24(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);
    }
  if (!IsTransform3(schema.unevaluatedProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      properties[key] = Default7(unevaluatedProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
}
function FromNot12(schema, references, path, value) {
  return Default7(schema.not, path, Default7(schema, path, value));
}
function FromObject27(schema, references, path, value) {
  const defaulted = Default7(schema, path, value);
  if (!IsObject6(defaulted))
    return defaulted;
  const knownKeys = KeyOfPropertyKeys2(schema);
  const knownProperties = { ...defaulted };
  for (const key of knownKeys) {
    if (!HasPropertyKey4(knownProperties, key))
      continue;
    if (IsUndefined6(knownProperties[key]) && (!IsUndefined7(schema.properties[key]) || TypeSystemPolicy2.IsExactOptionalProperty(knownProperties, key)))
      continue;
    knownProperties[key] = Visit24(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);
  }
  if (!IsSchema3(schema.additionalProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      properties[key] = Default7(additionalProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
}
function FromRecord18(schema, references, path, value) {
  const defaulted = Default7(schema, path, value);
  if (!IsObject6(value))
    return defaulted;
  const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern);
  const knownProperties = { ...defaulted };
  for (const key of Object.getOwnPropertyNames(value))
    if (knownKeys.test(key)) {
      knownProperties[key] = Visit24(schema.patternProperties[pattern], references, `${path}/${key}`, knownProperties[key]);
    }
  if (!IsSchema3(schema.additionalProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.test(key)) {
      properties[key] = Default7(additionalProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
}
function FromRef22(schema, references, path, value) {
  const target = Deref4(schema, references);
  const resolved = Visit24(target, references, path, value);
  return Default7(schema, path, resolved);
}
function FromThis14(schema, references, path, value) {
  const target = Deref4(schema, references);
  const resolved = Visit24(target, references, path, value);
  return Default7(schema, path, resolved);
}
function FromTuple22(schema, references, path, value) {
  const value1 = Default7(schema, path, value);
  return IsArray6(schema.items) ? schema.items.map((schema2, index) => Visit24(schema2, references, `${path}/${index}`, value1[index])) : [];
}
function FromUnion32(schema, references, path, value) {
  for (const subschema of schema.anyOf) {
    if (!Check2(subschema, references, value))
      continue;
    const value1 = Visit24(subschema, references, path, value);
    return Default7(schema, path, value1);
  }
  for (const subschema of schema.anyOf) {
    const value1 = Visit24(subschema, references, path, value);
    if (!Check2(schema, references, value1))
      continue;
    return Default7(schema, path, value1);
  }
  return Default7(schema, path, value);
}
function Visit24(schema, references, path, value) {
  const references_ = Pushref2(schema, references);
  const schema_ = schema;
  switch (schema[Kind2]) {
    case "Array":
      return FromArray25(schema_, references_, path, value);
    case "Import":
      return FromImport13(schema_, references_, path, value);
    case "Intersect":
      return FromIntersect28(schema_, references_, path, value);
    case "Not":
      return FromNot12(schema_, references_, path, value);
    case "Object":
      return FromObject27(schema_, references_, path, value);
    case "Record":
      return FromRecord18(schema_, references_, path, value);
    case "Ref":
      return FromRef22(schema_, references_, path, value);
    case "This":
      return FromThis14(schema_, references_, path, value);
    case "Tuple":
      return FromTuple22(schema_, references_, path, value);
    case "Union":
      return FromUnion32(schema_, references_, path, value);
    default:
      return Default7(schema_, path, value);
  }
}
function TransformEncode2(schema, references, value) {
  return Visit24(schema, references, "", value);
}

// node_modules/@sinclair/typebox/build/esm/value/transform/has.mjs
function FromArray26(schema, references) {
  return IsTransform3(schema) || Visit25(schema.items, references);
}
function FromAsyncIterator11(schema, references) {
  return IsTransform3(schema) || Visit25(schema.items, references);
}
function FromConstructor12(schema, references) {
  return IsTransform3(schema) || Visit25(schema.returns, references) || schema.parameters.some((schema2) => Visit25(schema2, references));
}
function FromFunction11(schema, references) {
  return IsTransform3(schema) || Visit25(schema.returns, references) || schema.parameters.some((schema2) => Visit25(schema2, references));
}
function FromIntersect29(schema, references) {
  return IsTransform3(schema) || IsTransform3(schema.unevaluatedProperties) || schema.allOf.some((schema2) => Visit25(schema2, references));
}
function FromIterator11(schema, references) {
  return IsTransform3(schema) || Visit25(schema.items, references);
}
function FromNot13(schema, references) {
  return IsTransform3(schema) || Visit25(schema.not, references);
}
function FromObject28(schema, references) {
  return IsTransform3(schema) || Object.values(schema.properties).some((schema2) => Visit25(schema2, references)) || IsSchema3(schema.additionalProperties) && Visit25(schema.additionalProperties, references);
}
function FromPromise11(schema, references) {
  return IsTransform3(schema) || Visit25(schema.item, references);
}
function FromRecord19(schema, references) {
  const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[pattern];
  return IsTransform3(schema) || Visit25(property, references) || IsSchema3(schema.additionalProperties) && IsTransform3(schema.additionalProperties);
}
function FromRef23(schema, references) {
  if (IsTransform3(schema))
    return true;
  return Visit25(Deref4(schema, references), references);
}
function FromThis15(schema, references) {
  if (IsTransform3(schema))
    return true;
  return Visit25(Deref4(schema, references), references);
}
function FromTuple23(schema, references) {
  return IsTransform3(schema) || !IsUndefined6(schema.items) && schema.items.some((schema2) => Visit25(schema2, references));
}
function FromUnion33(schema, references) {
  return IsTransform3(schema) || schema.anyOf.some((schema2) => Visit25(schema2, references));
}
function Visit25(schema, references) {
  const references_ = Pushref2(schema, references);
  const schema_ = schema;
  if (schema.$id && visited2.has(schema.$id))
    return false;
  if (schema.$id)
    visited2.add(schema.$id);
  switch (schema[Kind2]) {
    case "Array":
      return FromArray26(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator11(schema_, references_);
    case "Constructor":
      return FromConstructor12(schema_, references_);
    case "Function":
      return FromFunction11(schema_, references_);
    case "Intersect":
      return FromIntersect29(schema_, references_);
    case "Iterator":
      return FromIterator11(schema_, references_);
    case "Not":
      return FromNot13(schema_, references_);
    case "Object":
      return FromObject28(schema_, references_);
    case "Promise":
      return FromPromise11(schema_, references_);
    case "Record":
      return FromRecord19(schema_, references_);
    case "Ref":
      return FromRef23(schema_, references_);
    case "This":
      return FromThis15(schema_, references_);
    case "Tuple":
      return FromTuple23(schema_, references_);
    case "Union":
      return FromUnion33(schema_, references_);
    default:
      return IsTransform3(schema);
  }
}
var visited2 = new Set;
function HasTransform2(schema, references) {
  visited2.clear();
  return Visit25(schema, references);
}

// node_modules/@sinclair/typebox/build/esm/compiler/compiler.mjs
class TypeCheck2 {
  constructor(schema, references, checkFunc, code) {
    this.schema = schema;
    this.references = references;
    this.checkFunc = checkFunc;
    this.code = code;
    this.hasTransform = HasTransform2(schema, references);
  }
  Code() {
    return this.code;
  }
  Schema() {
    return this.schema;
  }
  References() {
    return this.references;
  }
  Errors(value) {
    return Errors2(this.schema, this.references, value);
  }
  Check(value) {
    return this.checkFunc(value);
  }
  Decode(value) {
    if (!this.checkFunc(value))
      throw new TransformDecodeCheckError2(this.schema, value, this.Errors(value).First());
    return this.hasTransform ? TransformDecode2(this.schema, this.references, value) : value;
  }
  Encode(value) {
    const encoded = this.hasTransform ? TransformEncode2(this.schema, this.references, value) : value;
    if (!this.checkFunc(encoded))
      throw new TransformEncodeCheckError2(this.schema, value, this.Errors(value).First());
    return encoded;
  }
}
var Character2;
(function(Character3) {
  function DollarSign(code) {
    return code === 36;
  }
  Character3.DollarSign = DollarSign;
  function IsUnderscore(code) {
    return code === 95;
  }
  Character3.IsUnderscore = IsUnderscore;
  function IsAlpha(code) {
    return code >= 65 && code <= 90 || code >= 97 && code <= 122;
  }
  Character3.IsAlpha = IsAlpha;
  function IsNumeric(code) {
    return code >= 48 && code <= 57;
  }
  Character3.IsNumeric = IsNumeric;
})(Character2 || (Character2 = {}));
var MemberExpression2;
(function(MemberExpression3) {
  function IsFirstCharacterNumeric(value) {
    if (value.length === 0)
      return false;
    return Character2.IsNumeric(value.charCodeAt(0));
  }
  function IsAccessor(value) {
    if (IsFirstCharacterNumeric(value))
      return false;
    for (let i = 0;i < value.length; i++) {
      const code = value.charCodeAt(i);
      const check2 = Character2.IsAlpha(code) || Character2.IsNumeric(code) || Character2.DollarSign(code) || Character2.IsUnderscore(code);
      if (!check2)
        return false;
    }
    return true;
  }
  function EscapeHyphen(key) {
    return key.replace(/'/g, "\\'");
  }
  function Encode2(object, key) {
    return IsAccessor(key) ? `${object}.${key}` : `${object}['${EscapeHyphen(key)}']`;
  }
  MemberExpression3.Encode = Encode2;
})(MemberExpression2 || (MemberExpression2 = {}));
var Identifier2;
(function(Identifier3) {
  function Encode2($id) {
    const buffer = [];
    for (let i = 0;i < $id.length; i++) {
      const code = $id.charCodeAt(i);
      if (Character2.IsNumeric(code) || Character2.IsAlpha(code)) {
        buffer.push($id.charAt(i));
      } else {
        buffer.push(`_${code}_`);
      }
    }
    return buffer.join("").replace(/__/g, "_");
  }
  Identifier3.Encode = Encode2;
})(Identifier2 || (Identifier2 = {}));
var LiteralString2;
(function(LiteralString3) {
  function Escape4(content) {
    return content.replace(/'/g, "\\'");
  }
  LiteralString3.Escape = Escape4;
})(LiteralString2 || (LiteralString2 = {}));

class TypeCompilerUnknownTypeError2 extends TypeBoxError2 {
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
}

class TypeCompilerTypeGuardError2 extends TypeBoxError2 {
  constructor(schema) {
    super("Preflight validation check failed to guard for the given schema");
    this.schema = schema;
  }
}
var Policy2;
(function(Policy3) {
  function IsExactOptionalProperty(value, key, expression) {
    return TypeSystemPolicy2.ExactOptionalPropertyTypes ? `('${key}' in ${value} ? ${expression} : true)` : `(${MemberExpression2.Encode(value, key)} !== undefined ? ${expression} : true)`;
  }
  Policy3.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value) {
    return !TypeSystemPolicy2.AllowArrayObject ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}))` : `(typeof ${value} === 'object' && ${value} !== null)`;
  }
  Policy3.IsObjectLike = IsObjectLike;
  function IsRecordLike(value) {
    return !TypeSystemPolicy2.AllowArrayObject ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}) && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))` : `(typeof ${value} === 'object' && ${value} !== null && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))`;
  }
  Policy3.IsRecordLike = IsRecordLike;
  function IsNumberLike(value) {
    return TypeSystemPolicy2.AllowNaN ? `typeof ${value} === 'number'` : `Number.isFinite(${value})`;
  }
  Policy3.IsNumberLike = IsNumberLike;
  function IsVoidLike(value) {
    return TypeSystemPolicy2.AllowNullVoid ? `(${value} === undefined || ${value} === null)` : `${value} === undefined`;
  }
  Policy3.IsVoidLike = IsVoidLike;
})(Policy2 || (Policy2 = {}));
var TypeCompiler2;
(function(TypeCompiler3) {
  function IsAnyOrUnknown3(schema) {
    return schema[Kind2] === "Any" || schema[Kind2] === "Unknown";
  }
  function* FromAny8(schema, references, value) {
    yield "true";
  }
  function* FromArray27(schema, references, value) {
    yield `Array.isArray(${value})`;
    const [parameter, accumulator] = [CreateParameter("value", "any"), CreateParameter("acc", "number")];
    if (IsNumber6(schema.maxItems))
      yield `${value}.length <= ${schema.maxItems}`;
    if (IsNumber6(schema.minItems))
      yield `${value}.length >= ${schema.minItems}`;
    const elementExpression = CreateExpression(schema.items, references, "value");
    yield `${value}.every((${parameter}) => ${elementExpression})`;
    if (IsSchema4(schema.contains) || IsNumber6(schema.minContains) || IsNumber6(schema.maxContains)) {
      const containsSchema = IsSchema4(schema.contains) ? schema.contains : Never2();
      const checkExpression = CreateExpression(containsSchema, references, "value");
      const checkMinContains = IsNumber6(schema.minContains) ? [`(count >= ${schema.minContains})`] : [];
      const checkMaxContains = IsNumber6(schema.maxContains) ? [`(count <= ${schema.maxContains})`] : [];
      const checkCount = `const count = value.reduce((${accumulator}, ${parameter}) => ${checkExpression} ? acc + 1 : acc, 0)`;
      const check2 = [`(count > 0)`, ...checkMinContains, ...checkMaxContains].join(" && ");
      yield `((${parameter}) => { ${checkCount}; return ${check2}})(${value})`;
    }
    if (schema.uniqueItems === true) {
      const check2 = `const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true`;
      const block = `const set = new Set(); for(const element of value) { ${check2} }`;
      yield `((${parameter}) => { ${block} )(${value})`;
    }
  }
  function* FromAsyncIterator12(schema, references, value) {
    yield `(typeof value === 'object' && Symbol.asyncIterator in ${value})`;
  }
  function* FromBigInt9(schema, references, value) {
    yield `(typeof ${value} === 'bigint')`;
    if (IsBigInt6(schema.exclusiveMaximum))
      yield `${value} < BigInt(${schema.exclusiveMaximum})`;
    if (IsBigInt6(schema.exclusiveMinimum))
      yield `${value} > BigInt(${schema.exclusiveMinimum})`;
    if (IsBigInt6(schema.maximum))
      yield `${value} <= BigInt(${schema.maximum})`;
    if (IsBigInt6(schema.minimum))
      yield `${value} >= BigInt(${schema.minimum})`;
    if (IsBigInt6(schema.multipleOf))
      yield `(${value} % BigInt(${schema.multipleOf})) === 0`;
  }
  function* FromBoolean9(schema, references, value) {
    yield `(typeof ${value} === 'boolean')`;
  }
  function* FromConstructor13(schema, references, value) {
    yield* Visit26(schema.returns, references, `${value}.prototype`);
  }
  function* FromDate11(schema, references, value) {
    yield `(${value} instanceof Date) && Number.isFinite(${value}.getTime())`;
    if (IsNumber6(schema.exclusiveMaximumTimestamp))
      yield `${value}.getTime() < ${schema.exclusiveMaximumTimestamp}`;
    if (IsNumber6(schema.exclusiveMinimumTimestamp))
      yield `${value}.getTime() > ${schema.exclusiveMinimumTimestamp}`;
    if (IsNumber6(schema.maximumTimestamp))
      yield `${value}.getTime() <= ${schema.maximumTimestamp}`;
    if (IsNumber6(schema.minimumTimestamp))
      yield `${value}.getTime() >= ${schema.minimumTimestamp}`;
    if (IsNumber6(schema.multipleOfTimestamp))
      yield `(${value}.getTime() % ${schema.multipleOfTimestamp}) === 0`;
  }
  function* FromFunction12(schema, references, value) {
    yield `(typeof ${value} === 'function')`;
  }
  function* FromImport14(schema, references, value) {
    const members = globalThis.Object.getOwnPropertyNames(schema.$defs).reduce((result, key) => {
      return [...result, schema.$defs[key]];
    }, []);
    yield* Visit26(Ref2(schema.$ref), [...references, ...members], value);
  }
  function* FromInteger9(schema, references, value) {
    yield `Number.isInteger(${value})`;
    if (IsNumber6(schema.exclusiveMaximum))
      yield `${value} < ${schema.exclusiveMaximum}`;
    if (IsNumber6(schema.exclusiveMinimum))
      yield `${value} > ${schema.exclusiveMinimum}`;
    if (IsNumber6(schema.maximum))
      yield `${value} <= ${schema.maximum}`;
    if (IsNumber6(schema.minimum))
      yield `${value} >= ${schema.minimum}`;
    if (IsNumber6(schema.multipleOf))
      yield `(${value} % ${schema.multipleOf}) === 0`;
  }
  function* FromIntersect30(schema, references, value) {
    const check1 = schema.allOf.map((schema2) => CreateExpression(schema2, references, value)).join(" && ");
    if (schema.unevaluatedProperties === false) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern2(schema))};`);
      const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key))`;
      yield `(${check1} && ${check2})`;
    } else if (IsSchema4(schema.unevaluatedProperties)) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern2(schema))};`);
      const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key) || ${CreateExpression(schema.unevaluatedProperties, references, `${value}[key]`)})`;
      yield `(${check1} && ${check2})`;
    } else {
      yield `(${check1})`;
    }
  }
  function* FromIterator12(schema, references, value) {
    yield `(typeof value === 'object' && Symbol.iterator in ${value})`;
  }
  function* FromLiteral11(schema, references, value) {
    if (typeof schema.const === "number" || typeof schema.const === "boolean") {
      yield `(${value} === ${schema.const})`;
    } else {
      yield `(${value} === '${LiteralString2.Escape(schema.const)}')`;
    }
  }
  function* FromNever9(schema, references, value) {
    yield `false`;
  }
  function* FromNot14(schema, references, value) {
    const expression = CreateExpression(schema.not, references, value);
    yield `(!${expression})`;
  }
  function* FromNull9(schema, references, value) {
    yield `(${value} === null)`;
  }
  function* FromNumber9(schema, references, value) {
    yield Policy2.IsNumberLike(value);
    if (IsNumber6(schema.exclusiveMaximum))
      yield `${value} < ${schema.exclusiveMaximum}`;
    if (IsNumber6(schema.exclusiveMinimum))
      yield `${value} > ${schema.exclusiveMinimum}`;
    if (IsNumber6(schema.maximum))
      yield `${value} <= ${schema.maximum}`;
    if (IsNumber6(schema.minimum))
      yield `${value} >= ${schema.minimum}`;
    if (IsNumber6(schema.multipleOf))
      yield `(${value} % ${schema.multipleOf}) === 0`;
  }
  function* FromObject29(schema, references, value) {
    yield Policy2.IsObjectLike(value);
    if (IsNumber6(schema.minProperties))
      yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;
    if (IsNumber6(schema.maxProperties))
      yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;
    const knownKeys = Object.getOwnPropertyNames(schema.properties);
    for (const knownKey of knownKeys) {
      const memberExpression = MemberExpression2.Encode(value, knownKey);
      const property = schema.properties[knownKey];
      if (schema.required && schema.required.includes(knownKey)) {
        yield* Visit26(property, references, memberExpression);
        if (ExtendsUndefinedCheck2(property) || IsAnyOrUnknown3(property))
          yield `('${knownKey}' in ${value})`;
      } else {
        const expression = CreateExpression(property, references, memberExpression);
        yield Policy2.IsExactOptionalProperty(value, knownKey, expression);
      }
    }
    if (schema.additionalProperties === false) {
      if (schema.required && schema.required.length === knownKeys.length) {
        yield `Object.getOwnPropertyNames(${value}).length === ${knownKeys.length}`;
      } else {
        const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
        yield `Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key))`;
      }
    }
    if (typeof schema.additionalProperties === "object") {
      const expression = CreateExpression(schema.additionalProperties, references, `${value}[key]`);
      const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
      yield `(Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key) || ${expression}))`;
    }
  }
  function* FromPromise12(schema, references, value) {
    yield `(typeof value === 'object' && typeof ${value}.then === 'function')`;
  }
  function* FromRecord20(schema, references, value) {
    yield Policy2.IsRecordLike(value);
    if (IsNumber6(schema.minProperties))
      yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;
    if (IsNumber6(schema.maxProperties))
      yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;
    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
    const variable = CreateVariable(`${new RegExp(patternKey)}`);
    const check1 = CreateExpression(patternSchema, references, "value");
    const check2 = IsSchema4(schema.additionalProperties) ? CreateExpression(schema.additionalProperties, references, value) : schema.additionalProperties === false ? "false" : "true";
    const expression = `(${variable}.test(key) ? ${check1} : ${check2})`;
    yield `(Object.entries(${value}).every(([key, value]) => ${expression}))`;
  }
  function* FromRef24(schema, references, value) {
    const target = Deref4(schema, references);
    if (state.functions.has(schema.$ref))
      return yield `${CreateFunctionName(schema.$ref)}(${value})`;
    yield* Visit26(target, references, value);
  }
  function* FromRegExp8(schema, references, value) {
    const variable = CreateVariable(`${new RegExp(schema.source, schema.flags)};`);
    yield `(typeof ${value} === 'string')`;
    if (IsNumber6(schema.maxLength))
      yield `${value}.length <= ${schema.maxLength}`;
    if (IsNumber6(schema.minLength))
      yield `${value}.length >= ${schema.minLength}`;
    yield `${variable}.test(${value})`;
  }
  function* FromString9(schema, references, value) {
    yield `(typeof ${value} === 'string')`;
    if (IsNumber6(schema.maxLength))
      yield `${value}.length <= ${schema.maxLength}`;
    if (IsNumber6(schema.minLength))
      yield `${value}.length >= ${schema.minLength}`;
    if (schema.pattern !== undefined) {
      const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
      yield `${variable}.test(${value})`;
    }
    if (schema.format !== undefined) {
      yield `format('${schema.format}', ${value})`;
    }
  }
  function* FromSymbol9(schema, references, value) {
    yield `(typeof ${value} === 'symbol')`;
  }
  function* FromTemplateLiteral12(schema, references, value) {
    yield `(typeof ${value} === 'string')`;
    const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
    yield `${variable}.test(${value})`;
  }
  function* FromThis16(schema, references, value) {
    yield `${CreateFunctionName(schema.$ref)}(${value})`;
  }
  function* FromTuple24(schema, references, value) {
    yield `Array.isArray(${value})`;
    if (schema.items === undefined)
      return yield `${value}.length === 0`;
    yield `(${value}.length === ${schema.maxItems})`;
    for (let i = 0;i < schema.items.length; i++) {
      const expression = CreateExpression(schema.items[i], references, `${value}[${i}]`);
      yield `${expression}`;
    }
  }
  function* FromUndefined9(schema, references, value) {
    yield `${value} === undefined`;
  }
  function* FromUnion34(schema, references, value) {
    const expressions = schema.anyOf.map((schema2) => CreateExpression(schema2, references, value));
    yield `(${expressions.join(" || ")})`;
  }
  function* FromUint8Array8(schema, references, value) {
    yield `${value} instanceof Uint8Array`;
    if (IsNumber6(schema.maxByteLength))
      yield `(${value}.length <= ${schema.maxByteLength})`;
    if (IsNumber6(schema.minByteLength))
      yield `(${value}.length >= ${schema.minByteLength})`;
  }
  function* FromUnknown8(schema, references, value) {
    yield "true";
  }
  function* FromVoid8(schema, references, value) {
    yield Policy2.IsVoidLike(value);
  }
  function* FromKind6(schema, references, value) {
    const instance = state.instances.size;
    state.instances.set(instance, schema);
    yield `kind('${schema[Kind2]}', ${instance}, ${value})`;
  }
  function* Visit26(schema, references, value, useHoisting = true) {
    const references_ = IsString6(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    if (useHoisting && IsString6(schema.$id)) {
      const functionName = CreateFunctionName(schema.$id);
      if (state.functions.has(functionName)) {
        return yield `${functionName}(${value})`;
      } else {
        state.functions.set(functionName, "<deferred>");
        const functionCode = CreateFunction(functionName, schema, references, "value", false);
        state.functions.set(functionName, functionCode);
        return yield `${functionName}(${value})`;
      }
    }
    switch (schema_[Kind2]) {
      case "Any":
        return yield* FromAny8(schema_, references_, value);
      case "Array":
        return yield* FromArray27(schema_, references_, value);
      case "AsyncIterator":
        return yield* FromAsyncIterator12(schema_, references_, value);
      case "BigInt":
        return yield* FromBigInt9(schema_, references_, value);
      case "Boolean":
        return yield* FromBoolean9(schema_, references_, value);
      case "Constructor":
        return yield* FromConstructor13(schema_, references_, value);
      case "Date":
        return yield* FromDate11(schema_, references_, value);
      case "Function":
        return yield* FromFunction12(schema_, references_, value);
      case "Import":
        return yield* FromImport14(schema_, references_, value);
      case "Integer":
        return yield* FromInteger9(schema_, references_, value);
      case "Intersect":
        return yield* FromIntersect30(schema_, references_, value);
      case "Iterator":
        return yield* FromIterator12(schema_, references_, value);
      case "Literal":
        return yield* FromLiteral11(schema_, references_, value);
      case "Never":
        return yield* FromNever9(schema_, references_, value);
      case "Not":
        return yield* FromNot14(schema_, references_, value);
      case "Null":
        return yield* FromNull9(schema_, references_, value);
      case "Number":
        return yield* FromNumber9(schema_, references_, value);
      case "Object":
        return yield* FromObject29(schema_, references_, value);
      case "Promise":
        return yield* FromPromise12(schema_, references_, value);
      case "Record":
        return yield* FromRecord20(schema_, references_, value);
      case "Ref":
        return yield* FromRef24(schema_, references_, value);
      case "RegExp":
        return yield* FromRegExp8(schema_, references_, value);
      case "String":
        return yield* FromString9(schema_, references_, value);
      case "Symbol":
        return yield* FromSymbol9(schema_, references_, value);
      case "TemplateLiteral":
        return yield* FromTemplateLiteral12(schema_, references_, value);
      case "This":
        return yield* FromThis16(schema_, references_, value);
      case "Tuple":
        return yield* FromTuple24(schema_, references_, value);
      case "Undefined":
        return yield* FromUndefined9(schema_, references_, value);
      case "Union":
        return yield* FromUnion34(schema_, references_, value);
      case "Uint8Array":
        return yield* FromUint8Array8(schema_, references_, value);
      case "Unknown":
        return yield* FromUnknown8(schema_, references_, value);
      case "Void":
        return yield* FromVoid8(schema_, references_, value);
      default:
        if (!exports_type5.Has(schema_[Kind2]))
          throw new TypeCompilerUnknownTypeError2(schema);
        return yield* FromKind6(schema_, references_, value);
    }
  }
  const state = {
    language: "javascript",
    functions: new Map,
    variables: new Map,
    instances: new Map
  };
  function CreateExpression(schema, references, value, useHoisting = true) {
    return `(${[...Visit26(schema, references, value, useHoisting)].join(" && ")})`;
  }
  function CreateFunctionName($id) {
    return `check_${Identifier2.Encode($id)}`;
  }
  function CreateVariable(expression) {
    const variableName = `local_${state.variables.size}`;
    state.variables.set(variableName, `const ${variableName} = ${expression}`);
    return variableName;
  }
  function CreateFunction(name, schema, references, value, useHoisting = true) {
    const [newline, pad] = [`
`, (length) => "".padStart(length, " ")];
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const expression = [...Visit26(schema, references, value, useHoisting)].map((expression2) => `${pad(4)}${expression2}`).join(` &&${newline}`);
    return `function ${name}(${parameter})${returns} {${newline}${pad(2)}return (${newline}${expression}${newline}${pad(2)})
}`;
  }
  function CreateParameter(name, type) {
    const annotation = state.language === "typescript" ? `: ${type}` : "";
    return `${name}${annotation}`;
  }
  function CreateReturns(type) {
    return state.language === "typescript" ? `: ${type}` : "";
  }
  function Build(schema, references, options) {
    const functionCode = CreateFunction("check", schema, references, "value");
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const functions = [...state.functions.values()];
    const variables = [...state.variables.values()];
    const checkFunction = IsString6(schema.$id) ? `return function check(${parameter})${returns} {
  return ${CreateFunctionName(schema.$id)}(value)
}` : `return ${functionCode}`;
    return [...variables, ...functions, checkFunction].join(`
`);
  }
  function Code(...args) {
    const defaults = { language: "javascript" };
    const [schema, references, options] = args.length === 2 && IsArray6(args[1]) ? [args[0], args[1], defaults] : args.length === 2 && !IsArray6(args[1]) ? [args[0], [], args[1]] : args.length === 3 ? [args[0], args[1], args[2]] : args.length === 1 ? [args[0], [], defaults] : [null, [], defaults];
    state.language = options.language;
    state.variables.clear();
    state.functions.clear();
    state.instances.clear();
    if (!IsSchema4(schema))
      throw new TypeCompilerTypeGuardError2(schema);
    for (const schema2 of references)
      if (!IsSchema4(schema2))
        throw new TypeCompilerTypeGuardError2(schema2);
    return Build(schema, references, options);
  }
  TypeCompiler3.Code = Code;
  function Compile(schema, references = []) {
    const generatedCode = Code(schema, references, { language: "javascript" });
    const compiledFunction = globalThis.Function("kind", "format", "hash", generatedCode);
    const instances = new Map(state.instances);
    function typeRegistryFunction(kind, instance, value) {
      if (!exports_type5.Has(kind) || !instances.has(instance))
        return false;
      const checkFunc = exports_type5.Get(kind);
      const schema2 = instances.get(instance);
      return checkFunc(schema2, value);
    }
    function formatRegistryFunction(format, value) {
      if (!exports_format2.Has(format))
        return false;
      const checkFunc = exports_format2.Get(format);
      return checkFunc(value);
    }
    function hashFunction(value) {
      return Hash2(value);
    }
    const checkFunction = compiledFunction(typeRegistryFunction, formatRegistryFunction, hashFunction);
    return new TypeCheck2(schema, references, checkFunction, generatedCode);
  }
  TypeCompiler3.Compile = Compile;
})(TypeCompiler2 || (TypeCompiler2 = {}));
// node_modules/@sinclair/typebox/build/esm/value/assert/assert.mjs
var __classPrivateFieldSet2 = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet2 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AssertError_instances2;
var _AssertError_iterator2;
var _AssertError_Iterator3;

class AssertError2 extends TypeBoxError2 {
  constructor(iterator) {
    const error2 = iterator.First();
    super(error2 === undefined ? "Invalid Value" : error2.message);
    _AssertError_instances2.add(this);
    _AssertError_iterator2.set(this, undefined);
    __classPrivateFieldSet2(this, _AssertError_iterator2, iterator, "f");
    this.error = error2;
  }
  Errors() {
    return new ValueErrorIterator2(__classPrivateFieldGet2(this, _AssertError_instances2, "m", _AssertError_Iterator3).call(this));
  }
}
_AssertError_iterator2 = new WeakMap, _AssertError_instances2 = new WeakSet, _AssertError_Iterator3 = function* _AssertError_Iterator4() {
  if (this.error)
    yield this.error;
  yield* __classPrivateFieldGet2(this, _AssertError_iterator2, "f");
};
function AssertValue2(schema, references, value) {
  if (Check2(schema, references, value))
    return;
  throw new AssertError2(Errors2(schema, references, value));
}
function Assert2(...args) {
  return args.length === 3 ? AssertValue2(args[0], args[1], args[2]) : AssertValue2(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/clone/clone.mjs
function FromObject29(value) {
  const Acc = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    Acc[key] = Clone4(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    Acc[key] = Clone4(value[key]);
  }
  return Acc;
}
function FromArray27(value) {
  return value.map((element) => Clone4(element));
}
function FromTypedArray2(value) {
  return value.slice();
}
function FromMap2(value) {
  return new Map(Clone4([...value.entries()]));
}
function FromSet2(value) {
  return new Set(Clone4([...value.entries()]));
}
function FromDate11(value) {
  return new Date(value.toISOString());
}
function FromValue4(value) {
  return value;
}
function Clone4(value) {
  if (IsArray6(value))
    return FromArray27(value);
  if (IsDate6(value))
    return FromDate11(value);
  if (IsTypedArray2(value))
    return FromTypedArray2(value);
  if (IsMap2(value))
    return FromMap2(value);
  if (IsSet2(value))
    return FromSet2(value);
  if (IsObject6(value))
    return FromObject29(value);
  if (IsValueType2(value))
    return FromValue4(value);
  throw new Error("ValueClone: Unable to clone value");
}

// node_modules/@sinclair/typebox/build/esm/value/create/create.mjs
class ValueCreateError2 extends TypeBoxError2 {
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
}
function FromDefault2(value) {
  return IsFunction6(value) ? value() : Clone4(value);
}
function FromAny8(schema, references) {
  if (HasPropertyKey4(schema, "default")) {
    return FromDefault2(schema.default);
  } else {
    return {};
  }
}
function FromArray28(schema, references) {
  if (schema.uniqueItems === true && !HasPropertyKey4(schema, "default")) {
    throw new ValueCreateError2(schema, "Array with the uniqueItems constraint requires a default value");
  } else if ("contains" in schema && !HasPropertyKey4(schema, "default")) {
    throw new ValueCreateError2(schema, "Array with the contains constraint requires a default value");
  } else if ("default" in schema) {
    return FromDefault2(schema.default);
  } else if (schema.minItems !== undefined) {
    return Array.from({ length: schema.minItems }).map((item) => {
      return Visit26(schema.items, references);
    });
  } else {
    return [];
  }
}
function FromAsyncIterator12(schema, references) {
  if (HasPropertyKey4(schema, "default")) {
    return FromDefault2(schema.default);
  } else {
    return async function* () {
    }();
  }
}
function FromBigInt9(schema, references) {
  if (HasPropertyKey4(schema, "default")) {
    return FromDefault2(schema.default);
  } else {
    return BigInt(0);
  }
}
function FromBoolean9(schema, references) {
  if (HasPropertyKey4(schema, "default")) {
    return FromDefault2(schema.default);
  } else {
    return false;
  }
}
function FromConstructor13(schema, references) {
  if (HasPropertyKey4(schema, "default")) {
    return FromDefault2(schema.default);
  } else {
    const value = Visit26(schema.returns, references);
    if (typeof value === "object" && !Array.isArray(value)) {
      return class {
        constructor() {
          for (const [key, val] of Object.entries(value)) {
            const self = this;
            self[key] = val;
          }
        }
      };
    } else {
      return class {
      };
    }
  }
}
function FromDate12(schema, references) {
  if (HasPropertyKey4(schema, "default")) {
    return FromDefault2(schema.default);
  } else if (schema.minimumTimestamp !== undefined) {
    return new Date(schema.minimumTimestamp);
  } else {
    return new Date;
  }
}
function FromFunction12(schema, references) {
  if (HasPropertyKey4(schema, "default")) {
    return FromDefault2(schema.default);
  } else {
    return () => Visit26(schema.returns, references);
  }
}
function FromImport14(schema, references) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit26(target, [...references, ...definitions]);
}
function FromInteger9(schema, references) {
  if (HasPropertyKey4(schema, "default")) {
    return FromDefault2(schema.default);
  } else if (schema.minimum !== undefined) {
    return schema.minimum;
  } else {
    return 0;
  }
}
function FromIntersect30(schema, references) {
  if (HasPropertyKey4(schema, "default")) {
    return FromDefault2(schema.default);
  } else {
    const value = schema.allOf.reduce((acc, schema2) => {
      const next = Visit26(schema2, references);
      return typeof next === "object" ? { ...acc, ...next } : next;
    }, {});
    if (!Check2(schema, references, value))
      throw new ValueCreateError2(schema, "Intersect produced invalid value. Consider using a default value.");
    return value;
  }
}
function FromIterator12(schema, references) {
  if (HasPropertyKey4(schema, "default")) {
    return FromDefault2(schema.default);
  } else {
    return function* () {
    }();
  }
}
function FromLiteral11(schema, references) {
  if (HasPropertyKey4(schema, "default")) {
    return FromDefault2(schema.default);
  } else {
    return schema.const;
  }
}
function FromNever9(schema, references) {
  if (HasPropertyKey4(schema, "default")) {
    return FromDefault2(schema.default);
  } else {
    throw new ValueCreateError2(schema, "Never types cannot be created. Consider using a default value.");
  }
}
function FromNot14(schema, references) {
  if (HasPropertyKey4(schema, "default")) {
    return FromDefault2(schema.default);
  } else {
    throw new ValueCreateError2(schema, "Not types must have a default value");
  }
}
function FromNull9(schema, references) {
  if (HasPropertyKey4(schema, "default")) {
    return FromDefault2(schema.default);
  } else {
    return null;
  }
}
function FromNumber9(schema, references) {
  if (HasPropertyKey4(schema, "default")) {
    return FromDefault2(schema.default);
  } else if (schema.minimum !== undefined) {
    return schema.minimum;
  } else {
    return 0;
  }
}
function FromObject30(schema, references) {
  if (HasPropertyKey4(schema, "default")) {
    return FromDefault2(schema.default);
  } else {
    const required = new Set(schema.required);
    const Acc = {};
    for (const [key, subschema] of Object.entries(schema.properties)) {
      if (!required.has(key))
        continue;
      Acc[key] = Visit26(subschema, references);
    }
    return Acc;
  }
}
function FromPromise12(schema, references) {
  if (HasPropertyKey4(schema, "default")) {
    return FromDefault2(schema.default);
  } else {
    return Promise.resolve(Visit26(schema.item, references));
  }
}
function FromRecord20(schema, references) {
  const [keyPattern, valueSchema] = Object.entries(schema.patternProperties)[0];
  if (HasPropertyKey4(schema, "default")) {
    return FromDefault2(schema.default);
  } else if (!(keyPattern === PatternStringExact2 || keyPattern === PatternNumberExact2)) {
    const propertyKeys = keyPattern.slice(1, keyPattern.length - 1).split("|");
    const Acc = {};
    for (const key of propertyKeys)
      Acc[key] = Visit26(valueSchema, references);
    return Acc;
  } else {
    return {};
  }
}
function FromRef24(schema, references) {
  if (HasPropertyKey4(schema, "default")) {
    return FromDefault2(schema.default);
  } else {
    return Visit26(Deref4(schema, references), references);
  }
}
function FromRegExp8(schema, references) {
  if (HasPropertyKey4(schema, "default")) {
    return FromDefault2(schema.default);
  } else {
    throw new ValueCreateError2(schema, "RegExp types cannot be created. Consider using a default value.");
  }
}
function FromString9(schema, references) {
  if (schema.pattern !== undefined) {
    if (!HasPropertyKey4(schema, "default")) {
      throw new ValueCreateError2(schema, "String types with patterns must specify a default value");
    } else {
      return FromDefault2(schema.default);
    }
  } else if (schema.format !== undefined) {
    if (!HasPropertyKey4(schema, "default")) {
      throw new ValueCreateError2(schema, "String types with formats must specify a default value");
    } else {
      return FromDefault2(schema.default);
    }
  } else {
    if (HasPropertyKey4(schema, "default")) {
      return FromDefault2(schema.default);
    } else if (schema.minLength !== undefined) {
      return Array.from({ length: schema.minLength }).map(() => " ").join("");
    } else {
      return "";
    }
  }
}
function FromSymbol9(schema, references) {
  if (HasPropertyKey4(schema, "default")) {
    return FromDefault2(schema.default);
  } else if ("value" in schema) {
    return Symbol.for(schema.value);
  } else {
    return Symbol();
  }
}
function FromTemplateLiteral12(schema, references) {
  if (HasPropertyKey4(schema, "default")) {
    return FromDefault2(schema.default);
  }
  if (!IsTemplateLiteralFinite2(schema))
    throw new ValueCreateError2(schema, "Can only create template literals that produce a finite variants. Consider using a default value.");
  const generated = TemplateLiteralGenerate2(schema);
  return generated[0];
}
function FromThis16(schema, references) {
  if (recursiveDepth2++ > recursiveMaxDepth2)
    throw new ValueCreateError2(schema, "Cannot create recursive type as it appears possibly infinite. Consider using a default.");
  if (HasPropertyKey4(schema, "default")) {
    return FromDefault2(schema.default);
  } else {
    return Visit26(Deref4(schema, references), references);
  }
}
function FromTuple24(schema, references) {
  if (HasPropertyKey4(schema, "default")) {
    return FromDefault2(schema.default);
  }
  if (schema.items === undefined) {
    return [];
  } else {
    return Array.from({ length: schema.minItems }).map((_3, index) => Visit26(schema.items[index], references));
  }
}
function FromUndefined9(schema, references) {
  if (HasPropertyKey4(schema, "default")) {
    return FromDefault2(schema.default);
  } else {
    return;
  }
}
function FromUnion34(schema, references) {
  if (HasPropertyKey4(schema, "default")) {
    return FromDefault2(schema.default);
  } else if (schema.anyOf.length === 0) {
    throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
  } else {
    return Visit26(schema.anyOf[0], references);
  }
}
function FromUint8Array8(schema, references) {
  if (HasPropertyKey4(schema, "default")) {
    return FromDefault2(schema.default);
  } else if (schema.minByteLength !== undefined) {
    return new Uint8Array(schema.minByteLength);
  } else {
    return new Uint8Array(0);
  }
}
function FromUnknown8(schema, references) {
  if (HasPropertyKey4(schema, "default")) {
    return FromDefault2(schema.default);
  } else {
    return {};
  }
}
function FromVoid8(schema, references) {
  if (HasPropertyKey4(schema, "default")) {
    return FromDefault2(schema.default);
  } else {
    return;
  }
}
function FromKind6(schema, references) {
  if (HasPropertyKey4(schema, "default")) {
    return FromDefault2(schema.default);
  } else {
    throw new Error("User defined types must specify a default value");
  }
}
function Visit26(schema, references) {
  const references_ = Pushref2(schema, references);
  const schema_ = schema;
  switch (schema_[Kind2]) {
    case "Any":
      return FromAny8(schema_, references_);
    case "Array":
      return FromArray28(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator12(schema_, references_);
    case "BigInt":
      return FromBigInt9(schema_, references_);
    case "Boolean":
      return FromBoolean9(schema_, references_);
    case "Constructor":
      return FromConstructor13(schema_, references_);
    case "Date":
      return FromDate12(schema_, references_);
    case "Function":
      return FromFunction12(schema_, references_);
    case "Import":
      return FromImport14(schema_, references_);
    case "Integer":
      return FromInteger9(schema_, references_);
    case "Intersect":
      return FromIntersect30(schema_, references_);
    case "Iterator":
      return FromIterator12(schema_, references_);
    case "Literal":
      return FromLiteral11(schema_, references_);
    case "Never":
      return FromNever9(schema_, references_);
    case "Not":
      return FromNot14(schema_, references_);
    case "Null":
      return FromNull9(schema_, references_);
    case "Number":
      return FromNumber9(schema_, references_);
    case "Object":
      return FromObject30(schema_, references_);
    case "Promise":
      return FromPromise12(schema_, references_);
    case "Record":
      return FromRecord20(schema_, references_);
    case "Ref":
      return FromRef24(schema_, references_);
    case "RegExp":
      return FromRegExp8(schema_, references_);
    case "String":
      return FromString9(schema_, references_);
    case "Symbol":
      return FromSymbol9(schema_, references_);
    case "TemplateLiteral":
      return FromTemplateLiteral12(schema_, references_);
    case "This":
      return FromThis16(schema_, references_);
    case "Tuple":
      return FromTuple24(schema_, references_);
    case "Undefined":
      return FromUndefined9(schema_, references_);
    case "Union":
      return FromUnion34(schema_, references_);
    case "Uint8Array":
      return FromUint8Array8(schema_, references_);
    case "Unknown":
      return FromUnknown8(schema_, references_);
    case "Void":
      return FromVoid8(schema_, references_);
    default:
      if (!exports_type5.Has(schema_[Kind2]))
        throw new ValueCreateError2(schema_, "Unknown type");
      return FromKind6(schema_, references_);
  }
}
var recursiveMaxDepth2 = 512;
var recursiveDepth2 = 0;
function Create4(...args) {
  recursiveDepth2 = 0;
  return args.length === 2 ? Visit26(args[0], args[1]) : Visit26(args[0], []);
}

// node_modules/@sinclair/typebox/build/esm/value/cast/cast.mjs
class ValueCastError2 extends TypeBoxError2 {
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
}
function ScoreUnion2(schema, references, value) {
  if (schema[Kind2] === "Object" && typeof value === "object" && !IsNull6(value)) {
    const object = schema;
    const keys = Object.getOwnPropertyNames(value);
    const entries = Object.entries(object.properties);
    const [point, max] = [1 / entries.length, entries.length];
    return entries.reduce((acc, [key, schema2]) => {
      const literal = schema2[Kind2] === "Literal" && schema2.const === value[key] ? max : 0;
      const checks = Check2(schema2, references, value[key]) ? point : 0;
      const exists = keys.includes(key) ? point : 0;
      return acc + (literal + checks + exists);
    }, 0);
  } else {
    return Check2(schema, references, value) ? 1 : 0;
  }
}
function SelectUnion2(union, references, value) {
  const schemas = union.anyOf.map((schema) => Deref4(schema, references));
  let [select, best] = [schemas[0], 0];
  for (const schema of schemas) {
    const score = ScoreUnion2(schema, references, value);
    if (score > best) {
      select = schema;
      best = score;
    }
  }
  return select;
}
function CastUnion2(union, references, value) {
  if ("default" in union) {
    return typeof value === "function" ? union.default : Clone4(union.default);
  } else {
    const schema = SelectUnion2(union, references, value);
    return Cast2(schema, references, value);
  }
}
function DefaultClone2(schema, references, value) {
  return Check2(schema, references, value) ? Clone4(value) : Create4(schema, references);
}
function Default8(schema, references, value) {
  return Check2(schema, references, value) ? value : Create4(schema, references);
}
function FromArray29(schema, references, value) {
  if (Check2(schema, references, value))
    return Clone4(value);
  const created = IsArray6(value) ? Clone4(value) : Create4(schema, references);
  const minimum = IsNumber6(schema.minItems) && created.length < schema.minItems ? [...created, ...Array.from({ length: schema.minItems - created.length }, () => null)] : created;
  const maximum = IsNumber6(schema.maxItems) && minimum.length > schema.maxItems ? minimum.slice(0, schema.maxItems) : minimum;
  const casted = maximum.map((value2) => Visit27(schema.items, references, value2));
  if (schema.uniqueItems !== true)
    return casted;
  const unique = [...new Set(casted)];
  if (!Check2(schema, references, unique))
    throw new ValueCastError2(schema, "Array cast produced invalid data due to uniqueItems constraint");
  return unique;
}
function FromConstructor14(schema, references, value) {
  if (Check2(schema, references, value))
    return Create4(schema, references);
  const required = new Set(schema.returns.required || []);
  const result = function() {
  };
  for (const [key, property] of Object.entries(schema.returns.properties)) {
    if (!required.has(key) && value.prototype[key] === undefined)
      continue;
    result.prototype[key] = Visit27(property, references, value.prototype[key]);
  }
  return result;
}
function FromImport15(schema, references, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit27(target, [...references, ...definitions], value);
}
function FromIntersect31(schema, references, value) {
  const created = Create4(schema, references);
  const mapped = IsObject6(created) && IsObject6(value) ? { ...created, ...value } : value;
  return Check2(schema, references, mapped) ? mapped : Create4(schema, references);
}
function FromNever10(schema, references, value) {
  throw new ValueCastError2(schema, "Never types cannot be cast");
}
function FromObject31(schema, references, value) {
  if (Check2(schema, references, value))
    return value;
  if (value === null || typeof value !== "object")
    return Create4(schema, references);
  const required = new Set(schema.required || []);
  const result = {};
  for (const [key, property] of Object.entries(schema.properties)) {
    if (!required.has(key) && value[key] === undefined)
      continue;
    result[key] = Visit27(property, references, value[key]);
  }
  if (typeof schema.additionalProperties === "object") {
    const propertyNames = Object.getOwnPropertyNames(schema.properties);
    for (const propertyName of Object.getOwnPropertyNames(value)) {
      if (propertyNames.includes(propertyName))
        continue;
      result[propertyName] = Visit27(schema.additionalProperties, references, value[propertyName]);
    }
  }
  return result;
}
function FromRecord21(schema, references, value) {
  if (Check2(schema, references, value))
    return Clone4(value);
  if (value === null || typeof value !== "object" || Array.isArray(value) || value instanceof Date)
    return Create4(schema, references);
  const subschemaPropertyName = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const subschema = schema.patternProperties[subschemaPropertyName];
  const result = {};
  for (const [propKey, propValue] of Object.entries(value)) {
    result[propKey] = Visit27(subschema, references, propValue);
  }
  return result;
}
function FromRef25(schema, references, value) {
  return Visit27(Deref4(schema, references), references, value);
}
function FromThis17(schema, references, value) {
  return Visit27(Deref4(schema, references), references, value);
}
function FromTuple25(schema, references, value) {
  if (Check2(schema, references, value))
    return Clone4(value);
  if (!IsArray6(value))
    return Create4(schema, references);
  if (schema.items === undefined)
    return [];
  return schema.items.map((schema2, index) => Visit27(schema2, references, value[index]));
}
function FromUnion35(schema, references, value) {
  return Check2(schema, references, value) ? Clone4(value) : CastUnion2(schema, references, value);
}
function Visit27(schema, references, value) {
  const references_ = IsString6(schema.$id) ? Pushref2(schema, references) : references;
  const schema_ = schema;
  switch (schema[Kind2]) {
    case "Array":
      return FromArray29(schema_, references_, value);
    case "Constructor":
      return FromConstructor14(schema_, references_, value);
    case "Import":
      return FromImport15(schema_, references_, value);
    case "Intersect":
      return FromIntersect31(schema_, references_, value);
    case "Never":
      return FromNever10(schema_, references_, value);
    case "Object":
      return FromObject31(schema_, references_, value);
    case "Record":
      return FromRecord21(schema_, references_, value);
    case "Ref":
      return FromRef25(schema_, references_, value);
    case "This":
      return FromThis17(schema_, references_, value);
    case "Tuple":
      return FromTuple25(schema_, references_, value);
    case "Union":
      return FromUnion35(schema_, references_, value);
    case "Date":
    case "Symbol":
    case "Uint8Array":
      return DefaultClone2(schema, references, value);
    default:
      return Default8(schema_, references_, value);
  }
}
function Cast2(...args) {
  return args.length === 3 ? Visit27(args[0], args[1], args[2]) : Visit27(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/clean/clean.mjs
function IsCheckable2(schema) {
  return IsKind3(schema) && schema[Kind2] !== "Unsafe";
}
function FromArray30(schema, references, value) {
  if (!IsArray6(value))
    return value;
  return value.map((value2) => Visit28(schema.items, references, value2));
}
function FromImport16(schema, references, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit28(target, [...references, ...definitions], value);
}
function FromIntersect32(schema, references, value) {
  const unevaluatedProperties = schema.unevaluatedProperties;
  const intersections = schema.allOf.map((schema2) => Visit28(schema2, references, Clone4(value)));
  const composite = intersections.reduce((acc, value2) => IsObject6(value2) ? { ...acc, ...value2 } : value2, {});
  if (!IsObject6(value) || !IsObject6(composite) || !IsKind3(unevaluatedProperties))
    return composite;
  const knownkeys = KeyOfPropertyKeys2(schema);
  for (const key of Object.getOwnPropertyNames(value)) {
    if (knownkeys.includes(key))
      continue;
    if (Check2(unevaluatedProperties, references, value[key])) {
      composite[key] = Visit28(unevaluatedProperties, references, value[key]);
    }
  }
  return composite;
}
function FromObject32(schema, references, value) {
  if (!IsObject6(value) || IsArray6(value))
    return value;
  const additionalProperties = schema.additionalProperties;
  for (const key of Object.getOwnPropertyNames(value)) {
    if (HasPropertyKey4(schema.properties, key)) {
      value[key] = Visit28(schema.properties[key], references, value[key]);
      continue;
    }
    if (IsKind3(additionalProperties) && Check2(additionalProperties, references, value[key])) {
      value[key] = Visit28(additionalProperties, references, value[key]);
      continue;
    }
    delete value[key];
  }
  return value;
}
function FromRecord22(schema, references, value) {
  if (!IsObject6(value))
    return value;
  const additionalProperties = schema.additionalProperties;
  const propertyKeys = Object.getOwnPropertyNames(value);
  const [propertyKey, propertySchema] = Object.entries(schema.patternProperties)[0];
  const propertyKeyTest = new RegExp(propertyKey);
  for (const key of propertyKeys) {
    if (propertyKeyTest.test(key)) {
      value[key] = Visit28(propertySchema, references, value[key]);
      continue;
    }
    if (IsKind3(additionalProperties) && Check2(additionalProperties, references, value[key])) {
      value[key] = Visit28(additionalProperties, references, value[key]);
      continue;
    }
    delete value[key];
  }
  return value;
}
function FromRef26(schema, references, value) {
  return Visit28(Deref4(schema, references), references, value);
}
function FromThis18(schema, references, value) {
  return Visit28(Deref4(schema, references), references, value);
}
function FromTuple26(schema, references, value) {
  if (!IsArray6(value))
    return value;
  if (IsUndefined6(schema.items))
    return [];
  const length = Math.min(value.length, schema.items.length);
  for (let i = 0;i < length; i++) {
    value[i] = Visit28(schema.items[i], references, value[i]);
  }
  return value.length > length ? value.slice(0, length) : value;
}
function FromUnion36(schema, references, value) {
  for (const inner of schema.anyOf) {
    if (IsCheckable2(inner) && Check2(inner, references, value)) {
      return Visit28(inner, references, value);
    }
  }
  return value;
}
function Visit28(schema, references, value) {
  const references_ = IsString6(schema.$id) ? Pushref2(schema, references) : references;
  const schema_ = schema;
  switch (schema_[Kind2]) {
    case "Array":
      return FromArray30(schema_, references_, value);
    case "Import":
      return FromImport16(schema_, references_, value);
    case "Intersect":
      return FromIntersect32(schema_, references_, value);
    case "Object":
      return FromObject32(schema_, references_, value);
    case "Record":
      return FromRecord22(schema_, references_, value);
    case "Ref":
      return FromRef26(schema_, references_, value);
    case "This":
      return FromThis18(schema_, references_, value);
    case "Tuple":
      return FromTuple26(schema_, references_, value);
    case "Union":
      return FromUnion36(schema_, references_, value);
    default:
      return value;
  }
}
function Clean2(...args) {
  return args.length === 3 ? Visit28(args[0], args[1], args[2]) : Visit28(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/convert/convert.mjs
function IsStringNumeric2(value) {
  return IsString6(value) && !isNaN(value) && !isNaN(parseFloat(value));
}
function IsValueToString2(value) {
  return IsBigInt6(value) || IsBoolean6(value) || IsNumber6(value);
}
function IsValueTrue2(value) {
  return value === true || IsNumber6(value) && value === 1 || IsBigInt6(value) && value === BigInt("1") || IsString6(value) && (value.toLowerCase() === "true" || value === "1");
}
function IsValueFalse2(value) {
  return value === false || IsNumber6(value) && (value === 0 || Object.is(value, -0)) || IsBigInt6(value) && value === BigInt("0") || IsString6(value) && (value.toLowerCase() === "false" || value === "0" || value === "-0");
}
function IsTimeStringWithTimeZone2(value) {
  return IsString6(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
}
function IsTimeStringWithoutTimeZone2(value) {
  return IsString6(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
}
function IsDateTimeStringWithTimeZone2(value) {
  return IsString6(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
}
function IsDateTimeStringWithoutTimeZone2(value) {
  return IsString6(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
}
function IsDateString2(value) {
  return IsString6(value) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test(value);
}
function TryConvertLiteralString2(value, target) {
  const conversion = TryConvertString2(value);
  return conversion === target ? conversion : value;
}
function TryConvertLiteralNumber2(value, target) {
  const conversion = TryConvertNumber2(value);
  return conversion === target ? conversion : value;
}
function TryConvertLiteralBoolean2(value, target) {
  const conversion = TryConvertBoolean2(value);
  return conversion === target ? conversion : value;
}
function TryConvertLiteral2(schema, value) {
  return IsString6(schema.const) ? TryConvertLiteralString2(value, schema.const) : IsNumber6(schema.const) ? TryConvertLiteralNumber2(value, schema.const) : IsBoolean6(schema.const) ? TryConvertLiteralBoolean2(value, schema.const) : value;
}
function TryConvertBoolean2(value) {
  return IsValueTrue2(value) ? true : IsValueFalse2(value) ? false : value;
}
function TryConvertBigInt2(value) {
  const truncateInteger = (value2) => value2.split(".")[0];
  return IsStringNumeric2(value) ? BigInt(truncateInteger(value)) : IsNumber6(value) ? BigInt(Math.trunc(value)) : IsValueFalse2(value) ? BigInt(0) : IsValueTrue2(value) ? BigInt(1) : value;
}
function TryConvertString2(value) {
  return IsSymbol6(value) && value.description !== undefined ? value.description.toString() : IsValueToString2(value) ? value.toString() : value;
}
function TryConvertNumber2(value) {
  return IsStringNumeric2(value) ? parseFloat(value) : IsValueTrue2(value) ? 1 : IsValueFalse2(value) ? 0 : value;
}
function TryConvertInteger2(value) {
  return IsStringNumeric2(value) ? parseInt(value) : IsNumber6(value) ? value | 0 : IsValueTrue2(value) ? 1 : IsValueFalse2(value) ? 0 : value;
}
function TryConvertNull2(value) {
  return IsString6(value) && value.toLowerCase() === "null" ? null : value;
}
function TryConvertUndefined2(value) {
  return IsString6(value) && value === "undefined" ? undefined : value;
}
function TryConvertDate2(value) {
  return IsDate6(value) ? value : IsNumber6(value) ? new Date(value) : IsValueTrue2(value) ? new Date(1) : IsValueFalse2(value) ? new Date(0) : IsStringNumeric2(value) ? new Date(parseInt(value)) : IsTimeStringWithoutTimeZone2(value) ? new Date(`1970-01-01T${value}.000Z`) : IsTimeStringWithTimeZone2(value) ? new Date(`1970-01-01T${value}`) : IsDateTimeStringWithoutTimeZone2(value) ? new Date(`${value}.000Z`) : IsDateTimeStringWithTimeZone2(value) ? new Date(value) : IsDateString2(value) ? new Date(`${value}T00:00:00.000Z`) : value;
}
function Default9(value) {
  return value;
}
function FromArray31(schema, references, value) {
  const elements = IsArray6(value) ? value : [value];
  return elements.map((element) => Visit29(schema.items, references, element));
}
function FromBigInt10(schema, references, value) {
  return TryConvertBigInt2(value);
}
function FromBoolean10(schema, references, value) {
  return TryConvertBoolean2(value);
}
function FromDate13(schema, references, value) {
  return TryConvertDate2(value);
}
function FromImport17(schema, references, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit29(target, [...references, ...definitions], value);
}
function FromInteger10(schema, references, value) {
  return TryConvertInteger2(value);
}
function FromIntersect33(schema, references, value) {
  return schema.allOf.reduce((value2, schema2) => Visit29(schema2, references, value2), value);
}
function FromLiteral12(schema, references, value) {
  return TryConvertLiteral2(schema, value);
}
function FromNull10(schema, references, value) {
  return TryConvertNull2(value);
}
function FromNumber10(schema, references, value) {
  return TryConvertNumber2(value);
}
function FromObject33(schema, references, value) {
  if (!IsObject6(value))
    return value;
  for (const propertyKey of Object.getOwnPropertyNames(schema.properties)) {
    if (!HasPropertyKey4(value, propertyKey))
      continue;
    value[propertyKey] = Visit29(schema.properties[propertyKey], references, value[propertyKey]);
  }
  return value;
}
function FromRecord23(schema, references, value) {
  const isConvertable = IsObject6(value);
  if (!isConvertable)
    return value;
  const propertyKey = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[propertyKey];
  for (const [propKey, propValue] of Object.entries(value)) {
    value[propKey] = Visit29(property, references, propValue);
  }
  return value;
}
function FromRef27(schema, references, value) {
  return Visit29(Deref4(schema, references), references, value);
}
function FromString10(schema, references, value) {
  return TryConvertString2(value);
}
function FromSymbol10(schema, references, value) {
  return IsString6(value) || IsNumber6(value) ? Symbol(value) : value;
}
function FromThis19(schema, references, value) {
  return Visit29(Deref4(schema, references), references, value);
}
function FromTuple27(schema, references, value) {
  const isConvertable = IsArray6(value) && !IsUndefined6(schema.items);
  if (!isConvertable)
    return value;
  return value.map((value2, index) => {
    return index < schema.items.length ? Visit29(schema.items[index], references, value2) : value2;
  });
}
function FromUndefined10(schema, references, value) {
  return TryConvertUndefined2(value);
}
function FromUnion37(schema, references, value) {
  for (const subschema of schema.anyOf) {
    const converted = Visit29(subschema, references, Clone4(value));
    if (!Check2(subschema, references, converted))
      continue;
    return converted;
  }
  return value;
}
function Visit29(schema, references, value) {
  const references_ = Pushref2(schema, references);
  const schema_ = schema;
  switch (schema[Kind2]) {
    case "Array":
      return FromArray31(schema_, references_, value);
    case "BigInt":
      return FromBigInt10(schema_, references_, value);
    case "Boolean":
      return FromBoolean10(schema_, references_, value);
    case "Date":
      return FromDate13(schema_, references_, value);
    case "Import":
      return FromImport17(schema_, references_, value);
    case "Integer":
      return FromInteger10(schema_, references_, value);
    case "Intersect":
      return FromIntersect33(schema_, references_, value);
    case "Literal":
      return FromLiteral12(schema_, references_, value);
    case "Null":
      return FromNull10(schema_, references_, value);
    case "Number":
      return FromNumber10(schema_, references_, value);
    case "Object":
      return FromObject33(schema_, references_, value);
    case "Record":
      return FromRecord23(schema_, references_, value);
    case "Ref":
      return FromRef27(schema_, references_, value);
    case "String":
      return FromString10(schema_, references_, value);
    case "Symbol":
      return FromSymbol10(schema_, references_, value);
    case "This":
      return FromThis19(schema_, references_, value);
    case "Tuple":
      return FromTuple27(schema_, references_, value);
    case "Undefined":
      return FromUndefined10(schema_, references_, value);
    case "Union":
      return FromUnion37(schema_, references_, value);
    default:
      return Default9(value);
  }
}
function Convert2(...args) {
  return args.length === 3 ? Visit29(args[0], args[1], args[2]) : Visit29(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/decode/decode.mjs
function Decode2(...args) {
  const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  if (!Check2(schema, references, value))
    throw new TransformDecodeCheckError2(schema, value, Errors2(schema, references, value).First());
  return HasTransform2(schema, references) ? TransformDecode2(schema, references, value) : value;
}
// node_modules/@sinclair/typebox/build/esm/value/default/default.mjs
function ValueOrDefault2(schema, value) {
  const defaultValue = HasPropertyKey4(schema, "default") ? schema.default : undefined;
  const clone2 = IsFunction6(defaultValue) ? defaultValue() : Clone4(defaultValue);
  return IsUndefined6(value) ? clone2 : IsObject6(value) && IsObject6(clone2) ? Object.assign(clone2, value) : value;
}
function HasDefaultProperty2(schema) {
  return IsKind3(schema) && "default" in schema;
}
function FromArray32(schema, references, value) {
  if (IsArray6(value)) {
    for (let i = 0;i < value.length; i++) {
      value[i] = Visit30(schema.items, references, value[i]);
    }
    return value;
  }
  const defaulted = ValueOrDefault2(schema, value);
  if (!IsArray6(defaulted))
    return defaulted;
  for (let i = 0;i < defaulted.length; i++) {
    defaulted[i] = Visit30(schema.items, references, defaulted[i]);
  }
  return defaulted;
}
function FromDate14(schema, references, value) {
  return IsDate6(value) ? value : ValueOrDefault2(schema, value);
}
function FromImport18(schema, references, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit30(target, [...references, ...definitions], value);
}
function FromIntersect34(schema, references, value) {
  const defaulted = ValueOrDefault2(schema, value);
  return schema.allOf.reduce((acc, schema2) => {
    const next = Visit30(schema2, references, defaulted);
    return IsObject6(next) ? { ...acc, ...next } : next;
  }, {});
}
function FromObject34(schema, references, value) {
  const defaulted = ValueOrDefault2(schema, value);
  if (!IsObject6(defaulted))
    return defaulted;
  const knownPropertyKeys = Object.getOwnPropertyNames(schema.properties);
  for (const key of knownPropertyKeys) {
    const propertyValue = Visit30(schema.properties[key], references, defaulted[key]);
    if (IsUndefined6(propertyValue))
      continue;
    defaulted[key] = Visit30(schema.properties[key], references, defaulted[key]);
  }
  if (!HasDefaultProperty2(schema.additionalProperties))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKeys.includes(key))
      continue;
    defaulted[key] = Visit30(schema.additionalProperties, references, defaulted[key]);
  }
  return defaulted;
}
function FromRecord24(schema, references, value) {
  const defaulted = ValueOrDefault2(schema, value);
  if (!IsObject6(defaulted))
    return defaulted;
  const additionalPropertiesSchema = schema.additionalProperties;
  const [propertyKeyPattern, propertySchema] = Object.entries(schema.patternProperties)[0];
  const knownPropertyKey = new RegExp(propertyKeyPattern);
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (!(knownPropertyKey.test(key) && HasDefaultProperty2(propertySchema)))
      continue;
    defaulted[key] = Visit30(propertySchema, references, defaulted[key]);
  }
  if (!HasDefaultProperty2(additionalPropertiesSchema))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKey.test(key))
      continue;
    defaulted[key] = Visit30(additionalPropertiesSchema, references, defaulted[key]);
  }
  return defaulted;
}
function FromRef28(schema, references, value) {
  return Visit30(Deref4(schema, references), references, ValueOrDefault2(schema, value));
}
function FromThis20(schema, references, value) {
  return Visit30(Deref4(schema, references), references, value);
}
function FromTuple28(schema, references, value) {
  const defaulted = ValueOrDefault2(schema, value);
  if (!IsArray6(defaulted) || IsUndefined6(schema.items))
    return defaulted;
  const [items, max] = [schema.items, Math.max(schema.items.length, defaulted.length)];
  for (let i = 0;i < max; i++) {
    if (i < items.length)
      defaulted[i] = Visit30(items[i], references, defaulted[i]);
  }
  return defaulted;
}
function FromUnion38(schema, references, value) {
  const defaulted = ValueOrDefault2(schema, value);
  for (const inner of schema.anyOf) {
    const result = Visit30(inner, references, Clone4(defaulted));
    if (Check2(inner, references, result)) {
      return result;
    }
  }
  return defaulted;
}
function Visit30(schema, references, value) {
  const references_ = Pushref2(schema, references);
  const schema_ = schema;
  switch (schema_[Kind2]) {
    case "Array":
      return FromArray32(schema_, references_, value);
    case "Date":
      return FromDate14(schema_, references_, value);
    case "Import":
      return FromImport18(schema_, references_, value);
    case "Intersect":
      return FromIntersect34(schema_, references_, value);
    case "Object":
      return FromObject34(schema_, references_, value);
    case "Record":
      return FromRecord24(schema_, references_, value);
    case "Ref":
      return FromRef28(schema_, references_, value);
    case "This":
      return FromThis20(schema_, references_, value);
    case "Tuple":
      return FromTuple28(schema_, references_, value);
    case "Union":
      return FromUnion38(schema_, references_, value);
    default:
      return ValueOrDefault2(schema_, value);
  }
}
function Default10(...args) {
  return args.length === 3 ? Visit30(args[0], args[1], args[2]) : Visit30(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/pointer/pointer.mjs
var exports_pointer2 = {};
__export(exports_pointer2, {
  ValuePointerRootSetError: () => ValuePointerRootSetError2,
  ValuePointerRootDeleteError: () => ValuePointerRootDeleteError2,
  Set: () => Set7,
  Has: () => Has6,
  Get: () => Get6,
  Format: () => Format2,
  Delete: () => Delete7
});
class ValuePointerRootSetError2 extends TypeBoxError2 {
  constructor(value, path, update) {
    super("Cannot set root value");
    this.value = value;
    this.path = path;
    this.update = update;
  }
}

class ValuePointerRootDeleteError2 extends TypeBoxError2 {
  constructor(value, path) {
    super("Cannot delete root value");
    this.value = value;
    this.path = path;
  }
}
function Escape4(component) {
  return component.indexOf("~") === -1 ? component : component.replace(/~1/g, "/").replace(/~0/g, "~");
}
function* Format2(pointer2) {
  if (pointer2 === "")
    return;
  let [start, end] = [0, 0];
  for (let i = 0;i < pointer2.length; i++) {
    const char = pointer2.charAt(i);
    if (char === "/") {
      if (i === 0) {
        start = i + 1;
      } else {
        end = i;
        yield Escape4(pointer2.slice(start, end));
        start = i + 1;
      }
    } else {
      end = i;
    }
  }
  yield Escape4(pointer2.slice(start));
}
function Set7(value, pointer2, update) {
  if (pointer2 === "")
    throw new ValuePointerRootSetError2(value, pointer2, update);
  let [owner, next, key] = [null, value, ""];
  for (const component of Format2(pointer2)) {
    if (next[component] === undefined)
      next[component] = {};
    owner = next;
    next = next[component];
    key = component;
  }
  owner[key] = update;
}
function Delete7(value, pointer2) {
  if (pointer2 === "")
    throw new ValuePointerRootDeleteError2(value, pointer2);
  let [owner, next, key] = [null, value, ""];
  for (const component of Format2(pointer2)) {
    if (next[component] === undefined || next[component] === null)
      return;
    owner = next;
    next = next[component];
    key = component;
  }
  if (Array.isArray(owner)) {
    const index = parseInt(key);
    owner.splice(index, 1);
  } else {
    delete owner[key];
  }
}
function Has6(value, pointer2) {
  if (pointer2 === "")
    return true;
  let [owner, next, key] = [null, value, ""];
  for (const component of Format2(pointer2)) {
    if (next[component] === undefined)
      return false;
    owner = next;
    next = next[component];
    key = component;
  }
  return Object.getOwnPropertyNames(owner).includes(key);
}
function Get6(value, pointer2) {
  if (pointer2 === "")
    return value;
  let current = value;
  for (const component of Format2(pointer2)) {
    if (current[component] === undefined)
      return;
    current = current[component];
  }
  return current;
}
// node_modules/@sinclair/typebox/build/esm/value/equal/equal.mjs
function ObjectType8(left, right) {
  if (!IsObject6(right))
    return false;
  const leftKeys = [...Object.keys(left), ...Object.getOwnPropertySymbols(left)];
  const rightKeys = [...Object.keys(right), ...Object.getOwnPropertySymbols(right)];
  if (leftKeys.length !== rightKeys.length)
    return false;
  return leftKeys.every((key) => Equal2(left[key], right[key]));
}
function DateType6(left, right) {
  return IsDate6(right) && left.getTime() === right.getTime();
}
function ArrayType8(left, right) {
  if (!IsArray6(right) || left.length !== right.length)
    return false;
  return left.every((value, index) => Equal2(value, right[index]));
}
function TypedArrayType4(left, right) {
  if (!IsTypedArray2(right) || left.length !== right.length || Object.getPrototypeOf(left).constructor.name !== Object.getPrototypeOf(right).constructor.name)
    return false;
  return left.every((value, index) => Equal2(value, right[index]));
}
function ValueType4(left, right) {
  return left === right;
}
function Equal2(left, right) {
  if (IsDate6(left))
    return DateType6(left, right);
  if (IsTypedArray2(left))
    return TypedArrayType4(left, right);
  if (IsArray6(left))
    return ArrayType8(left, right);
  if (IsObject6(left))
    return ObjectType8(left, right);
  if (IsValueType2(left))
    return ValueType4(left, right);
  throw new Error("ValueEquals: Unable to compare value");
}

// node_modules/@sinclair/typebox/build/esm/value/delta/delta.mjs
var Insert2 = Object3({
  type: Literal2("insert"),
  path: String3(),
  value: Unknown2()
});
var Update2 = Object3({
  type: Literal2("update"),
  path: String3(),
  value: Unknown2()
});
var Delete8 = Object3({
  type: Literal2("delete"),
  path: String3()
});
var Edit2 = Union3([Insert2, Update2, Delete8]);

class ValueDiffError2 extends TypeBoxError2 {
  constructor(value, message) {
    super(message);
    this.value = value;
  }
}
function CreateUpdate2(path, value) {
  return { type: "update", path, value };
}
function CreateInsert2(path, value) {
  return { type: "insert", path, value };
}
function CreateDelete2(path) {
  return { type: "delete", path };
}
function AssertDiffable2(value) {
  if (globalThis.Object.getOwnPropertySymbols(value).length > 0)
    throw new ValueDiffError2(value, "Cannot diff objects with symbols");
}
function* ObjectType9(path, current, next) {
  AssertDiffable2(current);
  AssertDiffable2(next);
  if (!IsStandardObject3(next))
    return yield CreateUpdate2(path, next);
  const currentKeys = globalThis.Object.getOwnPropertyNames(current);
  const nextKeys = globalThis.Object.getOwnPropertyNames(next);
  for (const key of nextKeys) {
    if (HasPropertyKey4(current, key))
      continue;
    yield CreateInsert2(`${path}/${key}`, next[key]);
  }
  for (const key of currentKeys) {
    if (!HasPropertyKey4(next, key))
      continue;
    if (Equal2(current, next))
      continue;
    yield* Visit31(`${path}/${key}`, current[key], next[key]);
  }
  for (const key of currentKeys) {
    if (HasPropertyKey4(next, key))
      continue;
    yield CreateDelete2(`${path}/${key}`);
  }
}
function* ArrayType9(path, current, next) {
  if (!IsArray6(next))
    return yield CreateUpdate2(path, next);
  for (let i = 0;i < Math.min(current.length, next.length); i++) {
    yield* Visit31(`${path}/${i}`, current[i], next[i]);
  }
  for (let i = 0;i < next.length; i++) {
    if (i < current.length)
      continue;
    yield CreateInsert2(`${path}/${i}`, next[i]);
  }
  for (let i = current.length - 1;i >= 0; i--) {
    if (i < next.length)
      continue;
    yield CreateDelete2(`${path}/${i}`);
  }
}
function* TypedArrayType5(path, current, next) {
  if (!IsTypedArray2(next) || current.length !== next.length || globalThis.Object.getPrototypeOf(current).constructor.name !== globalThis.Object.getPrototypeOf(next).constructor.name)
    return yield CreateUpdate2(path, next);
  for (let i = 0;i < Math.min(current.length, next.length); i++) {
    yield* Visit31(`${path}/${i}`, current[i], next[i]);
  }
}
function* ValueType5(path, current, next) {
  if (current === next)
    return;
  yield CreateUpdate2(path, next);
}
function* Visit31(path, current, next) {
  if (IsStandardObject3(current))
    return yield* ObjectType9(path, current, next);
  if (IsArray6(current))
    return yield* ArrayType9(path, current, next);
  if (IsTypedArray2(current))
    return yield* TypedArrayType5(path, current, next);
  if (IsValueType2(current))
    return yield* ValueType5(path, current, next);
  throw new ValueDiffError2(current, "Unable to diff value");
}
function Diff2(current, next) {
  return [...Visit31("", current, next)];
}
function IsRootUpdate2(edits) {
  return edits.length > 0 && edits[0].path === "" && edits[0].type === "update";
}
function IsIdentity2(edits) {
  return edits.length === 0;
}
function Patch2(current, edits) {
  if (IsRootUpdate2(edits)) {
    return Clone4(edits[0].value);
  }
  if (IsIdentity2(edits)) {
    return Clone4(current);
  }
  const clone2 = Clone4(current);
  for (const edit of edits) {
    switch (edit.type) {
      case "insert": {
        exports_pointer2.Set(clone2, edit.path, edit.value);
        break;
      }
      case "update": {
        exports_pointer2.Set(clone2, edit.path, edit.value);
        break;
      }
      case "delete": {
        exports_pointer2.Delete(clone2, edit.path);
        break;
      }
    }
  }
  return clone2;
}
// node_modules/@sinclair/typebox/build/esm/value/encode/encode.mjs
function Encode2(...args) {
  const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  const encoded = HasTransform2(schema, references) ? TransformEncode2(schema, references, value) : value;
  if (!Check2(schema, references, encoded))
    throw new TransformEncodeCheckError2(schema, encoded, Errors2(schema, references, encoded).First());
  return encoded;
}
// node_modules/@sinclair/typebox/build/esm/value/mutate/mutate.mjs
function IsStandardObject4(value) {
  return IsObject6(value) && !IsArray6(value);
}

class ValueMutateError2 extends TypeBoxError2 {
  constructor(message) {
    super(message);
  }
}
function ObjectType10(root, path, current, next) {
  if (!IsStandardObject4(current)) {
    exports_pointer2.Set(root, path, Clone4(next));
  } else {
    const currentKeys = Object.getOwnPropertyNames(current);
    const nextKeys = Object.getOwnPropertyNames(next);
    for (const currentKey of currentKeys) {
      if (!nextKeys.includes(currentKey)) {
        delete current[currentKey];
      }
    }
    for (const nextKey of nextKeys) {
      if (!currentKeys.includes(nextKey)) {
        current[nextKey] = null;
      }
    }
    for (const nextKey of nextKeys) {
      Visit32(root, `${path}/${nextKey}`, current[nextKey], next[nextKey]);
    }
  }
}
function ArrayType10(root, path, current, next) {
  if (!IsArray6(current)) {
    exports_pointer2.Set(root, path, Clone4(next));
  } else {
    for (let index = 0;index < next.length; index++) {
      Visit32(root, `${path}/${index}`, current[index], next[index]);
    }
    current.splice(next.length);
  }
}
function TypedArrayType6(root, path, current, next) {
  if (IsTypedArray2(current) && current.length === next.length) {
    for (let i = 0;i < current.length; i++) {
      current[i] = next[i];
    }
  } else {
    exports_pointer2.Set(root, path, Clone4(next));
  }
}
function ValueType6(root, path, current, next) {
  if (current === next)
    return;
  exports_pointer2.Set(root, path, next);
}
function Visit32(root, path, current, next) {
  if (IsArray6(next))
    return ArrayType10(root, path, current, next);
  if (IsTypedArray2(next))
    return TypedArrayType6(root, path, current, next);
  if (IsStandardObject4(next))
    return ObjectType10(root, path, current, next);
  if (IsValueType2(next))
    return ValueType6(root, path, current, next);
}
function IsNonMutableValue2(value) {
  return IsTypedArray2(value) || IsValueType2(value);
}
function IsMismatchedValue2(current, next) {
  return IsStandardObject4(current) && IsArray6(next) || IsArray6(current) && IsStandardObject4(next);
}
function Mutate2(current, next) {
  if (IsNonMutableValue2(current) || IsNonMutableValue2(next))
    throw new ValueMutateError2("Only object and array types can be mutated at the root level");
  if (IsMismatchedValue2(current, next))
    throw new ValueMutateError2("Cannot assign due type mismatch of assignable values");
  Visit32(current, "", current, next);
}
// node_modules/@sinclair/typebox/build/esm/value/parse/parse.mjs
class ParseError3 extends TypeBoxError2 {
  constructor(message) {
    super(message);
  }
}
var ParseRegistry2;
(function(ParseRegistry3) {
  const registry = new Map([
    ["Clone", (_type, _references, value) => Clone4(value)],
    ["Clean", (type, references, value) => Clean2(type, references, value)],
    ["Default", (type, references, value) => Default10(type, references, value)],
    ["Convert", (type, references, value) => Convert2(type, references, value)],
    ["Assert", (type, references, value) => {
      Assert2(type, references, value);
      return value;
    }],
    ["Decode", (type, references, value) => HasTransform2(type, references) ? TransformDecode2(type, references, value) : value],
    ["Encode", (type, references, value) => HasTransform2(type, references) ? TransformEncode2(type, references, value) : value]
  ]);
  function Delete9(key) {
    registry.delete(key);
  }
  ParseRegistry3.Delete = Delete9;
  function Set8(key, callback) {
    registry.set(key, callback);
  }
  ParseRegistry3.Set = Set8;
  function Get7(key) {
    return registry.get(key);
  }
  ParseRegistry3.Get = Get7;
})(ParseRegistry2 || (ParseRegistry2 = {}));
var ParseDefault2 = [
  "Clone",
  "Clean",
  "Default",
  "Convert",
  "Assert",
  "Decode"
];
function ParseValue2(operations, type, references, value) {
  return operations.reduce((value2, operationKey) => {
    const operation = ParseRegistry2.Get(operationKey);
    if (IsUndefined6(operation))
      throw new ParseError3(`Unable to find Parse operation '${operationKey}'`);
    return operation(type, references, value2);
  }, value);
}
function Parse2(...args) {
  const [operations, schema, references, value] = args.length === 4 ? [args[0], args[1], args[2], args[3]] : args.length === 3 ? IsArray6(args[0]) ? [args[0], args[1], [], args[2]] : [ParseDefault2, args[0], args[1], args[2]] : args.length === 2 ? [ParseDefault2, args[0], [], args[1]] : (() => {
    throw new ParseError3("Invalid Arguments");
  })();
  return ParseValue2(operations, schema, references, value);
}
// node_modules/@sinclair/typebox/build/esm/value/value/value.mjs
var exports_value4 = {};
__export(exports_value4, {
  ValueErrorIterator: () => ValueErrorIterator2,
  Patch: () => Patch2,
  Parse: () => Parse2,
  Mutate: () => Mutate2,
  Hash: () => Hash2,
  Errors: () => Errors2,
  Equal: () => Equal2,
  Encode: () => Encode2,
  Edit: () => Edit2,
  Diff: () => Diff2,
  Default: () => Default10,
  Decode: () => Decode2,
  Create: () => Create4,
  Convert: () => Convert2,
  Clone: () => Clone4,
  Clean: () => Clean2,
  Check: () => Check2,
  Cast: () => Cast2,
  Assert: () => Assert2
});
// node_modules/elysia/dist/bun/index.js
var import_cookie2 = __toESM(require_dist2(), 1);
var import_fast_decode_uri_component4 = __toESM(require_fast_decode_uri_component2(), 1);
var import_fast_decode_uri_component5 = __toESM(require_fast_decode_uri_component2(), 1);
var import_fast_decode_uri_component6 = __toESM(require_fast_decode_uri_component2(), 1);
var fullFormats2 = { date: date2, time: getTime2(true), "date-time": getDateTime2(true), "iso-time": getTime2(false), "iso-date-time": getDateTime2(false), duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/, uri: uri2, "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i, "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i, url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu, email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i, hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i, ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/, ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i, regex: regex2, uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i, "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/, "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i, "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/, byte: byte2, int32: { type: "number", validate: validateInt322 }, int64: { type: "number", validate: validateInt642 }, float: { type: "number", validate: validateNumber2 }, double: { type: "number", validate: validateNumber2 }, password: true, binary: true };
function isLeapYear2(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
var DATE2 = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
var DAYS2 = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function date2(str) {
  let matches = DATE2.exec(str);
  if (!matches)
    return false;
  let year = +matches[1], month = +matches[2], day = +matches[3];
  return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear2(year) ? 29 : DAYS2[month]);
}
var TIME2 = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
function getTime2(strictTimeZone) {
  return function time(str) {
    let matches = TIME2.exec(str);
    if (!matches)
      return false;
    let hr = +matches[1], min = +matches[2], sec = +matches[3], tz = matches[4], tzSign = matches[5] === "-" ? -1 : 1, tzH = +(matches[6] || 0), tzM = +(matches[7] || 0);
    if (tzH > 23 || tzM > 59 || strictTimeZone && !tz)
      return false;
    if (hr <= 23 && min <= 59 && sec < 60)
      return true;
    let utcMin = min - tzM * tzSign, utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
    return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
  };
}
var DATE_TIME_SEPARATOR2 = /t|\s/i;
function getDateTime2(strictTimeZone) {
  let time = getTime2(strictTimeZone);
  return function date_time(str) {
    let dateTime = str.split(DATE_TIME_SEPARATOR2);
    return dateTime.length === 2 && date2(dateTime[0]) && time(dateTime[1]);
  };
}
var NOT_URI_FRAGMENT2 = /\/|:/;
var URI2 = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
function uri2(str) {
  return NOT_URI_FRAGMENT2.test(str) && URI2.test(str);
}
var BYTE2 = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
function byte2(str) {
  return BYTE2.lastIndex = 0, BYTE2.test(str);
}
var MIN_INT322 = -2147483648;
var MAX_INT322 = 2147483647;
function validateInt322(value) {
  return Number.isInteger(value) && value <= MAX_INT322 && value >= MIN_INT322;
}
function validateInt642(value) {
  return Number.isInteger(value);
}
function validateNumber2() {
  return true;
}
var Z_ANCHOR2 = /[^\\]\\Z/;
function regex2(str) {
  if (Z_ANCHOR2.test(str))
    return false;
  try {
    return new RegExp(str), true;
  } catch (e) {
    return false;
  }
}
var hasHeaderShorthand2 = "toJSON" in new Headers;
var replaceUrlPath2 = (url, pathname) => {
  let urlObject = new URL(url);
  return urlObject.pathname = pathname, urlObject.toString();
};
var isClass2 = (v) => typeof v === "function" && /^\s*class\s+/.test(v.toString()) || v.toString().startsWith("[object ") && v.toString() !== "[object Object]" || isNotEmpty2(Object.getPrototypeOf(v));
var isObject2 = (item) => item && typeof item === "object" && !Array.isArray(item);
var mergeDeep2 = (target, source, { skipKeys, override = true } = {}) => {
  if (!isObject2(target) || !isObject2(source))
    return target;
  for (let [key, value] of Object.entries(source)) {
    if (skipKeys?.includes(key))
      continue;
    if (!isObject2(value) || !(key in target) || isClass2(value)) {
      if (override || !(key in target))
        target[key] = value;
      continue;
    }
    target[key] = mergeDeep2(target[key], value, { skipKeys, override });
  }
  return target;
};
var mergeCookie2 = (a, b) => {
  let { properties: _3, ...target } = a ?? {}, { properties: __, ...source } = b ?? {};
  return mergeDeep2(target, source);
};
var mergeObjectArray2 = (a = [], b = []) => {
  if (!a)
    return [];
  if (!b)
    return a;
  let array = [], checksums = [];
  if (!Array.isArray(a))
    a = [a];
  if (!Array.isArray(b))
    b = [b];
  for (let item of a)
    if (array.push(item), item.checksum)
      checksums.push(item.checksum);
  for (let item of b)
    if (!checksums.includes(item.checksum))
      array.push(item);
  return array;
};
var primitiveHooks2 = ["start", "request", "parse", "transform", "resolve", "beforeHandle", "afterHandle", "mapResponse", "afterResponse", "trace", "error", "stop", "body", "headers", "params", "query", "response", "type", "detail"];
var primitiveHookMap2 = primitiveHooks2.reduce((acc, x) => (acc[x] = true, acc), {});
var mergeResponse2 = (a, b) => {
  let isRecordNumber = (x) => typeof x === "object" && Object.keys(x).every(isNumericString2);
  if (isRecordNumber(a) && isRecordNumber(b))
    return { ...a, ...b };
  else if (a && !isRecordNumber(a) && isRecordNumber(b))
    return { 200: a, ...b };
  return b ?? a;
};
var mergeSchemaValidator2 = (a, b) => {
  return { body: b?.body ?? a?.body, headers: b?.headers ?? a?.headers, params: b?.params ?? a?.params, query: b?.query ?? a?.query, cookie: b?.cookie ?? a?.cookie, response: mergeResponse2(a?.response, b?.response) };
};
var mergeHook2 = (a, b) => {
  let { resolve: resolveA, ...restA } = a ?? {}, { resolve: resolveB, ...restB } = b ?? {};
  return { ...restA, ...restB, body: b?.body ?? a?.body, headers: b?.headers ?? a?.headers, params: b?.params ?? a?.params, query: b?.query ?? a?.query, cookie: b?.cookie ?? a?.cookie, response: mergeResponse2(a?.response, b?.response), type: a?.type || b?.type, detail: mergeDeep2(b?.detail ?? {}, a?.detail ?? {}), parse: mergeObjectArray2(a?.parse, b?.parse), transform: mergeObjectArray2(a?.transform, b?.transform), beforeHandle: mergeObjectArray2(mergeObjectArray2(fnToContainer2(resolveA, "resolve"), a?.beforeHandle), mergeObjectArray2(fnToContainer2(resolveB, "resolve"), b?.beforeHandle)), afterHandle: mergeObjectArray2(a?.afterHandle, b?.afterHandle), mapResponse: mergeObjectArray2(a?.mapResponse, b?.mapResponse), afterResponse: mergeObjectArray2(a?.afterResponse, b?.afterResponse), trace: mergeObjectArray2(a?.trace, b?.trace), error: mergeObjectArray2(a?.error, b?.error) };
};
var replaceSchemaType2 = (schema, options, root = true) => {
  if (!Array.isArray(options))
    return _replaceSchemaType2(schema, options, root);
  for (let option of options)
    schema = _replaceSchemaType2(schema, option, root);
  return schema;
};
var _replaceSchemaType2 = (schema, options, root = true) => {
  if (!schema)
    return schema;
  if (options.untilObjectFound && !root && schema.type === "object")
    return schema;
  let fromSymbol = options.from[Kind2];
  if (schema.oneOf) {
    for (let i = 0;i < schema.oneOf.length; i++)
      schema.oneOf[i] = _replaceSchemaType2(schema.oneOf[i], options, root);
    return schema;
  }
  if (schema.anyOf) {
    for (let i = 0;i < schema.anyOf.length; i++)
      schema.anyOf[i] = _replaceSchemaType2(schema.anyOf[i], options, root);
    return schema;
  }
  if (schema.allOf) {
    for (let i = 0;i < schema.allOf.length; i++)
      schema.allOf[i] = _replaceSchemaType2(schema.allOf[i], options, root);
    return schema;
  }
  if (schema.not) {
    for (let i = 0;i < schema.not.length; i++)
      schema.not[i] = _replaceSchemaType2(schema.not[i], options, root);
    return schema;
  }
  let isRoot = root && !!options.excludeRoot;
  if (schema[Kind2] === fromSymbol) {
    let { anyOf, oneOf, allOf, not, properties: properties2, items, ...rest } = schema, to = options.to(rest), transform3, composeProperties = (v) => {
      if (properties2 && v.type === "object") {
        let newProperties = {};
        for (let [key, value2] of Object.entries(properties2))
          newProperties[key] = _replaceSchemaType2(value2, options, false);
        return { ...rest, ...v, properties: newProperties };
      }
      if (items && v.type === "array")
        return { ...rest, ...v, items: _replaceSchemaType2(items, options, false) };
      let value = { ...rest, ...v };
      if (delete value.required, properties2 && v.type === "string" && v.format === "ObjectString" && v.default === "{}")
        transform3 = t2.ObjectString(properties2, rest), value.default = JSON.stringify(exports_value4.Create(t2.Object(properties2))), value.properties = properties2;
      if (items && v.type === "string" && v.format === "ArrayString" && v.default === "[]")
        transform3 = t2.ArrayString(items, rest), value.default = JSON.stringify(exports_value4.Create(t2.Array(items))), value.items = items;
      return value;
    };
    if (isRoot) {
      if (properties2) {
        let newProperties = {};
        for (let [key, value] of Object.entries(properties2))
          newProperties[key] = _replaceSchemaType2(value, options, false);
        return { ...rest, properties: newProperties };
      } else if (items?.map)
        return { ...rest, items: items.map((v) => _replaceSchemaType2(v, options, false)) };
      return rest;
    }
    if (to.anyOf)
      for (let i = 0;i < to.anyOf.length; i++)
        to.anyOf[i] = composeProperties(to.anyOf[i]);
    else if (to.oneOf)
      for (let i = 0;i < to.oneOf.length; i++)
        to.oneOf[i] = composeProperties(to.oneOf[i]);
    else if (to.allOf)
      for (let i = 0;i < to.allOf.length; i++)
        to.allOf[i] = composeProperties(to.allOf[i]);
    else if (to.not)
      for (let i = 0;i < to.not.length; i++)
        to.not[i] = composeProperties(to.not[i]);
    if (transform3)
      to[TransformKind2] = transform3[TransformKind2];
    if (to.anyOf || to.oneOf || to.allOf || to.not)
      return to;
    if (properties2) {
      let newProperties = {};
      for (let [key, value] of Object.entries(properties2))
        newProperties[key] = _replaceSchemaType2(value, options, false);
      return { ...rest, ...to, properties: newProperties };
    } else if (items?.map)
      return { ...rest, ...to, items: items.map((v) => _replaceSchemaType2(v, options, false)) };
    return { ...rest, ...to };
  }
  let properties = schema?.properties;
  if (properties && root && options.rootOnly !== true)
    for (let [key, value] of Object.entries(properties))
      switch (value[Kind2]) {
        case fromSymbol:
          let { anyOf, oneOf, allOf, not, type, ...rest } = value, to = options.to(rest);
          if (to.anyOf)
            for (let i = 0;i < to.anyOf.length; i++)
              to.anyOf[i] = { ...rest, ...to.anyOf[i] };
          else if (to.oneOf)
            for (let i = 0;i < to.oneOf.length; i++)
              to.oneOf[i] = { ...rest, ...to.oneOf[i] };
          else if (to.allOf)
            for (let i = 0;i < to.allOf.length; i++)
              to.allOf[i] = { ...rest, ...to.allOf[i] };
          else if (to.not)
            for (let i = 0;i < to.not.length; i++)
              to.not[i] = { ...rest, ...to.not[i] };
          properties[key] = { ...rest, ..._replaceSchemaType2(rest, options, false) };
          break;
        case "Object":
        case "Union":
          properties[key] = _replaceSchemaType2(value, options, false);
          break;
        default:
          if (value.items)
            for (let i = 0;i < value.items.length; i++)
              value.items[i] = _replaceSchemaType2(value.items[i], options, false);
          else if (value.anyOf || value.oneOf || value.allOf || value.not)
            properties[key] = _replaceSchemaType2(value, options, false);
          break;
      }
  return schema;
};
var createCleaner2 = (schema) => (value) => {
  if (typeof value === "object")
    try {
      return exports_value4.Clean(schema, structuredClone(value));
    } catch {
      try {
        return exports_value4.Clean(schema, value);
      } catch {
        return value;
      }
    }
  return value;
};
var getSchemaValidator2 = (s, { models = {}, dynamic = false, modules, normalize = false, additionalProperties = false, coerce = false, additionalCoerce = [] } = { modules: t2.Module({}) }) => {
  if (!s)
    return;
  if (typeof s === "string" && !(s in models))
    return;
  let schema = typeof s === "string" ? modules.Import(s) ?? models[s] : s;
  if (coerce || additionalCoerce)
    if (coerce)
      schema = replaceSchemaType2(schema, [{ from: t2.Ref(""), to: (options) => modules.Import(options.$ref) }, { from: t2.Number(), to: (options) => t2.Numeric(options), untilObjectFound: true }, { from: t2.Boolean(), to: (options) => t2.BooleanString(options), untilObjectFound: true }, ...Array.isArray(additionalCoerce) ? additionalCoerce : [additionalCoerce]]);
    else
      schema = replaceSchemaType2(schema, [{ from: t2.Ref(""), to: (options) => modules.Import(options.$ref) }, ...Array.isArray(additionalCoerce) ? additionalCoerce : [additionalCoerce]]);
  if (schema.type === "object" && "additionalProperties" in schema === false)
    schema.additionalProperties = additionalProperties;
  if (dynamic) {
    let validator = { schema, references: "", checkFunc: () => {
    }, code: "", Check: (value) => exports_value4.Check(schema, value), Errors: (value) => exports_value4.Errors(schema, value), Code: () => "", Clean: createCleaner2(schema), Decode: (value) => exports_value4.Decode(schema, value), Encode: (value) => exports_value4.Encode(schema, value) };
    if (normalize && schema.additionalProperties === false)
      validator.Clean = createCleaner2(schema);
    if (schema.config) {
      if (validator.config = schema.config, validator?.schema?.config)
        delete validator.schema.config;
    }
    return validator.parse = (v) => {
      try {
        return validator.Decode(v);
      } catch (error2) {
        throw [...validator.Errors(v)].map(mapValueError2);
      }
    }, validator.safeParse = (v) => {
      try {
        return { success: true, data: validator.Decode(v), error: null };
      } catch (error2) {
        let errors = [...compiled.Errors(v)].map(mapValueError2);
        return { success: false, data: null, error: errors[0]?.summary, errors };
      }
    }, validator;
  }
  let compiled = TypeCompiler2.Compile(schema, Object.values(models));
  if (compiled.Clean = createCleaner2(schema), schema.config) {
    if (compiled.config = schema.config, compiled?.schema?.config)
      delete compiled.schema.config;
  }
  return compiled.parse = (v) => {
    try {
      return compiled.Decode(v);
    } catch (error2) {
      throw [...compiled.Errors(v)].map(mapValueError2);
    }
  }, compiled.safeParse = (v) => {
    try {
      return { success: true, data: compiled.Decode(v), error: null };
    } catch (error2) {
      let errors = [...compiled.Errors(v)].map(mapValueError2);
      return { success: false, data: null, error: errors[0]?.summary, errors };
    }
  }, compiled;
};
var getResponseSchemaValidator2 = (s, { models = {}, modules, dynamic = false, normalize = false, additionalProperties = false }) => {
  if (!s)
    return;
  if (typeof s === "string" && !(s in models))
    return;
  let maybeSchemaOrRecord = typeof s === "string" ? modules.Import(s) ?? models[s] : s, compile = (schema, references) => {
    if (dynamic)
      return { schema, references: "", checkFunc: () => {
      }, code: "", Check: (value) => exports_value4.Check(schema, value), Errors: (value) => exports_value4.Errors(schema, value), Code: () => "", Clean: createCleaner2(schema), Decode: (value) => exports_value4.Decode(schema, value), Encode: (value) => exports_value4.Encode(schema, value) };
    let compiledValidator = TypeCompiler2.Compile(schema, references);
    if (normalize && schema.additionalProperties === false)
      compiledValidator.Clean = createCleaner2(schema);
    return compiledValidator;
  };
  if (Kind2 in maybeSchemaOrRecord) {
    if ("additionalProperties" in maybeSchemaOrRecord === false)
      maybeSchemaOrRecord.additionalProperties = additionalProperties;
    return { 200: compile(maybeSchemaOrRecord, Object.values(models)) };
  }
  let record = {};
  return Object.keys(maybeSchemaOrRecord).forEach((status) => {
    let maybeNameOrSchema = maybeSchemaOrRecord[+status];
    if (typeof maybeNameOrSchema === "string") {
      if (maybeNameOrSchema in models) {
        let schema = models[maybeNameOrSchema];
        schema.type === "object" && "additionalProperties" in schema, record[+status] = Kind2 in schema ? compile(schema, Object.values(models)) : schema;
      }
      return;
    }
    if (maybeNameOrSchema.type === "object" && "additionalProperties" in maybeNameOrSchema === false)
      maybeNameOrSchema.additionalProperties = additionalProperties;
    record[+status] = Kind2 in maybeNameOrSchema ? compile(maybeNameOrSchema, Object.values(models)) : maybeNameOrSchema;
  }), record;
};
var isBun5 = typeof Bun !== "undefined";
var hasHash2 = isBun5 && typeof Bun.hash === "function";
var checksum2 = (s) => {
  if (hasHash2)
    return Bun.hash(s);
  let h = 9;
  for (let i = 0;i < s.length; )
    h = Math.imul(h ^ s.charCodeAt(i++), 387420489);
  return h = h ^ h >>> 9;
};
var _stringToStructureCoercions2;
var stringToStructureCoercions2 = () => {
  if (!_stringToStructureCoercions2)
    _stringToStructureCoercions2 = [{ from: t2.Object({}), to: () => t2.ObjectString({}), excludeRoot: true }, { from: t2.Array(t2.Any()), to: () => t2.ArrayString(t2.Any()) }];
  return _stringToStructureCoercions2;
};
var _coercePrimitiveRoot2;
var coercePrimitiveRoot2 = () => {
  if (!_coercePrimitiveRoot2)
    _coercePrimitiveRoot2 = [{ from: t2.Number(), to: (options) => t2.Numeric(options), rootOnly: true }, { from: t2.Boolean(), to: (options) => t2.BooleanString(options), rootOnly: true }];
  return _coercePrimitiveRoot2;
};
var getCookieValidator2 = ({ validator, modules, defaultConfig = {}, config: config2, dynamic, models }) => {
  let cookieValidator = getSchemaValidator2(validator, { modules, dynamic, models, additionalProperties: true, coerce: true, additionalCoerce: stringToStructureCoercions2() });
  if (isNotEmpty2(defaultConfig))
    if (cookieValidator)
      cookieValidator.config = mergeCookie2(cookieValidator.config, config2);
    else
      cookieValidator = getSchemaValidator2(t2.Cookie({}), { modules, dynamic, models, additionalProperties: true }), cookieValidator.config = defaultConfig;
  return cookieValidator;
};
var injectChecksum2 = (checksum22, x) => {
  if (!x)
    return;
  if (!Array.isArray(x)) {
    let fn = x;
    if (checksum22 && !fn.checksum)
      fn.checksum = checksum22;
    if (fn.scope === "scoped")
      fn.scope = "local";
    return fn;
  }
  let fns = [...x];
  for (let fn of fns) {
    if (checksum22 && !fn.checksum)
      fn.checksum = checksum22;
    if (fn.scope === "scoped")
      fn.scope = "local";
  }
  return fns;
};
var mergeLifeCycle2 = (a, b, checksum22) => {
  return { start: mergeObjectArray2(a.start, injectChecksum2(checksum22, b?.start)), request: mergeObjectArray2(a.request, injectChecksum2(checksum22, b?.request)), parse: mergeObjectArray2(a.parse, injectChecksum2(checksum22, b?.parse)), transform: mergeObjectArray2(a.transform, injectChecksum2(checksum22, b?.transform)), beforeHandle: mergeObjectArray2(mergeObjectArray2(fnToContainer2(a.resolve, "resolve"), a.beforeHandle), injectChecksum2(checksum22, mergeObjectArray2(fnToContainer2(b?.resolve, "resolve"), b?.beforeHandle))), afterHandle: mergeObjectArray2(a.afterHandle, injectChecksum2(checksum22, b?.afterHandle)), mapResponse: mergeObjectArray2(a.mapResponse, injectChecksum2(checksum22, b?.mapResponse)), afterResponse: mergeObjectArray2(a.afterResponse, injectChecksum2(checksum22, b?.afterResponse)), trace: mergeObjectArray2(a.trace, injectChecksum2(checksum22, b?.trace)), error: mergeObjectArray2(a.error, injectChecksum2(checksum22, b?.error)), stop: mergeObjectArray2(a.stop, injectChecksum2(checksum22, b?.stop)) };
};
var asHookType2 = (fn, inject, { skipIfHasType = false } = {}) => {
  if (!fn)
    return fn;
  if (!Array.isArray(fn)) {
    if (skipIfHasType)
      fn.scope ??= inject;
    else
      fn.scope = inject;
    return fn;
  }
  for (let x of fn)
    if (skipIfHasType)
      x.scope ??= inject;
    else
      x.scope = inject;
  return fn;
};
var filterGlobal2 = (fn) => {
  if (!fn)
    return fn;
  if (!Array.isArray(fn))
    switch (fn.scope) {
      case "global":
      case "scoped":
        return { ...fn };
      default:
        return { fn };
    }
  let array = [];
  for (let x of fn)
    switch (x.scope) {
      case "global":
      case "scoped":
        array.push({ ...x });
        break;
    }
  return array;
};
var filterGlobalHook2 = (hook) => {
  return { ...hook, type: hook?.type, detail: hook?.detail, parse: filterGlobal2(hook?.parse), transform: filterGlobal2(hook?.transform), beforeHandle: filterGlobal2(hook?.beforeHandle), afterHandle: filterGlobal2(hook?.afterHandle), mapResponse: filterGlobal2(hook?.mapResponse), afterResponse: filterGlobal2(hook?.afterResponse), error: filterGlobal2(hook?.error), trace: filterGlobal2(hook?.trace) };
};
var StatusMap2 = { Continue: 100, "Switching Protocols": 101, Processing: 102, "Early Hints": 103, OK: 200, Created: 201, Accepted: 202, "Non-Authoritative Information": 203, "No Content": 204, "Reset Content": 205, "Partial Content": 206, "Multi-Status": 207, "Already Reported": 208, "Multiple Choices": 300, "Moved Permanently": 301, Found: 302, "See Other": 303, "Not Modified": 304, "Temporary Redirect": 307, "Permanent Redirect": 308, "Bad Request": 400, Unauthorized: 401, "Payment Required": 402, Forbidden: 403, "Not Found": 404, "Method Not Allowed": 405, "Not Acceptable": 406, "Proxy Authentication Required": 407, "Request Timeout": 408, Conflict: 409, Gone: 410, "Length Required": 411, "Precondition Failed": 412, "Payload Too Large": 413, "URI Too Long": 414, "Unsupported Media Type": 415, "Range Not Satisfiable": 416, "Expectation Failed": 417, "I'm a teapot": 418, "Misdirected Request": 421, "Unprocessable Content": 422, Locked: 423, "Failed Dependency": 424, "Too Early": 425, "Upgrade Required": 426, "Precondition Required": 428, "Too Many Requests": 429, "Request Header Fields Too Large": 431, "Unavailable For Legal Reasons": 451, "Internal Server Error": 500, "Not Implemented": 501, "Bad Gateway": 502, "Service Unavailable": 503, "Gateway Timeout": 504, "HTTP Version Not Supported": 505, "Variant Also Negotiates": 506, "Insufficient Storage": 507, "Loop Detected": 508, "Not Extended": 510, "Network Authentication Required": 511 };
var InvertedStatusMap2 = Object.fromEntries(Object.entries(StatusMap2).map(([k, v]) => [v, k]));
function removeTrailingEquals2(digest) {
  let trimmedDigest = digest;
  while (trimmedDigest.endsWith("="))
    trimmedDigest = trimmedDigest.slice(0, -1);
  return trimmedDigest;
}
var encoder2 = new TextEncoder;
var signCookie2 = async (val, secret) => {
  if (typeof val !== "string")
    throw new TypeError("Cookie value must be provided as a string.");
  if (secret === null)
    throw new TypeError("Secret key must be provided.");
  let secretKey = await crypto.subtle.importKey("raw", encoder2.encode(secret), { name: "HMAC", hash: "SHA-256" }, false, ["sign"]), hmacBuffer = await crypto.subtle.sign("HMAC", secretKey, encoder2.encode(val));
  return val + "." + removeTrailingEquals2(Buffer.from(hmacBuffer).toString("base64"));
};
var unsignCookie2 = async (input, secret) => {
  if (typeof input !== "string")
    throw new TypeError("Signed cookie string must be provided.");
  if (secret === null)
    throw new TypeError("Secret key must be provided.");
  let tentativeValue = input.slice(0, input.lastIndexOf("."));
  return await signCookie2(tentativeValue, secret) === input ? tentativeValue : false;
};
var traceBackMacro2 = (extension, property, manage) => {
  if (!extension || typeof extension !== "object" || !property)
    return;
  for (let [key, value] of Object.entries(property)) {
    if (key in primitiveHookMap2 || !(key in extension))
      continue;
    let v = extension[key];
    if (typeof v === "function") {
      let hook = v(value);
      if (typeof hook === "object")
        for (let [k, v2] of Object.entries(hook))
          manage(k)({ fn: v2 });
      delete property[key];
    }
  }
};
var createMacroManager2 = ({ globalHook, localHook }) => (stackName) => (type, fn) => {
  if (typeof type === "function")
    type = { fn: type };
  if (stackName === "resolve")
    type = { ...type, subType: "resolve" };
  if ("fn" in type || Array.isArray(type)) {
    if (!localHook[stackName])
      localHook[stackName] = [];
    if (typeof localHook[stackName] === "function")
      localHook[stackName] = [localHook[stackName]];
    if (Array.isArray(type))
      localHook[stackName] = localHook[stackName].concat(type);
    else
      localHook[stackName].push(type);
    return;
  }
  let { insert = "after", stack = "local" } = type;
  if (typeof fn === "function")
    fn = { fn };
  if (stack === "global")
    if (!Array.isArray(fn))
      if (insert === "before")
        globalHook[stackName].unshift(fn);
      else
        globalHook[stackName].push(fn);
    else if (insert === "before")
      globalHook[stackName] = fn.concat(globalHook[stackName]);
    else
      globalHook[stackName] = globalHook[stackName].concat(fn);
  else {
    if (!localHook[stackName])
      localHook[stackName] = [];
    if (typeof localHook[stackName] === "function")
      localHook[stackName] = [localHook[stackName]];
    if (!Array.isArray(fn))
      if (insert === "before")
        localHook[stackName].unshift(fn);
      else
        localHook[stackName].push(fn);
    else if (insert === "before")
      localHook[stackName] = fn.concat(localHook[stackName]);
    else
      localHook[stackName] = localHook[stackName].concat(fn);
  }
};
var parseNumericString2 = (message) => {
  if (typeof message === "number")
    return message;
  if (message.length < 16) {
    if (message.trim().length === 0)
      return null;
    let length = Number(message);
    if (Number.isNaN(length))
      return null;
    return length;
  }
  if (message.length === 16) {
    if (message.trim().length === 0)
      return null;
    let number = Number(message);
    if (Number.isNaN(number) || number.toString() !== message)
      return null;
    return number;
  }
  return null;
};
var isNumericString2 = (message) => parseNumericString2(message) !== null;

class PromiseGroup2 {
  onError;
  root = null;
  promises = [];
  constructor(onError = console.error) {
    this.onError = onError;
  }
  get size() {
    return this.promises.length;
  }
  add(promise) {
    return this.promises.push(promise), this.root ||= this.drain(), promise;
  }
  async drain() {
    while (this.promises.length > 0) {
      try {
        await this.promises[0];
      } catch (error2) {
        this.onError(error2);
      }
      this.promises.shift();
    }
    this.root = null;
  }
  then(onfulfilled, onrejected) {
    return (this.root ?? Promise.resolve()).then(onfulfilled, onrejected);
  }
}
var fnToContainer2 = (fn, subType) => {
  if (!fn)
    return fn;
  if (!Array.isArray(fn)) {
    if (typeof fn === "function" || typeof fn === "string")
      return subType ? { fn, subType } : { fn };
    else if ("fn" in fn)
      return fn;
  }
  let fns = [];
  for (let x of fn)
    if (typeof x === "function" || typeof x === "string")
      fns.push(subType ? { fn: x, subType } : { fn: x });
    else if ("fn" in x)
      fns.push(x);
  return fns;
};
var localHookToLifeCycleStore2 = (a) => {
  return { ...a, start: fnToContainer2(a?.start), request: fnToContainer2(a?.request), parse: fnToContainer2(a?.parse), transform: fnToContainer2(a?.transform), beforeHandle: fnToContainer2(a?.beforeHandle), afterHandle: fnToContainer2(a?.afterHandle), mapResponse: fnToContainer2(a?.mapResponse), afterResponse: fnToContainer2(a?.afterResponse), trace: fnToContainer2(a?.trace), error: fnToContainer2(a?.error), stop: fnToContainer2(a?.stop) };
};
var lifeCycleToFn2 = (a) => {
  return { ...a, start: a.start?.map((x) => x.fn), request: a.request?.map((x) => x.fn), parse: a.parse?.map((x) => x.fn), transform: a.transform?.map((x) => x.fn), beforeHandle: a.beforeHandle?.map((x) => x.fn), afterHandle: a.afterHandle?.map((x) => x.fn), afterResponse: a.afterResponse?.map((x) => x.fn), mapResponse: a.mapResponse?.map((x) => x.fn), trace: a.trace?.map((x) => x.fn), error: a.error?.map((x) => x.fn), stop: a.stop?.map((x) => x.fn) };
};
var cloneInference2 = (inference) => ({ body: inference.body, cookie: inference.cookie, headers: inference.headers, query: inference.query, set: inference.set, server: inference.server, request: inference.request, route: inference.route });
var redirect2 = (url, status = 302) => Response.redirect(url, status);
var ELYSIA_FORM_DATA2 = Symbol("ElysiaFormData");
var ELYSIA_REQUEST_ID2 = Symbol("ElysiaRequestId");
var randomId2 = () => {
  let uuid = crypto.randomUUID();
  return uuid.slice(0, 8) + uuid.slice(24, 32);
};
var deduplicateChecksum2 = (array) => {
  let hashes = [];
  for (let i = 0;i < array.length; i++) {
    let item = array[i];
    if (item.checksum) {
      if (hashes.includes(item.checksum))
        array.splice(i, 1), i--;
      hashes.push(item.checksum);
    }
  }
  return array;
};
var promoteEvent2 = (events, as = "scoped") => {
  if (as === "scoped") {
    for (let event of events)
      if ("scope" in event && event.scope === "local")
        event.scope = "scoped";
    return;
  }
  for (let event of events)
    if ("scope" in event)
      event.scope = "global";
};
var getLoosePath2 = (path) => {
  if (path.charCodeAt(path.length - 1) === 47)
    return path.slice(0, path.length - 1);
  return path + "/";
};
var isNotEmpty2 = (obj) => {
  if (!obj)
    return false;
  for (let x in obj)
    return true;
  return false;
};
var env3 = typeof Bun !== "undefined" ? Bun.env : typeof process !== "undefined" ? process?.env : undefined;
var ERROR_CODE2 = Symbol("ElysiaErrorCode");
var isProduction2 = (env3?.NODE_ENV ?? env3?.ENV) === "production";

class ElysiaCustomStatusResponse2 {
  code;
  response;
  constructor(code, response) {
    let res = response ?? (code in InvertedStatusMap2 ? InvertedStatusMap2[code] : code);
    this.code = StatusMap2[code] ?? code, this.response = res;
  }
}
var error2 = (code, response) => new ElysiaCustomStatusResponse2(code, response);

class InternalServerError2 extends Error {
  code = "INTERNAL_SERVER_ERROR";
  status = 500;
  constructor(message) {
    super(message ?? "INTERNAL_SERVER_ERROR");
  }
}

class NotFoundError2 extends Error {
  code = "NOT_FOUND";
  status = 404;
  constructor(message) {
    super(message ?? "NOT_FOUND");
  }
}

class ParseError4 extends Error {
  code = "PARSE";
  status = 400;
  constructor() {
    super("Bad Request");
  }
}

class InvalidCookieSignature2 extends Error {
  key;
  code = "INVALID_COOKIE_SIGNATURE";
  status = 400;
  constructor(key, message) {
    super(message ?? `"${key}" has invalid cookie signature`);
    this.key = key;
  }
}
var mapValueError2 = (error22) => {
  if (!error22)
    return { summary: undefined };
  let { message, path, value, type } = error22, property = path.slice(1).replaceAll("/", "."), isRoot = path === "";
  switch (type) {
    case 42:
      return { ...error22, summary: isRoot ? "Value should not be provided" : `Property '${property}' should not be provided` };
    case 45:
      return { ...error22, summary: isRoot ? "Value is missing" : `Property '${property}' is missing` };
    case 50:
      let quoteIndex = message.indexOf("'"), format = message.slice(quoteIndex + 1, message.indexOf("'", quoteIndex + 1));
      return { ...error22, summary: isRoot ? "Value should be an email" : `Property '${property}' should be ${format}` };
    case 54:
      return { ...error22, summary: `${message.slice(0, 9)} property '${property}' to be ${message.slice(8)} but found: ${value}` };
    case 62:
      let union = error22.schema.anyOf.map((x) => `'${x?.format ?? x.type}'`).join(", ");
      return { ...error22, summary: isRoot ? `Value should be one of ${union}` : `Property '${property}' should be one of: ${union}` };
    default:
      return { summary: message, ...error22 };
  }
};

class ValidationError2 extends Error {
  type;
  validator;
  value;
  code = "VALIDATION";
  status = 422;
  constructor(type, validator, value) {
    if (value && typeof value === "object" && value instanceof ElysiaCustomStatusResponse2)
      value = value.response;
    let error22 = isProduction2 ? undefined : ("Errors" in validator) ? validator.Errors(value).First() : exports_value4.Errors(validator, value).First(), customError = error22.schema.message || error22?.schema.error !== undefined ? typeof error22.schema.error === "function" ? error22.schema.error({ type, validator, value, get errors() {
      return [...validator.Errors(value)].map(mapValueError2);
    } }) : error22.schema.error : undefined, accessor = error22?.path || "root", message = "";
    if (customError !== undefined)
      message = typeof customError === "object" ? JSON.stringify(customError) : customError + "";
    else if (isProduction2)
      message = JSON.stringify({ type: "validation", on: type, summary: mapValueError2(error22).summary, message: error22?.message, found: value });
    else {
      let schema = validator?.schema ?? validator, errors = "Errors" in validator ? [...validator.Errors(value)].map(mapValueError2) : [...exports_value4.Errors(validator, value)].map(mapValueError2), expected;
      try {
        expected = exports_value4.Create(schema);
      } catch (error3) {
        expected = { type: "Could not create expected value", message: error3?.message, error: error3 };
      }
      message = JSON.stringify({ type: "validation", on: type, summary: mapValueError2(error22).summary, property: accessor, message: error22?.message, expected, found: value, errors }, null, 2);
    }
    super(message);
    this.type = type;
    this.validator = validator;
    this.value = value;
    Object.setPrototypeOf(this, ValidationError2.prototype);
  }
  get all() {
    return "Errors" in this.validator ? [...this.validator.Errors(this.value)].map(mapValueError2) : [...exports_value4.Errors(this.validator, this.value)].map(mapValueError2);
  }
  static simplifyModel(validator) {
    let model = "schema" in validator ? validator.schema : validator;
    try {
      return exports_value4.Create(model);
    } catch {
      return model;
    }
  }
  get model() {
    return ValidationError2.simplifyModel(this.validator);
  }
  toResponse(headers) {
    return new Response(this.message, { status: 400, headers: { ...headers, "content-type": "application/json" } });
  }
}
var isISO86012 = /(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))/;
var isFormalDate2 = /(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s\d{2}\s\d{4}\s\d{2}:\d{2}:\d{2}\sGMT(?:\+|-)\d{4}\s\([^)]+\)/;
var isShortenDate2 = /^(?:(?:(?:(?:0?[1-9]|[12][0-9]|3[01])[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:19|20)\d{2})|(?:(?:19|20)\d{2}[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:0?[1-9]|[12][0-9]|3[01]))))(?:\s(?:1[012]|0?[1-9]):[0-5][0-9](?::[0-5][0-9])?(?:\s[AP]M)?)?$/;
var _validateDate2 = fullFormats2.date;
var _validateDateTime2 = fullFormats2["date-time"];
if (!exports_format2.Has("date"))
  TypeSystem2.Format("date", (value) => {
    let temp = value.replace(/"/g, "");
    if (isISO86012.test(temp) || isFormalDate2.test(temp) || isShortenDate2.test(temp) || _validateDate2(temp)) {
      let date22 = new Date(temp);
      if (!Number.isNaN(date22.getTime()))
        return true;
    }
    return false;
  });
if (!exports_format2.Has("date-time"))
  TypeSystem2.Format("date-time", (value) => {
    let temp = value.replace(/"/g, "");
    if (isISO86012.test(temp) || isFormalDate2.test(temp) || isShortenDate2.test(temp) || _validateDateTime2(temp)) {
      let date22 = new Date(temp);
      if (!Number.isNaN(date22.getTime()))
        return true;
    }
    return false;
  });
Object.entries(fullFormats2).forEach((formatEntry) => {
  let [formatName, formatValue] = formatEntry;
  if (!exports_format2.Has(formatName)) {
    if (formatValue instanceof RegExp)
      TypeSystem2.Format(formatName, (value) => formatValue.test(value));
    else if (typeof formatValue === "function")
      TypeSystem2.Format(formatName, formatValue);
  }
});
var t2 = Object.assign({}, Type2);
var parseFileUnit2 = (size) => {
  if (typeof size === "string")
    switch (size.slice(-1)) {
      case "k":
        return +size.slice(0, size.length - 1) * 1024;
      case "m":
        return +size.slice(0, size.length - 1) * 1048576;
      default:
        return +size;
    }
  return size;
};
var validateFile2 = (options, value) => {
  if (!(value instanceof Blob))
    return false;
  if (options.minSize && value.size < parseFileUnit2(options.minSize))
    return false;
  if (options.maxSize && value.size > parseFileUnit2(options.maxSize))
    return false;
  if (options.extension)
    if (typeof options.extension === "string") {
      if (!value.type.startsWith(options.extension))
        return false;
    } else {
      for (let i = 0;i < options.extension.length; i++)
        if (value.type.startsWith(options.extension[i]))
          return true;
      return false;
    }
  return true;
};
var File22 = exports_type5.Get("Files") ?? TypeSystem2.Type("File", validateFile2);
var Files2 = exports_type5.Get("Files") ?? TypeSystem2.Type("Files", (options, value) => {
  if (!Array.isArray(value))
    return validateFile2(options, value);
  if (options.minItems && value.length < options.minItems)
    return false;
  if (options.maxItems && value.length > options.maxItems)
    return false;
  for (let i = 0;i < value.length; i++)
    if (!validateFile2(options, value[i]))
      return false;
  return true;
});
if (!exports_format2.Has("numeric"))
  exports_format2.Set("numeric", (value) => !!value && !isNaN(+value));
if (!exports_format2.Has("integer"))
  exports_format2.Set("integer", (value) => !!value && Number.isInteger(+value));
if (!exports_format2.Has("boolean"))
  exports_format2.Set("boolean", (value) => value === "true" || value === "false");
if (!exports_format2.Has("ObjectString"))
  exports_format2.Set("ObjectString", (value) => {
    let start = value.charCodeAt(0);
    if (start === 9 || start === 10 || start === 32)
      start = value.trimStart().charCodeAt(0);
    if (start !== 123 && start !== 91)
      return false;
    try {
      return JSON.parse(value), true;
    } catch {
      return false;
    }
  });
if (!exports_format2.Has("ArrayString"))
  exports_format2.Set("ArrayString", (value) => {
    let start = value.charCodeAt(0);
    if (start === 9 || start === 10 || start === 32)
      start = value.trimStart().charCodeAt(0);
    if (start !== 123 && start !== 91)
      return false;
    try {
      return JSON.parse(value), true;
    } catch {
      return false;
    }
  });
exports_type5.Set("UnionEnum", (schema, value) => {
  return (typeof value === "number" || typeof value === "string" || value === null) && schema.enum.includes(value);
});
var ElysiaType2 = { Numeric: (property) => {
  let schema = Type2.Number(property);
  return t2.Transform(t2.Union([t2.String({ format: "numeric", default: 0 }), t2.Number(property)], property)).Decode((value) => {
    let number = +value;
    if (isNaN(number))
      return value;
    if (property && !exports_value4.Check(schema, number))
      throw new ValidationError2("property", schema, number);
    return number;
  }).Encode((value) => value);
}, Integer: (property) => {
  let schema = Type2.Integer(property);
  return t2.Transform(t2.Union([t2.String({ format: "integer", default: 0 }), t2.Number(property)], property)).Decode((value) => {
    let number = +value;
    if (!exports_value4.Check(schema, number))
      throw new ValidationError2("property", schema, number);
    return number;
  }).Encode((value) => value);
}, Date: (property) => {
  let schema = Type2.Date(property);
  return t2.Transform(t2.Union([Type2.Date(property), t2.String({ format: "date", default: new Date().toISOString() }), t2.String({ format: "date-time", default: new Date().toISOString() }), t2.Number()], property)).Decode((value) => {
    if (typeof value === "number") {
      let date3 = new Date(value);
      if (!exports_value4.Check(schema, date3))
        throw new ValidationError2("property", schema, date3);
      return date3;
    }
    if (value instanceof Date)
      return value;
    let date22 = new Date(value);
    if (!exports_value4.Check(schema, date22))
      throw new ValidationError2("property", schema, date22);
    return date22;
  }).Encode((value) => {
    if (typeof value === "string")
      return new Date(value);
    return value;
  });
}, BooleanString: (property) => {
  let schema = Type2.Boolean(property);
  return t2.Transform(t2.Union([t2.Boolean(property), t2.String({ format: "boolean", default: false })], property)).Decode((value) => {
    if (typeof value === "string")
      return value === "true";
    if (value !== undefined && !exports_value4.Check(schema, value))
      throw new ValidationError2("property", schema, value);
    return value;
  }).Encode((value) => value);
}, ObjectString: (properties, options) => {
  let schema = t2.Object(properties, options), defaultValue = JSON.stringify(exports_value4.Create(schema)), compiler;
  try {
    compiler = TypeCompiler2.Compile(schema);
  } catch {
  }
  return t2.Transform(t2.Union([t2.String({ format: "ObjectString", default: defaultValue }), schema])).Decode((value) => {
    if (typeof value === "string") {
      if (value.charCodeAt(0) !== 123)
        throw new ValidationError2("property", schema, value);
      try {
        value = JSON.parse(value);
      } catch {
        throw new ValidationError2("property", schema, value);
      }
      if (compiler) {
        if (!compiler.Check(value))
          throw new ValidationError2("property", schema, value);
        return compiler.Decode(value);
      }
      if (!exports_value4.Check(schema, value))
        throw new ValidationError2("property", schema, value);
      return exports_value4.Decode(schema, value);
    }
    return value;
  }).Encode((value) => {
    if (typeof value === "string")
      try {
        value = JSON.parse(value);
      } catch {
        throw new ValidationError2("property", schema, value);
      }
    if (!exports_value4.Check(schema, value))
      throw new ValidationError2("property", schema, value);
    return JSON.stringify(value);
  });
}, ArrayString: (children = {}, options) => {
  let schema = t2.Array(children, options), defaultValue = JSON.stringify(exports_value4.Create(schema)), compiler;
  try {
    compiler = TypeCompiler2.Compile(schema);
  } catch {
  }
  return t2.Transform(t2.Union([t2.String({ format: "ArrayString", default: defaultValue }), schema])).Decode((value) => {
    if (typeof value === "string") {
      if (value.charCodeAt(0) !== 91)
        throw new ValidationError2("property", schema, value);
      try {
        value = JSON.parse(value);
      } catch {
        throw new ValidationError2("property", schema, value);
      }
      if (compiler) {
        if (!compiler.Check(value))
          throw new ValidationError2("property", schema, value);
        return compiler.Decode(value);
      }
      if (!exports_value4.Check(schema, value))
        throw new ValidationError2("property", schema, value);
      return exports_value4.Decode(schema, value);
    }
    return value;
  }).Encode((value) => {
    if (typeof value === "string")
      try {
        value = JSON.parse(value);
      } catch {
        throw new ValidationError2("property", schema, value);
      }
    if (!exports_value4.Check(schema, value))
      throw new ValidationError2("property", schema, value);
    return JSON.stringify(value);
  });
}, File: File22, Files: (options = {}) => t2.Transform(Files2(options)).Decode((value) => {
  if (Array.isArray(value))
    return value;
  return [value];
}).Encode((value) => value), Nullable: (schema) => t2.Union([schema, t2.Null()]), MaybeEmpty: (schema) => t2.Union([schema, t2.Null(), t2.Undefined()]), Cookie: (properties, { domain, expires, httpOnly, maxAge, path, priority, sameSite, secure, secrets, sign, ...options } = {}) => {
  let v = t2.Object(properties, options);
  return v.config = { domain, expires, httpOnly, maxAge, path, priority, sameSite, secure, secrets, sign }, v;
}, UnionEnum: (values, options = {}) => {
  let type = values.every((value) => typeof value === "string") ? { type: "string" } : values.every((value) => typeof value === "number") ? { type: "number" } : values.every((value) => value === null) ? { type: "null" } : {};
  if (values.some((x) => typeof x === "object" && x !== null))
    throw new Error("This type does not support objects or arrays");
  return { default: values[0], ...options, [Kind2]: "UnionEnum", ...type, enum: values };
} };
t2.BooleanString = ElysiaType2.BooleanString;
t2.ObjectString = ElysiaType2.ObjectString;
t2.ArrayString = ElysiaType2.ArrayString;
t2.Numeric = ElysiaType2.Numeric;
t2.Integer = ElysiaType2.Integer;
t2.File = (arg = {}) => ElysiaType2.File({ default: "File", ...arg, extension: arg?.type, type: "string", format: "binary" });
t2.Files = (arg = {}) => ElysiaType2.Files({ ...arg, elysiaMeta: "Files", default: "Files", extension: arg?.type, type: "array", items: { ...arg, default: "Files", type: "string", format: "binary" } });
t2.Nullable = (schema) => ElysiaType2.Nullable(schema);
t2.MaybeEmpty = ElysiaType2.MaybeEmpty;
t2.Cookie = ElysiaType2.Cookie;
t2.Date = ElysiaType2.Date;
t2.UnionEnum = ElysiaType2.UnionEnum;
var hasReturn2 = (fn) => {
  let fnLiteral = typeof fn === "object" ? fn.fn.toString() : typeof fn === "string" ? fn.toString() : fn, parenthesisEnd = fnLiteral.indexOf(")");
  if (fnLiteral.charCodeAt(parenthesisEnd + 2) === 61 && fnLiteral.charCodeAt(parenthesisEnd + 5) !== 123)
    return true;
  return fnLiteral.includes("return");
};
var separateFunction2 = (code) => {
  if (code.startsWith("async"))
    code = code.slice(5);
  code = code.trimStart();
  let index = -1;
  if (code.charCodeAt(0) === 40) {
    if (index = code.indexOf("=>", code.indexOf(")")), index !== -1) {
      let bracketEndIndex = index;
      while (bracketEndIndex > 0)
        if (code.charCodeAt(--bracketEndIndex) === 41)
          break;
      let body = code.slice(index + 2);
      if (body.charCodeAt(0) === 32)
        body = body.trimStart();
      return [code.slice(1, bracketEndIndex), body, { isArrowReturn: body.charCodeAt(0) !== 123 }];
    }
  }
  if (/^(\w+)=>/g.test(code)) {
    if (index = code.indexOf("=>"), index !== -1) {
      let body = code.slice(index + 2);
      if (body.charCodeAt(0) === 32)
        body = body.trimStart();
      return [code.slice(0, index), body, { isArrowReturn: body.charCodeAt(0) !== 123 }];
    }
  }
  if (code.startsWith("function")) {
    index = code.indexOf("(");
    let end = code.indexOf(")");
    return [code.slice(index + 1, end), code.slice(end + 2), { isArrowReturn: false }];
  }
  let start = code.indexOf("(");
  if (start !== -1) {
    let sep = code.indexOf(`
`, 2), parameter = code.slice(0, sep), end = parameter.lastIndexOf(")") + 1, body = code.slice(sep + 1);
    return [parameter.slice(start, end), "{" + body, { isArrowReturn: false }];
  }
  let x = code.split(`
`, 2);
  return [x[0], x[1], { isArrowReturn: false }];
};
var bracketPairRange2 = (parameter) => {
  let start = parameter.indexOf("{");
  if (start === -1)
    return [-1, 0];
  let end = start + 1, deep = 1;
  for (;end < parameter.length; end++) {
    let char = parameter.charCodeAt(end);
    if (char === 123)
      deep++;
    else if (char === 125)
      deep--;
    if (deep === 0)
      break;
  }
  if (deep !== 0)
    return [0, parameter.length];
  return [start, end + 1];
};
var bracketPairRangeReverse2 = (parameter) => {
  let end = parameter.lastIndexOf("}");
  if (end === -1)
    return [-1, 0];
  let start = end - 1, deep = 1;
  for (;start >= 0; start--) {
    let char = parameter.charCodeAt(start);
    if (char === 125)
      deep++;
    else if (char === 123)
      deep--;
    if (deep === 0)
      break;
  }
  if (deep !== 0)
    return [-1, 0];
  return [start, end + 1];
};
var removeColonAlias2 = (parameter) => {
  while (true) {
    let start = parameter.indexOf(":");
    if (start === -1)
      break;
    let end = parameter.indexOf(",", start);
    if (end === -1)
      end = parameter.indexOf("}", start) - 1;
    if (end === -2)
      end = parameter.length;
    parameter = parameter.slice(0, start) + parameter.slice(end);
  }
  return parameter;
};
var retrieveRootParamters2 = (parameter) => {
  let hasParenthesis = false;
  if (parameter.charCodeAt(0) === 40)
    parameter = parameter.slice(1, -1);
  if (parameter.charCodeAt(0) === 123)
    hasParenthesis = true, parameter = parameter.slice(1, -1);
  parameter = parameter.replace(/( |\t|\n)/g, "").trim();
  let parameters = [];
  while (true) {
    let [start, end] = bracketPairRange2(parameter);
    if (start === -1)
      break;
    if (parameters.push(parameter.slice(0, start - 1)), parameter.charCodeAt(end) === 44)
      end++;
    parameter = parameter.slice(end);
  }
  if (parameter = removeColonAlias2(parameter), parameter)
    parameters = parameters.concat(parameter.split(","));
  let newParameters = [];
  for (let p of parameters) {
    if (p.indexOf(",") === -1) {
      newParameters.push(p);
      continue;
    }
    for (let q of p.split(","))
      newParameters.push(q.trim());
  }
  return parameters = newParameters, { hasParenthesis, parameters };
};
var findParameterReference2 = (parameter, inference) => {
  let { parameters, hasParenthesis } = retrieveRootParamters2(parameter);
  if (!inference.query && parameters.includes("query"))
    inference.query = true;
  if (!inference.headers && parameters.includes("headers"))
    inference.headers = true;
  if (!inference.body && parameters.includes("body"))
    inference.body = true;
  if (!inference.cookie && parameters.includes("cookie"))
    inference.cookie = true;
  if (!inference.set && parameters.includes("set"))
    inference.set = true;
  if (!inference.server && parameters.includes("server"))
    inference.server = true;
  if (!inference.request && parameters.includes("request"))
    inference.request = true;
  if (!inference.route && parameters.includes("route"))
    inference.route = true;
  if (hasParenthesis)
    return `{ ${parameters.join(", ")} }`;
  return parameters.join(", ");
};
var findEndIndex2 = (type, content, index) => {
  let newLineIndex = content.indexOf(type + `
`, index), newTabIndex = content.indexOf(type + "\t", index), commaIndex = content.indexOf(type + ",", index), semicolonIndex = content.indexOf(type + ";", index), emptyIndex = content.indexOf(type + " ", index);
  return [newLineIndex, newTabIndex, commaIndex, semicolonIndex, emptyIndex].filter((i) => i > 0).sort((a, b) => a - b)[0] || -1;
};
var findAlias2 = (type, body, depth = 0) => {
  if (depth > 5)
    return [];
  let aliases = [], content = body;
  while (true) {
    let index = findEndIndex2(" = " + type, content);
    if (index === -1)
      index = findEndIndex2("=" + type, content);
    if (index === -1) {
      let lastIndex = content.indexOf(" = " + type);
      if (lastIndex === -1)
        lastIndex = content.indexOf("=" + type);
      if (lastIndex + 3 + type.length !== content.length)
        break;
      index = lastIndex;
    }
    let part = content.slice(0, index), lastPart = part.lastIndexOf(" "), variable = part.slice(lastPart !== -1 ? lastPart + 1 : -1);
    if (variable === "}") {
      let [start, end] = bracketPairRangeReverse2(part);
      aliases.push(removeColonAlias2(content.slice(start, end))), content = content.slice(index + 3 + type.length);
      continue;
    }
    while (variable.charCodeAt(0) === 44)
      variable = variable.slice(1);
    while (variable.charCodeAt(0) === 9)
      variable = variable.slice(1);
    if (!variable.includes("("))
      aliases.push(variable);
    content = content.slice(index + 3 + type.length);
  }
  for (let alias of aliases) {
    if (alias.charCodeAt(0) === 123)
      continue;
    let deepAlias = findAlias2(alias, body);
    if (deepAlias.length > 0)
      aliases.push(...deepAlias);
  }
  return aliases;
};
var extractMainParameter2 = (parameter) => {
  if (!parameter)
    return;
  if (parameter.charCodeAt(0) !== 123)
    return parameter;
  if (parameter = parameter.slice(2, -2), !parameter.includes(",")) {
    if (parameter.includes("..."))
      return parameter.slice(parameter.indexOf("...") + 3);
    return;
  }
  let spreadIndex = parameter.indexOf("...");
  if (spreadIndex === -1)
    return;
  return parameter.slice(spreadIndex + 3).trimEnd();
};
var inferBodyReference2 = (code, aliases, inference) => {
  let access = (type, alias) => code.includes(alias + "." + type) || code.includes(alias + '["' + type + '"]') || code.includes(alias + "['" + type + "']");
  for (let alias of aliases) {
    if (!alias)
      continue;
    if (alias.charCodeAt(0) === 123) {
      let parameters = retrieveRootParamters2(alias).parameters;
      if (!inference.query && parameters.includes("query"))
        inference.query = true;
      if (!inference.headers && parameters.includes("headers"))
        inference.headers = true;
      if (!inference.body && parameters.includes("body"))
        inference.body = true;
      if (!inference.cookie && parameters.includes("cookie"))
        inference.cookie = true;
      if (!inference.set && parameters.includes("set"))
        inference.set = true;
      if (!inference.query && parameters.includes("server"))
        inference.server = true;
      if (!inference.request && parameters.includes("request"))
        inference.request = true;
      if (!inference.route && parameters.includes("route"))
        inference.route = true;
      continue;
    }
    if (!inference.query && access("query", alias))
      inference.query = true;
    if (code.includes("return " + alias) || code.includes("return " + alias + ".query"))
      inference.query = true;
    if (!inference.headers && access("headers", alias))
      inference.headers = true;
    if (!inference.body && access("body", alias))
      inference.body = true;
    if (!inference.cookie && access("cookie", alias))
      inference.cookie = true;
    if (!inference.set && access("set", alias))
      inference.set = true;
    if (!inference.server && access("server", alias))
      inference.server = true;
    if (inference.query && inference.headers && inference.body && inference.cookie && inference.set && inference.server && inference.server && inference.route)
      break;
  }
  return aliases;
};
var isContextPassToFunction2 = (context, body, inference) => {
  try {
    let captureFunction = new RegExp(`(?:\\w)\\((?:.*)?${context}`, "gs");
    captureFunction.test(body);
    let nextChar = body.charCodeAt(captureFunction.lastIndex);
    if (nextChar === 41 || nextChar === 44)
      return inference.query = true, inference.headers = true, inference.body = true, inference.cookie = true, inference.set = true, inference.server = true, inference.route = true, inference.request = true, true;
    return false;
  } catch (error22) {
    return console.log("[Sucrose] warning: unexpected isContextPassToFunction error, you may continue development as usual but please report the following to maintainers:"), console.log("--- body ---"), console.log(body), console.log("--- context ---"), console.log(context), true;
  }
};
var sucrose2 = (lifeCycle, inference = { query: false, headers: false, body: false, cookie: false, set: false, server: false, request: false, route: false }) => {
  let events = [];
  if (lifeCycle.handler && typeof lifeCycle.handler === "function")
    events.push(lifeCycle.handler);
  if (lifeCycle.request?.length)
    events.push(...lifeCycle.request);
  if (lifeCycle.beforeHandle?.length)
    events.push(...lifeCycle.beforeHandle);
  if (lifeCycle.parse?.length)
    events.push(...lifeCycle.parse);
  if (lifeCycle.error?.length)
    events.push(...lifeCycle.error);
  if (lifeCycle.transform?.length)
    events.push(...lifeCycle.transform);
  if (lifeCycle.afterHandle?.length)
    events.push(...lifeCycle.afterHandle);
  if (lifeCycle.mapResponse?.length)
    events.push(...lifeCycle.mapResponse);
  if (lifeCycle.afterResponse?.length)
    events.push(...lifeCycle.afterResponse);
  for (let e of events) {
    if (!e)
      continue;
    let event = "fn" in e ? e.fn : e;
    if (typeof event !== "function")
      continue;
    let [parameter, body, { isArrowReturn }] = separateFunction2(event.toString()), rootParameters = findParameterReference2(parameter, inference), mainParameter = extractMainParameter2(rootParameters);
    if (mainParameter) {
      let aliases = findAlias2(mainParameter, body);
      if (aliases.splice(0, -1, mainParameter), !isContextPassToFunction2(mainParameter, body, inference))
        inferBodyReference2(body, aliases, inference);
      if (!inference.query && body.includes("return " + mainParameter + ".query"))
        inference.query = true;
    }
    if (inference.query && inference.headers && inference.body && inference.cookie && inference.set && inference.server && inference.request && inference.route)
      break;
  }
  return inference;
};

class Cookie2 {
  name;
  jar;
  initial;
  constructor(name, jar, initial = {}) {
    this.name = name;
    this.jar = jar;
    this.initial = initial;
  }
  get cookie() {
    return this.jar[this.name] ?? this.initial;
  }
  set cookie(jar) {
    if (!(this.name in this.jar))
      this.jar[this.name] = this.initial;
    this.jar[this.name] = jar;
  }
  get setCookie() {
    if (!(this.name in this.jar))
      this.jar[this.name] = this.initial;
    return this.jar[this.name];
  }
  set setCookie(jar) {
    this.cookie = jar;
  }
  get value() {
    return this.cookie.value;
  }
  set value(value) {
    this.setCookie.value = value;
  }
  get expires() {
    return this.cookie.expires;
  }
  set expires(expires) {
    this.setCookie.expires = expires;
  }
  get maxAge() {
    return this.cookie.maxAge;
  }
  set maxAge(maxAge) {
    this.setCookie.maxAge = maxAge;
  }
  get domain() {
    return this.cookie.domain;
  }
  set domain(domain) {
    this.setCookie.domain = domain;
  }
  get path() {
    return this.cookie.path;
  }
  set path(path) {
    this.setCookie.path = path;
  }
  get secure() {
    return this.cookie.secure;
  }
  set secure(secure) {
    this.setCookie.secure = secure;
  }
  get httpOnly() {
    return this.cookie.httpOnly;
  }
  set httpOnly(httpOnly) {
    this.setCookie.httpOnly = httpOnly;
  }
  get sameSite() {
    return this.cookie.sameSite;
  }
  set sameSite(sameSite) {
    this.setCookie.sameSite = sameSite;
  }
  get priority() {
    return this.cookie.priority;
  }
  set priority(priority) {
    this.setCookie.priority = priority;
  }
  get partitioned() {
    return this.cookie.partitioned;
  }
  set partitioned(partitioned) {
    this.setCookie.partitioned = partitioned;
  }
  get secrets() {
    return this.cookie.secrets;
  }
  set secrets(secrets) {
    this.setCookie.secrets = secrets;
  }
  update(config2) {
    return this.setCookie = Object.assign(this.cookie, typeof config2 === "function" ? config2(this.cookie) : config2), this;
  }
  set(config2) {
    return this.setCookie = Object.assign({ ...this.initial, value: this.value }, typeof config2 === "function" ? config2(this.cookie) : config2), this;
  }
  remove() {
    if (this.value === undefined)
      return;
    return this.set({ expires: new Date(0), maxAge: 0, value: "" }), this;
  }
  toString() {
    return typeof this.value === "object" ? JSON.stringify(this.value) : this.value?.toString() ?? "";
  }
}
var createCookieJar2 = (set2, store, initial) => {
  if (!set2.cookie)
    set2.cookie = {};
  return new Proxy(store, { get(_3, key) {
    if (key in store)
      return new Cookie2(key, set2.cookie, Object.assign({}, initial ?? {}, store[key]));
    return new Cookie2(key, set2.cookie, Object.assign({}, initial));
  } });
};
var parseCookie2 = async (set2, cookieString, { secrets, sign, ...initial } = {}) => {
  if (!cookieString)
    return createCookieJar2(set2, {}, initial);
  let isStringKey = typeof secrets === "string";
  if (sign && sign !== true && !Array.isArray(sign))
    sign = [sign];
  let jar = {}, cookies = import_cookie2.parse(cookieString);
  for (let [name, v] of Object.entries(cookies)) {
    let value = import_fast_decode_uri_component4.default(v);
    if (sign === true || sign?.includes(name)) {
      if (!secrets)
        throw new Error("No secret is provided to cookie plugin");
      if (isStringKey) {
        let temp = await unsignCookie2(value, secrets);
        if (temp === false)
          throw new InvalidCookieSignature2(name);
        value = temp;
      } else {
        let decoded = true;
        for (let i = 0;i < secrets.length; i++) {
          let temp = await unsignCookie2(value, secrets[i]);
          if (temp !== false) {
            decoded = true, value = temp;
            break;
          }
        }
        if (!decoded)
          throw new InvalidCookieSignature2(name);
      }
    }
    jar[name] = { value };
  }
  return createCookieJar2(set2, jar, initial);
};
var serializeCookie2 = (cookies) => {
  if (!cookies || !isNotEmpty2(cookies))
    return;
  let set2 = [];
  for (let [key, property] of Object.entries(cookies)) {
    if (!key || !property)
      continue;
    let value = property.value;
    if (value === undefined || value === null)
      continue;
    set2.push(import_cookie2.serialize(key, typeof value === "object" ? JSON.stringify(value) : value + "", property));
  }
  if (set2.length === 0)
    return;
  if (set2.length === 1)
    return set2[0];
  return set2;
};
var handleFile2 = (response, set2) => {
  let size = response.size;
  if (!set2 && size || size && set2 && set2.status !== 206 && set2.status !== 304 && set2.status !== 412 && set2.status !== 416) {
    if (set2) {
      if (set2.headers instanceof Headers) {
        let setHeaders = { "accept-ranges": "bytes", "content-range": `bytes 0-${size - 1}/${size}`, "transfer-encoding": "chunked" };
        if (hasHeaderShorthand2)
          setHeaders = set2.headers.toJSON();
        else {
          setHeaders = {};
          for (let [key, value] of set2.headers.entries())
            if (key in set2.headers)
              setHeaders[key] = value;
        }
        return new Response(response, { status: set2.status, headers: setHeaders });
      }
      if (isNotEmpty2(set2.headers))
        return new Response(response, { status: set2.status, headers: Object.assign({ "accept-ranges": "bytes", "content-range": `bytes 0-${size - 1}/${size}`, "transfer-encoding": "chunked" }, set2.headers) });
    }
    return new Response(response, { headers: { "accept-ranges": "bytes", "content-range": `bytes 0-${size - 1}/${size}`, "transfer-encoding": "chunked" } });
  }
  return new Response(response);
};
var parseSetCookies2 = (headers, setCookie) => {
  if (!headers)
    return headers;
  headers.delete("set-cookie");
  for (let i = 0;i < setCookie.length; i++) {
    let index = setCookie[i].indexOf("=");
    headers.append("set-cookie", `${setCookie[i].slice(0, index)}=${setCookie[i].slice(index + 1) || ""}`);
  }
  return headers;
};
var handleStream2 = async (generator, set2, request) => {
  let init = generator.next();
  if (init instanceof Promise)
    init = await init;
  if (init.done) {
    if (set2)
      return mapResponse2(init.value, set2, request);
    return mapCompactResponse2(init.value, request);
  }
  return new Response(new ReadableStream({ async start(controller) {
    let end = false;
    if (request?.signal?.addEventListener("abort", () => {
      end = true;
      try {
        controller.close();
      } catch {
      }
    }), init.value !== undefined && init.value !== null)
      if (typeof init.value === "object")
        try {
          controller.enqueue(Buffer.from(JSON.stringify(init.value)));
        } catch {
          controller.enqueue(Buffer.from(init.value.toString()));
        }
      else
        controller.enqueue(Buffer.from(init.value.toString()));
    for await (let chunk of generator) {
      if (end)
        break;
      if (chunk === undefined || chunk === null)
        continue;
      if (typeof chunk === "object")
        try {
          controller.enqueue(Buffer.from(JSON.stringify(chunk)));
        } catch {
          controller.enqueue(Buffer.from(chunk.toString()));
        }
      else
        controller.enqueue(Buffer.from(chunk.toString()));
      await new Promise((resolve) => setTimeout(() => resolve(), 0));
    }
    try {
      controller.close();
    } catch {
    }
  } }), { ...set2, headers: { "transfer-encoding": "chunked", "content-type": "text/event-stream; charset=utf-8", ...set2?.headers } });
};
async function* streamResponse2(response) {
  let body = response.body;
  if (!body)
    return;
  let reader = body.getReader(), decoder = new TextDecoder;
  try {
    while (true) {
      let { done, value } = await reader.read();
      if (done)
        break;
      yield decoder.decode(value);
    }
  } finally {
    reader.releaseLock();
  }
}
var handleSet2 = (set2) => {
  if (typeof set2.status === "string")
    set2.status = StatusMap2[set2.status];
  if (set2.cookie && isNotEmpty2(set2.cookie)) {
    let cookie = serializeCookie2(set2.cookie);
    if (cookie)
      set2.headers["set-cookie"] = cookie;
  }
  if (set2.headers["set-cookie"] && Array.isArray(set2.headers["set-cookie"]))
    set2.headers = parseSetCookies2(new Headers(set2.headers), set2.headers["set-cookie"]);
};
var mergeResponseWithSetHeaders2 = (response, set2) => {
  if (response.status !== set2.status && set2.status !== 200 && (response.status <= 300 || response.status > 400))
    response = new Response(response.body, { headers: response.headers, status: set2.status });
  let isCookieSet = false;
  if (set2.headers instanceof Headers)
    for (let key of set2.headers.keys())
      if (key === "set-cookie") {
        if (isCookieSet)
          continue;
        isCookieSet = true;
        for (let cookie of set2.headers.getSetCookie())
          response.headers.append("set-cookie", cookie);
      } else
        response.headers.append(key, set2.headers?.get(key) ?? "");
  else
    for (let key in set2.headers)
      response.headers.append(key, set2.headers[key]);
  return response;
};
var mapResponse2 = (response, set2, request) => {
  if (isNotEmpty2(set2.headers) || set2.status !== 200 || set2.cookie)
    switch (handleSet2(set2), response?.constructor?.name) {
      case "String":
        return new Response(response, set2);
      case "Array":
      case "Object":
        return Response.json(response, set2);
      case "ElysiaFile":
        return handleFile2(response.value);
      case "Blob":
        return handleFile2(response, set2);
      case "ElysiaCustomStatusResponse":
        return set2.status = response.code, mapResponse2(response.response, set2, request);
      case "ReadableStream":
        if (!set2.headers["content-type"]?.startsWith("text/event-stream"))
          set2.headers["content-type"] = "text/event-stream; charset=utf-8";
        return request?.signal?.addEventListener("abort", { handleEvent() {
          if (request?.signal && !request?.signal?.aborted)
            response.cancel();
        } }, { once: true }), new Response(response, set2);
      case undefined:
        if (!response)
          return new Response("", set2);
        return Response.json(response, set2);
      case "Response":
        if (response = mergeResponseWithSetHeaders2(response, set2), response.headers.get("transfer-encoding") === "chunked")
          return handleStream2(streamResponse2(response), set2, request);
        return response;
      case "Error":
        return errorToResponse2(response, set2);
      case "Promise":
        return response.then((x) => mapResponse2(x, set2, request));
      case "Function":
        return mapResponse2(response(), set2, request);
      case "Number":
      case "Boolean":
        return new Response(response.toString(), set2);
      case "Cookie":
        if (response instanceof Cookie2)
          return new Response(response.value, set2);
        return new Response(response?.toString(), set2);
      case "FormData":
        return new Response(response, set2);
      default:
        if (response instanceof Response) {
          if (response = mergeResponseWithSetHeaders2(response, set2), response.headers.get("transfer-encoding") === "chunked")
            return handleStream2(streamResponse2(response), set2, request);
          return response;
        }
        if (response instanceof Promise)
          return response.then((x) => mapResponse2(x, set2));
        if (response instanceof Error)
          return errorToResponse2(response, set2);
        if (response instanceof ElysiaCustomStatusResponse2)
          return set2.status = response.code, mapResponse2(response.response, set2, request);
        if (typeof response?.next === "function")
          return handleStream2(response, set2, request);
        if (typeof response?.then === "function")
          return response.then((x) => mapResponse2(x, set2));
        if (typeof response?.toResponse === "function")
          return mapResponse2(response.toResponse(), set2);
        if ("charCodeAt" in response) {
          let code = response.charCodeAt(0);
          if (code === 123 || code === 91) {
            if (!set2.headers["Content-Type"])
              set2.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set2);
          }
        }
        return new Response(response, set2);
    }
  if (typeof response?.next === "function" || response instanceof ReadableStream || response instanceof Response && response.headers.get("transfer-encoding") === "chunked")
    return handleStream2(response, set2, request);
  return mapCompactResponse2(response, request);
};
var mapEarlyResponse2 = (response, set2, request) => {
  if (response === undefined || response === null)
    return;
  if (isNotEmpty2(set2.headers) || set2.status !== 200 || set2.cookie)
    switch (handleSet2(set2), response?.constructor?.name) {
      case "String":
        return new Response(response, set2);
      case "Array":
      case "Object":
        return Response.json(response, set2);
      case "ElysiaFile":
        return handleFile2(response.value);
      case "Blob":
        return handleFile2(response, set2);
      case "ElysiaCustomStatusResponse":
        return set2.status = response.code, mapEarlyResponse2(response.response, set2, request);
      case "ReadableStream":
        if (!set2.headers["content-type"]?.startsWith("text/event-stream"))
          set2.headers["content-type"] = "text/event-stream; charset=utf-8";
        return request?.signal?.addEventListener("abort", { handleEvent() {
          if (request?.signal && !request?.signal?.aborted)
            response.cancel();
        } }, { once: true }), new Response(response, set2);
      case undefined:
        if (!response)
          return;
        return Response.json(response, set2);
      case "Response":
        if (response = mergeResponseWithSetHeaders2(response, set2), response.headers.get("transfer-encoding") === "chunked")
          return handleStream2(streamResponse2(response), set2, request);
        return response;
      case "Promise":
        return response.then((x) => mapEarlyResponse2(x, set2));
      case "Error":
        return errorToResponse2(response, set2);
      case "Function":
        return mapEarlyResponse2(response(), set2);
      case "Number":
      case "Boolean":
        return new Response(response.toString(), set2);
      case "FormData":
        return new Response(response);
      case "Cookie":
        if (response instanceof Cookie2)
          return new Response(response.value, set2);
        return new Response(response?.toString(), set2);
      default:
        if (response instanceof Response) {
          if (response = mergeResponseWithSetHeaders2(response, set2), response.headers.get("transfer-encoding") === "chunked")
            return handleStream2(streamResponse2(response), set2, request);
          return response;
        }
        if (response instanceof Promise)
          return response.then((x) => mapEarlyResponse2(x, set2));
        if (response instanceof Error)
          return errorToResponse2(response, set2);
        if (response instanceof ElysiaCustomStatusResponse2)
          return set2.status = response.code, mapEarlyResponse2(response.response, set2, request);
        if (typeof response?.next === "function")
          return handleStream2(response, set2, request);
        if (typeof response?.then === "function")
          return response.then((x) => mapEarlyResponse2(x, set2));
        if (typeof response?.toResponse === "function")
          return mapEarlyResponse2(response.toResponse(), set2);
        if ("charCodeAt" in response) {
          let code = response.charCodeAt(0);
          if (code === 123 || code === 91) {
            if (!set2.headers["Content-Type"])
              set2.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set2);
          }
        }
        return new Response(response, set2);
    }
  else
    switch (response?.constructor?.name) {
      case "String":
        return new Response(response);
      case "Array":
      case "Object":
        return Response.json(response, set2);
      case "ElysiaFile":
        return handleFile2(response.value);
      case "Blob":
        return handleFile2(response, set2);
      case "ElysiaCustomStatusResponse":
        return set2.status = response.code, mapEarlyResponse2(response.response, set2, request);
      case "ReadableStream":
        return request?.signal?.addEventListener("abort", { handleEvent() {
          if (request?.signal && !request?.signal?.aborted)
            response.cancel();
        } }, { once: true }), new Response(response, { headers: { "Content-Type": "text/event-stream; charset=utf-8" } });
      case undefined:
        if (!response)
          return new Response("");
        return new Response(JSON.stringify(response), { headers: { "content-type": "application/json" } });
      case "Response":
        if (response.headers.get("transfer-encoding") === "chunked")
          return handleStream2(streamResponse2(response));
        return response;
      case "Promise":
        return response.then((x) => {
          let r = mapEarlyResponse2(x, set2);
          if (r !== undefined)
            return r;
        });
      case "Error":
        return errorToResponse2(response, set2);
      case "Function":
        return mapCompactResponse2(response(), request);
      case "Number":
      case "Boolean":
        return new Response(response.toString());
      case "Cookie":
        if (response instanceof Cookie2)
          return new Response(response.value, set2);
        return new Response(response?.toString(), set2);
      case "FormData":
        return new Response(response);
      default:
        if (response instanceof Response)
          return response;
        if (response instanceof Promise)
          return response.then((x) => mapEarlyResponse2(x, set2));
        if (response instanceof Error)
          return errorToResponse2(response, set2);
        if (response instanceof ElysiaCustomStatusResponse2)
          return set2.status = response.code, mapEarlyResponse2(response.response, set2, request);
        if (typeof response?.next === "function")
          return handleStream2(response, set2, request);
        if (typeof response?.then === "function")
          return response.then((x) => mapEarlyResponse2(x, set2));
        if (typeof response?.toResponse === "function")
          return mapEarlyResponse2(response.toResponse(), set2);
        if ("charCodeAt" in response) {
          let code = response.charCodeAt(0);
          if (code === 123 || code === 91) {
            if (!set2.headers["Content-Type"])
              set2.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set2);
          }
        }
        return new Response(response);
    }
};
var mapCompactResponse2 = (response, request) => {
  switch (response?.constructor?.name) {
    case "String":
      return new Response(response);
    case "Object":
    case "Array":
      return Response.json(response);
    case "ElysiaFile":
      return handleFile2(response.value);
    case "Blob":
      return handleFile2(response);
    case "ElysiaCustomStatusResponse":
      return mapResponse2(response.response, { status: response.code, headers: {} });
    case "ReadableStream":
      return request?.signal?.addEventListener("abort", { handleEvent() {
        if (request?.signal && !request?.signal?.aborted)
          response.cancel();
      } }, { once: true }), new Response(response, { headers: { "Content-Type": "text/event-stream; charset=utf-8" } });
    case undefined:
      if (!response)
        return new Response("");
      return new Response(JSON.stringify(response), { headers: { "content-type": "application/json" } });
    case "Response":
      if (response.headers.get("transfer-encoding") === "chunked")
        return handleStream2(streamResponse2(response));
      return response;
    case "Error":
      return errorToResponse2(response);
    case "Promise":
      return response.then((x) => mapCompactResponse2(x, request));
    case "Function":
      return mapCompactResponse2(response(), request);
    case "Number":
    case "Boolean":
      return new Response(response.toString());
    case "FormData":
      return new Response(response);
    default:
      if (response instanceof Response)
        return response;
      if (response instanceof Promise)
        return response.then((x) => mapCompactResponse2(x, request));
      if (response instanceof Error)
        return errorToResponse2(response);
      if (response instanceof ElysiaCustomStatusResponse2)
        return mapResponse2(response.response, { status: response.code, headers: {} });
      if (typeof response?.next === "function")
        return handleStream2(response, undefined, request);
      if (typeof response?.then === "function")
        return response.then((x) => mapResponse2(x, set));
      if (typeof response?.toResponse === "function")
        return mapCompactResponse2(response.toResponse());
      if ("charCodeAt" in response) {
        let code = response.charCodeAt(0);
        if (code === 123 || code === 91)
          return new Response(JSON.stringify(response), { headers: { "Content-Type": "application/json" } });
      }
      return new Response(response);
  }
};
var errorToResponse2 = (error22, set2) => new Response(JSON.stringify({ name: error22?.name, message: error22?.message, cause: error22?.cause }), { status: set2?.status !== 200 ? set2?.status ?? 500 : 500, headers: set2?.headers });
var createStaticHandler2 = (handle, hooks, setHeaders = {}) => {
  if (typeof handle === "function")
    return;
  let response = mapResponse2(handle, { headers: setHeaders });
  if (hooks.parse.length === 0 && hooks.transform.length === 0 && hooks.beforeHandle.length === 0 && hooks.afterHandle.length === 0)
    return response.clone.bind(response);
};
var WebStandardAdapter2 = { name: "web-standard", isWebStandard: true, handler: { mapResponse: mapResponse2, mapEarlyResponse: mapEarlyResponse2, mapCompactResponse: mapCompactResponse2, createStaticHandler: createStaticHandler2 }, composeHandler: { mapResponseContext: "c.request", preferWebstandardHeaders: true, headers: `c.headers = {}
for (const [key, value] of c.request.headers.entries())c.headers[key] = value
`, parser: { json(isOptional2) {
  if (isOptional2)
    return `try{c.body=await c.request.json()}catch{}
`;
  return `c.body=await c.request.json()
`;
}, text() {
  return `c.body=await c.request.text()
`;
}, urlencoded() {
  return `c.body=parseQuery(await c.request.text())
`;
}, arrayBuffer() {
  return `c.body=await c.request.arrayBuffer()
`;
}, formData(isOptional2) {
  let fnLiteral = `
c.body={}
`;
  if (isOptional2)
    fnLiteral += "let form;try{form=await c.request.formData()}catch{}";
  else
    fnLiteral += `const form=await c.request.formData()
`;
  return fnLiteral + `for(const key of form.keys()){if(c.body[key]) continue
const value=form.getAll(key)
if(value.length===1)c.body[key]=value[0]
else c.body[key]=value}`;
} } }, composeGeneralHandler: { parameters: "r", createContext(app) {
  let decoratorsLiteral = "", fnLiteral = "", defaultHeaders = app.setHeaders;
  for (let key of Object.keys(app.singleton.decorator))
    decoratorsLiteral += `,${key}: decorator['${key}']`;
  let standardHostname = app.config.handler?.standardHostname ?? true, hasTrace = app.event.trace.length > 0;
  if (fnLiteral += `const u=r.url,s=u.indexOf('/',${standardHostname ? 11 : 7}),qi=u.indexOf('?', s + 1)
let p
if(qi===-1)p=u.substring(s)
else p=u.substring(s, qi)
`, hasTrace)
    fnLiteral += `const id=randomId()
`;
  if (fnLiteral += "const c={request:r,store,qi,path:p,url:u,redirect,error,set:{headers:", fnLiteral += Object.keys(defaultHeaders ?? {}).length ? "Object.assign({}, app.setHeaders)" : "{}", fnLiteral += ",status:200}", app.inference.server)
    fnLiteral += ",get server(){return getServer()}";
  if (hasTrace)
    fnLiteral += ",[ELYSIA_REQUEST_ID]:id";
  return fnLiteral += decoratorsLiteral, fnLiteral += `}
`, fnLiteral;
}, websocket(app) {
  let fnLiteral = "", wsPaths = app.router.static.ws, wsRouter = app.router.ws;
  if (Object.keys(wsPaths).length || wsRouter.history.length) {
    fnLiteral += "if(r.method==='GET'){switch(p){";
    for (let [path, index] of Object.entries(wsPaths))
      fnLiteral += `case'${path}':` + (app.config.strictPath !== true ? `case'${getLoosePath2(path)}':` : "") + `if(r.headers.get('upgrade')==='websocket')return ht[${index}].composed(c)
`;
    fnLiteral += `default:if(r.headers.get('upgrade')==='websocket'){const route=wsRouter.find('ws',p)
if(route){c.params=route.params
if(route.store.handler)return route.store.handler(c)
return (route.store.handler=route.store.compile())(c)}}break}}`;
  }
  return fnLiteral;
}, error404(hasEventHook, hasErrorHook) {
  let findDynamicRoute = "if(route===null)return ";
  if (hasErrorHook)
    findDynamicRoute += `app.handleError(c,notFound,false,${this.parameters})`;
  else
    findDynamicRoute += hasEventHook ? "new Response(error404Message,{status:c.set.status===200?404:c.set.status,headers:c.set.headers})" : "error404.clone()";
  return { declare: hasErrorHook ? "" : `const error404Message=notFound.message.toString()
const error404=new Response(error404Message,{status:404})
`, code: findDynamicRoute };
} }, composeError: { mapResponseContext: "", validationError: "return new Response(error.message,{headers:Object.assign({'content-type':'application/json'},set.headers),status:set.status})", unknownError: "return new Response(error.message,{headers:set.headers,status:error.status??set.status??500})" }, listen() {
  return () => {
    throw new Error("WebStandard does not support listen, you might want to export default Elysia.fetch instead");
  };
} };
var createNativeStaticHandler2 = (handle, hooks, setHeaders = {}) => {
  if (typeof handle === "function" || handle instanceof Blob)
    return;
  let response = mapResponse2(handle, { headers: setHeaders });
  if (hooks.parse.length === 0 && hooks.transform.length === 0 && hooks.beforeHandle.length === 0 && hooks.afterHandle.length === 0) {
    if (!response.headers.has("content-type"))
      response.headers.append("content-type", "text/plain;charset=utf-8");
    return response.clone.bind(response);
  }
};
var websocket2 = { open(ws) {
  ws.data.open?.(ws);
}, message(ws, message) {
  ws.data.message?.(ws, message);
}, drain(ws) {
  ws.data.drain?.(ws);
}, close(ws, code, reason) {
  ws.data.close?.(ws, code, reason);
} };

class ElysiaWS2 {
  raw;
  data;
  body;
  validator;
  ["~types"];
  get id() {
    return this.data.id;
  }
  constructor(raw2, data, body = undefined) {
    this.raw = raw2;
    this.data = data;
    this.body = body;
    this.validator = raw2.data?.validator, this.sendText = raw2.sendText.bind(raw2), this.sendBinary = raw2.sendBinary.bind(raw2), this.close = raw2.close.bind(raw2), this.terminate = raw2.terminate.bind(raw2), this.publishText = raw2.publishText.bind(raw2), this.publishBinary = raw2.publishBinary.bind(raw2), this.subscribe = raw2.subscribe.bind(raw2), this.unsubscribe = raw2.unsubscribe.bind(raw2), this.isSubscribed = raw2.isSubscribed.bind(raw2), this.cork = raw2.cork.bind(raw2), this.remoteAddress = raw2.remoteAddress, this.binaryType = raw2.binaryType, this.data = raw2.data, this.send = this.send.bind(this), this.ping = this.ping.bind(this), this.pong = this.pong.bind(this), this.publish = this.publish.bind(this);
  }
  send(data, compress) {
    if (Buffer.isBuffer(data))
      return this.raw.send(data, compress);
    if (this.validator?.Check(data) === false)
      return this.raw.send(new ValidationError2("message", this.validator, data).message);
    if (typeof data === "object")
      data = JSON.stringify(data);
    return this.raw.send(data, compress);
  }
  ping(data) {
    if (Buffer.isBuffer(data))
      return this.raw.ping(data);
    if (this.validator?.Check(data) === false)
      return this.raw.send(new ValidationError2("message", this.validator, data).message);
    if (typeof data === "object")
      data = JSON.stringify(data);
    return this.raw.ping(data);
  }
  pong(data) {
    if (Buffer.isBuffer(data))
      return this.raw.pong(data);
    if (this.validator?.Check(data) === false)
      return this.raw.send(new ValidationError2("message", this.validator, data).message);
    if (typeof data === "object")
      data = JSON.stringify(data);
    return this.raw.pong(data);
  }
  publish(topic, data, compress) {
    if (Buffer.isBuffer(data))
      return this.raw.publish(topic, data, compress);
    if (this.validator?.Check(data) === false)
      return this.raw.send(new ValidationError2("message", this.validator, data).message);
    if (typeof data === "object")
      data = JSON.stringify(data);
    return this.raw.publish(topic, data, compress);
  }
  sendText;
  sendBinary;
  close;
  terminate;
  publishText;
  publishBinary;
  subscribe;
  unsubscribe;
  isSubscribed;
  cork;
  remoteAddress;
  binaryType;
  get readyState() {
    return this.raw.readyState;
  }
}
var createWSMessageParser2 = (parse22) => {
  let parsers = typeof parse22 === "function" ? [parse22] : parse22;
  return async function parseMessage(ws, message) {
    if (typeof message === "string") {
      let start = message?.charCodeAt(0);
      if (start === 47 || start === 123)
        try {
          message = JSON.parse(message);
        } catch {
        }
      else if (isNumericString2(message))
        message = +message;
    }
    if (parsers)
      for (let i = 0;i < parsers.length; i++) {
        let temp = parsers[i](ws, message);
        if (temp instanceof Promise)
          temp = await temp;
        if (temp !== undefined)
          return temp;
      }
    return message;
  };
};
var createHandleWSResponse2 = (validateResponse) => {
  let handleWSResponse = (ws, data) => {
    if (data instanceof Promise)
      return data.then((data2) => handleWSResponse(ws, data2));
    if (Buffer.isBuffer(data))
      return ws.send(data.toString());
    if (data === undefined)
      return;
    let send = (datum) => {
      if (validateResponse?.Check(datum) === false)
        return ws.send(new ValidationError2("message", validateResponse, datum).message);
      if (typeof datum === "object")
        return ws.send(JSON.stringify(datum));
      ws.send(datum);
    };
    if (typeof data?.next !== "function")
      return void send(data);
    let init = data.next();
    if (init instanceof Promise)
      return (async () => {
        let first = await init;
        if (validateResponse?.Check(first) === false)
          return ws.send(new ValidationError2("message", validateResponse, first).message);
        if (send(first.value), !first.done)
          for await (let datum of data)
            send(datum);
      })();
    if (send(init.value), !init.done)
      for (let datum of data)
        send(datum);
  };
  return handleWSResponse;
};
var BunAdapter2 = { ...WebStandardAdapter2, name: "bun", handler: { ...WebStandardAdapter2.handler, createNativeStaticHandler: createNativeStaticHandler2 }, composeHandler: { ...WebStandardAdapter2.composeHandler, headers: hasHeaderShorthand2 ? `c.headers = c.request.headers.toJSON()
` : `c.headers = {}
for (const [key, value] of c.request.headers.entries())c.headers[key] = value
` }, listen(app) {
  return (options, callback) => {
    if (typeof Bun === "undefined")
      throw new Error(".listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch");
    if (app.compile(), typeof options === "string") {
      if (!isNumericString2(options))
        throw new Error("Port must be a numeric value");
      options = parseInt(options);
    }
    let fetch2 = app.fetch, serve = typeof options === "object" ? { development: !isProduction2, reusePort: true, ...app.config.serve || {}, ...options || {}, static: app.router.static.http.static, websocket: { ...app.config.websocket || {}, ...websocket2 || {} }, fetch: fetch2, error: app.outerErrorHandler } : { development: !isProduction2, reusePort: true, ...app.config.serve || {}, static: app.router.static.http.static, websocket: { ...app.config.websocket || {}, ...websocket2 || {} }, port: options, fetch: fetch2, error: app.outerErrorHandler };
    app.server = Bun?.serve(serve);
    for (let i = 0;i < app.event.start.length; i++)
      app.event.start[i].fn(app);
    if (callback)
      callback(app.server);
    process.on("beforeExit", () => {
      if (app.server) {
        app.server.stop(), app.server = null;
        for (let i = 0;i < app.event.stop.length; i++)
          app.event.stop[i].fn(app);
      }
    }), app.promisedModules.then(() => {
      Bun?.gc(false);
    });
  };
}, ws(app, path, options) {
  let { parse: parse22, body, response, ...rest } = options, validateMessage = getSchemaValidator2(body, { modules: app.definitions.typebox, models: app.definitions.type, normalize: app.config.normalize }), validateResponse = getSchemaValidator2(response, { modules: app.definitions.typebox, models: app.definitions.type, normalize: app.config.normalize });
  app.route("$INTERNALWS", path, async (context) => {
    let server = app.getServer(), { set: set2, path: path2, qi, headers, query, params } = context;
    if (context.validator = validateResponse, options.upgrade) {
      if (typeof options.upgrade === "function") {
        let temp = options.upgrade(context);
        if (temp instanceof Promise)
          await temp;
      } else if (options.upgrade)
        Object.assign(set2.headers, options.upgrade);
    }
    if (set2.cookie && isNotEmpty2(set2.cookie)) {
      let cookie = serializeCookie2(set2.cookie);
      if (cookie)
        set2.headers["set-cookie"] = cookie;
    }
    if (set2.headers["set-cookie"] && Array.isArray(set2.headers["set-cookie"]))
      set2.headers = parseSetCookies2(new Headers(set2.headers), set2.headers["set-cookie"]);
    let handleResponse = createHandleWSResponse2(validateResponse), parseMessage = createWSMessageParser2(parse22), _id;
    if (server?.upgrade(context.request, { headers: isNotEmpty2(set2.headers) ? set2.headers : undefined, data: { ...context, get id() {
      if (_id)
        return _id;
      return _id = randomId2();
    }, validator: validateResponse, ping(data) {
      options.ping?.(data);
    }, pong(data) {
      options.pong?.(data);
    }, open(ws) {
      handleResponse(ws, options.open?.(new ElysiaWS2(ws, context)));
    }, message: async (ws, _message) => {
      let message = await parseMessage(ws, _message);
      if (validateMessage?.Check(message) === false)
        return void ws.send(new ValidationError2("message", validateMessage, message).message);
      handleResponse(ws, options.message?.(new ElysiaWS2(ws, context, message), message));
    }, drain(ws) {
      handleResponse(ws, options.drain?.(new ElysiaWS2(ws, context)));
    }, close(ws, code, reason) {
      handleResponse(ws, options.close?.(new ElysiaWS2(ws, context), code, reason));
    } } }))
      return;
    return set2.status = 400, "Expected a websocket connection";
  }, { ...rest, websocket: options });
} };
var isBun22 = typeof Bun !== "undefined";
var env22 = isBun22 ? Bun.env : typeof process !== "undefined" && process?.env ? process.env : {};
var plusRegex2 = /\+/g;
function parseQueryFromURL2(input) {
  let result = {};
  if (typeof input !== "string")
    return result;
  let key = "", value = "", startingIndex = -1, equalityIndex = -1, flags = 0, l = input.length;
  for (let i = 0;i < l; i++)
    switch (input.charCodeAt(i)) {
      case 38:
        let hasBothKeyValuePair = equalityIndex > startingIndex;
        if (!hasBothKeyValuePair)
          equalityIndex = i;
        if (key = input.slice(startingIndex + 1, equalityIndex), hasBothKeyValuePair || key.length > 0) {
          if (flags & 1)
            key = key.replace(plusRegex2, " ");
          if (flags & 2)
            key = import_fast_decode_uri_component5.default(key) || key;
          if (!result[key]) {
            if (hasBothKeyValuePair) {
              if (value = input.slice(equalityIndex + 1, i), flags & 4)
                value = value.replace(plusRegex2, " ");
              if (flags & 8)
                value = import_fast_decode_uri_component5.default(value) || value;
            }
            result[key] = value;
          }
        }
        key = "", value = "", startingIndex = i, equalityIndex = i, flags = 0;
        break;
      case 61:
        if (equalityIndex <= startingIndex)
          equalityIndex = i;
        else
          flags |= 8;
        break;
      case 43:
        if (equalityIndex > startingIndex)
          flags |= 4;
        else
          flags |= 1;
        break;
      case 37:
        if (equalityIndex > startingIndex)
          flags |= 8;
        else
          flags |= 2;
        break;
    }
  if (startingIndex < l) {
    let hasBothKeyValuePair = equalityIndex > startingIndex;
    if (key = input.slice(startingIndex + 1, hasBothKeyValuePair ? equalityIndex : l), hasBothKeyValuePair || key.length > 0) {
      if (flags & 1)
        key = key.replace(plusRegex2, " ");
      if (flags & 2)
        key = import_fast_decode_uri_component5.default(key) || key;
      if (!result[key]) {
        if (hasBothKeyValuePair) {
          if (value = input.slice(equalityIndex + 1, l), flags & 4)
            value = value.replace(plusRegex2, " ");
          if (flags & 8)
            value = import_fast_decode_uri_component5.default(value) || value;
        }
        result[key] = value;
      }
    }
  }
  return result;
}
var parseQuery2 = (input) => {
  let result = {};
  if (typeof input !== "string")
    return result;
  let inputLength = input.length, key = "", value = "", startingIndex = -1, equalityIndex = -1, shouldDecodeKey = false, shouldDecodeValue = false, keyHasPlus = false, valueHasPlus = false, hasBothKeyValuePair = false, c = 0;
  for (let i = 0;i < inputLength + 1; i++) {
    if (i !== inputLength)
      c = input.charCodeAt(i);
    else
      c = 38;
    switch (c) {
      case 38: {
        if (hasBothKeyValuePair = equalityIndex > startingIndex, !hasBothKeyValuePair)
          equalityIndex = i;
        if (key = input.slice(startingIndex + 1, equalityIndex), hasBothKeyValuePair || key.length > 0) {
          if (keyHasPlus)
            key = key.replace(plusRegex2, " ");
          if (shouldDecodeKey)
            key = import_fast_decode_uri_component5.default(key) || key;
          if (hasBothKeyValuePair) {
            if (value = input.slice(equalityIndex + 1, i), valueHasPlus)
              value = value.replace(plusRegex2, " ");
            if (shouldDecodeValue)
              value = import_fast_decode_uri_component5.default(value) || value;
          }
          let currentValue = result[key];
          if (currentValue === undefined)
            result[key] = value;
          else if (currentValue.pop)
            currentValue.push(value);
          else
            result[key] = [currentValue, value];
        }
        value = "", startingIndex = i, equalityIndex = i, shouldDecodeKey = false, shouldDecodeValue = false, keyHasPlus = false, valueHasPlus = false;
        break;
      }
      case 61:
        if (equalityIndex <= startingIndex)
          equalityIndex = i;
        else
          shouldDecodeValue = true;
        break;
      case 43:
        if (equalityIndex > startingIndex)
          valueHasPlus = true;
        else
          keyHasPlus = true;
        break;
      case 37:
        if (equalityIndex > startingIndex)
          shouldDecodeValue = true;
        else
          shouldDecodeKey = true;
        break;
    }
  }
  return result;
};
var ELYSIA_TRACE2 = Symbol("ElysiaTrace");
var createProcess2 = () => {
  let { promise, resolve } = Promise.withResolvers(), { promise: end, resolve: resolveEnd } = Promise.withResolvers(), { promise: error22, resolve: resolveError } = Promise.withResolvers(), callbacks = [], callbacksEnd = [];
  return [(callback) => {
    if (callback)
      callbacks.push(callback);
    return promise;
  }, (process2) => {
    let processes = [], resolvers = [], groupError = null;
    for (let i = 0;i < (process2.total ?? 0); i++) {
      let { promise: promise2, resolve: resolve2 } = Promise.withResolvers(), { promise: end2, resolve: resolveEnd2 } = Promise.withResolvers(), { promise: error3, resolve: resolveError2 } = Promise.withResolvers(), callbacks2 = [], callbacksEnd2 = [];
      processes.push((callback) => {
        if (callback)
          callbacks2.push(callback);
        return promise2;
      }), resolvers.push((process3) => {
        let result2 = { ...process3, end: end2, error: error3, index: i, onStop(callback) {
          if (callback)
            callbacksEnd2.push(callback);
          return end2;
        } };
        resolve2(result2);
        for (let i2 = 0;i2 < callbacks2.length; i2++)
          callbacks2[i2](result2);
        return (error4 = null) => {
          let end3 = performance.now();
          if (error4)
            groupError = error4;
          let detail = { end: end3, error: error4, get elapsed() {
            return end3 - process3.begin;
          } };
          for (let i2 = 0;i2 < callbacksEnd2.length; i2++)
            callbacksEnd2[i2](detail);
          resolveEnd2(end3), resolveError2(error4);
        };
      });
    }
    let result = { ...process2, end, error: error22, onEvent(callback) {
      for (let i = 0;i < processes.length; i++)
        processes[i](callback);
    }, onStop(callback) {
      if (callback)
        callbacksEnd.push(callback);
      return end;
    } };
    resolve(result);
    for (let i = 0;i < callbacks.length; i++)
      callbacks[i](result);
    return { resolveChild: resolvers, resolve(error3 = null) {
      let end2 = performance.now();
      if (!error3 && groupError)
        error3 = groupError;
      let detail = { end: end2, error: error3, get elapsed() {
        return end2 - process2.begin;
      } };
      for (let i = 0;i < callbacksEnd.length; i++)
        callbacksEnd[i](detail);
      resolveEnd(end2), resolveError(error3);
    } };
  }];
};
var createTracer2 = (traceListener) => {
  return (context) => {
    let [onRequest, resolveRequest] = createProcess2(), [onParse, resolveParse] = createProcess2(), [onTransform, resolveTransform] = createProcess2(), [onBeforeHandle, resolveBeforeHandle] = createProcess2(), [onHandle, resolveHandle] = createProcess2(), [onAfterHandle, resolveAfterHandle] = createProcess2(), [onError, resolveError] = createProcess2(), [onMapResponse, resolveMapResponse] = createProcess2(), [onAfterResponse, resolveAfterResponse] = createProcess2();
    return traceListener({ id: context[ELYSIA_REQUEST_ID2], context, set: context.set, onRequest, onParse, onTransform, onBeforeHandle, onHandle, onAfterHandle, onMapResponse, onAfterResponse, onError }), { request: resolveRequest, parse: resolveParse, transform: resolveTransform, beforeHandle: resolveBeforeHandle, handle: resolveHandle, afterHandle: resolveAfterHandle, error: resolveError, mapResponse: resolveMapResponse, afterResponse: resolveAfterResponse };
  };
};
var TypeBoxSymbol2 = { optional: Symbol.for("TypeBox.Optional"), kind: Symbol.for("TypeBox.Kind") };
var isOptional2 = (validator) => {
  if (!validator)
    return false;
  let schema = validator?.schema;
  if (schema?.[TypeBoxSymbol2.kind] === "Import")
    return validator.References().some(isOptional2);
  return !!schema && TypeBoxSymbol2.optional in schema;
};
var defaultParsers2 = ["json", "text", "urlencoded", "arrayBuffer", "formdata", "application/json", "text/plain", "application/x-www-form-urlencoded", "application/octet-stream", "multipart/form-data"];
var hasAdditionalProperties2 = (_schema) => {
  if (!_schema)
    return false;
  let schema = _schema?.schema ?? _schema;
  if (schema[TypeBoxSymbol2.kind] === "Import" && _schema.References())
    return _schema.References().some(hasAdditionalProperties2);
  if (schema.anyOf)
    return schema.anyOf.some(hasAdditionalProperties2);
  if (schema.someOf)
    return schema.someOf.some(hasAdditionalProperties2);
  if (schema.allOf)
    return schema.allOf.some(hasAdditionalProperties2);
  if (schema.not)
    return schema.not.some(hasAdditionalProperties2);
  if (schema.type === "object") {
    let properties = schema.properties;
    if ("additionalProperties" in schema)
      return schema.additionalProperties;
    if ("patternProperties" in schema)
      return false;
    for (let key of Object.keys(properties)) {
      let property = properties[key];
      if (property.type === "object") {
        if (hasAdditionalProperties2(property))
          return true;
      } else if (property.anyOf) {
        for (let i = 0;i < property.anyOf.length; i++)
          if (hasAdditionalProperties2(property.anyOf[i]))
            return true;
      }
      return property.additionalProperties;
    }
    return false;
  }
  return false;
};
var createReport2 = ({ context = "c", trace, addFn }) => {
  if (!trace.length)
    return () => {
      return { resolveChild() {
        return () => {
        };
      }, resolve() {
      } };
    };
  for (let i = 0;i < trace.length; i++)
    addFn(`let report${i}, reportChild${i}, reportErr${i}, reportErrChild${i};let trace${i} = ${context}[ELYSIA_TRACE]?.[${i}] ?? trace[${i}](${context});
`);
  return (event, { name, total = 0 } = {}) => {
    if (!name)
      name = "anonymous";
    let reporter = event === "error" ? "reportErr" : "report";
    for (let i = 0;i < trace.length; i++)
      addFn(`${reporter}${i} = trace${i}.${event}({id,event:'${event}',name:'${name}',begin:performance.now(),total:${total}})
`);
    return { resolve() {
      for (let i = 0;i < trace.length; i++)
        addFn(`${reporter}${i}.resolve()
`);
    }, resolveChild(name2) {
      for (let i = 0;i < trace.length; i++)
        addFn(`${reporter}Child${i}=${reporter}${i}.resolveChild?.shift()?.({id,event:'${event}',name:'${name2}',begin:performance.now()})
`);
      return (binding) => {
        for (let i = 0;i < trace.length; i++)
          if (binding)
            addFn(`if(${binding} instanceof Error){${reporter}Child${i}?.(${binding}) }else{${reporter}Child${i}?.()}`);
          else
            addFn(`${reporter}Child${i}?.()
`);
      };
    } };
  };
};
var composeValidationFactory2 = ({ injectResponse = "", normalize = false, validator }) => ({ composeValidation: (type, value = `c.${type}`) => `c.set.status=422;throw new ValidationError('${type}',validator.${type},${value})`, composeResponseValidation: (name = "r") => {
  let code = injectResponse + `
`;
  code += `if(${name} instanceof ElysiaCustomStatusResponse){c.set.status=${name}.code
${name}=${name}.response}const isResponse=${name} instanceof Response
switch(c.set.status){`;
  for (let [status, value] of Object.entries(validator.response)) {
    if (code += `
case ${status}:if(!isResponse){`, normalize && "Clean" in value && !hasAdditionalProperties2(value))
      code += `${name}=validator.response['${status}'].Clean(${name})
`;
    code += `if(validator.response['${status}'].Check(${name})===false){c.set.status=422
throw new ValidationError('response',validator.response['${status}'],${name})}c.set.status = ${status}}break
`;
  }
  return code + "}";
} });
var KindSymbol2 = Symbol.for("TypeBox.Kind");
var hasProperty2 = (expectedProperty, _schema) => {
  if (!_schema)
    return;
  let schema = _schema.schema ?? _schema;
  if (schema[TypeBoxSymbol2.kind] === "Import")
    return _schema.References().some((schema2) => hasProperty2(expectedProperty, schema2));
  if (schema.type === "object") {
    let properties = schema.properties;
    if (!properties)
      return false;
    for (let key of Object.keys(properties)) {
      let property = properties[key];
      if (expectedProperty in property)
        return true;
      if (property.type === "object") {
        if (hasProperty2(expectedProperty, property))
          return true;
      } else if (property.anyOf) {
        for (let i = 0;i < property.anyOf.length; i++)
          if (hasProperty2(expectedProperty, property.anyOf[i]))
            return true;
      }
    }
    return false;
  }
  return expectedProperty in schema;
};
var TransformSymbol2 = Symbol.for("TypeBox.Transform");
var hasTransform2 = (schema) => {
  if (!schema)
    return;
  if (schema.type === "object" && schema.properties) {
    let properties = schema.properties;
    for (let key of Object.keys(properties)) {
      let property = properties[key];
      if (property.type === "object") {
        if (hasTransform2(property))
          return true;
      } else if (property.anyOf) {
        for (let i = 0;i < property.anyOf.length; i++)
          if (hasTransform2(property.anyOf[i]))
            return true;
      }
      if (TransformSymbol2 in property)
        return true;
    }
    return false;
  }
  return TransformSymbol2 in schema || schema.properties && TransformSymbol2 in schema.properties;
};
var matchFnReturn2 = /(?:return|=>) \S+\(/g;
var isAsyncName2 = (v) => {
  return (v?.fn ?? v).constructor.name === "AsyncFunction";
};
var isAsync2 = (v) => {
  let fn = v?.fn ?? v;
  if (fn.constructor.name === "AsyncFunction")
    return true;
  let literal = fn.toString();
  if (literal.includes("=> response.clone("))
    return false;
  if (literal.includes("await"))
    return true;
  if (literal.includes("async"))
    return true;
  if (literal.includes("=>response.clone("))
    return false;
  return !!literal.match(matchFnReturn2);
};
var isGenerator2 = (v) => {
  let fn = v?.fn ?? v;
  return fn.constructor.name === "AsyncGeneratorFunction" || fn.constructor.name === "GeneratorFunction";
};
var composeHandler2 = ({ app, path, method, localHook, hooks, validator, handler, allowMeta = false, inference, asManifest = false }) => {
  let adapter = app["~adapter"].composeHandler, adapterHandler = app["~adapter"].handler, isHandleFn = typeof handler === "function";
  if (!isHandleFn) {
    if (handler = adapterHandler.mapResponse(handler, { headers: app.setHeaders ?? {} }), hooks.parse.length === 0 && hooks.transform.length === 0 && hooks.beforeHandle.length === 0 && hooks.afterHandle.length === 0) {
      if (handler instanceof Response)
        return Function("a", "return function(){return a.clone()}")(handler);
      return Function("a", "return function(){return a}")(handler);
    }
  }
  let handle = isHandleFn ? "handler(c)" : "handler", hasAfterResponse = hooks.afterResponse.length > 0, hasTrace = hooks.trace.length > 0, fnLiteral = "";
  if (inference = sucrose2(Object.assign(localHook, { handler }), inference), adapter.declare) {
    let literal = adapter.declare(inference);
    if (literal)
      fnLiteral += literal;
  }
  if (inference.server)
    fnLiteral += `Object.defineProperty(c,'server',{get:function(){return getServer()}})
`;
  validator.createBody?.(), validator.createQuery?.(), validator.createHeaders?.(), validator.createParams?.(), validator.createCookie?.(), validator.createResponse?.();
  let hasQuery = inference.query || !!validator.query, hasBody = method !== "$INTERNALWS" && method !== "GET" && method !== "HEAD" && (inference.body || !!validator.body || hooks.parse.length);
  if (hasBody)
    fnLiteral += `let isParsing=false
`;
  let defaultHeaders = app.setHeaders, hasDefaultHeaders = defaultHeaders && !!Object.keys(defaultHeaders).length, hasHeaders = inference.headers || validator.headers || adapter.preferWebstandardHeaders !== true && inference.body, hasCookie = inference.cookie || !!validator.cookie, cookieValidator = hasCookie ? getCookieValidator2({ modules: app.definitions.typebox, validator: validator.cookie, defaultConfig: app.config.cookie, dynamic: !!app.config.aot, config: validator.cookie?.config ?? {}, models: app.definitions.type }) : undefined, cookieMeta = cookieValidator?.config, encodeCookie = "";
  if (cookieMeta?.sign) {
    if (!cookieMeta.secrets)
      throw new Error(`t.Cookie required secret which is not set in (${method}) ${path}.`);
    let secret = !cookieMeta.secrets ? undefined : typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets[0];
    if (encodeCookie += `const _setCookie = c.set.cookie
if(_setCookie){`, cookieMeta.sign === true)
      encodeCookie += `for(const [key, cookie] of Object.entries(_setCookie)){c.set.cookie[key].value=await signCookie(cookie.value,'${secret}')}`;
    else
      for (let name of cookieMeta.sign)
        encodeCookie += `if(_setCookie['${name}']?.value){c.set.cookie['${name}'].value=await signCookie(_setCookie['${name}'].value,'${secret}')}`;
    encodeCookie += `}
`;
  }
  let normalize = app.config.normalize, { composeValidation, composeResponseValidation } = composeValidationFactory2({ normalize, validator });
  if (hasHeaders)
    fnLiteral += adapter.headers;
  if (hasTrace)
    fnLiteral += `const id=c[ELYSIA_REQUEST_ID]
`;
  let report = createReport2({ trace: hooks.trace, addFn: (word) => {
    fnLiteral += word;
  } });
  if (fnLiteral += "try{", hasCookie) {
    let get = (name, defaultValue) => {
      let value = cookieMeta?.[name] ?? defaultValue;
      if (!value)
        return typeof defaultValue === "string" ? `${name}:"${defaultValue}",` : `${name}:${defaultValue},`;
      if (typeof value === "string")
        return `${name}:'${value}',`;
      if (value instanceof Date)
        return `${name}: new Date(${value.getTime()}),`;
      return `${name}:${value},`;
    }, options = cookieMeta ? `{secrets:${cookieMeta.secrets !== undefined ? typeof cookieMeta.secrets === "string" ? `'${cookieMeta.secrets}'` : "[" + cookieMeta.secrets.reduce((a, b) => a + `'${b}',`, "") + "]" : "undefined"},sign:${cookieMeta.sign === true ? true : cookieMeta.sign !== undefined ? "[" + cookieMeta.sign.reduce((a, b) => a + `'${b}',`, "") + "]" : "undefined"},` + get("domain") + get("expires") + get("httpOnly") + get("maxAge") + get("path", "/") + get("priority") + get("sameSite") + get("secure") + "}" : "undefined";
    if (hasHeaders)
      fnLiteral += `
c.cookie=await parseCookie(c.set,c.headers.cookie,${options})
`;
    else
      fnLiteral += `
c.cookie=await parseCookie(c.set,c.request.headers.get('cookie'),${options})
`;
  }
  if (hasQuery) {
    let destructured = [];
    if (validator.query && validator.query.schema.type === "object") {
      let properties = validator.query.schema.properties;
      if (!hasAdditionalProperties2(validator.query))
        for (let [key, _value] of Object.entries(properties)) {
          let value = _value;
          if (value && TypeBoxSymbol2.optional in value && value.type === "array" && value.items)
            value = value.items;
          let { type, anyOf } = value, isArray = type === "array" || anyOf?.some((v) => v.type === "string" && v.format === "ArrayString");
          destructured.push({ key, isArray, isNestedObjectArray: isArray && value.items?.type === "object" || !!value.items?.anyOf?.some((x) => x.type === "object" || x.type === "array"), isObject: type === "object" || anyOf?.some((v) => v.type === "string" && v.format === "ArrayString"), anyOf: !!anyOf });
        }
    }
    if (!destructured.length)
      fnLiteral += "if(c.qi===-1){c.query={}}else{c.query=parseQueryFromURL(c.url.slice(c.qi + 1))}";
    else {
      fnLiteral += `if(c.qi!==-1){let url = '&' + decodeURIComponent(c.url.slice(c.qi + 1))
`;
      let index = 0;
      for (let { key, isArray, isObject: isObject22, isNestedObjectArray, anyOf } of destructured) {
        let init2 = (index === 0 ? "let " : "") + `memory=url.indexOf('&${key}=')
let a${index}
`;
        if (isArray)
          if (fnLiteral += init2, isNestedObjectArray)
            fnLiteral += `while(memory!==-1){const start=memory+${key.length + 2}
memory=url.indexOf('&',start)
if(a${index}===undefined)
a${index}=''
else
a${index}+=','
let temp
if(memory===-1)temp=decodeURIComponent(url.slice(start).replace(/\\+|%20/g,' '))
else temp=decodeURIComponent(url.slice(start, memory).replace(/\\+|%20/g,' '))
const charCode = temp.charCodeAt(0)
if(charCode !== 91 && charCode !== 123)
temp='"'+temp+'"'
a${index} += temp
if(memory === -1)break
memory=url.indexOf('&${key}=',memory)
if(memory === -1)break}try{if(a${index}.charCodeAt(0) === 91)a${index} = JSON.parse(a${index})
else
a${index}=JSON.parse('['+a${index}+']')}catch{}
`;
          else
            fnLiteral += `while(memory!==-1){const start=memory+${key.length + 2}
memory=url.indexOf('&',start)
if(a${index}===undefined)a${index}=[]
if(memory===-1){a${index}.push(decodeURIComponent(url.slice(start)).replace(/\\+|%20/g,' '))
break}else a${index}.push(decodeURIComponent(url.slice(start, memory)).replace(/\\+|%20/g,' '))
memory=url.indexOf('&${key}=',memory)
if(memory===-1) break
}`;
        else if (isObject22)
          fnLiteral += init2 + `if(memory!==-1){const start=memory+${key.length + 2}
memory=url.indexOf('&',start)
if(memory===-1)a${index}=decodeURIComponent(url.slice(start).replace(/\\+|%20/g,' '))else a${index}=decodeURIComponent(url.slice(start,memory).replace(/\\+|%20/g,' '))if(a${index}!==undefined)try{a${index}=JSON.parse(a${index})}catch{}}`;
        else {
          if (fnLiteral += init2 + `if(memory!==-1){const start=memory+${key.length + 2}
memory=url.indexOf('&',start)
if(memory===-1)a${index}=decodeURIComponent(url.slice(start).replace(/\\+|%20/g,' '))
else{a${index}=decodeURIComponent(url.slice(start,memory).replace(/\\+|%20/g,' '))`, anyOf)
            fnLiteral += `
let deepMemory=url.indexOf('&${key}=',memory)
if(deepMemory!==-1){a${index}=[a${index}]
let first=true
while(true){const start=deepMemory+${key.length + 2}
if(first)first=false
else deepMemory = url.indexOf('&', start)
let value
if(deepMemory===-1)value=decodeURIComponent(url.slice(start).replace(/\\+|%20/g,' '))
else value=decodeURIComponent(url.slice(start, deepMemory).replace(/\\+|%20/g,' '))
const vStart=value.charCodeAt(0)
const vEnd=value.charCodeAt(value.length - 1)
if((vStart===91&&vEnd===93)||(vStart===123&&vEnd===125))
try{a${index}.push(JSON.parse(value))}catch{a${index}.push(value)}if(deepMemory===-1)break}}`;
          fnLiteral += "}}";
        }
        index++, fnLiteral += `
`;
      }
      fnLiteral += "c.query={" + destructured.map(({ key }, index2) => `'${key}':a${index2}`).join(",") + "}", fnLiteral += `} else c.query = {}
`;
    }
  }
  let isAsyncHandler = typeof handler === "function" && isAsync2(handler), saveResponse = hasTrace || hooks.afterResponse.length > 0 ? "c.response= " : "", maybeAsync = hasCookie || hasBody || isAsyncHandler || hooks.parse.length > 0 || hooks.afterHandle.some(isAsync2) || hooks.beforeHandle.some(isAsync2) || hooks.transform.some(isAsync2) || hooks.mapResponse.some(isAsync2), maybeStream = (typeof handler === "function" ? isGenerator2(handler) : false) || hooks.beforeHandle.some(isGenerator2) || hooks.afterHandle.some(isGenerator2) || hooks.transform.some(isGenerator2), hasSet = inference.cookie || inference.set || hasHeaders || hasTrace || validator.response || isHandleFn && hasDefaultHeaders || maybeStream, mapResponseContext = adapter.mapResponseContext ? `,${adapter.mapResponseContext}` : "";
  if (inference.route)
    fnLiteral += `c.route=\`${path}\`
`;
  let parseReporter = report("parse", { total: hooks.parse.length });
  if (hasBody) {
    let isOptionalBody = isOptional2(validator.body), hasBodyInference = hooks.parse.length || inference.body || validator.body;
    if (adapter.parser.declare)
      fnLiteral += adapter.parser.declare;
    fnLiteral += `
isParsing=true`;
    let parser = typeof hooks.parse === "string" ? hooks.parse : Array.isArray(hooks.parse) && hooks.parse.length === 1 ? typeof hooks.parse[0] === "string" ? hooks.parse[0] : typeof hooks.parse[0].fn === "string" ? hooks.parse[0].fn : undefined : undefined;
    if (parser && parser in defaultParsers2) {
      let reporter = report("parse", { total: hooks.parse.length });
      switch (parser) {
        case "json":
        case "application/json":
          fnLiteral += adapter.parser.json(isOptionalBody);
          break;
        case "text":
        case "text/plain":
          fnLiteral += adapter.parser.text(isOptionalBody);
          break;
        case "urlencoded":
        case "application/x-www-form-urlencoded":
          fnLiteral += adapter.parser.urlencoded(isOptionalBody);
          break;
        case "arrayBuffer":
        case "application/octet-stream":
          fnLiteral += adapter.parser.arrayBuffer(isOptionalBody);
          break;
        case "formdata":
        case "multipart/form-data":
          fnLiteral += adapter.parser.formData(isOptionalBody);
          break;
        default:
          if (parser[0] in app["~parser"])
            fnLiteral += hasHeaders ? "let contentType = c.headers['content-type']" : "let contentType = c.request.headers.get('content-type')", fnLiteral += `
if(contentType){const index=contentType.indexOf(';')
if(index!==-1)contentType=contentType.substring(0, index)}
else{contentType=''}c.contentType=contentType
`, fnLiteral += `let result=parser['${parser}'](c, contentType)
if(result instanceof Promise)result=await result
if(result instanceof ElysiaCustomStatusResponse)throw result
if(result!==undefined)c.body=result
delete c.contentType
`;
          break;
      }
      reporter.resolve();
    } else if (hasBodyInference) {
      if (fnLiteral += `
`, fnLiteral += hasHeaders ? "let contentType = c.headers['content-type']" : "let contentType = c.request.headers.get('content-type')", fnLiteral += `
if(contentType){const index=contentType.indexOf(';')
if(index!==-1)contentType=contentType.substring(0, index)}
else{contentType=''}c.contentType=contentType
`, hooks.parse.length)
        fnLiteral += `let used=false
`;
      let reporter = report("parse", { total: hooks.parse.length }), hasDefaultParser = false;
      for (let i = 0;i < hooks.parse.length; i++) {
        let name = `bo${i}`;
        if (i !== 0)
          fnLiteral += `
if(!used){`;
        if (typeof hooks.parse[i].fn === "string") {
          let endUnit = reporter.resolveChild(hooks.parse[i].fn);
          switch (hooks.parse[i].fn) {
            case "json":
            case "application/json":
              hasDefaultParser = true, fnLiteral += adapter.parser.json(isOptionalBody);
              break;
            case "text":
            case "text/plain":
              hasDefaultParser = true, fnLiteral += adapter.parser.text(isOptionalBody);
              break;
            case "urlencoded":
            case "application/x-www-form-urlencoded":
              hasDefaultParser = true, fnLiteral += adapter.parser.urlencoded(isOptionalBody);
              break;
            case "arrayBuffer":
            case "application/octet-stream":
              hasDefaultParser = true, fnLiteral += adapter.parser.arrayBuffer(isOptionalBody);
              break;
            case "formdata":
            case "multipart/form-data":
              hasDefaultParser = true, fnLiteral += adapter.parser.formData(isOptionalBody);
              break;
            default:
              fnLiteral += `${name}=parser['${hooks.parse[i].fn}'](c,contentType)
if(${name} instanceof Promise)${name}=await ${name}
if(${name}!==undefined){c.body=${name};used=true}
`;
          }
          endUnit();
        } else {
          let endUnit = reporter.resolveChild(hooks.parse[i].fn.name);
          fnLiteral += `let ${name}=parse[${i}]
${name}=${name}(c,contentType)
if(${name} instanceof Promise)${name}=await ${name}
if(${name}!==undefined){c.body=${name};used=true}`, endUnit();
        }
        if (i !== 0)
          fnLiteral += "}";
        if (hasDefaultParser)
          break;
      }
      if (reporter.resolve(), !hasDefaultParser) {
        if (hooks.parse.length)
          fnLiteral += `
if(!used){
if(!contentType) throw new ParseError()
`;
        fnLiteral += "switch(contentType){", fnLiteral += `case 'application/json':
` + adapter.parser.json(isOptionalBody) + `break
case 'text/plain':` + adapter.parser.text(isOptionalBody) + `break
case 'application/x-www-form-urlencoded':` + adapter.parser.urlencoded(isOptionalBody) + `break
case 'application/octet-stream':` + adapter.parser.arrayBuffer(isOptionalBody) + `break
case 'multipart/form-data':` + adapter.parser.formData(isOptionalBody) + `break
`;
        for (let key of Object.keys(app["~parser"]))
          fnLiteral += `case '${key}':let bo${key}=parser['${key}'](c,contentType)
if(bo${key} instanceof Promise)bo${key}=await bo${key}
if(bo${key} instanceof ElysiaCustomStatusResponse)throw result
if(bo${key}!==undefined)c.body=bo${key}
break
`;
        if (hooks.parse.length)
          fnLiteral += "}";
        fnLiteral += "}";
      }
    }
    fnLiteral += `
delete c.contentType`, fnLiteral += `
isParsing=false
`;
  }
  if (parseReporter.resolve(), hooks?.transform) {
    let reporter = report("transform", { total: hooks.transform.length });
    if (hooks.transform.length)
      fnLiteral += `let transformed
`;
    for (let i = 0;i < hooks.transform.length; i++) {
      let transform3 = hooks.transform[i], endUnit = reporter.resolveChild(transform3.fn.name);
      if (fnLiteral += isAsync2(transform3) ? `transformed=await transform[${i}](c)
` : `transformed=transform[${i}](c)
`, transform3.subType === "mapDerive")
        fnLiteral += `if(transformed instanceof ElysiaCustomStatusResponse)throw transformed
else{transformed.request=c.request
transformed.store=c.store
transformed.qi=c.qi
transformed.path=c.path
transformed.url=c.url
transformed.redirect=c.redirect
transformed.set=c.set
transformed.error=c.error
c=transformed}`;
      else
        fnLiteral += `if(transformed instanceof ElysiaCustomStatusResponse)throw transformed
else Object.assign(c,transformed)
`;
      endUnit();
    }
    reporter.resolve();
  }
  if (validator) {
    if (validator.headers) {
      if (normalize && "Clean" in validator.headers && !hasAdditionalProperties2(validator.headers))
        fnLiteral += `c.headers=validator.headers.Clean(c.headers);
`;
      if (hasProperty2("default", validator.headers))
        for (let [key, value] of Object.entries(exports_value4.Default(validator.headers.schema, {}))) {
          let parsed = typeof value === "object" ? JSON.stringify(value) : typeof value === "string" ? `'${value}'` : value;
          if (parsed !== undefined)
            fnLiteral += `c.headers['${key}']??=${parsed}
`;
        }
      if (isOptional2(validator.headers))
        fnLiteral += "if(isNotEmpty(c.headers)){";
      if (fnLiteral += "if(validator.headers.Check(c.headers) === false){" + composeValidation("headers") + "}", hasTransform2(validator.headers.schema))
        fnLiteral += `c.headers=validator.headers.Decode(c.headers)
`;
      if (isOptional2(validator.headers))
        fnLiteral += "}";
    }
    if (validator.params) {
      if (hasProperty2("default", validator.params))
        for (let [key, value] of Object.entries(exports_value4.Default(validator.params.schema, {}))) {
          let parsed = typeof value === "object" ? JSON.stringify(value) : typeof value === "string" ? `'${value}'` : value;
          if (parsed !== undefined)
            fnLiteral += `c.params['${key}']??=${parsed}
`;
        }
      if (fnLiteral += "if(validator.params.Check(c.params)===false){" + composeValidation("params") + "}", hasTransform2(validator.params.schema))
        fnLiteral += `c.params=validator.params.Decode(c.params)
`;
    }
    if (validator.query) {
      if (normalize && "Clean" in validator.query && !hasAdditionalProperties2(validator.query))
        fnLiteral += `c.query=validator.query.Clean(c.query)
`;
      if (hasProperty2("default", validator.query))
        for (let [key, value] of Object.entries(exports_value4.Default(validator.query.schema, {}))) {
          let parsed = typeof value === "object" ? JSON.stringify(value) : typeof value === "string" ? `'${value}'` : value;
          if (parsed !== undefined)
            fnLiteral += `if(c.query['${key}']===undefined)c.query['${key}']=${parsed}
`;
        }
      if (isOptional2(validator.query))
        fnLiteral += "if(isNotEmpty(c.query)){";
      if (fnLiteral += "if(validator.query.Check(c.query)===false){" + composeValidation("query") + "}", hasTransform2(validator.query.schema))
        fnLiteral += `c.query=validator.query.Decode(Object.assign({},c.query))
`;
      if (isOptional2(validator.query))
        fnLiteral += "}";
    }
    if (validator.body) {
      if (normalize && "Clean" in validator.body && !hasAdditionalProperties2(validator.body))
        fnLiteral += `c.body=validator.body.Clean(c.body)
`;
      let doesHaveTransform = hasTransform2(validator.body.schema);
      if (doesHaveTransform || isOptional2(validator.body))
        fnLiteral += `const isNotEmptyObject=c.body&&(typeof c.body==="object"&&isNotEmpty(c.body))
`;
      if (hasProperty2("default", validator.body)) {
        let value = exports_value4.Default(validator.body.schema, validator.body.schema.type === "object" ? {} : undefined), parsed = typeof value === "object" ? JSON.stringify(value) : typeof value === "string" ? `'${value}'` : value;
        if (fnLiteral += `if(validator.body.Check(c.body)===false){if(typeof c.body==='object')c.body=Object.assign(${parsed},c.body)
else c.body=${parsed}
`, isOptional2(validator.body))
          fnLiteral += "if(isNotEmptyObject&&validator.body.Check(c.body)===false){" + composeValidation("body") + "}";
        else
          fnLiteral += "if(validator.body.Check(c.body)===false){" + composeValidation("body") + "}";
        fnLiteral += "}";
      } else if (isOptional2(validator.body))
        fnLiteral += "if(isNotEmptyObject&&validator.body.Check(c.body)===false){" + composeValidation("body") + "}";
      else
        fnLiteral += "if(validator.body.Check(c.body)===false){" + composeValidation("body") + "}";
      if (doesHaveTransform)
        fnLiteral += `if(isNotEmptyObject)c.body=validator.body.Decode(c.body)
`;
    }
    if (cookieValidator && isNotEmpty2(cookieValidator?.schema?.properties ?? cookieValidator?.schema?.schema ?? {})) {
      if (fnLiteral += `const cookieValue={}
for(const [key,value] of Object.entries(c.cookie))cookieValue[key]=value.value
`, hasProperty2("default", cookieValidator))
        for (let [key, value] of Object.entries(exports_value4.Default(cookieValidator.schema, {})))
          fnLiteral += `cookieValue['${key}'] = ${typeof value === "object" ? JSON.stringify(value) : value}
`;
      if (isOptional2(validator.cookie))
        fnLiteral += "if(isNotEmpty(c.cookie)){";
      if (fnLiteral += "if(validator.cookie.Check(cookieValue)===false){" + composeValidation("cookie", "cookieValue") + "}", hasTransform2(validator.cookie.schema))
        fnLiteral += `for(const [key,value] of Object.entries(validator.cookie.Decode(cookieValue)))c.cookie[key].value=value
`;
      if (isOptional2(validator.cookie))
        fnLiteral += "}";
    }
  }
  if (hooks?.beforeHandle) {
    let reporter = report("beforeHandle", { total: hooks.beforeHandle.length }), hasResolve = false;
    for (let i = 0;i < hooks.beforeHandle.length; i++) {
      let beforeHandle = hooks.beforeHandle[i], endUnit = reporter.resolveChild(beforeHandle.fn.name), returning = hasReturn2(beforeHandle);
      if (beforeHandle.subType === "resolve" || beforeHandle.subType === "mapResolve") {
        if (!hasResolve)
          hasResolve = true, fnLiteral += `
let resolved
`;
        if (fnLiteral += isAsync2(beforeHandle) ? `resolved=await beforeHandle[${i}](c);
` : `resolved=beforeHandle[${i}](c);
`, beforeHandle.subType === "mapResolve")
          fnLiteral += `if(resolved instanceof ElysiaCustomStatusResponse)throw resolved
else{resolved.request = c.request
resolved.store = c.store
resolved.qi = c.qi
resolved.path = c.path
resolved.url = c.url
resolved.redirect = c.redirect
resolved.set = c.set
resolved.error = c.error
c = resolved}`;
        else
          fnLiteral += `if(resolved instanceof ElysiaCustomStatusResponse)throw resolved
else Object.assign(c, resolved)
`;
      } else if (!returning)
        fnLiteral += isAsync2(beforeHandle) ? `await beforeHandle[${i}](c)
` : `beforeHandle[${i}](c)
`, endUnit();
      else {
        if (fnLiteral += isAsync2(beforeHandle) ? `be=await beforeHandle[${i}](c)
` : `be=beforeHandle[${i}](c)
`, endUnit("be"), fnLiteral += "if(be!==undefined){", reporter.resolve(), hooks.afterHandle?.length) {
          report("handle", { name: isHandleFn ? handler.name : undefined }).resolve();
          let reporter2 = report("afterHandle", { total: hooks.afterHandle.length });
          for (let i2 = 0;i2 < hooks.afterHandle.length; i2++) {
            let hook = hooks.afterHandle[i2], returning2 = hasReturn2(hook), endUnit2 = reporter2.resolveChild(hook.fn.name);
            if (fnLiteral += `c.response = be
`, !returning2)
              fnLiteral += isAsync2(hook.fn) ? `await afterHandle[${i2}](c, be)
` : `afterHandle[${i2}](c, be)
`;
            else
              fnLiteral += isAsync2(hook.fn) ? `af = await afterHandle[${i2}](c)
` : `af = afterHandle[${i2}](c)
`, fnLiteral += `if(af!==undefined) c.response=be=af
`;
            endUnit2("af");
          }
          reporter2.resolve();
        }
        if (validator.response)
          fnLiteral += composeResponseValidation("be");
        let mapResponseReporter = report("mapResponse", { total: hooks.mapResponse.length });
        if (hooks.mapResponse.length) {
          fnLiteral += `c.response=be
`;
          for (let i2 = 0;i2 < hooks.mapResponse.length; i2++) {
            let mapResponse22 = hooks.mapResponse[i2], endUnit2 = mapResponseReporter.resolveChild(mapResponse22.fn.name);
            fnLiteral += `if(mr===undefined){mr=${isAsyncName2(mapResponse22) ? "await" : ""} onMapResponse[${i2}](c)
if(mr!==undefined)be=c.response=mr}`, endUnit2();
          }
        }
        mapResponseReporter.resolve(), fnLiteral += encodeCookie, fnLiteral += `return mapEarlyResponse(${saveResponse}be,c.set${mapResponseContext})}
`;
      }
    }
    reporter.resolve();
  }
  if (hooks?.afterHandle.length) {
    let handleReporter = report("handle", { name: isHandleFn ? handler.name : undefined });
    if (hooks.afterHandle.length)
      fnLiteral += isAsyncHandler ? `let r=c.response=await ${handle}
` : `let r=c.response=${handle}
`;
    else
      fnLiteral += isAsyncHandler ? `let r=await ${handle}
` : `let r=${handle}
`;
    handleReporter.resolve();
    let reporter = report("afterHandle", { total: hooks.afterHandle.length });
    for (let i = 0;i < hooks.afterHandle.length; i++) {
      let hook = hooks.afterHandle[i], returning = hasReturn2(hook), endUnit = reporter.resolveChild(hook.fn.name);
      if (!returning)
        fnLiteral += isAsync2(hook.fn) ? `await afterHandle[${i}](c)
` : `afterHandle[${i}](c)
`, endUnit();
      else if (fnLiteral += isAsync2(hook.fn) ? `af=await afterHandle[${i}](c)
` : `af=afterHandle[${i}](c)
`, endUnit("af"), validator.response)
        fnLiteral += "if(af!==undefined){", reporter.resolve(), fnLiteral += composeResponseValidation("af"), fnLiteral += "c.response=af}";
      else
        fnLiteral += "if(af!==undefined){", reporter.resolve(), fnLiteral += "c.response=af}";
    }
    if (reporter.resolve(), fnLiteral += `r=c.response
`, validator.response)
      fnLiteral += composeResponseValidation();
    fnLiteral += encodeCookie;
    let mapResponseReporter = report("mapResponse", { total: hooks.mapResponse.length });
    if (hooks.mapResponse.length)
      for (let i = 0;i < hooks.mapResponse.length; i++) {
        let mapResponse22 = hooks.mapResponse[i], endUnit = mapResponseReporter.resolveChild(mapResponse22.fn.name);
        fnLiteral += `mr=${isAsyncName2(mapResponse22) ? "await" : ""} onMapResponse[${i}](c)
if(mr!==undefined)r=c.response=mr
`, endUnit();
      }
    if (mapResponseReporter.resolve(), hasSet)
      fnLiteral += `return mapResponse(${saveResponse}r,c.set${mapResponseContext})
`;
    else
      fnLiteral += `return mapCompactResponse(${saveResponse}r${mapResponseContext})
`;
  } else {
    let handleReporter = report("handle", { name: isHandleFn ? handler.name : undefined });
    if (validator.response || hooks.mapResponse.length) {
      if (fnLiteral += isAsyncHandler ? `let r=await ${handle}
` : `let r=${handle}
`, handleReporter.resolve(), validator.response)
        fnLiteral += composeResponseValidation();
      report("afterHandle").resolve();
      let mapResponseReporter = report("mapResponse", { total: hooks.mapResponse.length });
      if (hooks.mapResponse.length) {
        fnLiteral += `
c.response=r
`;
        for (let i = 0;i < hooks.mapResponse.length; i++) {
          let mapResponse22 = hooks.mapResponse[i], endUnit = mapResponseReporter.resolveChild(mapResponse22.fn.name);
          fnLiteral += `
if(mr===undefined){mr=${isAsyncName2(mapResponse22) ? "await " : ""}onMapResponse[${i}](c)
if(mr!==undefined)r=c.response=mr}
`, endUnit();
        }
      }
      if (mapResponseReporter.resolve(), fnLiteral += encodeCookie, handler instanceof Response)
        fnLiteral += inference.set ? `if(isNotEmpty(c.set.headers)||c.set.status!==200||c.set.redirect||c.set.cookie)return mapResponse(${saveResponse}${handle}.clone(),c.set${mapResponseContext})else return ${handle}.clone()` : `return ${handle}.clone()`, fnLiteral += `
`;
      else if (hasSet)
        fnLiteral += `return mapResponse(${saveResponse}r,c.set${mapResponseContext})
`;
      else
        fnLiteral += `return mapCompactResponse(${saveResponse}r${mapResponseContext})
`;
    } else if (hasCookie || hasTrace) {
      fnLiteral += isAsyncHandler ? `let r=await ${handle}
` : `let r=${handle}
`, handleReporter.resolve(), report("afterHandle").resolve();
      let mapResponseReporter = report("mapResponse", { total: hooks.mapResponse.length });
      if (hooks.mapResponse.length) {
        fnLiteral += `c.response= r
`;
        for (let i = 0;i < hooks.mapResponse.length; i++) {
          let mapResponse22 = hooks.mapResponse[i], endUnit = mapResponseReporter.resolveChild(mapResponse22.fn.name);
          fnLiteral += `if(mr===undefined){mr=${isAsyncName2(mapResponse22) ? "await " : ""}onMapResponse[${i}](c)
if(mr!==undefined)r=c.response=mr}`, endUnit();
        }
      }
      if (mapResponseReporter.resolve(), fnLiteral += encodeCookie, hasSet)
        fnLiteral += `return mapResponse(${saveResponse}r,c.set${mapResponseContext})
`;
      else
        fnLiteral += `return mapCompactResponse(${saveResponse}r${mapResponseContext})
`;
    } else {
      handleReporter.resolve();
      let handled = isAsyncHandler ? `await ${handle}` : handle;
      if (report("afterHandle").resolve(), handler instanceof Response)
        fnLiteral += inference.set ? `if(isNotEmpty(c.set.headers)||c.set.status!==200||c.set.redirect||c.set.cookie)return mapResponse(${saveResponse}${handle}.clone(),c.set${mapResponseContext})
else return ${handle}.clone()
` : `return ${handle}.clone()
`;
      else if (hasSet)
        fnLiteral += `return mapResponse(${saveResponse}${handled},c.set${mapResponseContext})
`;
      else
        fnLiteral += `return mapCompactResponse(${saveResponse}${handled}${mapResponseContext})
`;
    }
  }
  if (fnLiteral += `
}catch(error){`, hasBody)
    fnLiteral += `if(isParsing)error=new ParseError()
`;
  if (!maybeAsync)
    fnLiteral += "return(async()=>{";
  if (fnLiteral += `const set=c.set
if(!set.status||set.status<300)set.status=error?.status||500
`, hasTrace)
    for (let i = 0;i < hooks.trace.length; i++)
      fnLiteral += `report${i}?.resolve(error);reportChild${i}?.(error)
`;
  let errorReporter = report("error", { total: hooks.error.length });
  if (hooks.error.length) {
    fnLiteral += `c.error=error
if(error instanceof TypeBoxError){c.code="VALIDATION"
c.set.status=422}else{c.code=error.code??error[ERROR_CODE]??"UNKNOWN"}let er
`;
    for (let i = 0;i < hooks.error.length; i++) {
      let endUnit = errorReporter.resolveChild(hooks.error[i].fn.name);
      if (isAsync2(hooks.error[i]))
        fnLiteral += `er=await handleErrors[${i}](c)
`;
      else
        fnLiteral += `er=handleErrors[${i}](c)
if(er instanceof Promise)er=await er
`;
      endUnit();
      let mapResponseReporter = report("mapResponse", { total: hooks.mapResponse.length });
      if (hooks.mapResponse.length)
        for (let i2 = 0;i2 < hooks.mapResponse.length; i2++) {
          let mapResponse22 = hooks.mapResponse[i2], endUnit2 = mapResponseReporter.resolveChild(mapResponse22.fn.name);
          fnLiteral += `c.response=er
er=onMapResponse[${i2}](c)
if(er instanceof Promise)er=await er
`, endUnit2();
        }
      if (mapResponseReporter.resolve(), fnLiteral += `er=mapEarlyResponse(er,set${mapResponseContext})
`, fnLiteral += "if(er){", hasTrace) {
        for (let i2 = 0;i2 < hooks.trace.length; i2++)
          fnLiteral += `report${i2}.resolve()
`;
        errorReporter.resolve();
      }
      fnLiteral += "return er}";
    }
  }
  if (errorReporter.resolve(), fnLiteral += "return handleError(c,error,true)", !maybeAsync)
    fnLiteral += "})()";
  if (fnLiteral += "}", hasAfterResponse || hasTrace) {
    if (fnLiteral += "finally{ ", !maybeAsync)
      fnLiteral += ";(async()=>{";
    let reporter = report("afterResponse", { total: hooks.afterResponse.length });
    if (hasAfterResponse)
      for (let i = 0;i < hooks.afterResponse.length; i++) {
        let endUnit = reporter.resolveChild(hooks.afterResponse[i].fn.name);
        fnLiteral += `
await afterResponse[${i}](c)
`, endUnit();
      }
    if (reporter.resolve(), !maybeAsync)
      fnLiteral += "})()";
    fnLiteral += "}";
  }
  let init = "const {handler,handleError,hooks: {transform,resolve,beforeHandle,afterHandle,mapResponse: onMapResponse,parse,error: handleErrors,afterResponse,trace: _trace},validator,utils: {mapResponse,mapCompactResponse,mapEarlyResponse,parseQuery,parseQueryFromURL,isNotEmpty},error: {NotFoundError,ValidationError,InternalServerError,ParseError},schema,definitions,ERROR_CODE,parseCookie,signCookie,decodeURIComponent,ElysiaCustomStatusResponse,ELYSIA_TRACE,ELYSIA_REQUEST_ID,parser,getServer," + (adapter.inject ? Object.keys(adapter.inject).join(",") + "," : "") + `TypeBoxError}=hooks
const trace=_trace.map(x=>typeof x==='function'?x:x.fn)
return ${maybeAsync ? "async " : ""}function handle(c){`;
  if (hooks.beforeHandle.length)
    init += `let be
`;
  if (hooks.afterHandle.length)
    init += `let af
`;
  if (hooks.mapResponse.length)
    init += `let mr
`;
  if (allowMeta)
    init += `c.schema = schema
c.defs = definitions
`;
  init += fnLiteral + "}";
  try {
    if (asManifest)
      return Function("hooks", init);
    return Function("hooks", init)({ handler, hooks: lifeCycleToFn2(hooks), validator, handleError: app.handleError, utils: { mapResponse: adapterHandler.mapResponse, mapCompactResponse: adapterHandler.mapCompactResponse, mapEarlyResponse: adapterHandler.mapEarlyResponse, parseQuery: parseQuery2, parseQueryFromURL: parseQueryFromURL2, isNotEmpty: isNotEmpty2 }, error: { NotFoundError: NotFoundError2, ValidationError: ValidationError2, InternalServerError: InternalServerError2, ParseError: ParseError4 }, schema: app.router.history, definitions: app.definitions.type, ERROR_CODE: ERROR_CODE2, parseCookie: parseCookie2, signCookie: signCookie2, decodeURIComponent: import_fast_decode_uri_component6.default, ElysiaCustomStatusResponse: ElysiaCustomStatusResponse2, ELYSIA_TRACE: ELYSIA_TRACE2, ELYSIA_REQUEST_ID: ELYSIA_REQUEST_ID2, getServer: () => app.getServer(), TypeBoxError: TypeBoxError2, parser: app["~parser"], ...adapter.inject });
  } catch (error22) {
    let debugHooks = lifeCycleToFn2(hooks);
    console.log("[Composer] failed to generate optimized handler"), console.log("---"), console.log({ handler: typeof handler === "function" ? handler.toString() : handler, instruction: init, hooks: { ...debugHooks, transform: debugHooks?.transform?.map?.((x) => x.toString()), resolve: debugHooks?.resolve?.map?.((x) => x.toString()), beforeHandle: debugHooks?.beforeHandle?.map?.((x) => x.toString()), afterHandle: debugHooks?.afterHandle?.map?.((x) => x.toString()), mapResponse: debugHooks?.mapResponse?.map?.((x) => x.toString()), parse: debugHooks?.parse?.map?.((x) => x.toString()), error: debugHooks?.error?.map?.((x) => x.toString()), afterResponse: debugHooks?.afterResponse?.map?.((x) => x.toString()), stop: debugHooks?.stop?.map?.((x) => x.toString()) }, validator, definitions: app.definitions.type, error: error22, fnLiteral }), console.log("---"), process.exit(1);
  }
};
var composeGeneralHandler2 = (app, { asManifest = false } = {}) => {
  let adapter = app["~adapter"].composeGeneralHandler, error404 = adapter.error404(!!app.event.request.length, !!app.event.error.length), fnLiteral = "", router = app.router, findDynamicRoute = "const route=router.find(r.method,p)";
  findDynamicRoute += router.http.root.ALL ? `??router.find("ALL",p)
` : `
`, findDynamicRoute += error404.code, findDynamicRoute += `
c.params=route.params
if(route.store.handler)return route.store.handler(c)
return (route.store.handler=route.store.compile())(c)
`;
  let switchMap = "";
  for (let [path, { code, all }] of Object.entries(router.static.http.map)) {
    if (switchMap += `case'${path}':`, app.config.strictPath !== true)
      switchMap += `case'${getLoosePath2(path)}':`;
    switchMap += `switch(r.method){${code}
` + (all ?? "default: break map") + "}";
  }
  let maybeAsync = app.event.request.some(isAsync2), adapterVariables = adapter.inject ? Object.keys(adapter.inject).join(",") + "," : "";
  if (fnLiteral += `
const {app,mapEarlyResponse,NotFoundError,randomId,handleError,error,redirect,ELYSIA_TRACE,ELYSIA_REQUEST_ID,` + adapterVariables + `getServer}=data
const store=app.singleton.store
const decorator=app.singleton.decorator
const staticRouter=app.router.static.http
const ht=app.router.history
const wsRouter=app.router.ws
const router=app.router.http
const trace=app.event.trace.map(x=>typeof x==='function'?x:x.fn)
const notFound=new NotFoundError()
const hoc=app.extender.higherOrderFunctions.map(x=>x.fn)
`, app.event.request.length)
    fnLiteral += `const onRequest=app.event.request.map(x=>x.fn)
`;
  if (fnLiteral += error404.declare, app.event.trace.length)
    fnLiteral += "const " + app.event.trace.map((_3, i) => `tr${i}=app.event.trace[${i}].fn`).join(",") + `
`;
  if (fnLiteral += `${maybeAsync ? "async " : ""}function map(${adapter.parameters}){`, app.event.request.length)
    fnLiteral += `let re
`;
  if (fnLiteral += adapter.createContext(app), app.event.trace.length)
    fnLiteral += "c[ELYSIA_TRACE]=[" + app.event.trace.map((_3, i) => `tr${i}(c)`).join(",") + `]
`;
  let reporter = createReport2({ trace: app.event.trace, addFn(word) {
    fnLiteral += word;
  } })("request", { total: app.event.request.length });
  if (app.event.request.length) {
    fnLiteral += "try{";
    for (let i = 0;i < app.event.request.length; i++) {
      let hook = app.event.request[i], withReturn = hasReturn2(hook), maybeAsync2 = isAsync2(hook), endUnit = reporter.resolveChild(app.event.request[i].fn.name);
      if (withReturn)
        fnLiteral += `re=mapEarlyResponse(${maybeAsync2 ? "await " : ""}onRequest[${i}](c),c.set)
`, endUnit("re"), fnLiteral += `if(re!==undefined)return re
`;
      else
        fnLiteral += `${maybeAsync2 ? "await " : ""}onRequest[${i}](c)
`, endUnit();
    }
    fnLiteral += "}catch(error){return app.handleError(c,error,false)}";
  }
  if (reporter.resolve(), fnLiteral += adapter.websocket(app), fnLiteral += `
map:switch(p){
` + switchMap + "default:break}" + findDynamicRoute + `}
`, app.extender.higherOrderFunctions.length) {
    let handler = "map";
    for (let i = 0;i < app.extender.higherOrderFunctions.length; i++)
      handler = `hoc[${i}](${handler},${adapter.parameters})`;
    fnLiteral += `return function hocMap(${adapter.parameters}){return ${handler}(${adapter.parameters})}`;
  } else
    fnLiteral += "return map";
  let handleError = composeErrorHandler2(app);
  return app.handleError = handleError, Function("data", fnLiteral)({ app, mapEarlyResponse: app["~adapter"].handler.mapEarlyResponse, NotFoundError: NotFoundError2, randomId: randomId2, handleError, error: error2, redirect: redirect2, ELYSIA_TRACE: ELYSIA_TRACE2, ELYSIA_REQUEST_ID: ELYSIA_REQUEST_ID2, getServer: () => app.getServer(), ...adapter.inject });
};
var composeErrorHandler2 = (app) => {
  let hooks = app.event, fnLiteral = "", adapter = app["~adapter"].composeError, adapterVariables = adapter.inject ? Object.keys(adapter.inject).join(",") + "," : "";
  fnLiteral += "const {app:{event:{error:onErrorContainer,afterResponse:resContainer,mapResponse:_onMapResponse,trace:_trace}},mapResponse,ERROR_CODE,ElysiaCustomStatusResponse,ELYSIA_TRACE," + adapterVariables + `ELYSIA_REQUEST_ID}=inject
`, fnLiteral += `const trace=_trace.map(x=>typeof x==='function'?x:x.fn)
const onMapResponse=[]
for(let i=0;i<_onMapResponse.length;i++)onMapResponse.push(_onMapResponse[i].fn??_onMapResponse[i])
delete _onMapResponse
const onError=onErrorContainer.map(x=>x.fn)
const res=resContainer.map(x=>x.fn)
return ${app.event.error.find(isAsync2) || app.event.mapResponse.find(isAsync2) ? "async " : ""}function(context,error,skipGlobal){`;
  let hasTrace = app.event.trace.length > 0;
  if (fnLiteral += "", hasTrace)
    fnLiteral += `const id=context[ELYSIA_REQUEST_ID]
`;
  let report = createReport2({ context: "context", trace: hooks.trace, addFn: (word) => {
    fnLiteral += word;
  } });
  if (fnLiteral += `const set=context.set
let _r
if(!context.code)context.code=error.code??error[ERROR_CODE]
if(!(context.error instanceof Error))context.error=error
if(error instanceof ElysiaCustomStatusResponse){set.status=error.status=error.code
error.message=error.response}`, adapter.declare)
    fnLiteral += adapter.declare;
  let saveResponse = hasTrace || hooks.afterResponse.length > 0 || hooks.afterResponse.length > 0 ? "context.response = " : "";
  for (let i = 0;i < app.event.error.length; i++) {
    let handler = app.event.error[i], response = `${isAsync2(handler) ? "await " : ""}onError[${i}](context)
`;
    if (fnLiteral += "if(skipGlobal!==true){", hasReturn2(handler)) {
      fnLiteral += `_r=${response}
if(_r!==undefined){if(_r instanceof Response)return mapResponse(_r,set${adapter.mapResponseContext})
if(_r instanceof ElysiaCustomStatusResponse){error.status=error.code
error.message = error.response}if(set.status===200||!set.status)set.status=error.status
`;
      let mapResponseReporter2 = report("mapResponse", { total: hooks.mapResponse.length, name: "context" });
      if (hooks.mapResponse.length)
        for (let i2 = 0;i2 < hooks.mapResponse.length; i2++) {
          let mapResponse22 = hooks.mapResponse[i2], endUnit = mapResponseReporter2.resolveChild(mapResponse22.fn.name);
          fnLiteral += `context.response=_r_r=${isAsyncName2(mapResponse22) ? "await " : ""}onMapResponse[${i2}](context)
`, endUnit();
        }
      mapResponseReporter2.resolve(), fnLiteral += `return mapResponse(${saveResponse}_r,set${adapter.mapResponseContext})}`;
    } else
      fnLiteral += response;
    fnLiteral += "}";
  }
  fnLiteral += `if(error.constructor.name==="ValidationError"||error.constructor.name==="TransformDecodeError"){if(error.error)error=error.error
set.status=error.status??422
` + adapter.validationError + "}", fnLiteral += "if(error instanceof Error){" + adapter.unknownError + "}";
  let mapResponseReporter = report("mapResponse", { total: hooks.mapResponse.length, name: "context" });
  if (fnLiteral += `
if(!context.response)context.response=error.message??error
`, hooks.mapResponse.length) {
    fnLiteral += `let mr
`;
    for (let i = 0;i < hooks.mapResponse.length; i++) {
      let mapResponse22 = hooks.mapResponse[i], endUnit = mapResponseReporter.resolveChild(mapResponse22.fn.name);
      fnLiteral += `if(mr===undefined){mr=${isAsyncName2(mapResponse22) ? "await " : ""}onMapResponse[${i}](context)
if(mr!==undefined)error=context.response=mr}`, endUnit();
    }
  }
  return mapResponseReporter.resolve(), fnLiteral += `
return mapResponse(${saveResponse}error,set${adapter.mapResponseContext})}`, Function("inject", fnLiteral)({ app, mapResponse: app["~adapter"].handler.mapResponse, ERROR_CODE: ERROR_CODE2, ElysiaCustomStatusResponse: ElysiaCustomStatusResponse2, ELYSIA_TRACE: ELYSIA_TRACE2, ELYSIA_REQUEST_ID: ELYSIA_REQUEST_ID2, ...adapter.inject });
};
var injectDefaultValues2 = (typeChecker, obj) => {
  for (let [key, keySchema] of Object.entries(typeChecker.schema.properties))
    obj[key] ??= keySchema.default;
};
var createDynamicHandler2 = (app) => {
  let { mapResponse: mapResponse22, mapEarlyResponse: mapEarlyResponse22 } = app["~adapter"].handler;
  return async (request) => {
    let url = request.url, s = url.indexOf("/", 11), qi = url.indexOf("?", s + 1), path = qi === -1 ? url.substring(s) : url.substring(s, qi), set2 = { cookie: {}, status: 200, headers: {} }, context = Object.assign({}, app.singleton.decorator, { set: set2, store: app.singleton.store, request, path, qi, redirect: redirect2 });
    try {
      for (let i = 0;i < app.event.request.length; i++) {
        let onRequest = app.event.request[i].fn, response2 = onRequest(context);
        if (response2 instanceof Promise)
          response2 = await response2;
        if (response2 = mapEarlyResponse22(response2, set2), response2)
          return context.response = response2;
      }
      let handler = app.router.dynamic.find(request.method, path) ?? app.router.dynamic.find("ALL", path);
      if (!handler)
        throw new NotFoundError2;
      let { handle, hooks, validator, content } = handler.store, body;
      if (request.method !== "GET" && request.method !== "HEAD")
        if (content)
          switch (content) {
            case "application/json":
              body = await request.json();
              break;
            case "text/plain":
              body = await request.text();
              break;
            case "application/x-www-form-urlencoded":
              body = parseQuery2(await request.text());
              break;
            case "application/octet-stream":
              body = await request.arrayBuffer();
              break;
            case "multipart/form-data":
              body = {};
              let form2 = await request.formData();
              for (let key of form2.keys()) {
                if (body[key])
                  continue;
                let value = form2.getAll(key);
                if (value.length === 1)
                  body[key] = value[0];
                else
                  body[key] = value;
              }
              break;
          }
        else {
          let contentType = request.headers.get("content-type");
          if (contentType) {
            let index = contentType.indexOf(";");
            if (index !== -1)
              contentType = contentType.slice(0, index);
            context.contentType = contentType;
            for (let i = 0;i < hooks.parse.length; i++) {
              let hook = hooks.parse[i].fn, temp = hook(context, contentType);
              if (temp instanceof Promise)
                temp = await temp;
              if (temp) {
                body = temp;
                break;
              }
            }
            if (delete context.contentType, body === undefined)
              switch (contentType) {
                case "application/json":
                  body = await request.json();
                  break;
                case "text/plain":
                  body = await request.text();
                  break;
                case "application/x-www-form-urlencoded":
                  body = parseQuery2(await request.text());
                  break;
                case "application/octet-stream":
                  body = await request.arrayBuffer();
                  break;
                case "multipart/form-data":
                  body = {};
                  let form2 = await request.formData();
                  for (let key of form2.keys()) {
                    if (body[key])
                      continue;
                    let value = form2.getAll(key);
                    if (value.length === 1)
                      body[key] = value[0];
                    else
                      body[key] = value;
                  }
                  break;
              }
          }
        }
      context.body = body, context.params = handler?.params || undefined, context.query = qi === -1 ? {} : parseQuery2(url.substring(qi + 1)), context.headers = {};
      for (let [key, value] of request.headers.entries())
        context.headers[key] = value;
      let cookieMeta = Object.assign({}, app.config?.cookie, validator?.cookie?.config), cookieHeaderValue = request.headers.get("cookie");
      context.cookie = await parseCookie2(context.set, cookieHeaderValue, cookieMeta ? { secrets: cookieMeta.secrets !== undefined ? typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets.join(",") : undefined, sign: cookieMeta.sign === true ? true : cookieMeta.sign !== undefined ? typeof cookieMeta.sign === "string" ? cookieMeta.sign : cookieMeta.sign.join(",") : undefined } : undefined);
      let headerValidator = validator?.createHeaders?.();
      if (headerValidator)
        injectDefaultValues2(headerValidator, context.headers);
      let paramsValidator = validator?.createParams?.();
      if (paramsValidator)
        injectDefaultValues2(paramsValidator, context.params);
      let queryValidator = validator?.createQuery?.();
      if (queryValidator)
        injectDefaultValues2(queryValidator, context.query);
      for (let i = 0;i < hooks.transform.length; i++) {
        let hook = hooks.transform[i], operation = hook.fn(context);
        if (hook.subType === "derive")
          if (operation instanceof Promise)
            Object.assign(context, await operation);
          else
            Object.assign(context, operation);
        else if (operation instanceof Promise)
          await operation;
      }
      if (validator) {
        if (headerValidator) {
          let _header = structuredClone(context.headers);
          for (let [key, value] of request.headers)
            _header[key] = value;
          if (validator.headers.Check(_header) === false)
            throw new ValidationError2("header", validator.headers, _header);
        } else if (validator.headers?.Decode)
          context.headers = validator.headers.Decode(context.headers);
        if (paramsValidator?.Check(context.params) === false)
          throw new ValidationError2("params", validator.params, context.params);
        else if (validator.params?.Decode)
          context.params = validator.params.Decode(context.params);
        if (queryValidator?.Check(context.query) === false)
          throw new ValidationError2("query", validator.query, context.query);
        else if (validator.query?.Decode)
          context.query = validator.query.Decode(context.query);
        if (validator.createCookie?.()) {
          let cookieValue = {};
          for (let [key, value] of Object.entries(context.cookie))
            cookieValue[key] = value.value;
          if (validator.cookie.Check(cookieValue) === false)
            throw new ValidationError2("cookie", validator.cookie, cookieValue);
          else if (validator.cookie?.Decode)
            cookieValue = validator.cookie.Decode(cookieValue);
        }
        if (validator.createBody?.()?.Check(body) === false)
          throw new ValidationError2("body", validator.body, body);
        else if (validator.body?.Decode)
          context.body = validator.body.Decode(body);
      }
      for (let i = 0;i < hooks.beforeHandle.length; i++) {
        let hook = hooks.beforeHandle[i], response2 = hook.fn(context);
        if (hook.subType === "resolve") {
          if (response2 instanceof ElysiaCustomStatusResponse2) {
            let result = mapEarlyResponse22(response2, context.set);
            if (result)
              return context.response = result;
          }
          if (response2 instanceof Promise)
            Object.assign(context, await response2);
          else
            Object.assign(context, response2);
          continue;
        } else if (response2 instanceof Promise)
          response2 = await response2;
        if (response2 !== undefined) {
          context.response = response2;
          for (let i2 = 0;i2 < hooks.afterHandle.length; i2++) {
            let newResponse = hooks.afterHandle[i2].fn(context);
            if (newResponse instanceof Promise)
              newResponse = await newResponse;
            if (newResponse)
              response2 = newResponse;
          }
          let result = mapEarlyResponse22(response2, context.set);
          if (result)
            return context.response = result;
        }
      }
      let response = typeof handle === "function" ? handle(context) : handle;
      if (response instanceof Promise)
        response = await response;
      if (!hooks.afterHandle.length) {
        let status = response instanceof ElysiaCustomStatusResponse2 ? response.code : set2.status ? typeof set2.status === "string" ? StatusMap2[set2.status] : set2.status : 200, responseValidator = validator?.createResponse?.()?.[status];
        if (responseValidator?.Check(response) === false)
          throw new ValidationError2("response", responseValidator, response);
        else if (responseValidator?.Decode)
          response = responseValidator.Decode(response);
      } else {
        context.response = response;
        for (let i = 0;i < hooks.afterHandle.length; i++) {
          let newResponse = hooks.afterHandle[i].fn(context);
          if (newResponse instanceof Promise)
            newResponse = await newResponse;
          let result = mapEarlyResponse22(newResponse, context.set);
          if (result !== undefined) {
            let responseValidator = validator?.response?.[result.status];
            if (responseValidator?.Check(result) === false)
              throw new ValidationError2("response", responseValidator, result);
            else if (responseValidator?.Decode)
              response = responseValidator.Decode(response);
            return context.response = result;
          }
        }
      }
      if (context.set.cookie && cookieMeta?.sign) {
        let secret = !cookieMeta.secrets ? undefined : typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets[0];
        if (cookieMeta.sign === true)
          for (let [key, cookie] of Object.entries(context.set.cookie))
            context.set.cookie[key].value = await signCookie2(cookie.value, "${secret}");
        else {
          let properties = validator?.cookie?.schema?.properties;
          for (let name of cookieMeta.sign) {
            if (!(name in properties))
              continue;
            if (context.set.cookie[name]?.value)
              context.set.cookie[name].value = await signCookie2(context.set.cookie[name].value, secret);
          }
        }
      }
      return mapResponse22(context.response = response, context.set);
    } catch (error22) {
      let reportedError = error22 instanceof TransformDecodeError2 && error22.error ? error22.error : error22;
      return app.handleError(context, reportedError);
    } finally {
      for (let afterResponse of app.event.afterResponse)
        await afterResponse.fn(context);
    }
  };
};
var createDynamicErrorHandler2 = (app) => {
  let { mapResponse: mapResponse22 } = app["~adapter"].handler;
  return async (context, error22) => {
    let errorContext = Object.assign(context, { error: error22, code: error22.code });
    errorContext.set = context.set;
    for (let i = 0;i < app.event.error.length; i++) {
      let response = app.event.error[i].fn(errorContext);
      if (response instanceof Promise)
        response = await response;
      if (response !== undefined && response !== null)
        return context.response = mapResponse22(response, context.set);
    }
    return new Response(typeof error22.cause === "string" ? error22.cause : error22.message, { headers: context.set.headers, status: error22.status ?? 500 });
  };
};
class Elysia2 {
  config;
  server = null;
  dependencies = {};
  _routes = {};
  _types = { Prefix: "", Singleton: {}, Definitions: {}, Metadata: {} };
  _ephemeral = {};
  _volatile = {};
  singleton = { decorator: {}, store: {}, derive: {}, resolve: {} };
  get store() {
    return this.singleton.store;
  }
  get decorator() {
    return this.singleton.decorator;
  }
  definitions = { typebox: t2.Module({}), type: {}, error: {} };
  extender = { macros: [], higherOrderFunctions: [] };
  validator = { global: null, scoped: null, local: null, getCandidate() {
    return mergeSchemaValidator2(mergeSchemaValidator2(this.global, this.scoped), this.local);
  } };
  event = { start: [], request: [], parse: [], transform: [], beforeHandle: [], afterHandle: [], mapResponse: [], afterResponse: [], trace: [], error: [], stop: [] };
  telemetry = { stack: undefined };
  router = { http: new Y2, ws: new Y2, dynamic: new Y2, static: { http: { static: {}, map: {}, all: "" }, ws: {} }, history: [] };
  routeTree = new Map;
  get routes() {
    return this.router.history;
  }
  getGlobalRoutes() {
    return this.router.history;
  }
  inference = { body: false, cookie: false, headers: false, query: false, set: false, server: false, request: false, route: false };
  getServer() {
    return this.server;
  }
  "~parser" = {};
  _promisedModules;
  get promisedModules() {
    if (!this._promisedModules)
      this._promisedModules = new PromiseGroup2;
    return this._promisedModules;
  }
  constructor(config2 = {}) {
    if (config2.tags)
      if (!config2.detail)
        config2.detail = { tags: config2.tags };
      else
        config2.detail.tags = config2.tags;
    if (config2.nativeStaticResponse === undefined)
      config2.nativeStaticResponse = true;
    if (this.config = {}, this.applyConfig(config2 ?? {}), this["~adapter"] = config2.adapter ?? (typeof Bun !== "undefined" ? BunAdapter2 : WebStandardAdapter2), config2?.analytic && (config2?.name || config2?.seed !== undefined))
      this.telemetry.stack = new Error().stack;
  }
  "~adapter";
  env(model, _env = env22) {
    if (getSchemaValidator2(model, { modules: this.definitions.typebox, dynamic: true, additionalProperties: true, coerce: true }).Check(_env) === false) {
      let error22 = new ValidationError2("env", model, _env);
      throw new Error(error22.all.map((x) => x.summary).join(`
`));
    }
    return this;
  }
  wrap(fn) {
    return this.extender.higherOrderFunctions.push({ checksum: checksum2(JSON.stringify({ name: this.config.name, seed: this.config.seed, content: fn.toString() })), fn }), this;
  }
  applyMacro(localHook) {
    if (this.extender.macros.length) {
      let manage = createMacroManager2({ globalHook: this.event, localHook }), manager = { events: { global: this.event, local: localHook }, get onParse() {
        return manage("parse");
      }, get onTransform() {
        return manage("transform");
      }, get onBeforeHandle() {
        return manage("beforeHandle");
      }, get onAfterHandle() {
        return manage("afterHandle");
      }, get mapResponse() {
        return manage("mapResponse");
      }, get onAfterResponse() {
        return manage("afterResponse");
      }, get onError() {
        return manage("error");
      } };
      for (let macro of this.extender.macros)
        traceBackMacro2(macro.fn(manager), localHook, manage);
    }
  }
  applyConfig(config2) {
    return this.config = { prefix: "", aot: env22.ELYSIA_AOT !== "false", normalize: true, ...config2, cookie: { path: "/", ...config2?.cookie }, experimental: config2?.experimental ?? {}, seed: config2?.seed === undefined ? "" : config2?.seed }, this;
  }
  get models() {
    let models = {};
    for (let name of Object.keys(this.definitions.type))
      models[name] = getSchemaValidator2(this.definitions.typebox.Import(name));
    return models.modules = this.definitions.typebox, models;
  }
  add(method, path, handle, localHook, { allowMeta = false, skipPrefix = false } = { allowMeta: false, skipPrefix: false }) {
    if (localHook = localHookToLifeCycleStore2(localHook), path !== "" && path.charCodeAt(0) !== 47)
      path = "/" + path;
    if (this.config.prefix && !skipPrefix)
      path = this.config.prefix + path;
    if (localHook?.type)
      switch (localHook.type) {
        case "text":
          localHook.type = "text/plain";
          break;
        case "json":
          localHook.type = "application/json";
          break;
        case "formdata":
          localHook.type = "multipart/form-data";
          break;
        case "urlencoded":
          localHook.type = "application/x-www-form-urlencoded";
          break;
        case "arrayBuffer":
          localHook.type = "application/octet-stream";
          break;
        default:
          break;
      }
    let models = this.definitions.type, dynamic = !this.config.aot, instanceValidator = { ...this.validator.getCandidate() }, cloned = { body: localHook?.body ?? instanceValidator?.body, headers: localHook?.headers ?? instanceValidator?.headers, params: localHook?.params ?? instanceValidator?.params, query: localHook?.query ?? instanceValidator?.query, cookie: localHook?.cookie ?? instanceValidator?.cookie, response: localHook?.response ?? instanceValidator?.response }, cookieValidator = () => cloned.cookie ? getCookieValidator2({ modules, validator: cloned.cookie, defaultConfig: this.config.cookie, config: cloned.cookie?.config ?? {}, dynamic, models }) : undefined, normalize = this.config.normalize, modules = this.definitions.typebox, validator = this.config.precompile === true || typeof this.config.precompile === "object" && this.config.precompile.schema === true ? { body: getSchemaValidator2(cloned.body, { modules, dynamic, models, normalize, additionalCoerce: coercePrimitiveRoot2() }), headers: getSchemaValidator2(cloned.headers, { modules, dynamic, models, additionalProperties: !this.config.normalize, coerce: true, additionalCoerce: stringToStructureCoercions2() }), params: getSchemaValidator2(cloned.params, { modules, dynamic, models, coerce: true, additionalCoerce: stringToStructureCoercions2() }), query: getSchemaValidator2(cloned.query, { modules, dynamic, models, normalize, coerce: true, additionalCoerce: stringToStructureCoercions2() }), cookie: cookieValidator(), response: getResponseSchemaValidator2(cloned.response, { modules, dynamic, models, normalize }) } : { createBody() {
      if (this.body)
        return this.body;
      return this.body = getSchemaValidator2(cloned.body, { modules, dynamic, models, normalize, additionalCoerce: coercePrimitiveRoot2() });
    }, createHeaders() {
      if (this.headers)
        return this.headers;
      return this.headers = getSchemaValidator2(cloned.headers, { modules, dynamic, models, additionalProperties: !normalize, coerce: true, additionalCoerce: stringToStructureCoercions2() });
    }, createParams() {
      if (this.params)
        return this.params;
      return this.params = getSchemaValidator2(cloned.params, { modules, dynamic, models, coerce: true, additionalCoerce: stringToStructureCoercions2() });
    }, createQuery() {
      if (this.query)
        return this.query;
      return this.query = getSchemaValidator2(cloned.query, { modules, dynamic, models, coerce: true, additionalCoerce: stringToStructureCoercions2() });
    }, createCookie() {
      if (this.cookie)
        return this.cookie;
      return this.cookie = cookieValidator();
    }, createResponse() {
      if (this.response)
        return this.response;
      return this.response = getResponseSchemaValidator2(cloned.response, { modules, dynamic, models, normalize });
    } };
    if (localHook = mergeHook2(localHook, instanceValidator), localHook.tags)
      if (!localHook.detail)
        localHook.detail = { tags: localHook.tags };
      else
        localHook.detail.tags = localHook.tags;
    if (isNotEmpty2(this.config.detail))
      localHook.detail = mergeDeep2(Object.assign({}, this.config.detail), localHook.detail);
    this.applyMacro(localHook);
    let hooks = mergeHook2(this.event, localHook);
    if (this.config.aot === false) {
      if (this.router.dynamic.add(method, path, { validator, hooks, content: localHook?.type, handle }), this.config.strictPath === false)
        this.router.dynamic.add(method, getLoosePath2(path), { validator, hooks, content: localHook?.type, handle });
      this.router.history.push({ method, path, composed: null, handler: handle, hooks, compile: handle });
      return;
    }
    let shouldPrecompile = this.config.precompile === true || typeof this.config.precompile === "object" && this.config.precompile.compose === true, inference = cloneInference2(this.inference), adapter = this["~adapter"].handler, staticHandler = typeof handle !== "function" && typeof adapter.createStaticHandler === "function" ? adapter.createStaticHandler(handle, hooks, this.setHeaders) : undefined, nativeStaticHandler = typeof handle !== "function" ? adapter.createNativeStaticHandler?.(handle, hooks, this.setHeaders) : undefined;
    if (this.config.nativeStaticResponse === true && nativeStaticHandler && (method === "GET" || method === "ALL"))
      this.router.static.http.static[path] = nativeStaticHandler();
    let compile = (asManifest = false) => composeHandler2({ app: this, path, method, localHook: mergeHook2(localHook), hooks, validator, handler: typeof handle !== "function" && typeof adapter.createStaticHandler !== "function" ? () => handle : handle, allowMeta, inference, asManifest });
    if (this.routeTree.has(method + path))
      for (let i = 0;i < this.router.history.length; i++) {
        let route = this.router.history[i];
        if (route.path === path && route.method === method) {
          let removed = this.router.history.splice(i, 1)[0];
          if (removed && this.routeTree.has(removed?.method + removed?.path))
            this.routeTree.delete(removed.method + removed.path);
        }
      }
    else
      this.routeTree.set(method + path, this.router.history.length);
    let history = this.router.history, index = this.router.history.length, mainHandler = shouldPrecompile ? compile() : (ctx) => (history[index].composed = compile())(ctx), isWebSocket = method === "$INTERNALWS";
    this.router.history.push({ method, path, composed: mainHandler, handler: handle, hooks, compile: () => compile(), websocket: localHook.websocket });
    let staticRouter = this.router.static.http, handler = { handler: shouldPrecompile ? mainHandler : undefined, compile };
    if (isWebSocket) {
      let loose = getLoosePath2(path);
      if (path.indexOf(":") === -1 && path.indexOf("*") === -1)
        this.router.static.ws[path] = index;
      else if (this.router.ws.add("ws", path, handler), loose)
        this.router.ws.add("ws", loose, handler);
      return;
    }
    if (path.indexOf(":") === -1 && path.indexOf("*") === -1) {
      if (!staticRouter.map[path])
        staticRouter.map[path] = { code: "" };
      let ctx = staticHandler ? "" : "c";
      if (method === "ALL")
        staticRouter.map[path].all = `default:return ht[${index}].composed(${ctx})
`;
      else
        staticRouter.map[path].code = `case '${method}':return ht[${index}].composed(${ctx})
${staticRouter.map[path].code}`;
      if (!this.config.strictPath && this.config.nativeStaticResponse === true && nativeStaticHandler && (method === "GET" || method === "ALL"))
        this.router.static.http.static[getLoosePath2(path)] = nativeStaticHandler();
    } else if (this.router.http.add(method, path, handler), !this.config.strictPath) {
      let loosePath = getLoosePath2(path);
      if (this.config.nativeStaticResponse === true && staticHandler && (method === "GET" || method === "ALL"))
        this.router.static.http.static[loosePath] = staticHandler();
      this.router.http.add(method, loosePath, handler);
    }
  }
  setHeaders;
  headers(header) {
    if (!header)
      return this;
    if (!this.setHeaders)
      this.setHeaders = {};
    return this.setHeaders = mergeDeep2(this.setHeaders, header), this;
  }
  onStart(handler) {
    return this.on("start", handler), this;
  }
  onRequest(handler) {
    return this.on("request", handler), this;
  }
  onParse(options, handler) {
    if (!handler) {
      if (typeof options === "string")
        return this.on("parse", this["~parser"][options]);
      return this.on("parse", options);
    }
    return this.on(options, "parse", handler);
  }
  parser(name, parser) {
    return this["~parser"][name] = parser, this;
  }
  onTransform(options, handler) {
    if (!handler)
      return this.on("transform", options);
    return this.on(options, "transform", handler);
  }
  resolve(optionsOrResolve, resolve) {
    if (!resolve)
      resolve = optionsOrResolve, optionsOrResolve = { as: "local" };
    let hook = { subType: "resolve", fn: resolve };
    return this.onBeforeHandle(optionsOrResolve, hook);
  }
  mapResolve(optionsOrResolve, mapper) {
    if (!mapper)
      mapper = optionsOrResolve, optionsOrResolve = { as: "local" };
    let hook = { subType: "mapResolve", fn: mapper };
    return this.onBeforeHandle(optionsOrResolve, hook);
  }
  onBeforeHandle(options, handler) {
    if (!handler)
      return this.on("beforeHandle", options);
    return this.on(options, "beforeHandle", handler);
  }
  onAfterHandle(options, handler) {
    if (!handler)
      return this.on("afterHandle", options);
    return this.on(options, "afterHandle", handler);
  }
  mapResponse(options, handler) {
    if (!handler)
      return this.on("mapResponse", options);
    return this.on(options, "mapResponse", handler);
  }
  onAfterResponse(options, handler) {
    if (!handler)
      return this.on("afterResponse", options);
    return this.on(options, "afterResponse", handler);
  }
  trace(options, handler) {
    if (!handler)
      handler = options, options = { as: "local" };
    if (!Array.isArray(handler))
      handler = [handler];
    for (let fn of handler)
      this.on(options, "trace", createTracer2(fn));
    return this;
  }
  error(name, error22) {
    switch (typeof name) {
      case "string":
        return error22.prototype[ERROR_CODE2] = name, this.definitions.error[name] = error22, this;
      case "function":
        return this.definitions.error = name(this.definitions.error), this;
    }
    for (let [code, error3] of Object.entries(name))
      error3.prototype[ERROR_CODE2] = code, this.definitions.error[code] = error3;
    return this;
  }
  onError(options, handler) {
    if (!handler)
      return this.on("error", options);
    return this.on(options, "error", handler);
  }
  onStop(handler) {
    return this.on("stop", handler), this;
  }
  on(optionsOrType, typeOrHandlers, handlers) {
    let type;
    switch (typeof optionsOrType) {
      case "string":
        type = optionsOrType, handlers = typeOrHandlers;
        break;
      case "object":
        if (type = typeOrHandlers, !Array.isArray(typeOrHandlers) && typeof typeOrHandlers === "object")
          handlers = typeOrHandlers;
        break;
    }
    if (Array.isArray(handlers))
      handlers = fnToContainer2(handlers);
    else if (typeof handlers === "function")
      handlers = [{ fn: handlers }];
    else
      handlers = [handlers];
    let handles = handlers;
    for (let handle of handles)
      if (handle.scope = typeof optionsOrType === "string" ? "local" : optionsOrType?.as ?? "local", type === "resolve" || type === "derive")
        handle.subType = type;
    if (type !== "trace")
      sucrose2({ [type]: handles.map((x) => x.fn) }, this.inference);
    for (let handle of handles) {
      let fn = asHookType2(handle, "global", { skipIfHasType: true });
      switch (type) {
        case "start":
          this.event.start.push(fn);
          break;
        case "request":
          this.event.request.push(fn);
          break;
        case "parse":
          this.event.parse.push(fn);
          break;
        case "transform":
          this.event.transform.push(fn);
          break;
        case "derive":
          this.event.transform.push(fnToContainer2(fn, "derive"));
          break;
        case "beforeHandle":
          this.event.beforeHandle.push(fn);
          break;
        case "resolve":
          this.event.beforeHandle.push(fnToContainer2(fn, "resolve"));
          break;
        case "afterHandle":
          this.event.afterHandle.push(fn);
          break;
        case "mapResponse":
          this.event.mapResponse.push(fn);
          break;
        case "afterResponse":
          this.event.afterResponse.push(fn);
          break;
        case "trace":
          this.event.trace.push(fn);
          break;
        case "error":
          this.event.error.push(fn);
          break;
        case "stop":
          this.event.stop.push(fn);
          break;
      }
    }
    return this;
  }
  propagate() {
    return promoteEvent2(this.event.parse), promoteEvent2(this.event.transform), promoteEvent2(this.event.beforeHandle), promoteEvent2(this.event.afterHandle), promoteEvent2(this.event.mapResponse), promoteEvent2(this.event.afterResponse), promoteEvent2(this.event.trace), promoteEvent2(this.event.error), this;
  }
  as(type) {
    let castType = { plugin: "scoped", scoped: "scoped", global: "global" }[type];
    if (promoteEvent2(this.event.parse, castType), promoteEvent2(this.event.transform, castType), promoteEvent2(this.event.beforeHandle, castType), promoteEvent2(this.event.afterHandle, castType), promoteEvent2(this.event.mapResponse, castType), promoteEvent2(this.event.afterResponse, castType), promoteEvent2(this.event.trace, castType), promoteEvent2(this.event.error, castType), type === "plugin")
      this.validator.scoped = mergeSchemaValidator2(this.validator.scoped, this.validator.local), this.validator.local = null;
    else if (type === "global")
      this.validator.global = mergeSchemaValidator2(this.validator.global, mergeSchemaValidator2(this.validator.scoped, this.validator.local)), this.validator.scoped = null, this.validator.local = null;
    return this;
  }
  group(prefix, schemaOrRun, run) {
    let instance = new Elysia2({ ...this.config, prefix: "" });
    instance.singleton = { ...this.singleton }, instance.definitions = { ...this.definitions }, instance.getServer = () => this.getServer(), instance.inference = cloneInference2(this.inference), instance.extender = { ...this.extender };
    let isSchema = typeof schemaOrRun === "object", sandbox = (isSchema ? run : schemaOrRun)(instance);
    if (this.singleton = mergeDeep2(this.singleton, instance.singleton), this.definitions = mergeDeep2(this.definitions, instance.definitions), sandbox.event.request.length)
      this.event.request = [...this.event.request || [], ...sandbox.event.request || []];
    if (sandbox.event.mapResponse.length)
      this.event.mapResponse = [...this.event.mapResponse || [], ...sandbox.event.mapResponse || []];
    return this.model(sandbox.definitions.type), Object.values(instance.router.history).forEach(({ method, path, handler, hooks }) => {
      if (path = (isSchema ? "" : this.config.prefix) + prefix + path, isSchema) {
        let hook = schemaOrRun, localHook = hooks;
        this.add(method, path, handler, mergeHook2(hook, { ...localHook || {}, error: !localHook.error ? sandbox.event.error : Array.isArray(localHook.error) ? [...localHook.error || {}, ...sandbox.event.error || {}] : [localHook.error, ...sandbox.event.error || {}] }));
      } else
        this.add(method, path, handler, mergeHook2(hooks, { error: sandbox.event.error }), { skipPrefix: true });
    }), this;
  }
  guard(hook, run) {
    if (!run) {
      if (typeof hook === "object") {
        this.applyMacro(hook);
        let type = hook.as ?? "local";
        if (this.validator[type] = { body: hook.body ?? this.validator[type]?.body, headers: hook.headers ?? this.validator[type]?.headers, params: hook.params ?? this.validator[type]?.params, query: hook.query ?? this.validator[type]?.query, response: hook.response ?? this.validator[type]?.response, cookie: hook.cookie ?? this.validator[type]?.cookie }, hook.parse)
          this.on({ as: type }, "parse", hook.parse);
        if (hook.transform)
          this.on({ as: type }, "transform", hook.transform);
        if (hook.derive)
          this.on({ as: type }, "derive", hook.derive);
        if (hook.beforeHandle)
          this.on({ as: type }, "beforeHandle", hook.beforeHandle);
        if (hook.resolve)
          this.on({ as: type }, "resolve", hook.resolve);
        if (hook.afterHandle)
          this.on({ as: type }, "afterHandle", hook.afterHandle);
        if (hook.mapResponse)
          this.on({ as: type }, "mapResponse", hook.mapResponse);
        if (hook.afterResponse)
          this.on({ as: type }, "afterResponse", hook.afterResponse);
        if (hook.error)
          this.on({ as: type }, "error", hook.error);
        if (hook.detail)
          if (this.config.detail)
            this.config.detail = mergeDeep2(Object.assign({}, this.config.detail), hook.detail);
          else
            this.config.detail = hook.detail;
        if (hook?.tags)
          if (!this.config.detail)
            this.config.detail = { tags: hook.tags };
          else
            this.config.detail.tags = hook.tags;
        return this;
      }
      return this.guard({}, hook);
    }
    let instance = new Elysia2({ ...this.config, prefix: "" });
    instance.singleton = { ...this.singleton }, instance.definitions = { ...this.definitions }, instance.inference = cloneInference2(this.inference), instance.extender = { ...this.extender };
    let sandbox = run(instance);
    if (this.singleton = mergeDeep2(this.singleton, instance.singleton), this.definitions = mergeDeep2(this.definitions, instance.definitions), sandbox.getServer = () => this.server, sandbox.event.request.length)
      this.event.request = [...this.event.request || [], ...sandbox.event.request || []];
    if (sandbox.event.mapResponse.length)
      this.event.mapResponse = [...this.event.mapResponse || [], ...sandbox.event.mapResponse || []];
    return this.model(sandbox.definitions.type), Object.values(instance.router.history).forEach(({ method, path, handler, hooks: localHook }) => {
      this.add(method, path, handler, mergeHook2(hook, { ...localHook || {}, error: !localHook.error ? sandbox.event.error : Array.isArray(localHook.error) ? [...localHook.error || {}, ...sandbox.event.error || []] : [localHook.error, ...sandbox.event.error || []] }));
    }), this;
  }
  use(plugin, options) {
    if (Array.isArray(plugin)) {
      let app = this;
      for (let p of plugin)
        app = app.use(p);
      return app;
    }
    if (options?.scoped)
      return this.guard({}, (app) => app.use(plugin));
    if (Array.isArray(plugin)) {
      let current = this;
      for (let p of plugin)
        current = this.use(p);
      return current;
    }
    if (plugin instanceof Promise)
      return this.promisedModules.add(plugin.then((plugin2) => {
        if (typeof plugin2 === "function")
          return plugin2(this);
        if (plugin2 instanceof Elysia2)
          return this._use(plugin2).compile();
        if (plugin2.constructor.name === "Elysia")
          return this._use(plugin2).compile();
        if (typeof plugin2.default === "function")
          return plugin2.default(this);
        if (plugin2.default instanceof Elysia2)
          return this._use(plugin2.default);
        if (plugin2.constructor.name === "Elysia")
          return this._use(plugin2.default);
        throw new Error('Invalid plugin type. Expected Elysia instance, function, or module with "default" as Elysia instance or function that returns Elysia instance.');
      }).then((x) => x.compile())), this;
    return this._use(plugin);
  }
  _use(plugin) {
    if (typeof plugin === "function") {
      let instance = plugin(this);
      if (instance instanceof Promise)
        return this.promisedModules.add(instance.then((plugin2) => {
          if (plugin2 instanceof Elysia2) {
            plugin2.getServer = () => this.getServer(), plugin2.getGlobalRoutes = () => this.getGlobalRoutes(), plugin2.model(this.definitions.type), plugin2.error(this.definitions.error);
            for (let { method, path, handler, hooks } of Object.values(plugin2.router.history))
              this.add(method, path, handler, mergeHook2(hooks, { error: plugin2.event.error }));
            return plugin2.compile(), plugin2;
          }
          if (typeof plugin2 === "function")
            return plugin2(this);
          if (typeof plugin2.default === "function")
            return plugin2.default(this);
          return this._use(plugin2);
        }).then((x) => x.compile())), this;
      return instance;
    }
    let { name, seed } = plugin.config;
    if (plugin.getServer = () => this.getServer(), plugin.getGlobalRoutes = () => this.getGlobalRoutes(), plugin.model(this.definitions.type), plugin.error(this.definitions.error), this["~parser"] = { ...plugin["~parser"], ...this["~parser"] }, this.headers(plugin.setHeaders), name) {
      if (!(name in this.dependencies))
        this.dependencies[name] = [];
      let current = seed !== undefined ? checksum2(name + JSON.stringify(seed)) : 0;
      if (!this.dependencies[name].some(({ checksum: checksum22 }) => current === checksum22))
        this.extender.macros = this.extender.macros.concat(plugin.extender.macros), this.extender.higherOrderFunctions = this.extender.higherOrderFunctions.concat(plugin.extender.higherOrderFunctions);
    } else
      this.extender.macros = this.extender.macros.concat(plugin.extender.macros), this.extender.higherOrderFunctions = this.extender.higherOrderFunctions.concat(plugin.extender.higherOrderFunctions);
    deduplicateChecksum2(this.extender.macros), deduplicateChecksum2(this.extender.higherOrderFunctions);
    let hofHashes = [];
    for (let i = 0;i < this.extender.higherOrderFunctions.length; i++) {
      let hof = this.extender.higherOrderFunctions[i];
      if (hof.checksum) {
        if (hofHashes.includes(hof.checksum))
          this.extender.higherOrderFunctions.splice(i, 1), i--;
        hofHashes.push(hof.checksum);
      }
    }
    this.inference = { body: this.inference.body || plugin.inference.body, cookie: this.inference.cookie || plugin.inference.cookie, headers: this.inference.headers || plugin.inference.headers, query: this.inference.query || plugin.inference.query, set: this.inference.set || plugin.inference.set, server: this.inference.server || plugin.inference.server, request: this.inference.request || plugin.inference.request, route: this.inference.route || plugin.inference.route }, this.decorate(plugin.singleton.decorator), this.state(plugin.singleton.store), this.model(plugin.definitions.type), this.error(plugin.definitions.error), plugin.extender.macros = this.extender.macros.concat(plugin.extender.macros);
    for (let { method, path, handler, hooks } of Object.values(plugin.router.history))
      this.add(method, path, handler, mergeHook2(hooks, { error: plugin.event.error }));
    if (name) {
      if (!(name in this.dependencies))
        this.dependencies[name] = [];
      let current = seed !== undefined ? checksum2(name + JSON.stringify(seed)) : 0;
      if (this.dependencies[name].some(({ checksum: checksum22 }) => current === checksum22))
        return this;
      this.dependencies[name].push(this.config?.analytic ? { name: plugin.config.name, seed: plugin.config.seed, checksum: current, dependencies: plugin.dependencies, stack: plugin.telemetry.stack, routes: plugin.router.history, decorators: plugin.singleton, store: plugin.singleton.store, error: plugin.definitions.error, derive: plugin.event.transform.filter((x) => x?.subType === "derive").map((x) => ({ fn: x.toString(), stack: new Error().stack ?? "" })), resolve: plugin.event.transform.filter((x) => x?.subType === "resolve").map((x) => ({ fn: x.toString(), stack: new Error().stack ?? "" })) } : { name: plugin.config.name, seed: plugin.config.seed, checksum: current, dependencies: plugin.dependencies }), this.event = mergeLifeCycle2(this.event, filterGlobalHook2(plugin.event), current);
    } else
      this.event = mergeLifeCycle2(this.event, filterGlobalHook2(plugin.event));
    return this.validator.global = mergeHook2(this.validator.global, { ...plugin.validator.global }), this.validator.local = mergeHook2(this.validator.local, { ...plugin.validator.scoped }), this;
  }
  macro(macro) {
    if (typeof macro === "function") {
      let hook = { checksum: checksum2(JSON.stringify({ name: this.config.name, seed: this.config.seed, content: macro.toString() })), fn: macro };
      this.extender.macros.push(hook);
    } else if (typeof macro === "object") {
      let hook = { checksum: checksum2(JSON.stringify({ name: this.config.name, seed: this.config.seed, content: Object.entries(macro).map(([k, v]) => `${k}+${v}`).join(",") })), fn: () => macro };
      this.extender.macros.push(hook);
    }
    return this;
  }
  mount(path, handle) {
    if (path instanceof Elysia2 || typeof path === "function" || path.length === 0 || path === "/") {
      let run = typeof path === "function" ? path : path instanceof Elysia2 ? path.compile().fetch : handle instanceof Elysia2 ? handle.compile().fetch : handle, handler2 = async ({ request, path: path2 }) => {
        if (request.method === "GET" || request.method === "HEAD" || !request.headers.get("content-type"))
          return run(new Request(replaceUrlPath2(request.url, path2 || "/"), request));
        return run(new Request(replaceUrlPath2(request.url, path2 || "/"), { ...request, body: await request.arrayBuffer() }));
      };
      return this.all("/*", handler2, { type: "none" }), this;
    }
    let length = path.length;
    if (handle instanceof Elysia2)
      handle = handle.compile().fetch;
    let handler = async ({ request, path: path2 }) => {
      if (request.method === "GET" || request.method === "HEAD" || !request.headers.get("content-type"))
        return handle(new Request(replaceUrlPath2(request.url, path2.slice(length) || "/"), request));
      return handle(new Request(replaceUrlPath2(request.url, path2.slice(length) || "/"), { ...request, body: await request.arrayBuffer() }));
    };
    return this.all(path, handler, { type: "none" }), this.all(path + (path.endsWith("/") ? "*" : "/*"), handler, { type: "none" }), this;
  }
  get(path, handler, hook) {
    return this.add("GET", path, handler, hook), this;
  }
  post(path, handler, hook) {
    return this.add("POST", path, handler, hook), this;
  }
  put(path, handler, hook) {
    return this.add("PUT", path, handler, hook), this;
  }
  patch(path, handler, hook) {
    return this.add("PATCH", path, handler, hook), this;
  }
  delete(path, handler, hook) {
    return this.add("DELETE", path, handler, hook), this;
  }
  options(path, handler, hook) {
    return this.add("OPTIONS", path, handler, hook), this;
  }
  all(path, handler, hook) {
    return this.add("ALL", path, handler, hook), this;
  }
  head(path, handler, hook) {
    return this.add("HEAD", path, handler, hook), this;
  }
  connect(path, handler, hook) {
    return this.add("CONNECT", path, handler, hook), this;
  }
  route(method, path, handler, hook) {
    return this.add(method.toUpperCase(), path, handler, hook, hook?.config), this;
  }
  ws(path, options) {
    if (this["~adapter"].ws)
      this["~adapter"].ws(this, path, options);
    else
      console.warn("Current adapter doesn't support WebSocket");
    return this;
  }
  state(options, name, value) {
    if (name === undefined)
      value = options, options = { as: "append" }, name = "";
    else if (value === undefined) {
      if (typeof options === "string")
        value = name, name = options, options = { as: "append" };
      else if (typeof options === "object")
        value = name, name = "";
    }
    let { as } = options;
    if (typeof name !== "string")
      return this;
    switch (typeof value) {
      case "object":
        if (name) {
          if (name in this.singleton.store)
            this.singleton.store[name] = mergeDeep2(this.singleton.store[name], value, { override: as === "override" });
          else
            this.singleton.store[name] = value;
          return this;
        }
        if (value === null)
          return this;
        return this.singleton.store = mergeDeep2(this.singleton.store, value, { override: as === "override" }), this;
      case "function":
        if (name) {
          if (as === "override" || !(name in this.singleton.store))
            this.singleton.store[name] = value;
        } else
          this.singleton.store = value(this.singleton.store);
        return this;
      default:
        if (as === "override" || !(name in this.singleton.store))
          this.singleton.store[name] = value;
        return this;
    }
  }
  decorate(options, name, value) {
    if (name === undefined)
      value = options, options = { as: "append" }, name = "";
    else if (value === undefined) {
      if (typeof options === "string")
        value = name, name = options, options = { as: "append" };
      else if (typeof options === "object")
        value = name, name = "";
    }
    let { as } = options;
    if (typeof name !== "string")
      return this;
    switch (typeof value) {
      case "object":
        if (name) {
          if (name in this.singleton.decorator)
            this.singleton.decorator[name] = mergeDeep2(this.singleton.decorator[name], value, { override: as === "override" });
          else
            this.singleton.decorator[name] = value;
          return this;
        }
        if (value === null)
          return this;
        return this.singleton.decorator = mergeDeep2(this.singleton.decorator, value, { override: as === "override" }), this;
      case "function":
        if (name) {
          if (as === "override" || !(name in this.singleton.decorator))
            this.singleton.decorator[name] = value;
        } else
          this.singleton.decorator = value(this.singleton.decorator);
        return this;
      default:
        if (as === "override" || !(name in this.singleton.decorator))
          this.singleton.decorator[name] = value;
        return this;
    }
  }
  derive(optionsOrTransform, transform3) {
    if (!transform3)
      transform3 = optionsOrTransform, optionsOrTransform = { as: "local" };
    let hook = { subType: "derive", fn: transform3 };
    return this.onTransform(optionsOrTransform, hook);
  }
  model(name, model) {
    let coerce = (schema) => replaceSchemaType2(schema, [{ from: t2.Number(), to: (options) => t2.Numeric(options), untilObjectFound: true }, { from: t2.Boolean(), to: (options) => t2.BooleanString(options), untilObjectFound: true }]);
    switch (typeof name) {
      case "object":
        let parsedSchemas = {};
        return Object.entries(name).forEach(([key, value]) => {
          if (!(key in this.definitions.type))
            parsedSchemas[key] = this.definitions.type[key] = coerce(value);
        }), this.definitions.typebox = t2.Module({ ...this.definitions.typebox.$defs, ...parsedSchemas }), this;
      case "function":
        let result = coerce(name(this.definitions.type));
        return this.definitions.type = result, this.definitions.typebox = t2.Module(result), this;
    }
    return this.definitions.type[name] = model, this.definitions.typebox = t2.Module({ ...this.definitions.typebox.$defs, [name]: model }), this;
  }
  mapDerive(optionsOrDerive, mapper) {
    if (!mapper)
      mapper = optionsOrDerive, optionsOrDerive = { as: "local" };
    let hook = { subType: "mapDerive", fn: mapper };
    return this.onTransform(optionsOrDerive, hook);
  }
  affix(base, type, word) {
    if (word === "")
      return this;
    let delimieter = ["_", "-", " "], capitalize = (word2) => word2[0].toUpperCase() + word2.slice(1), joinKey = base === "prefix" ? (prefix, word2) => delimieter.includes(prefix.at(-1) ?? "") ? prefix + word2 : prefix + capitalize(word2) : delimieter.includes(word.at(-1) ?? "") ? (suffix, word2) => word2 + suffix : (suffix, word2) => word2 + capitalize(suffix), remap = (type2) => {
      let store = {};
      switch (type2) {
        case "decorator":
          for (let key in this.singleton.decorator)
            store[joinKey(word, key)] = this.singleton.decorator[key];
          this.singleton.decorator = store;
          break;
        case "state":
          for (let key in this.singleton.store)
            store[joinKey(word, key)] = this.singleton.store[key];
          this.singleton.store = store;
          break;
        case "model":
          for (let key in this.definitions.type)
            store[joinKey(word, key)] = this.definitions.type[key];
          this.definitions.type = store;
          break;
        case "error":
          for (let key in this.definitions.error)
            store[joinKey(word, key)] = this.definitions.error[key];
          this.definitions.error = store;
          break;
      }
    }, types = Array.isArray(type) ? type : [type];
    for (let type2 of types.some((x) => x === "all") ? ["decorator", "state", "model", "error"] : types)
      remap(type2);
    return this;
  }
  prefix(type, word) {
    return this.affix("prefix", type, word);
  }
  suffix(type, word) {
    return this.affix("suffix", type, word);
  }
  compile() {
    if (this["~adapter"].isWebStandard) {
      if (this.fetch = this.config.aot ? composeGeneralHandler2(this) : createDynamicHandler2(this), typeof this.server?.reload === "function")
        this.server.reload({ ...this.server || {}, fetch: this.fetch });
      return this;
    }
    if (typeof this.server?.reload === "function")
      this.server.reload(this.server || {});
    return this._handle = composeGeneralHandler2(this), this;
  }
  handle = async (request) => this.fetch(request);
  fetch = (request) => {
    return (this.fetch = this.config.aot ? composeGeneralHandler2(this) : createDynamicHandler2(this))(request);
  };
  handleError = async (context, error22) => {
    return (this.handleError = this.config.aot ? composeErrorHandler2(this) : createDynamicErrorHandler2(this))(context, error22);
  };
  outerErrorHandler = (error22) => new Response(error22.message || error22.name || "Error", { status: error22?.status ?? 500 });
  listen = (options, callback) => {
    return this["~adapter"].listen(this)(options, callback), this;
  };
  stop = async (closeActiveConnections) => {
    if (!this.server)
      throw new Error("Elysia isn't running. Call `app.listen` to start the server.");
    if (this.server) {
      if (this.server.stop(closeActiveConnections), this.server = null, this.event.stop.length)
        for (let i = 0;i < this.event.stop.length; i++)
          this.event.stop[i].fn(this);
    }
  };
  get modules() {
    return Promise.all(this.promisedModules.promises);
  }
}

// node_modules/@scalar/themes/dist/presets/alternate.css2.js
var a = `/* basic theme */
:root {
  --scalar-text-decoration: underline;
  --scalar-text-decoration-hover: underline;
}
.light-mode,
.light-mode .dark-mode {
  --scalar-background-1: #f9f9f9;
  --scalar-background-2: #f1f1f1;
  --scalar-background-3: #e7e7e7;
  --scalar-background-card: #fff;

  --scalar-color-1: #2a2f45;
  --scalar-color-2: #757575;
  --scalar-color-3: #8e8e8e;

  --scalar-color-accent: var(--scalar-color-1);
  --scalar-background-accent: var(--scalar-background-3);

  --scalar-border-color: rgba(0, 0, 0, 0.1);
}
.dark-mode {
  --scalar-background-1: #131313;
  --scalar-background-2: #1d1d1d;
  --scalar-background-3: #272727;
  --scalar-background-card: #1d1d1d;

  --scalar-color-1: rgba(255, 255, 255, 0.9);
  --scalar-color-2: rgba(255, 255, 255, 0.62);
  --scalar-color-3: rgba(255, 255, 255, 0.44);

  --scalar-color-accent: var(--scalar-color-1);
  --scalar-background-accent: var(--scalar-background-3);

  --scalar-border-color: #2a2b2a;
}
/* Document Sidebar */
.light-mode .t-doc__sidebar,
.dark-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-border-color: var(--scalar-border-color);

  --scalar-sidebar-item-hover-background: var(--scalar-background-2);
  --scalar-sidebar-item-hover-color: currentColor;

  --scalar-sidebar-item-active-background: var(--scalar-background-accent);
  --scalar-sidebar-color-active: var(--scalar-color-accent);

  --scalar-sidebar-search-background: transparent;
  --scalar-sidebar-search-color: var(--scalar-color-3);
  --scalar-sidebar-search-border-color: var(--scalar-border-color);

  --scalar-sidebar-indent-border: var(--scalar-sidebar-border-color);
  --scalar-sidebar-indent-border-hover: var(--scalar-sidebar-border-color);
  --scalar-sidebar-indent-border-active: var(--scalar-sidebar-border-color);
}
/* advanced */
.light-mode .dark-mode,
.light-mode {
  --scalar-color-green: #069061;
  --scalar-color-red: #ef0006;
  --scalar-color-yellow: #edbe20;
  --scalar-color-blue: #0082d0;
  --scalar-color-orange: #fb892c;
  --scalar-color-purple: #5203d1;

  --scalar-button-1: rgba(0, 0, 0, 1);
  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);
  --scalar-button-1-color: rgba(255, 255, 255, 0.9);
}
.dark-mode {
  --scalar-color-green: #00b648;
  --scalar-color-red: #dd2f2c;
  --scalar-color-yellow: #ffc90d;
  --scalar-color-blue: #4eb3ec;
  --scalar-color-orange: #ff8d4d;
  --scalar-color-purple: #b191f9;

  --scalar-button-1: rgba(255, 255, 255, 1);
  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);
  --scalar-button-1-color: black;
}

.scalar-api-client__item,
.scalar-card,
.dark-mode .dark-mode.scalar-card {
  --scalar-background-1: var(--scalar-background-card);
  --scalar-background-2: var(--scalar-background-1);
  --scalar-background-3: var(--scalar-background-1);
}
.dark-mode .dark-mode.scalar-card {
  --scalar-background-3: var(--scalar-background-3);
}
.t-doc__sidebar {
  --scalar-color-green: var(--scalar-color-1);
  --scalar-color-red: var(--scalar-color-1);
  --scalar-color-yellow: var(--scalar-color-1);
  --scalar-color-blue: var(--scalar-color-1);
  --scalar-color-orange: var(--scalar-color-1);
  --scalar-color-purple: var(--scalar-color-1);
}
.light-mode *::selection {
  background-color: color-mix(
    in srgb,
    var(--scalar-color-blue),
    transparent 70%
  );
}
.dark-mode *::selection {
  background-color: color-mix(
    in srgb,
    var(--scalar-color-blue),
    transparent 50%
  );
}
`;

// node_modules/@scalar/themes/dist/presets/bluePlanet.css2.js
var a2 = `/* basic theme */
:root {
  --scalar-text-decoration: underline;
  --scalar-text-decoration-hover: underline;
}
.light-mode {
  --scalar-background-1: #f0f2f5;
  --scalar-background-2: #eaecf0;
  --scalar-background-3: #e0e2e6;
  --scalar-border-color: rgb(213 213 213);

  --scalar-color-1: rgb(9, 9, 11);
  --scalar-color-2: rgb(113, 113, 122);
  --scalar-color-3: rgba(25, 25, 28, 0.5);

  --scalar-color-accent: var(--scalar-color-1);
  --scalar-background-accent: #8ab4f81f;
}
.light-mode .scalar-card.dark-mode,
.dark-mode {
  --scalar-background-1: #000e23;
  --scalar-background-2: #01132e;
  --scalar-background-3: #03193b;
  --scalar-border-color: #2e394c;

  --scalar-color-1: #fafafa;
  --scalar-color-2: rgb(161, 161, 170);
  --scalar-color-3: rgba(255, 255, 255, 0.533);

  --scalar-color-accent: var(--scalar-color-1);
  --scalar-background-accent: #8ab4f81f;

  --scalar-code-language-color-supersede: var(--scalar-color-1);
}
/* Document Sidebar */
.light-mode .t-doc__sidebar,
.dark-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-border-color: var(--scalar-border-color);

  --scalar-sidebar-item-hover-background: var(--scalar-background-2);
  --scalar-sidebar-item-hover-color: currentColor;

  --scalar-sidebar-item-active-background: var(--scalar-background-3);
  --scalar-sidebar-color-active: var(--scalar-color-accent);

  --scalar-sidebar-search-background: rgba(255, 255, 255, 0.1);
  --scalar-sidebar-search-border-color: var(--scalar-border-color);
  --scalar-sidebar-search-color: var(--scalar-color-3);
  z-index: 1;
}
.light-mode .t-doc__sidebar {
  --scalar-sidebar-search-background: white;
}
/* advanced */
.light-mode {
  --scalar-color-green: #069061;
  --scalar-color-red: #ef0006;
  --scalar-color-yellow: #edbe20;
  --scalar-color-blue: #0082d0;
  --scalar-color-orange: #fb892c;
  --scalar-color-purple: #5203d1;

  --scalar-button-1: rgba(0, 0, 0, 1);
  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);
  --scalar-button-1-color: rgba(255, 255, 255, 0.9);
}
.dark-mode {
  --scalar-color-green: rgba(69, 255, 165, 0.823);
  --scalar-color-red: #ff8589;
  --scalar-color-yellow: #ffcc4d;
  --scalar-color-blue: #6bc1fe;
  --scalar-color-orange: #f98943;
  --scalar-color-purple: #b191f9;

  --scalar-button-1: rgba(255, 255, 255, 1);
  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);
  --scalar-button-1-color: black;
}
/* Custom theme */
/* Document header */
@keyframes headerbackground {
  from {
    background: transparent;
    backdrop-filter: none;
  }
  to {
    background: var(--header-background-1);
    backdrop-filter: blur(12px);
  }
}
.dark-mode h2.t-editor__heading,
.dark-mode .t-editor__page-title h1,
.dark-mode h1.section-header:not(::selection),
.dark-mode .markdown h1,
.dark-mode .markdown h2,
.dark-mode .markdown h3,
.dark-mode .markdown h4,
.dark-mode .markdown h5,
.dark-mode .markdown h6 {
  -webkit-text-fill-color: transparent;
  background-image: linear-gradient(
    to right bottom,
    rgb(255, 255, 255) 30%,
    rgba(255, 255, 255, 0.38)
  );
  -webkit-background-clip: text;
  background-clip: text;
}
/* Hero Section Flare */
.section-flare-item:nth-of-type(1) {
  --c1: #ffffff;
  --c2: #babfd8;
  --c3: #2e8bb2;
  --c4: #1a8593;
  --c5: #0a143e;
  --c6: #0a0f52;
  --c7: #2341b8;

  --solid: var(--c1), var(--c2), var(--c3), var(--c4), var(--c5), var(--c6),
    var(--c7);
  --solid-wrap: var(--solid), var(--c1);
  --trans: var(--c1), transparent, var(--c2), transparent, var(--c3),
    transparent, var(--c4), transparent, var(--c5), transparent, var(--c6),
    transparent, var(--c7);
  --trans-wrap: var(--trans), transparent, var(--c1);

  background: radial-gradient(circle, var(--trans)),
    conic-gradient(from 180deg, var(--trans-wrap)),
    radial-gradient(circle, var(--trans)), conic-gradient(var(--solid-wrap));
  width: 70vw;
  height: 700px;
  border-radius: 50%;
  filter: blur(100px);
  z-index: 0;
  right: 0;
  position: absolute;
  transform: rotate(-45deg);
  top: -300px;
  opacity: 0.3;
}
.section-flare-item:nth-of-type(3) {
  --star-color: #6b9acc;
  --star-color2: #446b8d;
  --star-color3: #3e5879;
  background-image: radial-gradient(
      2px 2px at 20px 30px,
      var(--star-color2),
      rgba(0, 0, 0, 0)
    ),
    radial-gradient(2px 2px at 40px 70px, var(--star-color), rgba(0, 0, 0, 0)),
    radial-gradient(2px 2px at 50px 160px, var(--star-color3), rgba(0, 0, 0, 0)),
    radial-gradient(2px 2px at 90px 40px, var(--star-color), rgba(0, 0, 0, 0)),
    radial-gradient(2px 2px at 130px 80px, var(--star-color), rgba(0, 0, 0, 0)),
    radial-gradient(
      2px 2px at 160px 120px,
      var(--star-color3),
      rgba(0, 0, 0, 0)
    );
  background-repeat: repeat;
  background-size: 200px 200px;
  width: 100%;
  height: 100%;
  mask-image: radial-gradient(ellipse at 100% 0%, black 40%, transparent 70%);
}
.section-flare {
  top: -150px !important;
  height: 100vh;
  background: linear-gradient(#000, var(--scalar-background-1));
  width: 100vw;
  overflow-x: hidden;
}
.light-mode .section-flare {
  display: none;
}
.light-mode .scalar-card {
  --scalar-background-1: #fff;
  --scalar-background-2: #fff;
  --scalar-background-3: #fff;
}

*::selection {
  background-color: color-mix(
    in srgb,
    var(--scalar-color-blue),
    transparent 60%
  );
}
`;

// node_modules/@scalar/themes/dist/presets/deepSpace.css2.js
var a3 = `/* basic theme */
:root {
  --scalar-text-decoration: underline;
  --scalar-text-decoration-hover: underline;
}
.light-mode {
  --scalar-color-1: rgb(9, 9, 11);
  --scalar-color-2: rgb(113, 113, 122);
  --scalar-color-3: rgba(25, 25, 28, 0.5);
  --scalar-color-accent: var(--scalar-color-1);

  --scalar-background-1: #fff;
  --scalar-background-2: #f4f4f5;
  --scalar-background-3: #e3e3e6;
  --scalar-background-accent: #8ab4f81f;

  --scalar-border-color: rgb(228, 228, 231);
  --scalar-code-language-color-supersede: var(--scalar-color-1);
}
.dark-mode {
  --scalar-color-1: #fafafa;
  --scalar-color-2: rgb(161, 161, 170);
  --scalar-color-3: rgba(255, 255, 255, 0.533);
  --scalar-color-accent: var(--scalar-color-1);

  --scalar-background-1: #09090b;
  --scalar-background-2: #18181b;
  --scalar-background-3: #2c2c30;
  --scalar-background-accent: #8ab4f81f;

  --scalar-border-color: rgba(255, 255, 255, 0.16);
  --scalar-code-language-color-supersede: var(--scalar-color-1);
}

/* Document Sidebar */
.light-mode .t-doc__sidebar,
.dark-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-border-color: var(--scalar-border-color);

  --scalar-sidebar-item-hover-color: currentColor;
  --scalar-sidebar-item-hover-background: var(--scalar-background-2);

  --scalar-sidebar-item-active-background: var(--scalar-background-3);
  --scalar-sidebar-color-active: var(--scalar-color-accent);

  --scalar-sidebar-search-background: transparent;
  --scalar-sidebar-search-border-color: var(--scalar-border-color);
  --scalar-sidebar-search-color: var(--scalar-color-3);
}
.light-mode .t-doc__sidebar {
  --scalar-sidebar-item-active-background: var(--scalar-background-2);
}
/* advanced */
.light-mode {
  --scalar-color-green: #069061;
  --scalar-color-red: #ef0006;
  --scalar-color-yellow: #edbe20;
  --scalar-color-blue: #0082d0;
  --scalar-color-orange: #fb892c;
  --scalar-color-purple: #5203d1;

  --scalar-button-1: rgba(0, 0, 0, 1);
  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);
  --scalar-button-1-color: rgba(255, 255, 255, 0.9);
}
.dark-mode {
  --scalar-color-green: rgba(69, 255, 165, 0.823);
  --scalar-color-red: #ff8589;
  --scalar-color-yellow: #ffcc4d;
  --scalar-color-blue: #6bc1fe;
  --scalar-color-orange: #f98943;
  --scalar-color-purple: #b191f9;

  --scalar-button-1: rgba(255, 255, 255, 1);
  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);
  --scalar-button-1-color: black;
}
/* Custom theme */
.dark-mode h2.t-editor__heading,
.dark-mode .t-editor__page-title h1,
.dark-mode h1.section-header:not(::selection),
.dark-mode .markdown h1,
.dark-mode .markdown h2,
.dark-mode .markdown h3,
.dark-mode .markdown h4,
.dark-mode .markdown h5,
.dark-mode .markdown h6 {
  -webkit-text-fill-color: transparent;
  background-image: linear-gradient(
    to right bottom,
    rgb(255, 255, 255) 30%,
    rgba(255, 255, 255, 0.38)
  );
  -webkit-background-clip: text;
  background-clip: text;
}
.examples .scalar-card-footer {
  --scalar-background-3: transparent;
  padding-top: 0;
}
/* Hero section flare */
.section-flare {
  width: 100vw;
  height: 550px;
  position: absolute;
}
.section-flare-item:nth-of-type(1) {
  position: absolute;
  width: 100vw;
  height: 550px;
  --stripesDark: repeating-linear-gradient(
    100deg,
    #000 0%,
    #000 7%,
    transparent 10%,
    transparent 12%,
    #000 16%
  );
  --rainbow: repeating-linear-gradient(
    100deg,
    #fff 10%,
    #fff 16%,
    #fff 22%,
    #fff 30%
  );
  background-image: var(--stripesDark), var(--rainbow);
  background-size: 300%, 200%;
  background-position:
    50% 50%,
    50% 50%;
  filter: invert(100%);
  -webkit-mask-image: radial-gradient(
    ellipse at 100% 0%,
    black 40%,
    transparent 70%
  );
  mask-image: radial-gradient(ellipse at 100% 0%, black 40%, transparent 70%);
  pointer-events: none;
  opacity: 0.07;
}
.dark-mode .section-flare-item:nth-of-type(1) {
  background-image: var(--stripesDark), var(--rainbow);
  filter: opacity(50%) saturate(200%);
  opacity: 0.25;
  height: 350px;
}
.section-flare-item:nth-of-type(1):after {
  content: '';
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  background-image: var(--stripesDark), var(--rainbow);
  background-size: 200%, 100%;
  background-attachment: fixed;
  mix-blend-mode: difference;
}
.dark-mode .section-flare:after {
  background-image: var(--stripesDark), var(--rainbow);
}
.section-flare-item:nth-of-type(2) {
  --star-color: #fff;
  --star-color2: #fff;
  --star-color3: #fff;
  width: 100%;
  height: 100%;
  position: absolute;
  background-image: radial-gradient(
      2px 2px at 20px 30px,
      var(--star-color2),
      rgba(0, 0, 0, 0)
    ),
    radial-gradient(2px 2px at 40px 70px, var(--star-color), rgba(0, 0, 0, 0)),
    radial-gradient(2px 2px at 50px 160px, var(--star-color3), rgba(0, 0, 0, 0)),
    radial-gradient(2px 2px at 90px 40px, var(--star-color), rgba(0, 0, 0, 0)),
    radial-gradient(2px 2px at 130px 80px, var(--star-color), rgba(0, 0, 0, 0)),
    radial-gradient(
      2px 2px at 160px 120px,
      var(--star-color3),
      rgba(0, 0, 0, 0)
    );
  background-repeat: repeat;
  background-size: 200px 200px;
  mask-image: radial-gradient(ellipse at 100% 0%, black 40%, transparent 70%);
  opacity: 0.2;
}
.light-mode *::selection {
  background-color: color-mix(
    in srgb,
    var(--scalar-color-blue),
    transparent 70%
  );
}
.dark-mode *::selection {
  background-color: color-mix(
    in srgb,
    var(--scalar-color-blue),
    transparent 50%
  );
}
`;

// node_modules/@scalar/themes/dist/presets/default.css2.js
var a4 = `/* basic theme */
.light-mode {
  --scalar-background-1: #fff;
  --scalar-background-2: #f6f6f6;
  --scalar-background-3: #e7e7e7;
  --scalar-background-accent: #8ab4f81f;

  --scalar-color-1: #2a2f45;
  --scalar-color-2: #757575;
  --scalar-color-3: #8e8e8e;

  --scalar-color-accent: #0099ff;
  --scalar-border-color: #dfdfdf;
}
.dark-mode {
  --scalar-background-1: #0f0f0f;
  --scalar-background-2: #1a1a1a;
  --scalar-background-3: #272727;

  --scalar-color-1: #e7e7e7;
  --scalar-color-2: #a4a4a4;
  --scalar-color-3: #797979;

  --scalar-color-accent: #3ea6ff;
  --scalar-background-accent: #3ea6ff1f;

  --scalar-border-color: #2d2d2d;
}
/* Document Sidebar */
.light-mode .t-doc__sidebar,
.dark-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-border-color: var(--scalar-border-color);

  --scalar-sidebar-item-hover-background: var(--scalar-background-2);
  --scalar-sidebar-item-hover-color: currentColor;

  --scalar-sidebar-item-active-background: var(--scalar-background-2);
  --scalar-sidebar-color-active: var(--scalar-color-1);

  --scalar-sidebar-search-background: transparent;
  --scalar-sidebar-search-color: var(--scalar-color-3);
  --scalar-sidebar-search-border-color: var(--scalar-border-color);
}
/* advanced */
.light-mode {
  --scalar-color-green: #069061;
  --scalar-color-red: #ef0006;
  --scalar-color-yellow: #edbe20;
  --scalar-color-blue: #0082d0;
  --scalar-color-orange: #fb892c;
  --scalar-color-purple: #5203d1;

  --scalar-button-1: rgba(0, 0, 0, 1);
  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);
  --scalar-button-1-color: rgba(255, 255, 255, 0.9);
}
.dark-mode {
  --scalar-color-green: #00b648;
  --scalar-color-red: #dc1b19;
  --scalar-color-yellow: #ffc90d;
  --scalar-color-blue: #4eb3ec;
  --scalar-color-orange: #ff8d4d;
  --scalar-color-purple: #b191f9;

  --scalar-button-1: rgba(255, 255, 255, 1);
  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);
  --scalar-button-1-color: black;
}
`;

// node_modules/@scalar/themes/dist/presets/elysiajs.css2.js
var a5 = `.light-mode {
  --scalar-color-1: #2a2f45;
  --scalar-color-2: #757575;
  --scalar-color-3: #8e8e8e;
  --scalar-color-accent: #f06292;

  --scalar-background-1: #fff;
  --scalar-background-2: #f6f6f6;
  --scalar-background-3: #e7e7e7;

  --scalar-border-color: rgba(0, 0, 0, 0.1);
}
.dark-mode {
  --scalar-color-1: rgba(255, 255, 255, 0.9);
  --scalar-color-2: rgba(156, 163, 175, 1);
  --scalar-color-3: rgba(255, 255, 255, 0.44);
  --scalar-color-accent: #f06292;

  --scalar-background-1: #111728;
  --scalar-background-2: #1e293b;
  --scalar-background-3: #334155;
  --scalar-background-accent: #f062921f;

  --scalar-border-color: rgba(255, 255, 255, 0.1);
}

/* Document Sidebar */
.light-mode .t-doc__sidebar,
.dark-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-border-color: var(--scalar-border-color);

  --scalar-sidebar-item-hover-background: var(--scalar-background-2);
  --scalar-sidebar-item-hover-color: currentColor;

  --scalar-sidebar-item-active-background: #f062921f;
  --scalar-sidebar-color-active: var(--scalar-color-accent);

  --scalar-sidebar-search-background: transparent;
  --scalar-sidebar-search-color: var(--scalar-color-3);
  --scalar-sidebar-search-border-color: var(--scalar-border-color);
}

/* advanced */
.light-mode {
  --scalar-button-1: rgb(49 53 56);
  --scalar-button-1-color: #fff;
  --scalar-button-1-hover: rgb(28 31 33);

  --scalar-color-green: #069061;
  --scalar-color-red: #ef0006;
  --scalar-color-yellow: #edbe20;
  --scalar-color-blue: #0082d0;
  --scalar-color-orange: #fb892c;
  --scalar-color-purple: #5203d1;

  --scalar-scrollbar-color: rgba(0, 0, 0, 0.18);
  --scalar-scrollbar-color-active: rgba(0, 0, 0, 0.36);
}
.dark-mode {
  --scalar-button-1: #f6f6f6;
  --scalar-button-1-color: #000;
  --scalar-button-1-hover: #e7e7e7;

  --scalar-color-green: #a3ffa9;
  --scalar-color-red: #ffa3a3;
  --scalar-color-yellow: #fffca3;
  --scalar-color-blue: #a5d6ff;
  --scalar-color-orange: #e2ae83;
  --scalar-color-purple: #d2a8ff;

  --scalar-scrollbar-color: rgba(255, 255, 255, 0.24);
  --scalar-scrollbar-color-active: rgba(255, 255, 255, 0.48);
}
.section-flare {
  width: 100%;
  height: 400px;
  position: absolute;
}
.section-flare-item:first-of-type:before {
  content: '';
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  --stripes: repeating-linear-gradient(
    100deg,
    #fff 0%,
    #fff 0%,
    transparent 2%,
    transparent 12%,
    #fff 17%
  );
  --stripesDark: repeating-linear-gradient(
    100deg,
    #000 0%,
    #000 0%,
    transparent 10%,
    transparent 12%,
    #000 17%
  );
  --rainbow: repeating-linear-gradient(
    100deg,
    #60a5fa 10%,
    #e879f9 16%,
    #5eead4 22%,
    #60a5fa 30%
  );
  contain: strict;
  contain-intrinsic-size: 100vw 40vh;
  background-image: var(--stripesDark), var(--rainbow);
  background-size: 300%, 200%;
  background-position:
    50% 50%,
    50% 50%;
  filter: opacity(20%) saturate(200%);
  -webkit-mask-image: radial-gradient(
    ellipse at 100% 0%,
    black 40%,
    transparent 70%
  );
  mask-image: radial-gradient(ellipse at 100% 0%, black 40%, transparent 70%);
  pointer-events: none;
}
.section-flare-item:first-of-type:after {
  content: '';
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  background-image: var(--stripes), var(--rainbow);
  background-size: 200%, 100%;
  background-attachment: fixed;
  mix-blend-mode: difference;
  background-image: var(--stripesDark), var(--rainbow);
  pointer-events: none;
}
.light-mode .section-flare-item:first-of-type:after,
.light-mode .section-flare-item:first-of-type:before {
  background-image: var(--stripes), var(--rainbow);
  filter: opacity(4%) saturate(200%);
}
`;

// node_modules/@scalar/themes/dist/presets/fastify.css2.js
var a6 = `.light-mode {
  color-scheme: light;
  --scalar-color-1: #1c1e21;
  --scalar-color-2: #757575;
  --scalar-color-3: #8e8e8e;
  --scalar-color-disabled: #b4b1b1;
  --scalar-color-ghost: #a7a7a7;
  --scalar-color-accent: #2f8555;
  --scalar-background-1: #fff;
  --scalar-background-2: #f5f5f5;
  --scalar-background-3: #ededed;
  --scalar-background-4: rgba(0, 0, 0, 0.06);
  --scalar-background-accent: #2f85551f;

  --scalar-border-color: rgba(0, 0, 0, 0.1);
  --scalar-scrollbar-color: rgba(0, 0, 0, 0.18);
  --scalar-scrollbar-color-active: rgba(0, 0, 0, 0.36);
  --scalar-lifted-brightness: 1;
  --scalar-backdrop-brightness: 1;

  --scalar-shadow-1: 0 1px 3px 0 rgba(0, 0, 0, 0.11);
  --scalar-shadow-2: rgba(0, 0, 0, 0.08) 0px 13px 20px 0px,
    rgba(0, 0, 0, 0.08) 0px 3px 8px 0px, #eeeeed 0px 0 0 1px;

  --scalar-button-1: rgb(49 53 56);
  --scalar-button-1-color: #fff;
  --scalar-button-1-hover: rgb(28 31 33);

  --scalar-color-green: #007300;
  --scalar-color-red: #af272b;
  --scalar-color-yellow: #b38200;
  --scalar-color-blue: #3b8ba5;
  --scalar-color-orange: #fb892c;
  --scalar-color-purple: #5203d1;
}

.dark-mode {
  color-scheme: dark;
  --scalar-color-1: rgba(255, 255, 255, 0.9);
  --scalar-color-2: rgba(255, 255, 255, 0.62);
  --scalar-color-3: rgba(255, 255, 255, 0.44);
  --scalar-color-disabled: rgba(255, 255, 255, 0.34);
  --scalar-color-ghost: rgba(255, 255, 255, 0.26);
  --scalar-color-accent: #27c2a0;
  --scalar-background-1: #1b1b1d;
  --scalar-background-2: #242526;
  --scalar-background-3: #3b3b3b;
  --scalar-background-4: rgba(255, 255, 255, 0.06);
  --scalar-background-accent: #27c2a01f;

  --scalar-border-color: rgba(255, 255, 255, 0.1);
  --scalar-scrollbar-color: rgba(255, 255, 255, 0.24);
  --scalar-scrollbar-color-active: rgba(255, 255, 255, 0.48);
  --scalar-lifted-brightness: 1.45;
  --scalar-backdrop-brightness: 0.5;

  --scalar-shadow-1: 0 1px 3px 0 rgb(0, 0, 0, 0.1);
  --scalar-shadow-2: rgba(15, 15, 15, 0.2) 0px 3px 6px,
    rgba(15, 15, 15, 0.4) 0px 9px 24px, 0 0 0 1px rgba(255, 255, 255, 0.1);

  --scalar-button-1: #f6f6f6;
  --scalar-button-1-color: #000;
  --scalar-button-1-hover: #e7e7e7;

  --scalar-color-green: #26b226;
  --scalar-color-red: #fb565b;
  --scalar-color-yellow: #ffc426;
  --scalar-color-blue: #6ecfef;
  --scalar-color-orange: #ff8d4d;
  --scalar-color-purple: #b191f9;
}
`;

// node_modules/@scalar/themes/dist/presets/kepler.css2.js
var a7 = `/* basic theme */
.light-mode {
  --scalar-color-1: #2a2f45;
  --scalar-color-2: #757575;
  --scalar-color-3: #8e8e8e;
  --scalar-color-accent: #7070ff;

  --scalar-background-1: #fff;
  --scalar-background-2: #f6f6f6;
  --scalar-background-3: #e7e7e7;
  --scalar-background-accent: #7070ff1f;

  --scalar-border-color: rgba(0, 0, 0, 0.1);

  --scalar-code-language-color-supersede: var(--scalar-color-3);
}
.dark-mode {
  --scalar-color-1: #f7f8f8;
  --scalar-color-2: rgb(180, 188, 208);
  --scalar-color-3: #b4bcd099;
  --scalar-color-accent: #828fff;

  --scalar-background-1: #000212;
  --scalar-background-2: #0d0f1e;
  --scalar-background-3: #232533;
  --scalar-background-accent: #8ab4f81f;

  --scalar-border-color: #313245;
  --scalar-code-language-color-supersede: var(--scalar-color-3);
}
/* Document Sidebar */
.light-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-item-hover-color: currentColor;
  --scalar-sidebar-item-hover-background: var(--scalar-background-2);
  --scalar-sidebar-item-active-background: var(--scalar-background-accent);
  --scalar-sidebar-border-color: var(--scalar-border-color);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-color-active: var(--scalar-color-accent);
  --scalar-sidebar-search-background: rgba(0, 0, 0, 0.05);
  --scalar-sidebar-search-border-color: 1px solid rgba(0, 0, 0, 0.05);
  --scalar-sidebar-search-color: var(--scalar-color-3);
  --scalar-background-2: rgba(0, 0, 0, 0.03);
}
.dark-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-item-hover-color: currentColor;
  --scalar-sidebar-item-hover-background: var(--scalar-background-2);
  --scalar-sidebar-item-active-background: rgba(255, 255, 255, 0.1);
  --scalar-sidebar-border-color: var(--scalar-border-color);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-color-active: var(--scalar-color-accent);
  --scalar-sidebar-search-background: rgba(255, 255, 255, 0.1);
  --scalar-sidebar-search-border-color: 1px solid rgba(255, 255, 255, 0.05);
  --scalar-sidebar-search-color: var(--scalar-color-3);
}
/* advanced */
.light-mode {
  --scalar-color-green: #069061;
  --scalar-color-red: #ef0006;
  --scalar-color-yellow: #edbe20;
  --scalar-color-blue: #0082d0;
  --scalar-color-orange: #fb892c;
  --scalar-color-purple: #5203d1;

  --scalar-button-1: rgba(0, 0, 0, 1);
  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);
  --scalar-button-1-color: rgba(255, 255, 255, 0.9);
}
.dark-mode {
  --scalar-color-green: #00b648;
  --scalar-color-red: #dc1b19;
  --scalar-color-yellow: #ffc90d;
  --scalar-color-blue: #4eb3ec;
  --scalar-color-orange: #ff8d4d;
  --scalar-color-purple: #b191f9;

  --scalar-button-1: rgba(255, 255, 255, 1);
  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);
  --scalar-button-1-color: black;
}
/* Custom Theme */
.dark-mode h2.t-editor__heading,
.dark-mode .t-editor__page-title h1,
.dark-mode h1.section-header:not(::selection),
.dark-mode .markdown h1,
.dark-mode .markdown h2,
.dark-mode .markdown h3,
.dark-mode .markdown h4,
.dark-mode .markdown h5,
.dark-mode .markdown h6 {
  -webkit-text-fill-color: transparent;
  background-image: linear-gradient(
    to right bottom,
    rgb(255, 255, 255) 30%,
    rgba(255, 255, 255, 0.38)
  );
  -webkit-background-clip: text;
  background-clip: text;
}
.sidebar-search {
  backdrop-filter: blur(12px);
}
@keyframes headerbackground {
  from {
    background: transparent;
    backdrop-filter: none;
  }
  to {
    background: var(--header-background-1);
    backdrop-filter: blur(12px);
  }
}
.dark-mode .scalar-card {
  background: rgba(255, 255, 255, 0.05) !important;
}
.dark-mode .scalar-card * {
  --scalar-background-2: transparent !important;
  --scalar-background-1: transparent !important;
}
.light-mode .dark-mode.scalar-card *,
.light-mode .dark-mode.scalar-card {
  --scalar-background-1: #0d0f1e !important;
  --scalar-background-2: #0d0f1e !important;
  --scalar-background-3: #191b29 !important;
}
.light-mode .dark-mode.scalar-card {
  background: #191b29 !important;
}
.badge {
  box-shadow: 0 0 0 1px var(--scalar-border-color);
  margin-right: 6px;
}

.table-row.required-parameter .table-row-item:nth-of-type(2):after {
  background: transparent;
  box-shadow: none;
}
/* Hero Section Flare */
.section-flare {
  width: 100vw;
  background: radial-gradient(
    ellipse 80% 50% at 50% -20%,
    rgba(120, 119, 198, 0.3),
    transparent
  );
  height: 100vh;
}
.light-mode *::selection {
  background-color: color-mix(
    in srgb,
    var(--scalar-color-accent),
    transparent 70%
  );
}
.dark-mode *::selection {
  background-color: color-mix(
    in srgb,
    var(--scalar-color-accent),
    transparent 50%
  );
}
`;

// node_modules/@scalar/themes/dist/presets/mars.css2.js
var a8 = `/* basic theme */
:root {
  --scalar-text-decoration: underline;
  --scalar-text-decoration-hover: underline;
}
.light-mode {
  --scalar-background-1: #f9f6f0;
  --scalar-background-2: #f2efe8;
  --scalar-background-3: #e9e7e2;
  --scalar-border-color: rgba(203, 165, 156, 0.6);

  --scalar-color-1: #c75549;
  --scalar-color-2: #c75549;
  --scalar-color-3: #c75549;

  --scalar-color-accent: #c75549;
  --scalar-background-accent: #dcbfa81f;

  --scalar-code-language-color-supersede: var(--scalar-color-1);
}
.dark-mode {
  --scalar-background-1: #140507;
  --scalar-background-2: #20090c;
  --scalar-background-3: #321116;
  --scalar-border-color: #3c3031;

  --scalar-color-1: rgba(255, 255, 255, 0.9);
  --scalar-color-2: rgba(255, 255, 255, 0.62);
  --scalar-color-3: rgba(255, 255, 255, 0.44);

  --scalar-color-accent: rgba(255, 255, 255, 0.9);
  --scalar-background-accent: #441313;

  --scalar-code-language-color-supersede: var(--scalar-color-1);
}

/* Document Sidebar */
.light-mode .t-doc__sidebar,
.dark-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-border-color: var(--scalar-border-color);

  --scalar-sidebar-item-hover-color: currentColor;
  --scalar-sidebar-item-hover-background: var(--scalar-background-2);

  --scalar-sidebar-item-active-background: var(--scalar-background-3);
  --scalar-sidebar-color-active: var(--scalar-color-accent);

  --scalar-sidebar-search-background: rgba(255, 255, 255, 0.1);
  --scalar-sidebar-search-color: var(--scalar-color-3);
  --scalar-sidebar-search-border-color: var(--scalar-border-color);
  z-index: 1;
}
/* advanced */
.light-mode {
  --scalar-color-green: #09533a;
  --scalar-color-red: #aa181d;
  --scalar-color-yellow: #ab8d2b;
  --scalar-color-blue: #19689a;
  --scalar-color-orange: #b26c34;
  --scalar-color-purple: #4c2191;

  --scalar-button-1: rgba(0, 0, 0, 1);
  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);
  --scalar-button-1-color: rgba(255, 255, 255, 0.9);
}
.dark-mode {
  --scalar-color-green: rgba(69, 255, 165, 0.823);
  --scalar-color-red: #ff8589;
  --scalar-color-yellow: #ffcc4d;
  --scalar-color-blue: #6bc1fe;
  --scalar-color-orange: #f98943;
  --scalar-color-purple: #b191f9;

  --scalar-button-1: rgba(255, 255, 255, 1);
  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);
  --scalar-button-1-color: black;
}
/* Custom Theme */
.dark-mode h2.t-editor__heading,
.dark-mode .t-editor__page-title h1,
.dark-mode h1.section-header:not(::selection),
.dark-mode .markdown h1,
.dark-mode .markdown h2,
.dark-mode .markdown h3,
.dark-mode .markdown h4,
.dark-mode .markdown h5,
.dark-mode .markdown h6 {
  -webkit-text-fill-color: transparent;
  background-image: linear-gradient(
    to right bottom,
    rgb(255, 255, 255) 30%,
    rgba(255, 255, 255, 0.38)
  );
  -webkit-background-clip: text;
  background-clip: text;
}
.light-mode .t-doc__sidebar {
  --scalar-sidebar-search-background: white;
}
.examples .scalar-card-footer {
  --scalar-background-3: transparent;
  padding-top: 0;
}
/* Hero section flare */
.section-flare {
  overflow-x: hidden;
  height: 100vh;
  left: initial;
}
.section-flare-item:nth-of-type(1) {
  background: #d25019;
  position: relative;
  top: -150px;
  right: -400px;
  width: 80vw;
  height: 500px;
  margin-top: -150px;
  border-radius: 50%;
  filter: blur(100px);
  z-index: 0;
}
.light-mode .section-flare {
  display: none;
}
*::selection {
  background-color: color-mix(
    in srgb,
    var(--scalar-color-red),
    transparent 75%
  );
}
`;

// node_modules/@scalar/themes/dist/presets/moon.css2.js
var a9 = `.light-mode {
  color-scheme: light;
  --scalar-color-1: #000000;
  --scalar-color-2: #000000;
  --scalar-color-3: #000000;
  --scalar-color-accent: #645b0f;
  --scalar-background-1: #ccc9b3;
  --scalar-background-2: #c2bfaa;
  --scalar-background-3: #b8b5a1;
  --scalar-background-accent: #000000;

  --scalar-border-color: rgba(0, 0, 0, 0.2);
  --scalar-scrollbar-color: rgba(0, 0, 0, 0.18);
  --scalar-scrollbar-color-active: rgba(0, 0, 0, 0.36);
  --scalar-lifted-brightness: 1;
  --scalar-backdrop-brightness: 1;

  --scalar-shadow-1: 0 1px 3px 0 rgba(0, 0, 0, 0.11);
  --scalar-shadow-2: rgba(0, 0, 0, 0.08) 0px 13px 20px 0px,
    rgba(0, 0, 0, 0.08) 0px 3px 8px 0px, var(--scalar-border-color) 0px 0 0 1px;

  --scalar-button-1: rgb(49 53 56);
  --scalar-button-1-color: #fff;
  --scalar-button-1-hover: rgb(28 31 33);

  --scalar-color-red: #b91c1c;
  --scalar-color-orange: #a16207;
  --scalar-color-green: #047857;
  --scalar-color-blue: #1d4ed8;
  --scalar-color-orange: #c2410c;
  --scalar-color-purple: #6d28d9;
}

.dark-mode {
  color-scheme: dark;
  --scalar-color-1: #fffef3;
  --scalar-color-2: #fffef3;
  --scalar-color-3: #fffef3;
  --scalar-color-accent: #c3b531;
  --scalar-background-1: #313332;
  --scalar-background-2: #393b3a;
  --scalar-background-3: #414342;
  --scalar-background-accent: #fffef3;

  --scalar-border-color: #505452;
  --scalar-scrollbar-color: rgba(255, 255, 255, 0.24);
  --scalar-scrollbar-color-active: rgba(255, 255, 255, 0.48);
  --scalar-lifted-brightness: 1.45;
  --scalar-backdrop-brightness: 0.5;

  --scalar-shadow-1: 0 1px 3px 0 rgba(0, 0, 0, 0.11);
  --scalar-shadow-2: rgba(15, 15, 15, 0.2) 0px 3px 6px,
    rgba(15, 15, 15, 0.4) 0px 9px 24px, 0 0 0 1px rgba(255, 255, 255, 0.1);

  --scalar-button-1: #f6f6f6;
  --scalar-button-1-color: #000;
  --scalar-button-1-hover: #e7e7e7;

  --scalar-color-green: #00b648;
  --scalar-color-red: #dc1b19;
  --scalar-color-yellow: #ffc90d;
  --scalar-color-blue: #4eb3ec;
  --scalar-color-orange: #ff8d4d;
  --scalar-color-purple: #b191f9;
}

/* Sidebar */
.light-mode .t-doc__sidebar,
.dark-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-border-color: var(--scalar-border-color);

  --scalar-sidebar-item-hover-background: var(--scalar-background-2);
  --scalar-sidebar-item-hover-color: currentColor;

  --scalar-sidebar-item-active-background: var(--scalar-background-3);
  --scalar-sidebar-color-active: var(--scalar-color-1);

  --scalar-sidebar-search-background: transparent;
  --scalar-sidebar-search-color: var(--scalar-color-3);
  --scalar-sidebar-search-border-color: var(--scalar-border-color);
}
*::selection {
  background-color: color-mix(
    in srgb,
    var(--scalar-color-accent),
    transparent 80%
  );
}
`;

// node_modules/@scalar/themes/dist/presets/purple.css2.js
var a10 = `/* basic theme */
.light-mode {
  --scalar-background-1: #fff;
  --scalar-background-2: #f5f6f8;
  --scalar-background-3: #eceef1;

  --scalar-color-1: #2a2f45;
  --scalar-color-2: #757575;
  --scalar-color-3: #8e8e8e;

  --scalar-color-accent: #5469d4;
  --scalar-background-accent: #5469d41f;

  --scalar-border-color: rgba(215, 215, 206, 0.68);
}
.dark-mode {
  --scalar-background-1: #15171c;
  --scalar-background-2: #1c1e24;
  --scalar-background-3: #22252b;

  --scalar-color-1: #fafafa;
  --scalar-color-2: #c9ced8;
  --scalar-color-3: #8c99ad;

  --scalar-color-accent: #5469d4;
  --scalar-background-accent: #5469d41f;

  --scalar-border-color: #3f4145;
}
/* Document Sidebar */
.light-mode .t-doc__sidebar,
.dark-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-border-color: var(--scalar-border-color);

  --scalar-sidebar-item-hover-color: currentColor;
  --scalar-sidebar-item-hover-background: var(--scalar-background-3);

  --scalar-sidebar-item-active-background: var(--scalar-background-accent);
  --scalar-sidebar-color-active: var(--scalar-color-accent);

  --scalar-sidebar-search-background: var(--scalar-background-1);
  --scalar-sidebar-search-color: var(--scalar-color-3);
  --scalar-sidebar-search-border-color: var(--scalar-border-color);
}

/* advanced */
.light-mode {
  --scalar-color-green: #17803d;
  --scalar-color-red: #e10909;
  --scalar-color-yellow: #edbe20;
  --scalar-color-blue: #1763a6;
  --scalar-color-orange: #e25b09;
  --scalar-color-purple: #5c3993;

  --scalar-button-1: rgba(0, 0, 0, 1);
  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);
  --scalar-button-1-color: rgba(255, 255, 255, 0.9);
}
.dark-mode {
  --scalar-color-green: #30a159;
  --scalar-color-red: #dc1b19;
  --scalar-color-yellow: #eec644;
  --scalar-color-blue: #2b7abf;
  --scalar-color-orange: #f07528;
  --scalar-color-purple: #7a59b1;

  --scalar-button-1: rgba(255, 255, 255, 1);
  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);
  --scalar-button-1-color: black;
}
.light-mode *::selection {
  background-color: color-mix(
    in srgb,
    var(--scalar-color-accent),
    transparent 70%
  );
}
.dark-mode *::selection {
  background-color: color-mix(
    in srgb,
    var(--scalar-color-accent),
    transparent 50%
  );
}
`;

// node_modules/@scalar/themes/dist/presets/saturn.css2.js
var a11 = `/* basic theme */
.light-mode {
  --scalar-background-1: #f3f3ee;
  --scalar-background-2: #e8e8e3;
  --scalar-background-3: #e4e4df;
  --scalar-border-color: rgba(215, 215, 206, 0.85);

  --scalar-color-1: #2a2f45;
  --scalar-color-2: #757575;
  --scalar-color-3: #8e8e8e;

  --scalar-color-accent: #1763a6;
  --scalar-background-accent: #1f648e1f;
}
.dark-mode {
  --scalar-background-1: #09090b;
  --scalar-background-2: #18181b;
  --scalar-background-3: #2c2c30;
  --scalar-border-color: rgba(255, 255, 255, 0.17);

  --scalar-color-1: #fafafa;
  --scalar-color-2: rgb(161, 161, 170);
  --scalar-color-3: rgba(255, 255, 255, 0.533);

  --scalar-color-accent: #4eb3ec;
  --scalar-background-accent: #8ab4f81f;
}
/* Document Sidebar */
.light-mode .t-doc__sidebar,
.dark-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-border-color: var(--scalar-border-color);

  --scalar-sidebar-item-hover-background: var(--scalar-background-2);
  --scalar-sidebar-item-hover-color: currentColor;

  --scalar-sidebar-item-active-background: var(--scalar-background-3);
  --scalar-sidebar-color-active: var(--scalar-color-1);

  --scalar-sidebar-search-background: var(--scalar-background-1);
  --scalar-sidebar-search-border-color: var(--scalar-border-color);
  --scalar-sidebar-search-color: var(--scalar-color-3);
}

/* advanced */
.light-mode {
  --scalar-color-green: #17803d;
  --scalar-color-red: #e10909;
  --scalar-color-yellow: #edbe20;
  --scalar-color-blue: #1763a6;
  --scalar-color-orange: #e25b09;
  --scalar-color-purple: #5c3993;

  --scalar-button-1: rgba(0, 0, 0, 1);
  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);
  --scalar-button-1-color: rgba(255, 255, 255, 0.9);
}
.dark-mode {
  --scalar-color-green: #30a159;
  --scalar-color-red: #dc1b19;
  --scalar-color-yellow: #eec644;
  --scalar-color-blue: #2b7abf;
  --scalar-color-orange: #f07528;
  --scalar-color-purple: #7a59b1;

  --scalar-button-1: rgba(255, 255, 255, 1);
  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);
  --scalar-button-1-color: black;
}
.dark-mode h2.t-editor__heading,
.dark-mode .t-editor__page-title h1,
.dark-mode h1.section-header:not(::selection),
.dark-mode .markdown h1,
.dark-mode .markdown h2,
.dark-mode .markdown h3,
.dark-mode .markdown h4,
.dark-mode .markdown h5,
.dark-mode .markdown h6 {
  -webkit-text-fill-color: transparent;
  background-image: linear-gradient(
    to right bottom,
    rgb(255, 255, 255) 30%,
    rgba(255, 255, 255, 0.38)
  );
  -webkit-background-clip: text;
  background-clip: text;
}
.light-mode *::selection {
  background-color: color-mix(
    in srgb,
    var(--scalar-color-accent),
    transparent 70%
  );
}
.dark-mode *::selection {
  background-color: color-mix(
    in srgb,
    var(--scalar-color-accent),
    transparent 50%
  );
}
`;

// node_modules/@scalar/themes/dist/presets/solarized.css2.js
var a12 = `.light-mode {
  color-scheme: light;
  --scalar-color-1: #584c27;
  --scalar-color-2: #616161;
  --scalar-color-3: #a89f84;
  --scalar-color-accent: #b58900;
  --scalar-background-1: #fdf6e3;
  --scalar-background-2: #eee8d5;
  --scalar-background-3: #ddd6c1;
  --scalar-background-accent: #b589001f;

  --scalar-border-color: #ded8c8;
  --scalar-scrollbar-color: rgba(0, 0, 0, 0.18);
  --scalar-scrollbar-color-active: rgba(0, 0, 0, 0.36);
  --scalar-lifted-brightness: 1;
  --scalar-backdrop-brightness: 1;

  --scalar-shadow-1: 0 1px 3px 0 rgba(0, 0, 0, 0.11);
  --scalar-shadow-2: rgba(0, 0, 0, 0.08) 0px 13px 20px 0px,
    rgba(0, 0, 0, 0.08) 0px 3px 8px 0px, #eeeeed 0px 0 0 1px;

  --scalar-button-1: rgb(49 53 56);
  --scalar-button-1-color: #fff;
  --scalar-button-1-hover: rgb(28 31 33);

  --scalar-color-red: #b91c1c;
  --scalar-color-orange: #a16207;
  --scalar-color-green: #047857;
  --scalar-color-blue: #1d4ed8;
  --scalar-color-orange: #c2410c;
  --scalar-color-purple: #6d28d9;
}

.dark-mode {
  color-scheme: dark;
  --scalar-color-1: #fff;
  --scalar-color-2: #cccccc;
  --scalar-color-3: #6d8890;
  --scalar-color-accent: #007acc;
  --scalar-background-1: #00212b;
  --scalar-background-2: #012b36;
  --scalar-background-3: #004052;
  --scalar-background-accent: #015a6f;

  --scalar-border-color: #2f4851;
  --scalar-scrollbar-color: rgba(255, 255, 255, 0.24);
  --scalar-scrollbar-color-active: rgba(255, 255, 255, 0.48);
  --scalar-lifted-brightness: 1.45;
  --scalar-backdrop-brightness: 0.5;

  --scalar-shadow-1: 0 1px 3px 0 rgb(0, 0, 0, 0.1);
  --scalar-shadow-2: rgba(15, 15, 15, 0.2) 0px 3px 6px,
    rgba(15, 15, 15, 0.4) 0px 9px 24px, 0 0 0 1px rgba(255, 255, 255, 0.1);

  --scalar-button-1: #f6f6f6;
  --scalar-button-1-color: #000;
  --scalar-button-1-hover: #e7e7e7;

  --scalar-color-green: #00b648;
  --scalar-color-red: #dc1b19;
  --scalar-color-yellow: #ffc90d;
  --scalar-color-blue: #4eb3ec;
  --scalar-color-orange: #ff8d4d;
  --scalar-color-purple: #b191f9;
}

/* Sidebar */
.light-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-item-hover-color: currentColor;
  --scalar-sidebar-item-hover-background: var(--scalar-background-2);
  --scalar-sidebar-item-active-background: var(--scalar-background-accent);
  --scalar-sidebar-border-color: var(--scalar-border-color);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-color-active: var(--scalar-color-accent);
  --scalar-sidebar-search-background: var(--scalar-background-2);
  --scalar-sidebar-search-border-color: var(--scalar-sidebar-search-background);
  --scalar-sidebar-search--color: var(--scalar-color-3);
}

.dark-mode .sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-item-hover-color: currentColor;
  --scalar-sidebar-item-hover-background: var(--scalar-background-2);
  --scalar-sidebar-item-active-background: var(--scalar-background-accent);
  --scalar-sidebar-border-color: var(--scalar-border-color);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-color-active: var(--scalar-sidebar-color-1);
  --scalar-sidebar-search-background: var(--scalar-background-2);
  --scalar-sidebar-search-border-color: var(--scalar-sidebar-search-background);
  --scalar-sidebar-search--color: var(--scalar-color-3);
}
*::selection {
  background-color: color-mix(
    in srgb,
    var(--scalar-color-accent),
    transparent 70%
  );
}
`;

// node_modules/@scalar/themes/dist/utilities/legacy.js
var r = [
  ["--theme-", "--scalar-"],
  ["--sidebar-", "--scalar-sidebar-"]
];
var c = r.map(([e]) => e);

// node_modules/@scalar/themes/dist/index.js
var m = {
  alternate: a,
  default: a4,
  moon: a9,
  elysiajs: a5,
  fastify: a6,
  purple: a10,
  solarized: a12,
  bluePlanet: a2,
  deepSpace: a3,
  saturn: a11,
  kepler: a7,
  mars: a8
};
var K = Object.keys(m);

// node_modules/pathe/dist/shared/pathe.ff20891b.mjs
var _DRIVE_LETTER_START_RE = /^[A-Za-z]:\//;
function normalizeWindowsPath(input = "") {
  if (!input) {
    return input;
  }
  return input.replace(/\\/g, "/").replace(_DRIVE_LETTER_START_RE, (r2) => r2.toUpperCase());
}
var _UNC_REGEX = /^[/\\]{2}/;
var _IS_ABSOLUTE_RE = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/;
var _DRIVE_LETTER_RE = /^[A-Za-z]:$/;
var normalize = function(path) {
  if (path.length === 0) {
    return ".";
  }
  path = normalizeWindowsPath(path);
  const isUNCPath = path.match(_UNC_REGEX);
  const isPathAbsolute = isAbsolute(path);
  const trailingSeparator = path[path.length - 1] === "/";
  path = normalizeString(path, !isPathAbsolute);
  if (path.length === 0) {
    if (isPathAbsolute) {
      return "/";
    }
    return trailingSeparator ? "./" : ".";
  }
  if (trailingSeparator) {
    path += "/";
  }
  if (_DRIVE_LETTER_RE.test(path)) {
    path += "/";
  }
  if (isUNCPath) {
    if (!isPathAbsolute) {
      return `//./${path}`;
    }
    return `//${path}`;
  }
  return isPathAbsolute && !isAbsolute(path) ? `/${path}` : path;
};
function normalizeString(path, allowAboveRoot) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let char = null;
  for (let index = 0;index <= path.length; ++index) {
    if (index < path.length) {
      char = path[index];
    } else if (char === "/") {
      break;
    } else {
      char = "/";
    }
    if (char === "/") {
      if (lastSlash === index - 1 || dots === 1)
        ;
      else if (dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res[res.length - 1] !== "." || res[res.length - 2] !== ".") {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
            }
            lastSlash = index;
            dots = 0;
            continue;
          } else if (res.length > 0) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = index;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          res += res.length > 0 ? "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += `/${path.slice(lastSlash + 1, index)}`;
        } else {
          res = path.slice(lastSlash + 1, index);
        }
        lastSegmentLength = index - lastSlash - 1;
      }
      lastSlash = index;
      dots = 0;
    } else if (char === "." && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
var isAbsolute = function(p) {
  return _IS_ABSOLUTE_RE.test(p);
};
// node_modules/@elysiajs/swagger/dist/index.mjs
function isSchemaObject(schema) {
  return "type" in schema || "properties" in schema || "items" in schema;
}
function isDateTimeProperty(key, schema) {
  return (key === "createdAt" || key === "updatedAt") && "anyOf" in schema && Array.isArray(schema.anyOf);
}
function transformDateProperties(schema) {
  if (!isSchemaObject(schema) || typeof schema !== "object" || schema === null) {
    return schema;
  }
  const newSchema = { ...schema };
  Object.entries(newSchema).forEach(([key, value]) => {
    if (isSchemaObject(value)) {
      if (isDateTimeProperty(key, value)) {
        const dateTimeFormat = value.anyOf?.find((item) => isSchemaObject(item) && item.format === "date-time");
        if (dateTimeFormat) {
          const dateTimeSchema = {
            type: "string",
            format: "date-time",
            default: dateTimeFormat.default
          };
          newSchema[key] = dateTimeSchema;
        }
      } else {
        newSchema[key] = transformDateProperties(value);
      }
    }
  });
  return newSchema;
}
var SwaggerUIRender = (info, version, theme, stringifiedSwaggerOptions, autoDarkMode) => {
  const swaggerOptions = JSON.parse(stringifiedSwaggerOptions);
  if (swaggerOptions.components && swaggerOptions.components.schemas) {
    swaggerOptions.components.schemas = Object.fromEntries(Object.entries(swaggerOptions.components.schemas).map(([key, schema]) => [
      key,
      transformDateProperties(schema)
    ]));
  }
  const transformedStringifiedSwaggerOptions = JSON.stringify(swaggerOptions);
  return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>${info.title}</title>
    <meta
        name="description"
        content="${info.description}"
    />
    <meta
        name="og:description"
        content="${info.description}"
    />
    ${autoDarkMode && typeof theme === "string" ? `
    <style>
        @media (prefers-color-scheme: dark) {
            body {
                background-color: #222;
                color: #faf9a;
            }
            .swagger-ui {
                filter: invert(92%) hue-rotate(180deg);
            }

            .swagger-ui .microlight {
                filter: invert(100%) hue-rotate(180deg);
            }
        }
    </style>` : ""}
    ${typeof theme === "string" ? `<link rel="stylesheet" href="${theme}" />` : `<link rel="stylesheet" media="(prefers-color-scheme: light)" href="${theme.light}" />
<link rel="stylesheet" media="(prefers-color-scheme: dark)" href="${theme.dark}" />`}
</head>
<body>
    <div id="swagger-ui"></div>
    <script src="https://unpkg.com/swagger-ui-dist@${version}/swagger-ui-bundle.js" crossorigin></script>
    <script>
        window.onload = () => {
            window.ui = SwaggerUIBundle(${transformedStringifiedSwaggerOptions});
        };
    </script>
</body>
</html>`;
};
var ScalarRender = (info, version, config2, cdn) => `<!doctype html>
<html>
  <head>
    <title>${info.title}</title>
    <meta
        name="description"
        content="${info.description}"
    />
    <meta
        name="og:description"
        content="${info.description}"
    />
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1" />
    <style>
      body {
        margin: 0;
      }
    </style>
    <style>
      ${config2.customCss ?? a5}
    </style>
  </head>
  <body>
    <script
      id="api-reference"
      data-url="${config2.spec?.url}"
      data-configuration='${JSON.stringify(config2)}'
    >
    </script>
    <script src="${cdn ? cdn : `https://cdn.jsdelivr.net/npm/@scalar/api-reference@${version}/dist/browser/standalone.min.js`}" crossorigin></script>
  </body>
</html>`;
var TransformKind3 = Symbol.for("TypeBox.Transform");
var ReadonlyKind3 = Symbol.for("TypeBox.Readonly");
var OptionalKind3 = Symbol.for("TypeBox.Optional");
var Hint3 = Symbol.for("TypeBox.Hint");
var Kind3 = Symbol.for("TypeBox.Kind");
var toOpenAPIPath = (path2) => path2.split("/").map((x) => {
  if (x.startsWith(":")) {
    x = x.slice(1, x.length);
    if (x.endsWith("?"))
      x = x.slice(0, -1);
    x = `{${x}}`;
  }
  return x;
}).join("/");
var mapProperties = (name, schema, models) => {
  if (schema === undefined)
    return [];
  if (typeof schema === "string")
    if (schema in models)
      schema = models[schema];
    else
      throw new Error(`Can't find model ${schema}`);
  return Object.entries(schema?.properties ?? []).map(([key, value]) => {
    const {
      type: valueType = undefined,
      description,
      examples,
      ...schemaKeywords
    } = value;
    return {
      description,
      examples,
      schema: { type: valueType, ...schemaKeywords },
      in: name,
      name: key,
      required: schema.required?.includes(key) ?? false
    };
  });
};
var mapTypesResponse = (types, schema) => {
  if (typeof schema === "object" && ["void", "undefined", "null"].includes(schema.type))
    return;
  const responses = {};
  for (const type of types) {
    responses[type] = {
      schema: typeof schema === "string" ? {
        $ref: `#/components/schemas/${schema}`
      } : { ...schema }
    };
  }
  return responses;
};
var capitalize = (word) => word.charAt(0).toUpperCase() + word.slice(1);
var generateOperationId = (method, paths) => {
  let operationId = method.toLowerCase();
  if (paths === "/")
    return operationId + "Index";
  for (const path2 of paths.split("/")) {
    if (path2.charCodeAt(0) === 123) {
      operationId += "By" + capitalize(path2.slice(1, -1));
    } else {
      operationId += capitalize(path2);
    }
  }
  return operationId;
};
var cloneHook = (hook) => {
  if (!hook)
    return;
  if (typeof hook === "string")
    return hook;
  if (Array.isArray(hook))
    return [...hook];
  return { ...hook };
};
var registerSchemaPath = ({
  schema,
  path: path2,
  method,
  hook,
  models
}) => {
  hook = cloneHook(hook);
  const contentType = hook?.type ?? [
    "application/json",
    "multipart/form-data",
    "text/plain"
  ];
  path2 = toOpenAPIPath(path2);
  const contentTypes = typeof contentType === "string" ? [contentType] : contentType ?? ["application/json"];
  const bodySchema = cloneHook(hook?.body);
  const paramsSchema = cloneHook(hook?.params);
  const headerSchema = cloneHook(hook?.headers);
  const querySchema = cloneHook(hook?.query);
  let responseSchema = cloneHook(hook?.response);
  if (typeof responseSchema === "object") {
    if (Kind3 in responseSchema) {
      const {
        type,
        properties,
        required,
        additionalProperties,
        patternProperties,
        ...rest
      } = responseSchema;
      responseSchema = {
        "200": {
          ...rest,
          description: rest.description,
          content: mapTypesResponse(contentTypes, type === "object" || type === "array" ? {
            type,
            properties,
            patternProperties,
            items: responseSchema.items,
            required
          } : responseSchema)
        }
      };
    } else {
      Object.entries(responseSchema).forEach(([key, value]) => {
        if (typeof value === "string") {
          if (!models[value])
            return;
          const {
            type,
            properties,
            required,
            additionalProperties: _1,
            patternProperties: _22,
            ...rest
          } = models[value];
          responseSchema[key] = {
            ...rest,
            description: rest.description,
            content: mapTypesResponse(contentTypes, value)
          };
        } else {
          const {
            type,
            properties,
            required,
            additionalProperties,
            patternProperties,
            ...rest
          } = value;
          responseSchema[key] = {
            ...rest,
            description: rest.description,
            content: mapTypesResponse(contentTypes, type === "object" || type === "array" ? {
              type,
              properties,
              patternProperties,
              items: value.items,
              required
            } : value)
          };
        }
      });
    }
  } else if (typeof responseSchema === "string") {
    if (!(responseSchema in models))
      return;
    const {
      type,
      properties,
      required,
      additionalProperties: _1,
      patternProperties: _22,
      ...rest
    } = models[responseSchema];
    responseSchema = {
      "200": {
        ...rest,
        content: mapTypesResponse(contentTypes, responseSchema)
      }
    };
  }
  const parameters = [
    ...mapProperties("header", headerSchema, models),
    ...mapProperties("path", paramsSchema, models),
    ...mapProperties("query", querySchema, models)
  ];
  schema[path2] = {
    ...schema[path2] ? schema[path2] : {},
    [method.toLowerCase()]: {
      ...headerSchema || paramsSchema || querySchema || bodySchema ? { parameters } : {},
      ...responseSchema ? {
        responses: responseSchema
      } : {},
      operationId: hook?.detail?.operationId ?? generateOperationId(method, path2),
      ...hook?.detail,
      ...bodySchema ? {
        requestBody: {
          required: true,
          content: mapTypesResponse(contentTypes, typeof bodySchema === "string" ? {
            $ref: `#/components/schemas/${bodySchema}`
          } : bodySchema)
        }
      } : null
    }
  };
};
var filterPaths = (paths, docsPath, {
  excludeStaticFile = true,
  exclude = []
}) => {
  const newPaths = {};
  const excludePaths = [`/${docsPath}`, `/${docsPath}/json`].map((p) => normalize(p));
  for (const [key, value] of Object.entries(paths))
    if (!exclude.some((x) => {
      if (typeof x === "string")
        return key === x;
      return x.test(key);
    }) && !excludePaths.includes(key) && !key.includes("*") && (excludeStaticFile ? !key.includes(".") : true)) {
      Object.keys(value).forEach((method) => {
        const schema = value[method];
        if (key.includes("{")) {
          if (!schema.parameters)
            schema.parameters = [];
          schema.parameters = [
            ...key.split("/").filter((x) => x.startsWith("{") && !schema.parameters.find((params) => params.in === "path" && params.name === x.slice(1, x.length - 1))).map((x) => ({
              schema: { type: "string" },
              in: "path",
              name: x.slice(1, x.length - 1),
              required: true
            })),
            ...schema.parameters
          ];
        }
        if (!schema.responses)
          schema.responses = {
            200: {}
          };
      });
      newPaths[key] = value;
    }
  return newPaths;
};
var swagger = async ({
  provider = "scalar",
  scalarVersion = "latest",
  scalarCDN = "",
  scalarConfig = {},
  documentation = {},
  version = "5.9.0",
  excludeStaticFile = true,
  path: path2 = "/swagger",
  exclude = [],
  swaggerOptions = {},
  theme = `https://unpkg.com/swagger-ui-dist@${version}/swagger-ui.css`,
  autoDarkMode = true,
  excludeMethods = ["OPTIONS"],
  excludeTags = []
} = {
  provider: "scalar",
  scalarVersion: "latest",
  scalarCDN: "",
  scalarConfig: {},
  documentation: {},
  version: "5.9.0",
  excludeStaticFile: true,
  path: "/swagger",
  exclude: [],
  swaggerOptions: {},
  autoDarkMode: true,
  excludeMethods: ["OPTIONS"],
  excludeTags: []
}) => {
  const schema = {};
  let totalRoutes = 0;
  if (!version)
    version = `https://unpkg.com/swagger-ui-dist@${version}/swagger-ui.css`;
  const info = {
    title: "Elysia Documentation",
    description: "Development documentation",
    version: "0.0.0",
    ...documentation.info
  };
  const relativePath = path2.startsWith("/") ? path2.slice(1) : path2;
  const app = new Elysia2({ name: "@elysiajs/swagger" });
  app.get(path2, function documentation2() {
    const combinedSwaggerOptions = {
      url: `/${relativePath}/json`,
      dom_id: "#swagger-ui",
      ...swaggerOptions
    };
    const stringifiedSwaggerOptions = JSON.stringify(combinedSwaggerOptions, (key, value) => {
      if (typeof value == "function")
        return;
      return value;
    });
    const scalarConfiguration = {
      spec: {
        ...scalarConfig.spec,
        url: `/${relativePath}/json`
      },
      ...scalarConfig,
      _integration: "elysiajs"
    };
    return new Response(provider === "swagger-ui" ? SwaggerUIRender(info, version, theme, stringifiedSwaggerOptions, autoDarkMode) : ScalarRender(info, scalarVersion, scalarConfiguration, scalarCDN), {
      headers: {
        "content-type": "text/html; charset=utf8"
      }
    });
  }).get(path2 === "/" ? "/json" : `${path2}/json`, function openAPISchema() {
    const routes = app.getGlobalRoutes();
    if (routes.length !== totalRoutes) {
      const ALLOWED_METHODS = ["GET", "PUT", "POST", "DELETE", "OPTIONS", "HEAD", "PATCH", "TRACE"];
      totalRoutes = routes.length;
      routes.forEach((route) => {
        if (route.hooks?.detail?.hide === true)
          return;
        if (excludeMethods.includes(route.method))
          return;
        if (ALLOWED_METHODS.includes(route.method) === false && route.method !== "ALL")
          return;
        if (route.method === "ALL") {
          ALLOWED_METHODS.forEach((method) => {
            registerSchemaPath({
              schema,
              hook: route.hooks,
              method,
              path: route.path,
              models: app.definitions?.type,
              contentType: route.hooks.type
            });
          });
          return;
        }
        registerSchemaPath({
          schema,
          hook: route.hooks,
          method: route.method,
          path: route.path,
          models: app.definitions?.type,
          contentType: route.hooks.type
        });
      });
    }
    return {
      openapi: "3.0.3",
      ...{
        ...documentation,
        tags: documentation.tags?.filter((tag) => !excludeTags?.includes(tag?.name)),
        info: {
          title: "Elysia Documentation",
          description: "Development documentation",
          version: "0.0.0",
          ...documentation.info
        }
      },
      paths: {
        ...filterPaths(schema, relativePath, {
          excludeStaticFile,
          exclude: Array.isArray(exclude) ? exclude : [exclude]
        }),
        ...documentation.paths
      },
      components: {
        ...documentation.components,
        schemas: {
          ...app.definitions?.type,
          ...documentation.components?.schemas
        }
      }
    };
  });
  return app;
};
var index_default2 = swagger;

// src/models/database.ts
var import_client = __toESM(require_default2(), 1);
var prisma = new import_client.PrismaClient;

// src/routes/userRouter.ts
var userRouter = new Elysia2({ prefix: "/users" }).get("/list", async ({}) => {
  try {
    const users = await prisma.user.findMany();
    return users;
  } catch (e) {
    return error2(500, "Internal Server Error");
  }
}).post("/create", async ({ body }) => {
  try {
    const { email, image, name, password } = body;
    const hashedPassword = await Bun.password.hash(password);
    const newUser = await prisma.user.create({
      data: {
        name,
        email,
        image,
        password: hashedPassword
      }
    });
    const user = {
      name: newUser.name
    };
    return user;
  } catch (e) {
    return error2(500, "Internal Server Error");
  }
}, {
  body: t2.Object({
    name: t2.String({
      minLength: 3,
      maxLength: 30
    }),
    email: t2.String({
      minLength: 3,
      maxLength: 30
    }),
    password: t2.String({
      minLength: 3,
      maxLength: 30
    }),
    image: t2.String({
      minLength: 1
    })
  })
}).delete("/:id", async ({ params }) => {
  try {
    const { id } = params;
    const deletedUser = await prisma.user.delete({
      where: {
        id
      }
    });
    return deletedUser;
  } catch (e) {
    return error2(500, "User is already deleted!");
  }
}, {
  params: t2.Object({
    id: t2.String({
      minLength: 3
    })
  })
}).put("/:id", async ({ body, params }) => {
  try {
    const { id } = params;
    const { name } = body;
    const newUser = await prisma.user.update({
      where: {
        id
      },
      data: {
        name
      }
    });
    const user = {
      name: newUser.name
    };
    return user;
  } catch (e) {
    return error2(500, "Internal Server Error");
  }
}, {
  body: t2.Object({
    name: t2.String({
      minLength: 3
    })
  }),
  params: t2.Object({
    id: t2.String({
      minLength: 3
    })
  })
}).get("/profile", async ({}) => {
  return "user profile";
});

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/runtime/webcrypto.js
var webcrypto_default = crypto;
var isCryptoKey = (key) => key instanceof CryptoKey;

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/lib/buffer_utils.js
var encoder3 = new TextEncoder;
var decoder = new TextDecoder;
var MAX_INT323 = 2 ** 32;
function concat(...buffers) {
  const size = buffers.reduce((acc, { length }) => acc + length, 0);
  const buf = new Uint8Array(size);
  let i = 0;
  buffers.forEach((buffer) => {
    buf.set(buffer, i);
    i += buffer.length;
  });
  return buf;
}

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/runtime/base64url.js
var encodeBase64 = (input) => {
  let unencoded = input;
  if (typeof unencoded === "string") {
    unencoded = encoder3.encode(unencoded);
  }
  const CHUNK_SIZE = 32768;
  const arr = [];
  for (let i = 0;i < unencoded.length; i += CHUNK_SIZE) {
    arr.push(String.fromCharCode.apply(null, unencoded.subarray(i, i + CHUNK_SIZE)));
  }
  return btoa(arr.join(""));
};
var encode3 = (input) => {
  return encodeBase64(input).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
};
var decodeBase64 = (encoded) => {
  const binary = atob(encoded);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0;i < binary.length; i++) {
    bytes[i] = binary.charCodeAt(i);
  }
  return bytes;
};
var decode3 = (input) => {
  let encoded = input;
  if (encoded instanceof Uint8Array) {
    encoded = decoder.decode(encoded);
  }
  encoded = encoded.replace(/-/g, "+").replace(/_/g, "/").replace(/\s/g, "");
  try {
    return decodeBase64(encoded);
  } catch (_a) {
    throw new TypeError("The input to be decoded is not correctly encoded.");
  }
};

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/util/errors.js
class JOSEError extends Error {
  static get code() {
    return "ERR_JOSE_GENERIC";
  }
  constructor(message) {
    var _a;
    super(message);
    this.code = "ERR_JOSE_GENERIC";
    this.name = this.constructor.name;
    (_a = Error.captureStackTrace) === null || _a === undefined || _a.call(Error, this, this.constructor);
  }
}

class JWTClaimValidationFailed extends JOSEError {
  static get code() {
    return "ERR_JWT_CLAIM_VALIDATION_FAILED";
  }
  constructor(message, claim = "unspecified", reason = "unspecified") {
    super(message);
    this.code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
    this.claim = claim;
    this.reason = reason;
  }
}

class JWTExpired extends JOSEError {
  static get code() {
    return "ERR_JWT_EXPIRED";
  }
  constructor(message, claim = "unspecified", reason = "unspecified") {
    super(message);
    this.code = "ERR_JWT_EXPIRED";
    this.claim = claim;
    this.reason = reason;
  }
}

class JOSEAlgNotAllowed extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JOSE_ALG_NOT_ALLOWED";
  }
  static get code() {
    return "ERR_JOSE_ALG_NOT_ALLOWED";
  }
}

class JOSENotSupported extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JOSE_NOT_SUPPORTED";
  }
  static get code() {
    return "ERR_JOSE_NOT_SUPPORTED";
  }
}
class JWSInvalid extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWS_INVALID";
  }
  static get code() {
    return "ERR_JWS_INVALID";
  }
}

class JWTInvalid extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWT_INVALID";
  }
  static get code() {
    return "ERR_JWT_INVALID";
  }
}
class JWSSignatureVerificationFailed extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
    this.message = "signature verification failed";
  }
  static get code() {
    return "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
  }
}

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/lib/crypto_key.js
function unusable(name, prop = "algorithm.name") {
  return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);
}
function isAlgorithm(algorithm, name) {
  return algorithm.name === name;
}
function getHashLength(hash3) {
  return parseInt(hash3.name.slice(4), 10);
}
function getNamedCurve(alg) {
  switch (alg) {
    case "ES256":
      return "P-256";
    case "ES384":
      return "P-384";
    case "ES512":
      return "P-521";
    default:
      throw new Error("unreachable");
  }
}
function checkUsage(key, usages) {
  if (usages.length && !usages.some((expected) => key.usages.includes(expected))) {
    let msg = "CryptoKey does not support this operation, its usages must include ";
    if (usages.length > 2) {
      const last = usages.pop();
      msg += `one of ${usages.join(", ")}, or ${last}.`;
    } else if (usages.length === 2) {
      msg += `one of ${usages[0]} or ${usages[1]}.`;
    } else {
      msg += `${usages[0]}.`;
    }
    throw new TypeError(msg);
  }
}
function checkSigCryptoKey(key, alg, ...usages) {
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512": {
      if (!isAlgorithm(key.algorithm, "HMAC"))
        throw unusable("HMAC");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "RS256":
    case "RS384":
    case "RS512": {
      if (!isAlgorithm(key.algorithm, "RSASSA-PKCS1-v1_5"))
        throw unusable("RSASSA-PKCS1-v1_5");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "PS256":
    case "PS384":
    case "PS512": {
      if (!isAlgorithm(key.algorithm, "RSA-PSS"))
        throw unusable("RSA-PSS");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "EdDSA": {
      if (key.algorithm.name !== "Ed25519" && key.algorithm.name !== "Ed448") {
        throw unusable("Ed25519 or Ed448");
      }
      break;
    }
    case "ES256":
    case "ES384":
    case "ES512": {
      if (!isAlgorithm(key.algorithm, "ECDSA"))
        throw unusable("ECDSA");
      const expected = getNamedCurve(alg);
      const actual = key.algorithm.namedCurve;
      if (actual !== expected)
        throw unusable(expected, "algorithm.namedCurve");
      break;
    }
    default:
      throw new TypeError("CryptoKey does not support this operation");
  }
  checkUsage(key, usages);
}

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/lib/invalid_key_input.js
function message(msg, actual, ...types) {
  if (types.length > 2) {
    const last = types.pop();
    msg += `one of type ${types.join(", ")}, or ${last}.`;
  } else if (types.length === 2) {
    msg += `one of type ${types[0]} or ${types[1]}.`;
  } else {
    msg += `of type ${types[0]}.`;
  }
  if (actual == null) {
    msg += ` Received ${actual}`;
  } else if (typeof actual === "function" && actual.name) {
    msg += ` Received function ${actual.name}`;
  } else if (typeof actual === "object" && actual != null) {
    if (actual.constructor && actual.constructor.name) {
      msg += ` Received an instance of ${actual.constructor.name}`;
    }
  }
  return msg;
}
var invalid_key_input_default = (actual, ...types) => {
  return message("Key must be ", actual, ...types);
};
function withAlg(alg, actual, ...types) {
  return message(`Key for the ${alg} algorithm must be `, actual, ...types);
}

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/runtime/is_key_like.js
var is_key_like_default = (key) => {
  return isCryptoKey(key);
};
var types = ["CryptoKey"];

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/lib/is_disjoint.js
var isDisjoint = (...headers) => {
  const sources = headers.filter(Boolean);
  if (sources.length === 0 || sources.length === 1) {
    return true;
  }
  let acc;
  for (const header of sources) {
    const parameters = Object.keys(header);
    if (!acc || acc.size === 0) {
      acc = new Set(parameters);
      continue;
    }
    for (const parameter of parameters) {
      if (acc.has(parameter)) {
        return false;
      }
      acc.add(parameter);
    }
  }
  return true;
};
var is_disjoint_default = isDisjoint;

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/lib/is_object.js
function isObjectLike(value) {
  return typeof value === "object" && value !== null;
}
function isObject3(input) {
  if (!isObjectLike(input) || Object.prototype.toString.call(input) !== "[object Object]") {
    return false;
  }
  if (Object.getPrototypeOf(input) === null) {
    return true;
  }
  let proto = input;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(input) === proto;
}

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/runtime/check_key_length.js
var check_key_length_default = (alg, key) => {
  if (alg.startsWith("RS") || alg.startsWith("PS")) {
    const { modulusLength } = key.algorithm;
    if (typeof modulusLength !== "number" || modulusLength < 2048) {
      throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
    }
  }
};

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/lib/check_key_type.js
var symmetricTypeCheck = (alg, key) => {
  if (key instanceof Uint8Array)
    return;
  if (!is_key_like_default(key)) {
    throw new TypeError(withAlg(alg, key, ...types, "Uint8Array"));
  }
  if (key.type !== "secret") {
    throw new TypeError(`${types.join(" or ")} instances for symmetric algorithms must be of type "secret"`);
  }
};
var asymmetricTypeCheck = (alg, key, usage) => {
  if (!is_key_like_default(key)) {
    throw new TypeError(withAlg(alg, key, ...types));
  }
  if (key.type === "secret") {
    throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);
  }
  if (usage === "sign" && key.type === "public") {
    throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);
  }
  if (usage === "decrypt" && key.type === "public") {
    throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);
  }
  if (key.algorithm && usage === "verify" && key.type === "private") {
    throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);
  }
  if (key.algorithm && usage === "encrypt" && key.type === "private") {
    throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`);
  }
};
var checkKeyType = (alg, key, usage) => {
  const symmetric = alg.startsWith("HS") || alg === "dir" || alg.startsWith("PBES2") || /^A\d{3}(?:GCM)?KW$/.test(alg);
  if (symmetric) {
    symmetricTypeCheck(alg, key);
  } else {
    asymmetricTypeCheck(alg, key, usage);
  }
};
var check_key_type_default = checkKeyType;

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/lib/validate_crit.js
function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
  if (joseHeader.crit !== undefined && protectedHeader.crit === undefined) {
    throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
  }
  if (!protectedHeader || protectedHeader.crit === undefined) {
    return new Set;
  }
  if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input) => typeof input !== "string" || input.length === 0)) {
    throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
  }
  let recognized;
  if (recognizedOption !== undefined) {
    recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);
  } else {
    recognized = recognizedDefault;
  }
  for (const parameter of protectedHeader.crit) {
    if (!recognized.has(parameter)) {
      throw new JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
    }
    if (joseHeader[parameter] === undefined) {
      throw new Err(`Extension Header Parameter "${parameter}" is missing`);
    } else if (recognized.get(parameter) && protectedHeader[parameter] === undefined) {
      throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
    }
  }
  return new Set(protectedHeader.crit);
}
var validate_crit_default = validateCrit;

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/lib/validate_algorithms.js
var validateAlgorithms = (option, algorithms) => {
  if (algorithms !== undefined && (!Array.isArray(algorithms) || algorithms.some((s) => typeof s !== "string"))) {
    throw new TypeError(`"${option}" option must be an array of strings`);
  }
  if (!algorithms) {
    return;
  }
  return new Set(algorithms);
};
var validate_algorithms_default = validateAlgorithms;

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/runtime/subtle_dsa.js
function subtleDsa(alg, algorithm) {
  const hash3 = `SHA-${alg.slice(-3)}`;
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512":
      return { hash: hash3, name: "HMAC" };
    case "PS256":
    case "PS384":
    case "PS512":
      return { hash: hash3, name: "RSA-PSS", saltLength: alg.slice(-3) >> 3 };
    case "RS256":
    case "RS384":
    case "RS512":
      return { hash: hash3, name: "RSASSA-PKCS1-v1_5" };
    case "ES256":
    case "ES384":
    case "ES512":
      return { hash: hash3, name: "ECDSA", namedCurve: algorithm.namedCurve };
    case "EdDSA":
      return { name: algorithm.name };
    default:
      throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
  }
}

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/runtime/get_sign_verify_key.js
function getCryptoKey(alg, key, usage) {
  if (isCryptoKey(key)) {
    checkSigCryptoKey(key, alg, usage);
    return key;
  }
  if (key instanceof Uint8Array) {
    if (!alg.startsWith("HS")) {
      throw new TypeError(invalid_key_input_default(key, ...types));
    }
    return webcrypto_default.subtle.importKey("raw", key, { hash: `SHA-${alg.slice(-3)}`, name: "HMAC" }, false, [usage]);
  }
  throw new TypeError(invalid_key_input_default(key, ...types, "Uint8Array"));
}

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/runtime/verify.js
var verify = async (alg, key, signature, data) => {
  const cryptoKey = await getCryptoKey(alg, key, "verify");
  check_key_length_default(alg, cryptoKey);
  const algorithm = subtleDsa(alg, cryptoKey.algorithm);
  try {
    return await webcrypto_default.subtle.verify(algorithm, cryptoKey, signature, data);
  } catch (_a) {
    return false;
  }
};
var verify_default = verify;

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/jws/flattened/verify.js
async function flattenedVerify(jws, key, options) {
  var _a;
  if (!isObject3(jws)) {
    throw new JWSInvalid("Flattened JWS must be an object");
  }
  if (jws.protected === undefined && jws.header === undefined) {
    throw new JWSInvalid('Flattened JWS must have either of the "protected" or "header" members');
  }
  if (jws.protected !== undefined && typeof jws.protected !== "string") {
    throw new JWSInvalid("JWS Protected Header incorrect type");
  }
  if (jws.payload === undefined) {
    throw new JWSInvalid("JWS Payload missing");
  }
  if (typeof jws.signature !== "string") {
    throw new JWSInvalid("JWS Signature missing or incorrect type");
  }
  if (jws.header !== undefined && !isObject3(jws.header)) {
    throw new JWSInvalid("JWS Unprotected Header incorrect type");
  }
  let parsedProt = {};
  if (jws.protected) {
    try {
      const protectedHeader = decode3(jws.protected);
      parsedProt = JSON.parse(decoder.decode(protectedHeader));
    } catch (_b) {
      throw new JWSInvalid("JWS Protected Header is invalid");
    }
  }
  if (!is_disjoint_default(parsedProt, jws.header)) {
    throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
  }
  const joseHeader = {
    ...parsedProt,
    ...jws.header
  };
  const extensions = validate_crit_default(JWSInvalid, new Map([["b64", true]]), options === null || options === undefined ? undefined : options.crit, parsedProt, joseHeader);
  let b64 = true;
  if (extensions.has("b64")) {
    b64 = parsedProt.b64;
    if (typeof b64 !== "boolean") {
      throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
    }
  }
  const { alg } = joseHeader;
  if (typeof alg !== "string" || !alg) {
    throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
  }
  const algorithms = options && validate_algorithms_default("algorithms", options.algorithms);
  if (algorithms && !algorithms.has(alg)) {
    throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter not allowed');
  }
  if (b64) {
    if (typeof jws.payload !== "string") {
      throw new JWSInvalid("JWS Payload must be a string");
    }
  } else if (typeof jws.payload !== "string" && !(jws.payload instanceof Uint8Array)) {
    throw new JWSInvalid("JWS Payload must be a string or an Uint8Array instance");
  }
  let resolvedKey = false;
  if (typeof key === "function") {
    key = await key(parsedProt, jws);
    resolvedKey = true;
  }
  check_key_type_default(alg, key, "verify");
  const data = concat(encoder3.encode((_a = jws.protected) !== null && _a !== undefined ? _a : ""), encoder3.encode("."), typeof jws.payload === "string" ? encoder3.encode(jws.payload) : jws.payload);
  let signature;
  try {
    signature = decode3(jws.signature);
  } catch (_c) {
    throw new JWSInvalid("Failed to base64url decode the signature");
  }
  const verified = await verify_default(alg, key, signature, data);
  if (!verified) {
    throw new JWSSignatureVerificationFailed;
  }
  let payload;
  if (b64) {
    try {
      payload = decode3(jws.payload);
    } catch (_d) {
      throw new JWSInvalid("Failed to base64url decode the payload");
    }
  } else if (typeof jws.payload === "string") {
    payload = encoder3.encode(jws.payload);
  } else {
    payload = jws.payload;
  }
  const result = { payload };
  if (jws.protected !== undefined) {
    result.protectedHeader = parsedProt;
  }
  if (jws.header !== undefined) {
    result.unprotectedHeader = jws.header;
  }
  if (resolvedKey) {
    return { ...result, key };
  }
  return result;
}

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/jws/compact/verify.js
async function compactVerify(jws, key, options) {
  if (jws instanceof Uint8Array) {
    jws = decoder.decode(jws);
  }
  if (typeof jws !== "string") {
    throw new JWSInvalid("Compact JWS must be a string or Uint8Array");
  }
  const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split(".");
  if (length !== 3) {
    throw new JWSInvalid("Invalid Compact JWS");
  }
  const verified = await flattenedVerify({ payload, protected: protectedHeader, signature }, key, options);
  const result = { payload: verified.payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: verified.key };
  }
  return result;
}

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/lib/epoch.js
var epoch_default = (date3) => Math.floor(date3.getTime() / 1000);

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/lib/secs.js
var minute = 60;
var hour = minute * 60;
var day = hour * 24;
var week = day * 7;
var year = day * 365.25;
var REGEX = /^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i;
var secs_default = (str) => {
  const matched = REGEX.exec(str);
  if (!matched) {
    throw new TypeError("Invalid time period format");
  }
  const value = parseFloat(matched[1]);
  const unit = matched[2].toLowerCase();
  switch (unit) {
    case "sec":
    case "secs":
    case "second":
    case "seconds":
    case "s":
      return Math.round(value);
    case "minute":
    case "minutes":
    case "min":
    case "mins":
    case "m":
      return Math.round(value * minute);
    case "hour":
    case "hours":
    case "hr":
    case "hrs":
    case "h":
      return Math.round(value * hour);
    case "day":
    case "days":
    case "d":
      return Math.round(value * day);
    case "week":
    case "weeks":
    case "w":
      return Math.round(value * week);
    default:
      return Math.round(value * year);
  }
};

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/lib/jwt_claims_set.js
var normalizeTyp = (value) => value.toLowerCase().replace(/^application\//, "");
var checkAudiencePresence = (audPayload, audOption) => {
  if (typeof audPayload === "string") {
    return audOption.includes(audPayload);
  }
  if (Array.isArray(audPayload)) {
    return audOption.some(Set.prototype.has.bind(new Set(audPayload)));
  }
  return false;
};
var jwt_claims_set_default = (protectedHeader, encodedPayload, options = {}) => {
  const { typ } = options;
  if (typ && (typeof protectedHeader.typ !== "string" || normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {
    throw new JWTClaimValidationFailed('unexpected "typ" JWT header value', "typ", "check_failed");
  }
  let payload;
  try {
    payload = JSON.parse(decoder.decode(encodedPayload));
  } catch (_a) {
  }
  if (!isObject3(payload)) {
    throw new JWTInvalid("JWT Claims Set must be a top-level JSON object");
  }
  const { requiredClaims = [], issuer, subject, audience, maxTokenAge } = options;
  if (maxTokenAge !== undefined)
    requiredClaims.push("iat");
  if (audience !== undefined)
    requiredClaims.push("aud");
  if (subject !== undefined)
    requiredClaims.push("sub");
  if (issuer !== undefined)
    requiredClaims.push("iss");
  for (const claim of new Set(requiredClaims.reverse())) {
    if (!(claim in payload)) {
      throw new JWTClaimValidationFailed(`missing required "${claim}" claim`, claim, "missing");
    }
  }
  if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {
    throw new JWTClaimValidationFailed('unexpected "iss" claim value', "iss", "check_failed");
  }
  if (subject && payload.sub !== subject) {
    throw new JWTClaimValidationFailed('unexpected "sub" claim value', "sub", "check_failed");
  }
  if (audience && !checkAudiencePresence(payload.aud, typeof audience === "string" ? [audience] : audience)) {
    throw new JWTClaimValidationFailed('unexpected "aud" claim value', "aud", "check_failed");
  }
  let tolerance;
  switch (typeof options.clockTolerance) {
    case "string":
      tolerance = secs_default(options.clockTolerance);
      break;
    case "number":
      tolerance = options.clockTolerance;
      break;
    case "undefined":
      tolerance = 0;
      break;
    default:
      throw new TypeError("Invalid clockTolerance option type");
  }
  const { currentDate } = options;
  const now = epoch_default(currentDate || new Date);
  if ((payload.iat !== undefined || maxTokenAge) && typeof payload.iat !== "number") {
    throw new JWTClaimValidationFailed('"iat" claim must be a number', "iat", "invalid");
  }
  if (payload.nbf !== undefined) {
    if (typeof payload.nbf !== "number") {
      throw new JWTClaimValidationFailed('"nbf" claim must be a number', "nbf", "invalid");
    }
    if (payload.nbf > now + tolerance) {
      throw new JWTClaimValidationFailed('"nbf" claim timestamp check failed', "nbf", "check_failed");
    }
  }
  if (payload.exp !== undefined) {
    if (typeof payload.exp !== "number") {
      throw new JWTClaimValidationFailed('"exp" claim must be a number', "exp", "invalid");
    }
    if (payload.exp <= now - tolerance) {
      throw new JWTExpired('"exp" claim timestamp check failed', "exp", "check_failed");
    }
  }
  if (maxTokenAge) {
    const age = now - payload.iat;
    const max = typeof maxTokenAge === "number" ? maxTokenAge : secs_default(maxTokenAge);
    if (age - tolerance > max) {
      throw new JWTExpired('"iat" claim timestamp check failed (too far in the past)', "iat", "check_failed");
    }
    if (age < 0 - tolerance) {
      throw new JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', "iat", "check_failed");
    }
  }
  return payload;
};

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/jwt/verify.js
async function jwtVerify(jwt, key, options) {
  var _a;
  const verified = await compactVerify(jwt, key, options);
  if (((_a = verified.protectedHeader.crit) === null || _a === undefined ? undefined : _a.includes("b64")) && verified.protectedHeader.b64 === false) {
    throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
  }
  const payload = jwt_claims_set_default(verified.protectedHeader, verified.payload, options);
  const result = { payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: verified.key };
  }
  return result;
}
// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/runtime/sign.js
var sign = async (alg, key, data) => {
  const cryptoKey = await getCryptoKey(alg, key, "sign");
  check_key_length_default(alg, cryptoKey);
  const signature = await webcrypto_default.subtle.sign(subtleDsa(alg, cryptoKey.algorithm), cryptoKey, data);
  return new Uint8Array(signature);
};
var sign_default = sign;

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/jws/flattened/sign.js
class FlattenedSign {
  constructor(payload) {
    if (!(payload instanceof Uint8Array)) {
      throw new TypeError("payload must be an instance of Uint8Array");
    }
    this._payload = payload;
  }
  setProtectedHeader(protectedHeader) {
    if (this._protectedHeader) {
      throw new TypeError("setProtectedHeader can only be called once");
    }
    this._protectedHeader = protectedHeader;
    return this;
  }
  setUnprotectedHeader(unprotectedHeader) {
    if (this._unprotectedHeader) {
      throw new TypeError("setUnprotectedHeader can only be called once");
    }
    this._unprotectedHeader = unprotectedHeader;
    return this;
  }
  async sign(key, options) {
    if (!this._protectedHeader && !this._unprotectedHeader) {
      throw new JWSInvalid("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");
    }
    if (!is_disjoint_default(this._protectedHeader, this._unprotectedHeader)) {
      throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
    }
    const joseHeader = {
      ...this._protectedHeader,
      ...this._unprotectedHeader
    };
    const extensions = validate_crit_default(JWSInvalid, new Map([["b64", true]]), options === null || options === undefined ? undefined : options.crit, this._protectedHeader, joseHeader);
    let b64 = true;
    if (extensions.has("b64")) {
      b64 = this._protectedHeader.b64;
      if (typeof b64 !== "boolean") {
        throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
      }
    }
    const { alg } = joseHeader;
    if (typeof alg !== "string" || !alg) {
      throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
    }
    check_key_type_default(alg, key, "sign");
    let payload = this._payload;
    if (b64) {
      payload = encoder3.encode(encode3(payload));
    }
    let protectedHeader;
    if (this._protectedHeader) {
      protectedHeader = encoder3.encode(encode3(JSON.stringify(this._protectedHeader)));
    } else {
      protectedHeader = encoder3.encode("");
    }
    const data = concat(protectedHeader, encoder3.encode("."), payload);
    const signature = await sign_default(alg, key, data);
    const jws = {
      signature: encode3(signature),
      payload: ""
    };
    if (b64) {
      jws.payload = decoder.decode(payload);
    }
    if (this._unprotectedHeader) {
      jws.header = this._unprotectedHeader;
    }
    if (this._protectedHeader) {
      jws.protected = decoder.decode(protectedHeader);
    }
    return jws;
  }
}

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/jws/compact/sign.js
class CompactSign {
  constructor(payload) {
    this._flattened = new FlattenedSign(payload);
  }
  setProtectedHeader(protectedHeader) {
    this._flattened.setProtectedHeader(protectedHeader);
    return this;
  }
  async sign(key, options) {
    const jws = await this._flattened.sign(key, options);
    if (jws.payload === undefined) {
      throw new TypeError("use the flattened module for creating JWS with b64: false");
    }
    return `${jws.protected}.${jws.payload}.${jws.signature}`;
  }
}

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/jwt/produce.js
class ProduceJWT {
  constructor(payload) {
    if (!isObject3(payload)) {
      throw new TypeError("JWT Claims Set MUST be an object");
    }
    this._payload = payload;
  }
  setIssuer(issuer) {
    this._payload = { ...this._payload, iss: issuer };
    return this;
  }
  setSubject(subject) {
    this._payload = { ...this._payload, sub: subject };
    return this;
  }
  setAudience(audience) {
    this._payload = { ...this._payload, aud: audience };
    return this;
  }
  setJti(jwtId) {
    this._payload = { ...this._payload, jti: jwtId };
    return this;
  }
  setNotBefore(input) {
    if (typeof input === "number") {
      this._payload = { ...this._payload, nbf: input };
    } else {
      this._payload = { ...this._payload, nbf: epoch_default(new Date) + secs_default(input) };
    }
    return this;
  }
  setExpirationTime(input) {
    if (typeof input === "number") {
      this._payload = { ...this._payload, exp: input };
    } else {
      this._payload = { ...this._payload, exp: epoch_default(new Date) + secs_default(input) };
    }
    return this;
  }
  setIssuedAt(input) {
    if (typeof input === "undefined") {
      this._payload = { ...this._payload, iat: epoch_default(new Date) };
    } else {
      this._payload = { ...this._payload, iat: input };
    }
    return this;
  }
}

// node_modules/.pnpm/jose@4.15.9/node_modules/jose/dist/browser/jwt/sign.js
class SignJWT extends ProduceJWT {
  setProtectedHeader(protectedHeader) {
    this._protectedHeader = protectedHeader;
    return this;
  }
  async sign(key, options) {
    var _a;
    const sig = new CompactSign(encoder3.encode(JSON.stringify(this._payload)));
    sig.setProtectedHeader(this._protectedHeader);
    if (Array.isArray((_a = this._protectedHeader) === null || _a === undefined ? undefined : _a.crit) && this._protectedHeader.crit.includes("b64") && this._protectedHeader.b64 === false) {
      throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
    }
    return sig.sign(key, options);
  }
}
// node_modules/.pnpm/@elysiajs+jwt@1.2.0_elysia@1.2.9_@sinclair+typebox@0.34.13_openapi-types@12.1.3_/node_modules/@elysiajs/jwt/dist/index.mjs
var __defProp2 = Object.defineProperty;
var __export2 = (target, all) => {
  for (var name in all)
    __defProp2(target, name, { get: all[name], enumerable: true });
};
var value_exports = {};
__export2(value_exports, {
  HasPropertyKey: () => HasPropertyKey5,
  IsArray: () => IsArray9,
  IsAsyncIterator: () => IsAsyncIterator9,
  IsBigInt: () => IsBigInt9,
  IsBoolean: () => IsBoolean9,
  IsDate: () => IsDate9,
  IsFunction: () => IsFunction9,
  IsIterator: () => IsIterator9,
  IsNull: () => IsNull9,
  IsNumber: () => IsNumber9,
  IsObject: () => IsObject9,
  IsRegExp: () => IsRegExp7,
  IsString: () => IsString9,
  IsSymbol: () => IsSymbol9,
  IsUint8Array: () => IsUint8Array9,
  IsUndefined: () => IsUndefined9
});
function HasPropertyKey5(value, key) {
  return key in value;
}
function IsAsyncIterator9(value) {
  return IsObject9(value) && !IsArray9(value) && !IsUint8Array9(value) && Symbol.asyncIterator in value;
}
function IsArray9(value) {
  return Array.isArray(value);
}
function IsBigInt9(value) {
  return typeof value === "bigint";
}
function IsBoolean9(value) {
  return typeof value === "boolean";
}
function IsDate9(value) {
  return value instanceof globalThis.Date;
}
function IsFunction9(value) {
  return typeof value === "function";
}
function IsIterator9(value) {
  return IsObject9(value) && !IsArray9(value) && !IsUint8Array9(value) && Symbol.iterator in value;
}
function IsNull9(value) {
  return value === null;
}
function IsNumber9(value) {
  return typeof value === "number";
}
function IsObject9(value) {
  return typeof value === "object" && value !== null;
}
function IsRegExp7(value) {
  return value instanceof globalThis.RegExp;
}
function IsString9(value) {
  return typeof value === "string";
}
function IsSymbol9(value) {
  return typeof value === "symbol";
}
function IsUint8Array9(value) {
  return value instanceof globalThis.Uint8Array;
}
function IsUndefined9(value) {
  return value === undefined;
}
function ArrayType11(value) {
  return value.map((value2) => Visit33(value2));
}
function DateType7(value) {
  return new Date(value.getTime());
}
function Uint8ArrayType5(value) {
  return new Uint8Array(value);
}
function RegExpType3(value) {
  return new RegExp(value.source, value.flags);
}
function ObjectType11(value) {
  const result = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    result[key] = Visit33(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    result[key] = Visit33(value[key]);
  }
  return result;
}
function Visit33(value) {
  return IsArray9(value) ? ArrayType11(value) : IsDate9(value) ? DateType7(value) : IsUint8Array9(value) ? Uint8ArrayType5(value) : IsRegExp7(value) ? RegExpType3(value) : IsObject9(value) ? ObjectType11(value) : value;
}
function Clone5(value) {
  return Visit33(value);
}
function CloneType3(schema, options) {
  return options === undefined ? Clone5(schema) : Clone5({ ...options, ...schema });
}
function IsObject22(value) {
  return value !== null && typeof value === "object";
}
function IsArray22(value) {
  return Array.isArray(value) && !ArrayBuffer.isView(value);
}
function IsUndefined22(value) {
  return value === undefined;
}
function IsNumber22(value) {
  return typeof value === "number";
}
var TypeSystemPolicy3;
(function(TypeSystemPolicy22) {
  TypeSystemPolicy22.InstanceMode = "default";
  TypeSystemPolicy22.ExactOptionalPropertyTypes = false;
  TypeSystemPolicy22.AllowArrayObject = false;
  TypeSystemPolicy22.AllowNaN = false;
  TypeSystemPolicy22.AllowNullVoid = false;
  function IsExactOptionalProperty(value, key) {
    return TypeSystemPolicy22.ExactOptionalPropertyTypes ? key in value : value[key] !== undefined;
  }
  TypeSystemPolicy22.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value) {
    const isObject4 = IsObject22(value);
    return TypeSystemPolicy22.AllowArrayObject ? isObject4 : isObject4 && !IsArray22(value);
  }
  TypeSystemPolicy22.IsObjectLike = IsObjectLike;
  function IsRecordLike(value) {
    return IsObjectLike(value) && !(value instanceof Date) && !(value instanceof Uint8Array);
  }
  TypeSystemPolicy22.IsRecordLike = IsRecordLike;
  function IsNumberLike(value) {
    return TypeSystemPolicy22.AllowNaN ? IsNumber22(value) : Number.isFinite(value);
  }
  TypeSystemPolicy22.IsNumberLike = IsNumberLike;
  function IsVoidLike(value) {
    const isUndefined = IsUndefined22(value);
    return TypeSystemPolicy22.AllowNullVoid ? isUndefined || value === null : isUndefined;
  }
  TypeSystemPolicy22.IsVoidLike = IsVoidLike;
})(TypeSystemPolicy3 || (TypeSystemPolicy3 = {}));
function ImmutableArray3(value) {
  return globalThis.Object.freeze(value).map((value2) => Immutable3(value2));
}
function ImmutableDate3(value) {
  return value;
}
function ImmutableUint8Array3(value) {
  return value;
}
function ImmutableRegExp3(value) {
  return value;
}
function ImmutableObject3(value) {
  const result = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    result[key] = Immutable3(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    result[key] = Immutable3(value[key]);
  }
  return globalThis.Object.freeze(result);
}
function Immutable3(value) {
  return IsArray9(value) ? ImmutableArray3(value) : IsDate9(value) ? ImmutableDate3(value) : IsUint8Array9(value) ? ImmutableUint8Array3(value) : IsRegExp7(value) ? ImmutableRegExp3(value) : IsObject9(value) ? ImmutableObject3(value) : value;
}
function CreateType3(schema, options) {
  const result = options !== undefined ? { ...options, ...schema } : schema;
  switch (TypeSystemPolicy3.InstanceMode) {
    case "freeze":
      return Immutable3(result);
    case "clone":
      return Clone5(result);
    default:
      return result;
  }
}
var TypeBoxError3 = class extends Error {
  constructor(message2) {
    super(message2);
  }
};
var TransformKind4 = Symbol.for("TypeBox.Transform");
var ReadonlyKind4 = Symbol.for("TypeBox.Readonly");
var OptionalKind4 = Symbol.for("TypeBox.Optional");
var Hint4 = Symbol.for("TypeBox.Hint");
var Kind4 = Symbol.for("TypeBox.Kind");
function IsReadonly5(value) {
  return IsObject9(value) && value[ReadonlyKind4] === "Readonly";
}
function IsOptional5(value) {
  return IsObject9(value) && value[OptionalKind4] === "Optional";
}
function IsAny5(value) {
  return IsKindOf5(value, "Any");
}
function IsArray32(value) {
  return IsKindOf5(value, "Array");
}
function IsAsyncIterator22(value) {
  return IsKindOf5(value, "AsyncIterator");
}
function IsBigInt22(value) {
  return IsKindOf5(value, "BigInt");
}
function IsBoolean22(value) {
  return IsKindOf5(value, "Boolean");
}
function IsComputed5(value) {
  return IsKindOf5(value, "Computed");
}
function IsConstructor5(value) {
  return IsKindOf5(value, "Constructor");
}
function IsDate22(value) {
  return IsKindOf5(value, "Date");
}
function IsFunction22(value) {
  return IsKindOf5(value, "Function");
}
function IsInteger7(value) {
  return IsKindOf5(value, "Integer");
}
function IsIntersect5(value) {
  return IsKindOf5(value, "Intersect");
}
function IsIterator22(value) {
  return IsKindOf5(value, "Iterator");
}
function IsKindOf5(value, kind) {
  return IsObject9(value) && Kind4 in value && value[Kind4] === kind;
}
function IsLiteralValue5(value) {
  return IsBoolean9(value) || IsNumber9(value) || IsString9(value);
}
function IsLiteral5(value) {
  return IsKindOf5(value, "Literal");
}
function IsMappedKey5(value) {
  return IsKindOf5(value, "MappedKey");
}
function IsMappedResult5(value) {
  return IsKindOf5(value, "MappedResult");
}
function IsNever5(value) {
  return IsKindOf5(value, "Never");
}
function IsNot5(value) {
  return IsKindOf5(value, "Not");
}
function IsNull22(value) {
  return IsKindOf5(value, "Null");
}
function IsNumber32(value) {
  return IsKindOf5(value, "Number");
}
function IsObject32(value) {
  return IsKindOf5(value, "Object");
}
function IsPromise7(value) {
  return IsKindOf5(value, "Promise");
}
function IsRecord5(value) {
  return IsKindOf5(value, "Record");
}
function IsRef5(value) {
  return IsKindOf5(value, "Ref");
}
function IsRegExp22(value) {
  return IsKindOf5(value, "RegExp");
}
function IsString22(value) {
  return IsKindOf5(value, "String");
}
function IsSymbol22(value) {
  return IsKindOf5(value, "Symbol");
}
function IsTemplateLiteral5(value) {
  return IsKindOf5(value, "TemplateLiteral");
}
function IsThis5(value) {
  return IsKindOf5(value, "This");
}
function IsTransform5(value) {
  return IsObject9(value) && TransformKind4 in value;
}
function IsTuple5(value) {
  return IsKindOf5(value, "Tuple");
}
function IsUndefined32(value) {
  return IsKindOf5(value, "Undefined");
}
function IsUnion5(value) {
  return IsKindOf5(value, "Union");
}
function IsUint8Array22(value) {
  return IsKindOf5(value, "Uint8Array");
}
function IsUnknown5(value) {
  return IsKindOf5(value, "Unknown");
}
function IsUnsafe5(value) {
  return IsKindOf5(value, "Unsafe");
}
function IsVoid5(value) {
  return IsKindOf5(value, "Void");
}
function IsKind5(value) {
  return IsObject9(value) && Kind4 in value && IsString9(value[Kind4]);
}
function IsSchema5(value) {
  return IsAny5(value) || IsArray32(value) || IsBoolean22(value) || IsBigInt22(value) || IsAsyncIterator22(value) || IsComputed5(value) || IsConstructor5(value) || IsDate22(value) || IsFunction22(value) || IsInteger7(value) || IsIntersect5(value) || IsIterator22(value) || IsLiteral5(value) || IsMappedKey5(value) || IsMappedResult5(value) || IsNever5(value) || IsNot5(value) || IsNull22(value) || IsNumber32(value) || IsObject32(value) || IsPromise7(value) || IsRecord5(value) || IsRef5(value) || IsRegExp22(value) || IsString22(value) || IsSymbol22(value) || IsTemplateLiteral5(value) || IsThis5(value) || IsTuple5(value) || IsUndefined32(value) || IsUnion5(value) || IsUint8Array22(value) || IsUnknown5(value) || IsUnsafe5(value) || IsVoid5(value) || IsKind5(value);
}
var type_exports = {};
__export2(type_exports, {
  IsAny: () => IsAny22,
  IsArray: () => IsArray42,
  IsAsyncIterator: () => IsAsyncIterator32,
  IsBigInt: () => IsBigInt32,
  IsBoolean: () => IsBoolean32,
  IsComputed: () => IsComputed22,
  IsConstructor: () => IsConstructor22,
  IsDate: () => IsDate32,
  IsFunction: () => IsFunction32,
  IsImport: () => IsImport3,
  IsInteger: () => IsInteger22,
  IsIntersect: () => IsIntersect22,
  IsIterator: () => IsIterator32,
  IsKind: () => IsKind22,
  IsKindOf: () => IsKindOf22,
  IsLiteral: () => IsLiteral22,
  IsLiteralBoolean: () => IsLiteralBoolean3,
  IsLiteralNumber: () => IsLiteralNumber3,
  IsLiteralString: () => IsLiteralString3,
  IsLiteralValue: () => IsLiteralValue22,
  IsMappedKey: () => IsMappedKey22,
  IsMappedResult: () => IsMappedResult22,
  IsNever: () => IsNever22,
  IsNot: () => IsNot22,
  IsNull: () => IsNull32,
  IsNumber: () => IsNumber42,
  IsObject: () => IsObject42,
  IsOptional: () => IsOptional22,
  IsPromise: () => IsPromise22,
  IsProperties: () => IsProperties3,
  IsReadonly: () => IsReadonly22,
  IsRecord: () => IsRecord22,
  IsRecursive: () => IsRecursive3,
  IsRef: () => IsRef22,
  IsRegExp: () => IsRegExp32,
  IsSchema: () => IsSchema22,
  IsString: () => IsString32,
  IsSymbol: () => IsSymbol32,
  IsTemplateLiteral: () => IsTemplateLiteral22,
  IsThis: () => IsThis22,
  IsTransform: () => IsTransform22,
  IsTuple: () => IsTuple22,
  IsUint8Array: () => IsUint8Array32,
  IsUndefined: () => IsUndefined42,
  IsUnion: () => IsUnion22,
  IsUnionLiteral: () => IsUnionLiteral3,
  IsUnknown: () => IsUnknown22,
  IsUnsafe: () => IsUnsafe22,
  IsVoid: () => IsVoid22,
  TypeGuardUnknownTypeError: () => TypeGuardUnknownTypeError3
});
var TypeGuardUnknownTypeError3 = class extends TypeBoxError3 {
};
var KnownTypes3 = [
  "Any",
  "Array",
  "AsyncIterator",
  "BigInt",
  "Boolean",
  "Computed",
  "Constructor",
  "Date",
  "Enum",
  "Function",
  "Integer",
  "Intersect",
  "Iterator",
  "Literal",
  "MappedKey",
  "MappedResult",
  "Not",
  "Null",
  "Number",
  "Object",
  "Promise",
  "Record",
  "Ref",
  "RegExp",
  "String",
  "Symbol",
  "TemplateLiteral",
  "This",
  "Tuple",
  "Undefined",
  "Union",
  "Uint8Array",
  "Unknown",
  "Void"
];
function IsPattern3(value) {
  try {
    new RegExp(value);
    return true;
  } catch {
    return false;
  }
}
function IsControlCharacterFree3(value) {
  if (!IsString9(value))
    return false;
  for (let i = 0;i < value.length; i++) {
    const code = value.charCodeAt(i);
    if (code >= 7 && code <= 13 || code === 27 || code === 127) {
      return false;
    }
  }
  return true;
}
function IsAdditionalProperties3(value) {
  return IsOptionalBoolean3(value) || IsSchema22(value);
}
function IsOptionalBigInt3(value) {
  return IsUndefined9(value) || IsBigInt9(value);
}
function IsOptionalNumber3(value) {
  return IsUndefined9(value) || IsNumber9(value);
}
function IsOptionalBoolean3(value) {
  return IsUndefined9(value) || IsBoolean9(value);
}
function IsOptionalString3(value) {
  return IsUndefined9(value) || IsString9(value);
}
function IsOptionalPattern3(value) {
  return IsUndefined9(value) || IsString9(value) && IsControlCharacterFree3(value) && IsPattern3(value);
}
function IsOptionalFormat3(value) {
  return IsUndefined9(value) || IsString9(value) && IsControlCharacterFree3(value);
}
function IsOptionalSchema3(value) {
  return IsUndefined9(value) || IsSchema22(value);
}
function IsReadonly22(value) {
  return IsObject9(value) && value[ReadonlyKind4] === "Readonly";
}
function IsOptional22(value) {
  return IsObject9(value) && value[OptionalKind4] === "Optional";
}
function IsAny22(value) {
  return IsKindOf22(value, "Any") && IsOptionalString3(value.$id);
}
function IsArray42(value) {
  return IsKindOf22(value, "Array") && value.type === "array" && IsOptionalString3(value.$id) && IsSchema22(value.items) && IsOptionalNumber3(value.minItems) && IsOptionalNumber3(value.maxItems) && IsOptionalBoolean3(value.uniqueItems) && IsOptionalSchema3(value.contains) && IsOptionalNumber3(value.minContains) && IsOptionalNumber3(value.maxContains);
}
function IsAsyncIterator32(value) {
  return IsKindOf22(value, "AsyncIterator") && value.type === "AsyncIterator" && IsOptionalString3(value.$id) && IsSchema22(value.items);
}
function IsBigInt32(value) {
  return IsKindOf22(value, "BigInt") && value.type === "bigint" && IsOptionalString3(value.$id) && IsOptionalBigInt3(value.exclusiveMaximum) && IsOptionalBigInt3(value.exclusiveMinimum) && IsOptionalBigInt3(value.maximum) && IsOptionalBigInt3(value.minimum) && IsOptionalBigInt3(value.multipleOf);
}
function IsBoolean32(value) {
  return IsKindOf22(value, "Boolean") && value.type === "boolean" && IsOptionalString3(value.$id);
}
function IsComputed22(value) {
  return IsKindOf22(value, "Computed") && IsString9(value.target) && IsArray9(value.parameters) && value.parameters.every((schema) => IsSchema22(schema));
}
function IsConstructor22(value) {
  return IsKindOf22(value, "Constructor") && value.type === "Constructor" && IsOptionalString3(value.$id) && IsArray9(value.parameters) && value.parameters.every((schema) => IsSchema22(schema)) && IsSchema22(value.returns);
}
function IsDate32(value) {
  return IsKindOf22(value, "Date") && value.type === "Date" && IsOptionalString3(value.$id) && IsOptionalNumber3(value.exclusiveMaximumTimestamp) && IsOptionalNumber3(value.exclusiveMinimumTimestamp) && IsOptionalNumber3(value.maximumTimestamp) && IsOptionalNumber3(value.minimumTimestamp) && IsOptionalNumber3(value.multipleOfTimestamp);
}
function IsFunction32(value) {
  return IsKindOf22(value, "Function") && value.type === "Function" && IsOptionalString3(value.$id) && IsArray9(value.parameters) && value.parameters.every((schema) => IsSchema22(schema)) && IsSchema22(value.returns);
}
function IsImport3(value) {
  return IsKindOf22(value, "Import") && HasPropertyKey5(value, "$defs") && IsObject9(value.$defs) && IsProperties3(value.$defs) && HasPropertyKey5(value, "$ref") && IsString9(value.$ref) && value.$ref in value.$defs;
}
function IsInteger22(value) {
  return IsKindOf22(value, "Integer") && value.type === "integer" && IsOptionalString3(value.$id) && IsOptionalNumber3(value.exclusiveMaximum) && IsOptionalNumber3(value.exclusiveMinimum) && IsOptionalNumber3(value.maximum) && IsOptionalNumber3(value.minimum) && IsOptionalNumber3(value.multipleOf);
}
function IsProperties3(value) {
  return IsObject9(value) && Object.entries(value).every(([key, schema]) => IsControlCharacterFree3(key) && IsSchema22(schema));
}
function IsIntersect22(value) {
  return IsKindOf22(value, "Intersect") && (IsString9(value.type) && value.type !== "object" ? false : true) && IsArray9(value.allOf) && value.allOf.every((schema) => IsSchema22(schema) && !IsTransform22(schema)) && IsOptionalString3(value.type) && (IsOptionalBoolean3(value.unevaluatedProperties) || IsOptionalSchema3(value.unevaluatedProperties)) && IsOptionalString3(value.$id);
}
function IsIterator32(value) {
  return IsKindOf22(value, "Iterator") && value.type === "Iterator" && IsOptionalString3(value.$id) && IsSchema22(value.items);
}
function IsKindOf22(value, kind) {
  return IsObject9(value) && Kind4 in value && value[Kind4] === kind;
}
function IsLiteralString3(value) {
  return IsLiteral22(value) && IsString9(value.const);
}
function IsLiteralNumber3(value) {
  return IsLiteral22(value) && IsNumber9(value.const);
}
function IsLiteralBoolean3(value) {
  return IsLiteral22(value) && IsBoolean9(value.const);
}
function IsLiteral22(value) {
  return IsKindOf22(value, "Literal") && IsOptionalString3(value.$id) && IsLiteralValue22(value.const);
}
function IsLiteralValue22(value) {
  return IsBoolean9(value) || IsNumber9(value) || IsString9(value);
}
function IsMappedKey22(value) {
  return IsKindOf22(value, "MappedKey") && IsArray9(value.keys) && value.keys.every((key) => IsNumber9(key) || IsString9(key));
}
function IsMappedResult22(value) {
  return IsKindOf22(value, "MappedResult") && IsProperties3(value.properties);
}
function IsNever22(value) {
  return IsKindOf22(value, "Never") && IsObject9(value.not) && Object.getOwnPropertyNames(value.not).length === 0;
}
function IsNot22(value) {
  return IsKindOf22(value, "Not") && IsSchema22(value.not);
}
function IsNull32(value) {
  return IsKindOf22(value, "Null") && value.type === "null" && IsOptionalString3(value.$id);
}
function IsNumber42(value) {
  return IsKindOf22(value, "Number") && value.type === "number" && IsOptionalString3(value.$id) && IsOptionalNumber3(value.exclusiveMaximum) && IsOptionalNumber3(value.exclusiveMinimum) && IsOptionalNumber3(value.maximum) && IsOptionalNumber3(value.minimum) && IsOptionalNumber3(value.multipleOf);
}
function IsObject42(value) {
  return IsKindOf22(value, "Object") && value.type === "object" && IsOptionalString3(value.$id) && IsProperties3(value.properties) && IsAdditionalProperties3(value.additionalProperties) && IsOptionalNumber3(value.minProperties) && IsOptionalNumber3(value.maxProperties);
}
function IsPromise22(value) {
  return IsKindOf22(value, "Promise") && value.type === "Promise" && IsOptionalString3(value.$id) && IsSchema22(value.item);
}
function IsRecord22(value) {
  return IsKindOf22(value, "Record") && value.type === "object" && IsOptionalString3(value.$id) && IsAdditionalProperties3(value.additionalProperties) && IsObject9(value.patternProperties) && ((schema) => {
    const keys = Object.getOwnPropertyNames(schema.patternProperties);
    return keys.length === 1 && IsPattern3(keys[0]) && IsObject9(schema.patternProperties) && IsSchema22(schema.patternProperties[keys[0]]);
  })(value);
}
function IsRecursive3(value) {
  return IsObject9(value) && Hint4 in value && value[Hint4] === "Recursive";
}
function IsRef22(value) {
  return IsKindOf22(value, "Ref") && IsOptionalString3(value.$id) && IsString9(value.$ref);
}
function IsRegExp32(value) {
  return IsKindOf22(value, "RegExp") && IsOptionalString3(value.$id) && IsString9(value.source) && IsString9(value.flags) && IsOptionalNumber3(value.maxLength) && IsOptionalNumber3(value.minLength);
}
function IsString32(value) {
  return IsKindOf22(value, "String") && value.type === "string" && IsOptionalString3(value.$id) && IsOptionalNumber3(value.minLength) && IsOptionalNumber3(value.maxLength) && IsOptionalPattern3(value.pattern) && IsOptionalFormat3(value.format);
}
function IsSymbol32(value) {
  return IsKindOf22(value, "Symbol") && value.type === "symbol" && IsOptionalString3(value.$id);
}
function IsTemplateLiteral22(value) {
  return IsKindOf22(value, "TemplateLiteral") && value.type === "string" && IsString9(value.pattern) && value.pattern[0] === "^" && value.pattern[value.pattern.length - 1] === "$";
}
function IsThis22(value) {
  return IsKindOf22(value, "This") && IsOptionalString3(value.$id) && IsString9(value.$ref);
}
function IsTransform22(value) {
  return IsObject9(value) && TransformKind4 in value;
}
function IsTuple22(value) {
  return IsKindOf22(value, "Tuple") && value.type === "array" && IsOptionalString3(value.$id) && IsNumber9(value.minItems) && IsNumber9(value.maxItems) && value.minItems === value.maxItems && (IsUndefined9(value.items) && IsUndefined9(value.additionalItems) && value.minItems === 0 || IsArray9(value.items) && value.items.every((schema) => IsSchema22(schema)));
}
function IsUndefined42(value) {
  return IsKindOf22(value, "Undefined") && value.type === "undefined" && IsOptionalString3(value.$id);
}
function IsUnionLiteral3(value) {
  return IsUnion22(value) && value.anyOf.every((schema) => IsLiteralString3(schema) || IsLiteralNumber3(schema));
}
function IsUnion22(value) {
  return IsKindOf22(value, "Union") && IsOptionalString3(value.$id) && IsObject9(value) && IsArray9(value.anyOf) && value.anyOf.every((schema) => IsSchema22(schema));
}
function IsUint8Array32(value) {
  return IsKindOf22(value, "Uint8Array") && value.type === "Uint8Array" && IsOptionalString3(value.$id) && IsOptionalNumber3(value.minByteLength) && IsOptionalNumber3(value.maxByteLength);
}
function IsUnknown22(value) {
  return IsKindOf22(value, "Unknown") && IsOptionalString3(value.$id);
}
function IsUnsafe22(value) {
  return IsKindOf22(value, "Unsafe");
}
function IsVoid22(value) {
  return IsKindOf22(value, "Void") && value.type === "void" && IsOptionalString3(value.$id);
}
function IsKind22(value) {
  return IsObject9(value) && Kind4 in value && IsString9(value[Kind4]) && !KnownTypes3.includes(value[Kind4]);
}
function IsSchema22(value) {
  return IsObject9(value) && (IsAny22(value) || IsArray42(value) || IsBoolean32(value) || IsBigInt32(value) || IsAsyncIterator32(value) || IsComputed22(value) || IsConstructor22(value) || IsDate32(value) || IsFunction32(value) || IsInteger22(value) || IsIntersect22(value) || IsIterator32(value) || IsLiteral22(value) || IsMappedKey22(value) || IsMappedResult22(value) || IsNever22(value) || IsNot22(value) || IsNull32(value) || IsNumber42(value) || IsObject42(value) || IsPromise22(value) || IsRecord22(value) || IsRef22(value) || IsRegExp32(value) || IsString32(value) || IsSymbol32(value) || IsTemplateLiteral22(value) || IsThis22(value) || IsTuple22(value) || IsUndefined42(value) || IsUnion22(value) || IsUint8Array32(value) || IsUnknown22(value) || IsUnsafe22(value) || IsVoid22(value) || IsKind22(value));
}
var PatternBoolean3 = "(true|false)";
var PatternNumber3 = "(0|[1-9][0-9]*)";
var PatternString3 = "(.*)";
var PatternNever3 = "(?!.*)";
var PatternBooleanExact3 = `^${PatternBoolean3}$`;
var PatternNumberExact3 = `^${PatternNumber3}$`;
var PatternStringExact3 = `^${PatternString3}$`;
var PatternNeverExact3 = `^${PatternNever3}$`;
function SetIncludes3(T, S) {
  return T.includes(S);
}
function SetDistinct3(T) {
  return [...new Set(T)];
}
function SetIntersect3(T, S) {
  return T.filter((L) => S.includes(L));
}
function SetIntersectManyResolve3(T, Init) {
  return T.reduce((Acc, L) => {
    return SetIntersect3(Acc, L);
  }, Init);
}
function SetIntersectMany3(T) {
  return T.length === 1 ? T[0] : T.length > 1 ? SetIntersectManyResolve3(T.slice(1), T[0]) : [];
}
function SetUnionMany3(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...L);
  return Acc;
}
function Any3(options) {
  return CreateType3({ [Kind4]: "Any" }, options);
}
function Array22(items, options) {
  return CreateType3({ [Kind4]: "Array", type: "array", items }, options);
}
function AsyncIterator3(items, options) {
  return CreateType3({ [Kind4]: "AsyncIterator", type: "AsyncIterator", items }, options);
}
function Computed3(target, parameters, options) {
  return CreateType3({ [Kind4]: "Computed", target, parameters }, options);
}
function DiscardKey3(value, key) {
  const { [key]: _3, ...rest } = value;
  return rest;
}
function Discard3(value, keys) {
  return keys.reduce((acc, key) => DiscardKey3(acc, key), value);
}
function Never3(options) {
  return CreateType3({ [Kind4]: "Never", not: {} }, options);
}
function MappedResult3(properties) {
  return CreateType3({
    [Kind4]: "MappedResult",
    properties
  });
}
function Constructor3(parameters, returns, options) {
  return CreateType3({ [Kind4]: "Constructor", type: "Constructor", parameters, returns }, options);
}
function Function4(parameters, returns, options) {
  return CreateType3({ [Kind4]: "Function", type: "Function", parameters, returns }, options);
}
function UnionCreate3(T, options) {
  return CreateType3({ [Kind4]: "Union", anyOf: T }, options);
}
function IsUnionOptional3(types2) {
  return types2.some((type) => IsOptional5(type));
}
function RemoveOptionalFromRest5(types2) {
  return types2.map((left) => IsOptional5(left) ? RemoveOptionalFromType5(left) : left);
}
function RemoveOptionalFromType5(T) {
  return Discard3(T, [OptionalKind4]);
}
function ResolveUnion3(types2, options) {
  const isOptional3 = IsUnionOptional3(types2);
  return isOptional3 ? Optional3(UnionCreate3(RemoveOptionalFromRest5(types2), options)) : UnionCreate3(RemoveOptionalFromRest5(types2), options);
}
function UnionEvaluated3(T, options) {
  return T.length === 1 ? CreateType3(T[0], options) : T.length === 0 ? Never3(options) : ResolveUnion3(T, options);
}
function Union5(types2, options) {
  return types2.length === 0 ? Never3(options) : types2.length === 1 ? CreateType3(types2[0], options) : UnionCreate3(types2, options);
}
var TemplateLiteralParserError3 = class extends TypeBoxError3 {
};
function Unescape3(pattern) {
  return pattern.replace(/\\\$/g, "$").replace(/\\\*/g, "*").replace(/\\\^/g, "^").replace(/\\\|/g, "|").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}
function IsNonEscaped3(pattern, index, char) {
  return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
}
function IsOpenParen3(pattern, index) {
  return IsNonEscaped3(pattern, index, "(");
}
function IsCloseParen3(pattern, index) {
  return IsNonEscaped3(pattern, index, ")");
}
function IsSeparator3(pattern, index) {
  return IsNonEscaped3(pattern, index, "|");
}
function IsGroup3(pattern) {
  if (!(IsOpenParen3(pattern, 0) && IsCloseParen3(pattern, pattern.length - 1)))
    return false;
  let count = 0;
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen3(pattern, index))
      count += 1;
    if (IsCloseParen3(pattern, index))
      count -= 1;
    if (count === 0 && index !== pattern.length - 1)
      return false;
  }
  return true;
}
function InGroup3(pattern) {
  return pattern.slice(1, pattern.length - 1);
}
function IsPrecedenceOr3(pattern) {
  let count = 0;
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen3(pattern, index))
      count += 1;
    if (IsCloseParen3(pattern, index))
      count -= 1;
    if (IsSeparator3(pattern, index) && count === 0)
      return true;
  }
  return false;
}
function IsPrecedenceAnd3(pattern) {
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen3(pattern, index))
      return true;
  }
  return false;
}
function Or3(pattern) {
  let [count, start] = [0, 0];
  const expressions = [];
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen3(pattern, index))
      count += 1;
    if (IsCloseParen3(pattern, index))
      count -= 1;
    if (IsSeparator3(pattern, index) && count === 0) {
      const range2 = pattern.slice(start, index);
      if (range2.length > 0)
        expressions.push(TemplateLiteralParse3(range2));
      start = index + 1;
    }
  }
  const range = pattern.slice(start);
  if (range.length > 0)
    expressions.push(TemplateLiteralParse3(range));
  if (expressions.length === 0)
    return { type: "const", const: "" };
  if (expressions.length === 1)
    return expressions[0];
  return { type: "or", expr: expressions };
}
function And3(pattern) {
  function Group(value, index) {
    if (!IsOpenParen3(value, index))
      throw new TemplateLiteralParserError3(`TemplateLiteralParser: Index must point to open parens`);
    let count = 0;
    for (let scan = index;scan < value.length; scan++) {
      if (IsOpenParen3(value, scan))
        count += 1;
      if (IsCloseParen3(value, scan))
        count -= 1;
      if (count === 0)
        return [index, scan];
    }
    throw new TemplateLiteralParserError3(`TemplateLiteralParser: Unclosed group parens in expression`);
  }
  function Range(pattern2, index) {
    for (let scan = index;scan < pattern2.length; scan++) {
      if (IsOpenParen3(pattern2, scan))
        return [index, scan];
    }
    return [index, pattern2.length];
  }
  const expressions = [];
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen3(pattern, index)) {
      const [start, end] = Group(pattern, index);
      const range = pattern.slice(start, end + 1);
      expressions.push(TemplateLiteralParse3(range));
      index = end;
    } else {
      const [start, end] = Range(pattern, index);
      const range = pattern.slice(start, end);
      if (range.length > 0)
        expressions.push(TemplateLiteralParse3(range));
      index = end - 1;
    }
  }
  return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
}
function TemplateLiteralParse3(pattern) {
  return IsGroup3(pattern) ? TemplateLiteralParse3(InGroup3(pattern)) : IsPrecedenceOr3(pattern) ? Or3(pattern) : IsPrecedenceAnd3(pattern) ? And3(pattern) : { type: "const", const: Unescape3(pattern) };
}
function TemplateLiteralParseExact3(pattern) {
  return TemplateLiteralParse3(pattern.slice(1, pattern.length - 1));
}
var TemplateLiteralFiniteError3 = class extends TypeBoxError3 {
};
function IsNumberExpression3(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
}
function IsBooleanExpression3(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
}
function IsStringExpression3(expression) {
  return expression.type === "const" && expression.const === ".*";
}
function IsTemplateLiteralExpressionFinite3(expression) {
  return IsNumberExpression3(expression) || IsStringExpression3(expression) ? false : IsBooleanExpression3(expression) ? true : expression.type === "and" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite3(expr)) : expression.type === "or" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite3(expr)) : expression.type === "const" ? true : (() => {
    throw new TemplateLiteralFiniteError3(`Unknown expression type`);
  })();
}
function IsTemplateLiteralFinite3(schema) {
  const expression = TemplateLiteralParseExact3(schema.pattern);
  return IsTemplateLiteralExpressionFinite3(expression);
}
var TemplateLiteralGenerateError3 = class extends TypeBoxError3 {
};
function* GenerateReduce3(buffer) {
  if (buffer.length === 1)
    return yield* buffer[0];
  for (const left of buffer[0]) {
    for (const right of GenerateReduce3(buffer.slice(1))) {
      yield `${left}${right}`;
    }
  }
}
function* GenerateAnd3(expression) {
  return yield* GenerateReduce3(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate3(expr)]));
}
function* GenerateOr3(expression) {
  for (const expr of expression.expr)
    yield* TemplateLiteralExpressionGenerate3(expr);
}
function* GenerateConst3(expression) {
  return yield expression.const;
}
function* TemplateLiteralExpressionGenerate3(expression) {
  return expression.type === "and" ? yield* GenerateAnd3(expression) : expression.type === "or" ? yield* GenerateOr3(expression) : expression.type === "const" ? yield* GenerateConst3(expression) : (() => {
    throw new TemplateLiteralGenerateError3("Unknown expression");
  })();
}
function TemplateLiteralGenerate3(schema) {
  const expression = TemplateLiteralParseExact3(schema.pattern);
  return IsTemplateLiteralExpressionFinite3(expression) ? [...TemplateLiteralExpressionGenerate3(expression)] : [];
}
function Literal3(value, options) {
  return CreateType3({
    [Kind4]: "Literal",
    const: value,
    type: typeof value
  }, options);
}
function Boolean4(options) {
  return CreateType3({ [Kind4]: "Boolean", type: "boolean" }, options);
}
function BigInt4(options) {
  return CreateType3({ [Kind4]: "BigInt", type: "bigint" }, options);
}
function Number22(options) {
  return CreateType3({ [Kind4]: "Number", type: "number" }, options);
}
function String4(options) {
  return CreateType3({ [Kind4]: "String", type: "string" }, options);
}
function* FromUnion39(syntax) {
  const trim = syntax.trim().replace(/"|'/g, "");
  return trim === "boolean" ? yield Boolean4() : trim === "number" ? yield Number22() : trim === "bigint" ? yield BigInt4() : trim === "string" ? yield String4() : yield (() => {
    const literals = trim.split("|").map((literal) => Literal3(literal.trim()));
    return literals.length === 0 ? Never3() : literals.length === 1 ? literals[0] : UnionEvaluated3(literals);
  })();
}
function* FromTerminal3(syntax) {
  if (syntax[1] !== "{") {
    const L = Literal3("$");
    const R = FromSyntax3(syntax.slice(1));
    return yield* [L, ...R];
  }
  for (let i = 2;i < syntax.length; i++) {
    if (syntax[i] === "}") {
      const L = FromUnion39(syntax.slice(2, i));
      const R = FromSyntax3(syntax.slice(i + 1));
      return yield* [...L, ...R];
    }
  }
  yield Literal3(syntax);
}
function* FromSyntax3(syntax) {
  for (let i = 0;i < syntax.length; i++) {
    if (syntax[i] === "$") {
      const L = Literal3(syntax.slice(0, i));
      const R = FromTerminal3(syntax.slice(i));
      return yield* [L, ...R];
    }
  }
  yield Literal3(syntax);
}
function TemplateLiteralSyntax3(syntax) {
  return [...FromSyntax3(syntax)];
}
var TemplateLiteralPatternError3 = class extends TypeBoxError3 {
};
function Escape5(value) {
  return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Visit210(schema, acc) {
  return IsTemplateLiteral5(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) : IsUnion5(schema) ? `(${schema.anyOf.map((schema2) => Visit210(schema2, acc)).join("|")})` : IsNumber32(schema) ? `${acc}${PatternNumber3}` : IsInteger7(schema) ? `${acc}${PatternNumber3}` : IsBigInt22(schema) ? `${acc}${PatternNumber3}` : IsString22(schema) ? `${acc}${PatternString3}` : IsLiteral5(schema) ? `${acc}${Escape5(schema.const.toString())}` : IsBoolean22(schema) ? `${acc}${PatternBoolean3}` : (() => {
    throw new TemplateLiteralPatternError3(`Unexpected Kind '${schema[Kind4]}'`);
  })();
}
function TemplateLiteralPattern3(kinds) {
  return `^${kinds.map((schema) => Visit210(schema, "")).join("")}$`;
}
function TemplateLiteralToUnion3(schema) {
  const R = TemplateLiteralGenerate3(schema);
  const L = R.map((S) => Literal3(S));
  return UnionEvaluated3(L);
}
function TemplateLiteral3(unresolved, options) {
  const pattern = IsString9(unresolved) ? TemplateLiteralPattern3(TemplateLiteralSyntax3(unresolved)) : TemplateLiteralPattern3(unresolved);
  return CreateType3({ [Kind4]: "TemplateLiteral", type: "string", pattern }, options);
}
function FromTemplateLiteral13(templateLiteral) {
  const keys = TemplateLiteralGenerate3(templateLiteral);
  return keys.map((key) => key.toString());
}
function FromUnion210(types2) {
  const result = [];
  for (const type of types2)
    result.push(...IndexPropertyKeys3(type));
  return result;
}
function FromLiteral13(literalValue) {
  return [literalValue.toString()];
}
function IndexPropertyKeys3(type) {
  return [...new Set(IsTemplateLiteral5(type) ? FromTemplateLiteral13(type) : IsUnion5(type) ? FromUnion210(type.anyOf) : IsLiteral5(type) ? FromLiteral13(type.const) : IsNumber32(type) ? ["[number]"] : IsInteger7(type) ? ["[number]"] : [])];
}
function FromProperties37(type, properties, options) {
  const result = {};
  for (const K2 of Object.getOwnPropertyNames(properties)) {
    result[K2] = Index3(type, IndexPropertyKeys3(properties[K2]), options);
  }
  return result;
}
function FromMappedResult25(type, mappedResult, options) {
  return FromProperties37(type, mappedResult.properties, options);
}
function IndexFromMappedResult3(type, mappedResult, options) {
  const properties = FromMappedResult25(type, mappedResult, options);
  return MappedResult3(properties);
}
function FromRest17(types2, key) {
  return types2.map((type) => IndexFromPropertyKey3(type, key));
}
function FromIntersectRest3(types2) {
  return types2.filter((type) => !IsNever5(type));
}
function FromIntersect35(types2, key) {
  return IntersectEvaluated3(FromIntersectRest3(FromRest17(types2, key)));
}
function FromUnionRest3(types2) {
  return types2.some((L) => IsNever5(L)) ? [] : types2;
}
function FromUnion310(types2, key) {
  return UnionEvaluated3(FromUnionRest3(FromRest17(types2, key)));
}
function FromTuple29(types2, key) {
  return key in types2 ? types2[key] : key === "[number]" ? UnionEvaluated3(types2) : Never3();
}
function FromArray33(type, key) {
  return key === "[number]" ? type : Never3();
}
function FromProperty5(properties, propertyKey) {
  return propertyKey in properties ? properties[propertyKey] : Never3();
}
function IndexFromPropertyKey3(type, propertyKey) {
  return IsIntersect5(type) ? FromIntersect35(type.allOf, propertyKey) : IsUnion5(type) ? FromUnion310(type.anyOf, propertyKey) : IsTuple5(type) ? FromTuple29(type.items ?? [], propertyKey) : IsArray32(type) ? FromArray33(type.items, propertyKey) : IsObject32(type) ? FromProperty5(type.properties, propertyKey) : Never3();
}
function IndexFromPropertyKeys3(type, propertyKeys) {
  return propertyKeys.map((propertyKey) => IndexFromPropertyKey3(type, propertyKey));
}
function FromSchema3(type, propertyKeys) {
  return UnionEvaluated3(IndexFromPropertyKeys3(type, propertyKeys));
}
function Index3(type, key, options) {
  if (IsRef5(type) || IsRef5(key)) {
    const error3 = `Index types using Ref parameters require both Type and Key to be of TSchema`;
    if (!IsSchema5(type) || !IsSchema5(key))
      throw new TypeBoxError3(error3);
    return Computed3("Index", [type, key]);
  }
  if (IsMappedResult5(key))
    return IndexFromMappedResult3(type, key, options);
  if (IsMappedKey5(key))
    return IndexFromMappedKey3(type, key, options);
  return CreateType3(IsSchema5(key) ? FromSchema3(type, IndexPropertyKeys3(key)) : FromSchema3(type, key), options);
}
function MappedIndexPropertyKey3(type, key, options) {
  return { [key]: Index3(type, [key], Clone5(options)) };
}
function MappedIndexPropertyKeys3(type, propertyKeys, options) {
  return propertyKeys.reduce((result, left) => {
    return { ...result, ...MappedIndexPropertyKey3(type, left, options) };
  }, {});
}
function MappedIndexProperties3(type, mappedKey, options) {
  return MappedIndexPropertyKeys3(type, mappedKey.keys, options);
}
function IndexFromMappedKey3(type, mappedKey, options) {
  const properties = MappedIndexProperties3(type, mappedKey, options);
  return MappedResult3(properties);
}
function Iterator3(items, options) {
  return CreateType3({ [Kind4]: "Iterator", type: "Iterator", items }, options);
}
function RequiredKeys3(properties) {
  const keys = [];
  for (let key in properties) {
    if (!IsOptional5(properties[key]))
      keys.push(key);
  }
  return keys;
}
function _Object3(properties, options) {
  const required = RequiredKeys3(properties);
  const schematic = required.length > 0 ? { [Kind4]: "Object", type: "object", properties, required } : { [Kind4]: "Object", type: "object", properties };
  return CreateType3(schematic, options);
}
var Object22 = _Object3;
function Promise22(item, options) {
  return CreateType3({ [Kind4]: "Promise", type: "Promise", item }, options);
}
function RemoveReadonly3(schema) {
  return CreateType3(Discard3(schema, [ReadonlyKind4]));
}
function AddReadonly3(schema) {
  return CreateType3({ ...schema, [ReadonlyKind4]: "Readonly" });
}
function ReadonlyWithFlag3(schema, F) {
  return F === false ? RemoveReadonly3(schema) : AddReadonly3(schema);
}
function Readonly3(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult5(schema) ? ReadonlyFromMappedResult3(schema, F) : ReadonlyWithFlag3(schema, F);
}
function FromProperties210(K2, F) {
  const Acc = {};
  for (const K22 of globalThis.Object.getOwnPropertyNames(K2))
    Acc[K22] = Readonly3(K2[K22], F);
  return Acc;
}
function FromMappedResult26(R, F) {
  return FromProperties210(R.properties, F);
}
function ReadonlyFromMappedResult3(R, F) {
  const P = FromMappedResult26(R, F);
  return MappedResult3(P);
}
function Tuple3(types2, options) {
  return CreateType3(types2.length > 0 ? { [Kind4]: "Tuple", type: "array", items: types2, additionalItems: false, minItems: types2.length, maxItems: types2.length } : { [Kind4]: "Tuple", type: "array", minItems: types2.length, maxItems: types2.length }, options);
}
function FromMappedResult32(K2, P) {
  return K2 in P ? FromSchemaType3(K2, P[K2]) : MappedResult3(P);
}
function MappedKeyToKnownMappedResultProperties3(K2) {
  return { [K2]: Literal3(K2) };
}
function MappedKeyToUnknownMappedResultProperties3(P) {
  const Acc = {};
  for (const L of P)
    Acc[L] = Literal3(L);
  return Acc;
}
function MappedKeyToMappedResultProperties3(K2, P) {
  return SetIncludes3(P, K2) ? MappedKeyToKnownMappedResultProperties3(K2) : MappedKeyToUnknownMappedResultProperties3(P);
}
function FromMappedKey9(K2, P) {
  const R = MappedKeyToMappedResultProperties3(K2, P);
  return FromMappedResult32(K2, R);
}
function FromRest22(K2, T) {
  return T.map((L) => FromSchemaType3(K2, L));
}
function FromProperties38(K2, T) {
  const Acc = {};
  for (const K22 of globalThis.Object.getOwnPropertyNames(T))
    Acc[K22] = FromSchemaType3(K2, T[K22]);
  return Acc;
}
function FromSchemaType3(K2, T) {
  const options = { ...T };
  return IsOptional5(T) ? Optional3(FromSchemaType3(K2, Discard3(T, [OptionalKind4]))) : IsReadonly5(T) ? Readonly3(FromSchemaType3(K2, Discard3(T, [ReadonlyKind4]))) : IsMappedResult5(T) ? FromMappedResult32(K2, T.properties) : IsMappedKey5(T) ? FromMappedKey9(K2, T.keys) : IsConstructor5(T) ? Constructor3(FromRest22(K2, T.parameters), FromSchemaType3(K2, T.returns), options) : IsFunction22(T) ? Function4(FromRest22(K2, T.parameters), FromSchemaType3(K2, T.returns), options) : IsAsyncIterator22(T) ? AsyncIterator3(FromSchemaType3(K2, T.items), options) : IsIterator22(T) ? Iterator3(FromSchemaType3(K2, T.items), options) : IsIntersect5(T) ? Intersect5(FromRest22(K2, T.allOf), options) : IsUnion5(T) ? Union5(FromRest22(K2, T.anyOf), options) : IsTuple5(T) ? Tuple3(FromRest22(K2, T.items ?? []), options) : IsObject32(T) ? Object22(FromProperties38(K2, T.properties), options) : IsArray32(T) ? Array22(FromSchemaType3(K2, T.items), options) : IsPromise7(T) ? Promise22(FromSchemaType3(K2, T.item), options) : T;
}
function MappedFunctionReturnType3(K2, T) {
  const Acc = {};
  for (const L of K2)
    Acc[L] = FromSchemaType3(L, T);
  return Acc;
}
function Mapped3(key, map5, options) {
  const K2 = IsSchema5(key) ? IndexPropertyKeys3(key) : key;
  const RT = map5({ [Kind4]: "MappedKey", keys: K2 });
  const R = MappedFunctionReturnType3(K2, RT);
  return Object22(R, options);
}
function RemoveOptional3(schema) {
  return CreateType3(Discard3(schema, [OptionalKind4]));
}
function AddOptional3(schema) {
  return CreateType3({ ...schema, [OptionalKind4]: "Optional" });
}
function OptionalWithFlag3(schema, F) {
  return F === false ? RemoveOptional3(schema) : AddOptional3(schema);
}
function Optional3(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult5(schema) ? OptionalFromMappedResult3(schema, F) : OptionalWithFlag3(schema, F);
}
function FromProperties42(P, F) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Optional3(P[K2], F);
  return Acc;
}
function FromMappedResult42(R, F) {
  return FromProperties42(R.properties, F);
}
function OptionalFromMappedResult3(R, F) {
  const P = FromMappedResult42(R, F);
  return MappedResult3(P);
}
function IntersectCreate3(T, options = {}) {
  const allObjects = T.every((schema) => IsObject32(schema));
  const clonedUnevaluatedProperties = IsSchema5(options.unevaluatedProperties) ? { unevaluatedProperties: options.unevaluatedProperties } : {};
  return CreateType3(options.unevaluatedProperties === false || IsSchema5(options.unevaluatedProperties) || allObjects ? { ...clonedUnevaluatedProperties, [Kind4]: "Intersect", type: "object", allOf: T } : { ...clonedUnevaluatedProperties, [Kind4]: "Intersect", allOf: T }, options);
}
function IsIntersectOptional3(types2) {
  return types2.every((left) => IsOptional5(left));
}
function RemoveOptionalFromType22(type) {
  return Discard3(type, [OptionalKind4]);
}
function RemoveOptionalFromRest22(types2) {
  return types2.map((left) => IsOptional5(left) ? RemoveOptionalFromType22(left) : left);
}
function ResolveIntersect3(types2, options) {
  return IsIntersectOptional3(types2) ? Optional3(IntersectCreate3(RemoveOptionalFromRest22(types2), options)) : IntersectCreate3(RemoveOptionalFromRest22(types2), options);
}
function IntersectEvaluated3(types2, options = {}) {
  if (types2.length === 1)
    return CreateType3(types2[0], options);
  if (types2.length === 0)
    return Never3(options);
  if (types2.some((schema) => IsTransform5(schema)))
    throw new Error("Cannot intersect transform types");
  return ResolveIntersect3(types2, options);
}
function Intersect5(types2, options) {
  if (types2.length === 1)
    return CreateType3(types2[0], options);
  if (types2.length === 0)
    return Never3(options);
  if (types2.some((schema) => IsTransform5(schema)))
    throw new Error("Cannot intersect transform types");
  return IntersectCreate3(types2, options);
}
function Ref3(...args) {
  const [$ref, options] = typeof args[0] === "string" ? [args[0], args[1]] : [args[0].$id, args[1]];
  if (typeof $ref !== "string")
    throw new TypeBoxError3("Ref: $ref must be a string");
  return CreateType3({ [Kind4]: "Ref", $ref }, options);
}
function FromComputed11(target, parameters) {
  return Computed3("Awaited", [Computed3(target, parameters)]);
}
function FromRef29($ref) {
  return Computed3("Awaited", [Ref3($ref)]);
}
function FromIntersect210(types2) {
  return Intersect5(FromRest32(types2));
}
function FromUnion42(types2) {
  return Union5(FromRest32(types2));
}
function FromPromise13(type) {
  return Awaited3(type);
}
function FromRest32(types2) {
  return types2.map((type) => Awaited3(type));
}
function Awaited3(type, options) {
  return CreateType3(IsComputed5(type) ? FromComputed11(type.target, type.parameters) : IsIntersect5(type) ? FromIntersect210(type.allOf) : IsUnion5(type) ? FromUnion42(type.anyOf) : IsPromise7(type) ? FromPromise13(type.item) : IsRef5(type) ? FromRef29(type.$ref) : type, options);
}
function FromRest42(types2) {
  const result = [];
  for (const L of types2)
    result.push(KeyOfPropertyKeys3(L));
  return result;
}
function FromIntersect36(types2) {
  const propertyKeysArray = FromRest42(types2);
  const propertyKeys = SetUnionMany3(propertyKeysArray);
  return propertyKeys;
}
function FromUnion52(types2) {
  const propertyKeysArray = FromRest42(types2);
  const propertyKeys = SetIntersectMany3(propertyKeysArray);
  return propertyKeys;
}
function FromTuple210(types2) {
  return types2.map((_3, indexer) => indexer.toString());
}
function FromArray210(_3) {
  return ["[number]"];
}
function FromProperties52(T) {
  return globalThis.Object.getOwnPropertyNames(T);
}
function FromPatternProperties3(patternProperties) {
  if (!includePatternProperties3)
    return [];
  const patternPropertyKeys = globalThis.Object.getOwnPropertyNames(patternProperties);
  return patternPropertyKeys.map((key) => {
    return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
  });
}
function KeyOfPropertyKeys3(type) {
  return IsIntersect5(type) ? FromIntersect36(type.allOf) : IsUnion5(type) ? FromUnion52(type.anyOf) : IsTuple5(type) ? FromTuple210(type.items ?? []) : IsArray32(type) ? FromArray210(type.items) : IsObject32(type) ? FromProperties52(type.properties) : IsRecord5(type) ? FromPatternProperties3(type.patternProperties) : [];
}
var includePatternProperties3 = false;
function FromComputed22(target, parameters) {
  return Computed3("KeyOf", [Computed3(target, parameters)]);
}
function FromRef210($ref) {
  return Computed3("KeyOf", [Ref3($ref)]);
}
function KeyOfFromType3(type, options) {
  const propertyKeys = KeyOfPropertyKeys3(type);
  const propertyKeyTypes = KeyOfPropertyKeysToRest3(propertyKeys);
  const result = UnionEvaluated3(propertyKeyTypes);
  return CreateType3(result, options);
}
function KeyOfPropertyKeysToRest3(propertyKeys) {
  return propertyKeys.map((L) => L === "[number]" ? Number22() : Literal3(L));
}
function KeyOf3(type, options) {
  return IsComputed5(type) ? FromComputed22(type.target, type.parameters) : IsRef5(type) ? FromRef210(type.$ref) : IsMappedResult5(type) ? KeyOfFromMappedResult3(type, options) : KeyOfFromType3(type, options);
}
function FromProperties62(properties, options) {
  const result = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
    result[K2] = KeyOf3(properties[K2], Clone5(options));
  return result;
}
function FromMappedResult52(mappedResult, options) {
  return FromProperties62(mappedResult.properties, options);
}
function KeyOfFromMappedResult3(mappedResult, options) {
  const properties = FromMappedResult52(mappedResult, options);
  return MappedResult3(properties);
}
function CompositeKeys3(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...KeyOfPropertyKeys3(L));
  return SetDistinct3(Acc);
}
function FilterNever3(T) {
  return T.filter((L) => !IsNever5(L));
}
function CompositeProperty3(T, K2) {
  const Acc = [];
  for (const L of T)
    Acc.push(...IndexFromPropertyKeys3(L, [K2]));
  return FilterNever3(Acc);
}
function CompositeProperties3(T, K2) {
  const Acc = {};
  for (const L of K2) {
    Acc[L] = IntersectEvaluated3(CompositeProperty3(T, L));
  }
  return Acc;
}
function Composite3(T, options) {
  const K2 = CompositeKeys3(T);
  const P = CompositeProperties3(T, K2);
  const R = Object22(P, options);
  return R;
}
function Date22(options) {
  return CreateType3({ [Kind4]: "Date", type: "Date" }, options);
}
function Null3(options) {
  return CreateType3({ [Kind4]: "Null", type: "null" }, options);
}
function Symbol22(options) {
  return CreateType3({ [Kind4]: "Symbol", type: "symbol" }, options);
}
function Undefined3(options) {
  return CreateType3({ [Kind4]: "Undefined", type: "undefined" }, options);
}
function Uint8Array22(options) {
  return CreateType3({ [Kind4]: "Uint8Array", type: "Uint8Array" }, options);
}
function Unknown3(options) {
  return CreateType3({ [Kind4]: "Unknown" }, options);
}
function FromArray34(T) {
  return T.map((L) => FromValue5(L, false));
}
function FromProperties72(value) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(value))
    Acc[K2] = Readonly3(FromValue5(value[K2], false));
  return Acc;
}
function ConditionalReadonly3(T, root) {
  return root === true ? T : Readonly3(T);
}
function FromValue5(value, root) {
  return IsAsyncIterator9(value) ? ConditionalReadonly3(Any3(), root) : IsIterator9(value) ? ConditionalReadonly3(Any3(), root) : IsArray9(value) ? Readonly3(Tuple3(FromArray34(value))) : IsUint8Array9(value) ? Uint8Array22() : IsDate9(value) ? Date22() : IsObject9(value) ? ConditionalReadonly3(Object22(FromProperties72(value)), root) : IsFunction9(value) ? ConditionalReadonly3(Function4([], Unknown3()), root) : IsUndefined9(value) ? Undefined3() : IsNull9(value) ? Null3() : IsSymbol9(value) ? Symbol22() : IsBigInt9(value) ? BigInt4() : IsNumber9(value) ? Literal3(value) : IsBoolean9(value) ? Literal3(value) : IsString9(value) ? Literal3(value) : Object22({});
}
function Const3(T, options) {
  return CreateType3(FromValue5(T, true), options);
}
function ConstructorParameters3(schema, options) {
  return Tuple3(schema.parameters, options);
}
function Enum3(item, options) {
  if (IsUndefined9(item))
    throw new Error("Enum undefined or empty");
  const values1 = globalThis.Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
  const values2 = [...new Set(values1)];
  const anyOf = values2.map((value) => Literal3(value));
  return Union5(anyOf, { ...options, [Hint4]: "Enum" });
}
var ExtendsResolverError3 = class extends TypeBoxError3 {
};
var ExtendsResult3;
(function(ExtendsResult22) {
  ExtendsResult22[ExtendsResult22["Union"] = 0] = "Union";
  ExtendsResult22[ExtendsResult22["True"] = 1] = "True";
  ExtendsResult22[ExtendsResult22["False"] = 2] = "False";
})(ExtendsResult3 || (ExtendsResult3 = {}));
function IntoBooleanResult3(result) {
  return result === ExtendsResult3.False ? result : ExtendsResult3.True;
}
function Throw3(message2) {
  throw new ExtendsResolverError3(message2);
}
function IsStructuralRight3(right) {
  return type_exports.IsNever(right) || type_exports.IsIntersect(right) || type_exports.IsUnion(right) || type_exports.IsUnknown(right) || type_exports.IsAny(right);
}
function StructuralRight3(left, right) {
  return type_exports.IsNever(right) ? FromNeverRight3(left, right) : type_exports.IsIntersect(right) ? FromIntersectRight3(left, right) : type_exports.IsUnion(right) ? FromUnionRight3(left, right) : type_exports.IsUnknown(right) ? FromUnknownRight3(left, right) : type_exports.IsAny(right) ? FromAnyRight3(left, right) : Throw3("StructuralRight");
}
function FromAnyRight3(left, right) {
  return ExtendsResult3.True;
}
function FromAny9(left, right) {
  return type_exports.IsIntersect(right) ? FromIntersectRight3(left, right) : type_exports.IsUnion(right) && right.anyOf.some((schema) => type_exports.IsAny(schema) || type_exports.IsUnknown(schema)) ? ExtendsResult3.True : type_exports.IsUnion(right) ? ExtendsResult3.Union : type_exports.IsUnknown(right) ? ExtendsResult3.True : type_exports.IsAny(right) ? ExtendsResult3.True : ExtendsResult3.Union;
}
function FromArrayRight3(left, right) {
  return type_exports.IsUnknown(left) ? ExtendsResult3.False : type_exports.IsAny(left) ? ExtendsResult3.Union : type_exports.IsNever(left) ? ExtendsResult3.True : ExtendsResult3.False;
}
function FromArray42(left, right) {
  return type_exports.IsObject(right) && IsObjectArrayLike3(right) ? ExtendsResult3.True : IsStructuralRight3(right) ? StructuralRight3(left, right) : !type_exports.IsArray(right) ? ExtendsResult3.False : IntoBooleanResult3(Visit34(left.items, right.items));
}
function FromAsyncIterator13(left, right) {
  return IsStructuralRight3(right) ? StructuralRight3(left, right) : !type_exports.IsAsyncIterator(right) ? ExtendsResult3.False : IntoBooleanResult3(Visit34(left.items, right.items));
}
function FromBigInt11(left, right) {
  return IsStructuralRight3(right) ? StructuralRight3(left, right) : type_exports.IsObject(right) ? FromObjectRight3(left, right) : type_exports.IsRecord(right) ? FromRecordRight3(left, right) : type_exports.IsBigInt(right) ? ExtendsResult3.True : ExtendsResult3.False;
}
function FromBooleanRight3(left, right) {
  return type_exports.IsLiteralBoolean(left) ? ExtendsResult3.True : type_exports.IsBoolean(left) ? ExtendsResult3.True : ExtendsResult3.False;
}
function FromBoolean11(left, right) {
  return IsStructuralRight3(right) ? StructuralRight3(left, right) : type_exports.IsObject(right) ? FromObjectRight3(left, right) : type_exports.IsRecord(right) ? FromRecordRight3(left, right) : type_exports.IsBoolean(right) ? ExtendsResult3.True : ExtendsResult3.False;
}
function FromConstructor15(left, right) {
  return IsStructuralRight3(right) ? StructuralRight3(left, right) : type_exports.IsObject(right) ? FromObjectRight3(left, right) : !type_exports.IsConstructor(right) ? ExtendsResult3.False : left.parameters.length > right.parameters.length ? ExtendsResult3.False : !left.parameters.every((schema, index) => IntoBooleanResult3(Visit34(right.parameters[index], schema)) === ExtendsResult3.True) ? ExtendsResult3.False : IntoBooleanResult3(Visit34(left.returns, right.returns));
}
function FromDate15(left, right) {
  return IsStructuralRight3(right) ? StructuralRight3(left, right) : type_exports.IsObject(right) ? FromObjectRight3(left, right) : type_exports.IsRecord(right) ? FromRecordRight3(left, right) : type_exports.IsDate(right) ? ExtendsResult3.True : ExtendsResult3.False;
}
function FromFunction13(left, right) {
  return IsStructuralRight3(right) ? StructuralRight3(left, right) : type_exports.IsObject(right) ? FromObjectRight3(left, right) : !type_exports.IsFunction(right) ? ExtendsResult3.False : left.parameters.length > right.parameters.length ? ExtendsResult3.False : !left.parameters.every((schema, index) => IntoBooleanResult3(Visit34(right.parameters[index], schema)) === ExtendsResult3.True) ? ExtendsResult3.False : IntoBooleanResult3(Visit34(left.returns, right.returns));
}
function FromIntegerRight3(left, right) {
  return type_exports.IsLiteral(left) && value_exports.IsNumber(left.const) ? ExtendsResult3.True : type_exports.IsNumber(left) || type_exports.IsInteger(left) ? ExtendsResult3.True : ExtendsResult3.False;
}
function FromInteger11(left, right) {
  return type_exports.IsInteger(right) || type_exports.IsNumber(right) ? ExtendsResult3.True : IsStructuralRight3(right) ? StructuralRight3(left, right) : type_exports.IsObject(right) ? FromObjectRight3(left, right) : type_exports.IsRecord(right) ? FromRecordRight3(left, right) : ExtendsResult3.False;
}
function FromIntersectRight3(left, right) {
  return right.allOf.every((schema) => Visit34(left, schema) === ExtendsResult3.True) ? ExtendsResult3.True : ExtendsResult3.False;
}
function FromIntersect42(left, right) {
  return left.allOf.some((schema) => Visit34(schema, right) === ExtendsResult3.True) ? ExtendsResult3.True : ExtendsResult3.False;
}
function FromIterator13(left, right) {
  return IsStructuralRight3(right) ? StructuralRight3(left, right) : !type_exports.IsIterator(right) ? ExtendsResult3.False : IntoBooleanResult3(Visit34(left.items, right.items));
}
function FromLiteral22(left, right) {
  return type_exports.IsLiteral(right) && right.const === left.const ? ExtendsResult3.True : IsStructuralRight3(right) ? StructuralRight3(left, right) : type_exports.IsObject(right) ? FromObjectRight3(left, right) : type_exports.IsRecord(right) ? FromRecordRight3(left, right) : type_exports.IsString(right) ? FromStringRight3(left, right) : type_exports.IsNumber(right) ? FromNumberRight3(left, right) : type_exports.IsInteger(right) ? FromIntegerRight3(left, right) : type_exports.IsBoolean(right) ? FromBooleanRight3(left, right) : ExtendsResult3.False;
}
function FromNeverRight3(left, right) {
  return ExtendsResult3.False;
}
function FromNever11(left, right) {
  return ExtendsResult3.True;
}
function UnwrapTNot3(schema) {
  let [current, depth] = [schema, 0];
  while (true) {
    if (!type_exports.IsNot(current))
      break;
    current = current.not;
    depth += 1;
  }
  return depth % 2 === 0 ? current : Unknown3();
}
function FromNot15(left, right) {
  return type_exports.IsNot(left) ? Visit34(UnwrapTNot3(left), right) : type_exports.IsNot(right) ? Visit34(left, UnwrapTNot3(right)) : Throw3("Invalid fallthrough for Not");
}
function FromNull11(left, right) {
  return IsStructuralRight3(right) ? StructuralRight3(left, right) : type_exports.IsObject(right) ? FromObjectRight3(left, right) : type_exports.IsRecord(right) ? FromRecordRight3(left, right) : type_exports.IsNull(right) ? ExtendsResult3.True : ExtendsResult3.False;
}
function FromNumberRight3(left, right) {
  return type_exports.IsLiteralNumber(left) ? ExtendsResult3.True : type_exports.IsNumber(left) || type_exports.IsInteger(left) ? ExtendsResult3.True : ExtendsResult3.False;
}
function FromNumber11(left, right) {
  return IsStructuralRight3(right) ? StructuralRight3(left, right) : type_exports.IsObject(right) ? FromObjectRight3(left, right) : type_exports.IsRecord(right) ? FromRecordRight3(left, right) : type_exports.IsInteger(right) || type_exports.IsNumber(right) ? ExtendsResult3.True : ExtendsResult3.False;
}
function IsObjectPropertyCount3(schema, count) {
  return Object.getOwnPropertyNames(schema.properties).length === count;
}
function IsObjectStringLike3(schema) {
  return IsObjectArrayLike3(schema);
}
function IsObjectSymbolLike3(schema) {
  return IsObjectPropertyCount3(schema, 0) || IsObjectPropertyCount3(schema, 1) && "description" in schema.properties && type_exports.IsUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (type_exports.IsString(schema.properties.description.anyOf[0]) && type_exports.IsUndefined(schema.properties.description.anyOf[1]) || type_exports.IsString(schema.properties.description.anyOf[1]) && type_exports.IsUndefined(schema.properties.description.anyOf[0]));
}
function IsObjectNumberLike3(schema) {
  return IsObjectPropertyCount3(schema, 0);
}
function IsObjectBooleanLike3(schema) {
  return IsObjectPropertyCount3(schema, 0);
}
function IsObjectBigIntLike3(schema) {
  return IsObjectPropertyCount3(schema, 0);
}
function IsObjectDateLike3(schema) {
  return IsObjectPropertyCount3(schema, 0);
}
function IsObjectUint8ArrayLike3(schema) {
  return IsObjectArrayLike3(schema);
}
function IsObjectFunctionLike3(schema) {
  const length = Number22();
  return IsObjectPropertyCount3(schema, 0) || IsObjectPropertyCount3(schema, 1) && "length" in schema.properties && IntoBooleanResult3(Visit34(schema.properties["length"], length)) === ExtendsResult3.True;
}
function IsObjectConstructorLike3(schema) {
  return IsObjectPropertyCount3(schema, 0);
}
function IsObjectArrayLike3(schema) {
  const length = Number22();
  return IsObjectPropertyCount3(schema, 0) || IsObjectPropertyCount3(schema, 1) && "length" in schema.properties && IntoBooleanResult3(Visit34(schema.properties["length"], length)) === ExtendsResult3.True;
}
function IsObjectPromiseLike3(schema) {
  const then = Function4([Any3()], Any3());
  return IsObjectPropertyCount3(schema, 0) || IsObjectPropertyCount3(schema, 1) && "then" in schema.properties && IntoBooleanResult3(Visit34(schema.properties["then"], then)) === ExtendsResult3.True;
}
function Property3(left, right) {
  return Visit34(left, right) === ExtendsResult3.False ? ExtendsResult3.False : type_exports.IsOptional(left) && !type_exports.IsOptional(right) ? ExtendsResult3.False : ExtendsResult3.True;
}
function FromObjectRight3(left, right) {
  return type_exports.IsUnknown(left) ? ExtendsResult3.False : type_exports.IsAny(left) ? ExtendsResult3.Union : type_exports.IsNever(left) || type_exports.IsLiteralString(left) && IsObjectStringLike3(right) || type_exports.IsLiteralNumber(left) && IsObjectNumberLike3(right) || type_exports.IsLiteralBoolean(left) && IsObjectBooleanLike3(right) || type_exports.IsSymbol(left) && IsObjectSymbolLike3(right) || type_exports.IsBigInt(left) && IsObjectBigIntLike3(right) || type_exports.IsString(left) && IsObjectStringLike3(right) || type_exports.IsSymbol(left) && IsObjectSymbolLike3(right) || type_exports.IsNumber(left) && IsObjectNumberLike3(right) || type_exports.IsInteger(left) && IsObjectNumberLike3(right) || type_exports.IsBoolean(left) && IsObjectBooleanLike3(right) || type_exports.IsUint8Array(left) && IsObjectUint8ArrayLike3(right) || type_exports.IsDate(left) && IsObjectDateLike3(right) || type_exports.IsConstructor(left) && IsObjectConstructorLike3(right) || type_exports.IsFunction(left) && IsObjectFunctionLike3(right) ? ExtendsResult3.True : type_exports.IsRecord(left) && type_exports.IsString(RecordKey3(left)) ? (() => {
    return right[Hint4] === "Record" ? ExtendsResult3.True : ExtendsResult3.False;
  })() : type_exports.IsRecord(left) && type_exports.IsNumber(RecordKey3(left)) ? (() => {
    return IsObjectPropertyCount3(right, 0) ? ExtendsResult3.True : ExtendsResult3.False;
  })() : ExtendsResult3.False;
}
function FromObject35(left, right) {
  return IsStructuralRight3(right) ? StructuralRight3(left, right) : type_exports.IsRecord(right) ? FromRecordRight3(left, right) : !type_exports.IsObject(right) ? ExtendsResult3.False : (() => {
    for (const key of Object.getOwnPropertyNames(right.properties)) {
      if (!(key in left.properties) && !type_exports.IsOptional(right.properties[key])) {
        return ExtendsResult3.False;
      }
      if (type_exports.IsOptional(right.properties[key])) {
        return ExtendsResult3.True;
      }
      if (Property3(left.properties[key], right.properties[key]) === ExtendsResult3.False) {
        return ExtendsResult3.False;
      }
    }
    return ExtendsResult3.True;
  })();
}
function FromPromise22(left, right) {
  return IsStructuralRight3(right) ? StructuralRight3(left, right) : type_exports.IsObject(right) && IsObjectPromiseLike3(right) ? ExtendsResult3.True : !type_exports.IsPromise(right) ? ExtendsResult3.False : IntoBooleanResult3(Visit34(left.item, right.item));
}
function RecordKey3(schema) {
  return PatternNumberExact3 in schema.patternProperties ? Number22() : (PatternStringExact3 in schema.patternProperties) ? String4() : Throw3("Unknown record key pattern");
}
function RecordValue3(schema) {
  return PatternNumberExact3 in schema.patternProperties ? schema.patternProperties[PatternNumberExact3] : (PatternStringExact3 in schema.patternProperties) ? schema.patternProperties[PatternStringExact3] : Throw3("Unable to get record value schema");
}
function FromRecordRight3(left, right) {
  const [Key, Value] = [RecordKey3(right), RecordValue3(right)];
  return type_exports.IsLiteralString(left) && type_exports.IsNumber(Key) && IntoBooleanResult3(Visit34(left, Value)) === ExtendsResult3.True ? ExtendsResult3.True : type_exports.IsUint8Array(left) && type_exports.IsNumber(Key) ? Visit34(left, Value) : type_exports.IsString(left) && type_exports.IsNumber(Key) ? Visit34(left, Value) : type_exports.IsArray(left) && type_exports.IsNumber(Key) ? Visit34(left, Value) : type_exports.IsObject(left) ? (() => {
    for (const key of Object.getOwnPropertyNames(left.properties)) {
      if (Property3(Value, left.properties[key]) === ExtendsResult3.False) {
        return ExtendsResult3.False;
      }
    }
    return ExtendsResult3.True;
  })() : ExtendsResult3.False;
}
function FromRecord25(left, right) {
  return IsStructuralRight3(right) ? StructuralRight3(left, right) : type_exports.IsObject(right) ? FromObjectRight3(left, right) : !type_exports.IsRecord(right) ? ExtendsResult3.False : Visit34(RecordValue3(left), RecordValue3(right));
}
function FromRegExp9(left, right) {
  const L = type_exports.IsRegExp(left) ? String4() : left;
  const R = type_exports.IsRegExp(right) ? String4() : right;
  return Visit34(L, R);
}
function FromStringRight3(left, right) {
  return type_exports.IsLiteral(left) && value_exports.IsString(left.const) ? ExtendsResult3.True : type_exports.IsString(left) ? ExtendsResult3.True : ExtendsResult3.False;
}
function FromString11(left, right) {
  return IsStructuralRight3(right) ? StructuralRight3(left, right) : type_exports.IsObject(right) ? FromObjectRight3(left, right) : type_exports.IsRecord(right) ? FromRecordRight3(left, right) : type_exports.IsString(right) ? ExtendsResult3.True : ExtendsResult3.False;
}
function FromSymbol11(left, right) {
  return IsStructuralRight3(right) ? StructuralRight3(left, right) : type_exports.IsObject(right) ? FromObjectRight3(left, right) : type_exports.IsRecord(right) ? FromRecordRight3(left, right) : type_exports.IsSymbol(right) ? ExtendsResult3.True : ExtendsResult3.False;
}
function FromTemplateLiteral22(left, right) {
  return type_exports.IsTemplateLiteral(left) ? Visit34(TemplateLiteralToUnion3(left), right) : type_exports.IsTemplateLiteral(right) ? Visit34(left, TemplateLiteralToUnion3(right)) : Throw3("Invalid fallthrough for TemplateLiteral");
}
function IsArrayOfTuple3(left, right) {
  return type_exports.IsArray(right) && left.items !== undefined && left.items.every((schema) => Visit34(schema, right.items) === ExtendsResult3.True);
}
function FromTupleRight3(left, right) {
  return type_exports.IsNever(left) ? ExtendsResult3.True : type_exports.IsUnknown(left) ? ExtendsResult3.False : type_exports.IsAny(left) ? ExtendsResult3.Union : ExtendsResult3.False;
}
function FromTuple32(left, right) {
  return IsStructuralRight3(right) ? StructuralRight3(left, right) : type_exports.IsObject(right) && IsObjectArrayLike3(right) ? ExtendsResult3.True : type_exports.IsArray(right) && IsArrayOfTuple3(left, right) ? ExtendsResult3.True : !type_exports.IsTuple(right) ? ExtendsResult3.False : value_exports.IsUndefined(left.items) && !value_exports.IsUndefined(right.items) || !value_exports.IsUndefined(left.items) && value_exports.IsUndefined(right.items) ? ExtendsResult3.False : value_exports.IsUndefined(left.items) && !value_exports.IsUndefined(right.items) ? ExtendsResult3.True : left.items.every((schema, index) => Visit34(schema, right.items[index]) === ExtendsResult3.True) ? ExtendsResult3.True : ExtendsResult3.False;
}
function FromUint8Array9(left, right) {
  return IsStructuralRight3(right) ? StructuralRight3(left, right) : type_exports.IsObject(right) ? FromObjectRight3(left, right) : type_exports.IsRecord(right) ? FromRecordRight3(left, right) : type_exports.IsUint8Array(right) ? ExtendsResult3.True : ExtendsResult3.False;
}
function FromUndefined11(left, right) {
  return IsStructuralRight3(right) ? StructuralRight3(left, right) : type_exports.IsObject(right) ? FromObjectRight3(left, right) : type_exports.IsRecord(right) ? FromRecordRight3(left, right) : type_exports.IsVoid(right) ? FromVoidRight3(left, right) : type_exports.IsUndefined(right) ? ExtendsResult3.True : ExtendsResult3.False;
}
function FromUnionRight3(left, right) {
  return right.anyOf.some((schema) => Visit34(left, schema) === ExtendsResult3.True) ? ExtendsResult3.True : ExtendsResult3.False;
}
function FromUnion62(left, right) {
  return left.anyOf.every((schema) => Visit34(schema, right) === ExtendsResult3.True) ? ExtendsResult3.True : ExtendsResult3.False;
}
function FromUnknownRight3(left, right) {
  return ExtendsResult3.True;
}
function FromUnknown9(left, right) {
  return type_exports.IsNever(right) ? FromNeverRight3(left, right) : type_exports.IsIntersect(right) ? FromIntersectRight3(left, right) : type_exports.IsUnion(right) ? FromUnionRight3(left, right) : type_exports.IsAny(right) ? FromAnyRight3(left, right) : type_exports.IsString(right) ? FromStringRight3(left, right) : type_exports.IsNumber(right) ? FromNumberRight3(left, right) : type_exports.IsInteger(right) ? FromIntegerRight3(left, right) : type_exports.IsBoolean(right) ? FromBooleanRight3(left, right) : type_exports.IsArray(right) ? FromArrayRight3(left, right) : type_exports.IsTuple(right) ? FromTupleRight3(left, right) : type_exports.IsObject(right) ? FromObjectRight3(left, right) : type_exports.IsUnknown(right) ? ExtendsResult3.True : ExtendsResult3.False;
}
function FromVoidRight3(left, right) {
  return type_exports.IsUndefined(left) ? ExtendsResult3.True : type_exports.IsUndefined(left) ? ExtendsResult3.True : ExtendsResult3.False;
}
function FromVoid9(left, right) {
  return type_exports.IsIntersect(right) ? FromIntersectRight3(left, right) : type_exports.IsUnion(right) ? FromUnionRight3(left, right) : type_exports.IsUnknown(right) ? FromUnknownRight3(left, right) : type_exports.IsAny(right) ? FromAnyRight3(left, right) : type_exports.IsObject(right) ? FromObjectRight3(left, right) : type_exports.IsVoid(right) ? ExtendsResult3.True : ExtendsResult3.False;
}
function Visit34(left, right) {
  return type_exports.IsTemplateLiteral(left) || type_exports.IsTemplateLiteral(right) ? FromTemplateLiteral22(left, right) : type_exports.IsRegExp(left) || type_exports.IsRegExp(right) ? FromRegExp9(left, right) : type_exports.IsNot(left) || type_exports.IsNot(right) ? FromNot15(left, right) : type_exports.IsAny(left) ? FromAny9(left, right) : type_exports.IsArray(left) ? FromArray42(left, right) : type_exports.IsBigInt(left) ? FromBigInt11(left, right) : type_exports.IsBoolean(left) ? FromBoolean11(left, right) : type_exports.IsAsyncIterator(left) ? FromAsyncIterator13(left, right) : type_exports.IsConstructor(left) ? FromConstructor15(left, right) : type_exports.IsDate(left) ? FromDate15(left, right) : type_exports.IsFunction(left) ? FromFunction13(left, right) : type_exports.IsInteger(left) ? FromInteger11(left, right) : type_exports.IsIntersect(left) ? FromIntersect42(left, right) : type_exports.IsIterator(left) ? FromIterator13(left, right) : type_exports.IsLiteral(left) ? FromLiteral22(left, right) : type_exports.IsNever(left) ? FromNever11(left, right) : type_exports.IsNull(left) ? FromNull11(left, right) : type_exports.IsNumber(left) ? FromNumber11(left, right) : type_exports.IsObject(left) ? FromObject35(left, right) : type_exports.IsRecord(left) ? FromRecord25(left, right) : type_exports.IsString(left) ? FromString11(left, right) : type_exports.IsSymbol(left) ? FromSymbol11(left, right) : type_exports.IsTuple(left) ? FromTuple32(left, right) : type_exports.IsPromise(left) ? FromPromise22(left, right) : type_exports.IsUint8Array(left) ? FromUint8Array9(left, right) : type_exports.IsUndefined(left) ? FromUndefined11(left, right) : type_exports.IsUnion(left) ? FromUnion62(left, right) : type_exports.IsUnknown(left) ? FromUnknown9(left, right) : type_exports.IsVoid(left) ? FromVoid9(left, right) : Throw3(`Unknown left type operand '${left[Kind4]}'`);
}
function ExtendsCheck3(left, right) {
  return Visit34(left, right);
}
function FromProperties82(P, Right, True, False, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Extends3(P[K2], Right, True, False, Clone5(options));
  return Acc;
}
function FromMappedResult62(Left, Right, True, False, options) {
  return FromProperties82(Left.properties, Right, True, False, options);
}
function ExtendsFromMappedResult3(Left, Right, True, False, options) {
  const P = FromMappedResult62(Left, Right, True, False, options);
  return MappedResult3(P);
}
function ExtendsResolve3(left, right, trueType, falseType) {
  const R = ExtendsCheck3(left, right);
  return R === ExtendsResult3.Union ? Union5([trueType, falseType]) : R === ExtendsResult3.True ? trueType : falseType;
}
function Extends3(L, R, T, F, options) {
  return IsMappedResult5(L) ? ExtendsFromMappedResult3(L, R, T, F, options) : IsMappedKey5(L) ? CreateType3(ExtendsFromMappedKey3(L, R, T, F, options)) : CreateType3(ExtendsResolve3(L, R, T, F), options);
}
function FromPropertyKey7(K2, U3, L, R, options) {
  return {
    [K2]: Extends3(Literal3(K2), U3, L, R, Clone5(options))
  };
}
function FromPropertyKeys7(K2, U3, L, R, options) {
  return K2.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey7(LK, U3, L, R, options) };
  }, {});
}
function FromMappedKey22(K2, U3, L, R, options) {
  return FromPropertyKeys7(K2.keys, U3, L, R, options);
}
function ExtendsFromMappedKey3(T, U3, L, R, options) {
  const P = FromMappedKey22(T, U3, L, R, options);
  return MappedResult3(P);
}
function ExcludeFromTemplateLiteral3(L, R) {
  return Exclude3(TemplateLiteralToUnion3(L), R);
}
function ExcludeRest3(L, R) {
  const excluded = L.filter((inner) => ExtendsCheck3(inner, R) === ExtendsResult3.False);
  return excluded.length === 1 ? excluded[0] : Union5(excluded);
}
function Exclude3(L, R, options = {}) {
  if (IsTemplateLiteral5(L))
    return CreateType3(ExcludeFromTemplateLiteral3(L, R), options);
  if (IsMappedResult5(L))
    return CreateType3(ExcludeFromMappedResult3(L, R), options);
  return CreateType3(IsUnion5(L) ? ExcludeRest3(L.anyOf, R) : ExtendsCheck3(L, R) !== ExtendsResult3.False ? Never3() : L, options);
}
function FromProperties92(P, U3) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Exclude3(P[K2], U3);
  return Acc;
}
function FromMappedResult72(R, T) {
  return FromProperties92(R.properties, T);
}
function ExcludeFromMappedResult3(R, T) {
  const P = FromMappedResult72(R, T);
  return MappedResult3(P);
}
function ExtractFromTemplateLiteral3(L, R) {
  return Extract3(TemplateLiteralToUnion3(L), R);
}
function ExtractRest3(L, R) {
  const extracted = L.filter((inner) => ExtendsCheck3(inner, R) !== ExtendsResult3.False);
  return extracted.length === 1 ? extracted[0] : Union5(extracted);
}
function Extract3(L, R, options) {
  if (IsTemplateLiteral5(L))
    return CreateType3(ExtractFromTemplateLiteral3(L, R), options);
  if (IsMappedResult5(L))
    return CreateType3(ExtractFromMappedResult3(L, R), options);
  return CreateType3(IsUnion5(L) ? ExtractRest3(L.anyOf, R) : ExtendsCheck3(L, R) !== ExtendsResult3.False ? L : Never3(), options);
}
function FromProperties102(P, T) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Extract3(P[K2], T);
  return Acc;
}
function FromMappedResult82(R, T) {
  return FromProperties102(R.properties, T);
}
function ExtractFromMappedResult3(R, T) {
  const P = FromMappedResult82(R, T);
  return MappedResult3(P);
}
function InstanceType3(schema, options) {
  return CreateType3(schema.returns, options);
}
function Integer3(options) {
  return CreateType3({ [Kind4]: "Integer", type: "integer" }, options);
}
function MappedIntrinsicPropertyKey3(K2, M, options) {
  return {
    [K2]: Intrinsic3(Literal3(K2), M, Clone5(options))
  };
}
function MappedIntrinsicPropertyKeys3(K2, M, options) {
  const result = K2.reduce((Acc, L) => {
    return { ...Acc, ...MappedIntrinsicPropertyKey3(L, M, options) };
  }, {});
  return result;
}
function MappedIntrinsicProperties3(T, M, options) {
  return MappedIntrinsicPropertyKeys3(T["keys"], M, options);
}
function IntrinsicFromMappedKey3(T, M, options) {
  const P = MappedIntrinsicProperties3(T, M, options);
  return MappedResult3(P);
}
function ApplyUncapitalize3(value) {
  const [first, rest] = [value.slice(0, 1), value.slice(1)];
  return [first.toLowerCase(), rest].join("");
}
function ApplyCapitalize3(value) {
  const [first, rest] = [value.slice(0, 1), value.slice(1)];
  return [first.toUpperCase(), rest].join("");
}
function ApplyUppercase3(value) {
  return value.toUpperCase();
}
function ApplyLowercase3(value) {
  return value.toLowerCase();
}
function FromTemplateLiteral32(schema, mode, options) {
  const expression = TemplateLiteralParseExact3(schema.pattern);
  const finite = IsTemplateLiteralExpressionFinite3(expression);
  if (!finite)
    return { ...schema, pattern: FromLiteralValue3(schema.pattern, mode) };
  const strings = [...TemplateLiteralExpressionGenerate3(expression)];
  const literals = strings.map((value) => Literal3(value));
  const mapped = FromRest52(literals, mode);
  const union = Union5(mapped);
  return TemplateLiteral3([union], options);
}
function FromLiteralValue3(value, mode) {
  return typeof value === "string" ? mode === "Uncapitalize" ? ApplyUncapitalize3(value) : mode === "Capitalize" ? ApplyCapitalize3(value) : mode === "Uppercase" ? ApplyUppercase3(value) : mode === "Lowercase" ? ApplyLowercase3(value) : value : value.toString();
}
function FromRest52(T, M) {
  return T.map((L) => Intrinsic3(L, M));
}
function Intrinsic3(schema, mode, options = {}) {
  return IsMappedKey5(schema) ? IntrinsicFromMappedKey3(schema, mode, options) : IsTemplateLiteral5(schema) ? FromTemplateLiteral32(schema, mode, options) : IsUnion5(schema) ? Union5(FromRest52(schema.anyOf, mode), options) : IsLiteral5(schema) ? Literal3(FromLiteralValue3(schema.const, mode), options) : CreateType3(schema, options);
}
function Capitalize3(T, options = {}) {
  return Intrinsic3(T, "Capitalize", options);
}
function Lowercase3(T, options = {}) {
  return Intrinsic3(T, "Lowercase", options);
}
function Uncapitalize3(T, options = {}) {
  return Intrinsic3(T, "Uncapitalize", options);
}
function Uppercase3(T, options = {}) {
  return Intrinsic3(T, "Uppercase", options);
}
function FromProperties112(properties, propertyKeys, options) {
  const result = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
    result[K2] = Omit3(properties[K2], propertyKeys, Clone5(options));
  return result;
}
function FromMappedResult92(mappedResult, propertyKeys, options) {
  return FromProperties112(mappedResult.properties, propertyKeys, options);
}
function OmitFromMappedResult3(mappedResult, propertyKeys, options) {
  const properties = FromMappedResult92(mappedResult, propertyKeys, options);
  return MappedResult3(properties);
}
function FromIntersect52(types2, propertyKeys) {
  return types2.map((type) => OmitResolve3(type, propertyKeys));
}
function FromUnion72(types2, propertyKeys) {
  return types2.map((type) => OmitResolve3(type, propertyKeys));
}
function FromProperty22(properties, key) {
  const { [key]: _3, ...R } = properties;
  return R;
}
function FromProperties122(properties, propertyKeys) {
  return propertyKeys.reduce((T, K2) => FromProperty22(T, K2), properties);
}
function FromObject210(properties, propertyKeys) {
  const options = Discard3(properties, [TransformKind4, "$id", "required", "properties"]);
  const omittedProperties = FromProperties122(properties["properties"], propertyKeys);
  return Object22(omittedProperties, options);
}
function UnionFromPropertyKeys5(propertyKeys) {
  const result = propertyKeys.reduce((result2, key) => IsLiteralValue5(key) ? [...result2, Literal3(key)] : result2, []);
  return Union5(result);
}
function OmitResolve3(properties, propertyKeys) {
  return IsIntersect5(properties) ? Intersect5(FromIntersect52(properties.allOf, propertyKeys)) : IsUnion5(properties) ? Union5(FromUnion72(properties.anyOf, propertyKeys)) : IsObject32(properties) ? FromObject210(properties, propertyKeys) : Object22({});
}
function Omit3(type, key, options) {
  const typeKey = IsArray9(key) ? UnionFromPropertyKeys5(key) : key;
  const propertyKeys = IsSchema5(key) ? IndexPropertyKeys3(key) : key;
  const isTypeRef = IsRef5(type);
  const isKeyRef = IsRef5(key);
  return IsMappedResult5(type) ? OmitFromMappedResult3(type, propertyKeys, options) : IsMappedKey5(key) ? OmitFromMappedKey3(type, key, options) : isTypeRef && isKeyRef ? Computed3("Omit", [type, typeKey], options) : !isTypeRef && isKeyRef ? Computed3("Omit", [type, typeKey], options) : isTypeRef && !isKeyRef ? Computed3("Omit", [type, typeKey], options) : CreateType3({ ...OmitResolve3(type, propertyKeys), ...options });
}
function FromPropertyKey22(type, key, options) {
  return { [key]: Omit3(type, [key], Clone5(options)) };
}
function FromPropertyKeys22(type, propertyKeys, options) {
  return propertyKeys.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey22(type, LK, options) };
  }, {});
}
function FromMappedKey32(type, mappedKey, options) {
  return FromPropertyKeys22(type, mappedKey.keys, options);
}
function OmitFromMappedKey3(type, mappedKey, options) {
  const properties = FromMappedKey32(type, mappedKey, options);
  return MappedResult3(properties);
}
function FromProperties132(properties, propertyKeys, options) {
  const result = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
    result[K2] = Pick3(properties[K2], propertyKeys, Clone5(options));
  return result;
}
function FromMappedResult102(mappedResult, propertyKeys, options) {
  return FromProperties132(mappedResult.properties, propertyKeys, options);
}
function PickFromMappedResult3(mappedResult, propertyKeys, options) {
  const properties = FromMappedResult102(mappedResult, propertyKeys, options);
  return MappedResult3(properties);
}
function FromIntersect62(types2, propertyKeys) {
  return types2.map((type) => PickResolve3(type, propertyKeys));
}
function FromUnion82(types2, propertyKeys) {
  return types2.map((type) => PickResolve3(type, propertyKeys));
}
function FromProperties142(properties, propertyKeys) {
  const result = {};
  for (const K2 of propertyKeys)
    if (K2 in properties)
      result[K2] = properties[K2];
  return result;
}
function FromObject36(T, K2) {
  const options = Discard3(T, [TransformKind4, "$id", "required", "properties"]);
  const properties = FromProperties142(T["properties"], K2);
  return Object22(properties, options);
}
function UnionFromPropertyKeys22(propertyKeys) {
  const result = propertyKeys.reduce((result2, key) => IsLiteralValue5(key) ? [...result2, Literal3(key)] : result2, []);
  return Union5(result);
}
function PickResolve3(properties, propertyKeys) {
  return IsIntersect5(properties) ? Intersect5(FromIntersect62(properties.allOf, propertyKeys)) : IsUnion5(properties) ? Union5(FromUnion82(properties.anyOf, propertyKeys)) : IsObject32(properties) ? FromObject36(properties, propertyKeys) : Object22({});
}
function Pick3(type, key, options) {
  const typeKey = IsArray9(key) ? UnionFromPropertyKeys22(key) : key;
  const propertyKeys = IsSchema5(key) ? IndexPropertyKeys3(key) : key;
  const isTypeRef = IsRef5(type);
  const isKeyRef = IsRef5(key);
  return IsMappedResult5(type) ? PickFromMappedResult3(type, propertyKeys, options) : IsMappedKey5(key) ? PickFromMappedKey3(type, key, options) : isTypeRef && isKeyRef ? Computed3("Pick", [type, typeKey], options) : !isTypeRef && isKeyRef ? Computed3("Pick", [type, typeKey], options) : isTypeRef && !isKeyRef ? Computed3("Pick", [type, typeKey], options) : CreateType3({ ...PickResolve3(type, propertyKeys), ...options });
}
function FromPropertyKey32(type, key, options) {
  return {
    [key]: Pick3(type, [key], Clone5(options))
  };
}
function FromPropertyKeys32(type, propertyKeys, options) {
  return propertyKeys.reduce((result, leftKey) => {
    return { ...result, ...FromPropertyKey32(type, leftKey, options) };
  }, {});
}
function FromMappedKey42(type, mappedKey, options) {
  return FromPropertyKeys32(type, mappedKey.keys, options);
}
function PickFromMappedKey3(type, mappedKey, options) {
  const properties = FromMappedKey42(type, mappedKey, options);
  return MappedResult3(properties);
}
function FromComputed32(target, parameters) {
  return Computed3("Partial", [Computed3(target, parameters)]);
}
function FromRef32($ref) {
  return Computed3("Partial", [Ref3($ref)]);
}
function FromProperties152(properties) {
  const partialProperties = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
    partialProperties[K2] = Optional3(properties[K2]);
  return partialProperties;
}
function FromObject42(T) {
  const options = Discard3(T, [TransformKind4, "$id", "required", "properties"]);
  const properties = FromProperties152(T["properties"]);
  return Object22(properties, options);
}
function FromRest62(types2) {
  return types2.map((type) => PartialResolve3(type));
}
function PartialResolve3(type) {
  return IsComputed5(type) ? FromComputed32(type.target, type.parameters) : IsRef5(type) ? FromRef32(type.$ref) : IsIntersect5(type) ? Intersect5(FromRest62(type.allOf)) : IsUnion5(type) ? Union5(FromRest62(type.anyOf)) : IsObject32(type) ? FromObject42(type) : Object22({});
}
function Partial3(type, options) {
  if (IsMappedResult5(type)) {
    return PartialFromMappedResult3(type, options);
  } else {
    return CreateType3({ ...PartialResolve3(type), ...options });
  }
}
function FromProperties162(K2, options) {
  const Acc = {};
  for (const K22 of globalThis.Object.getOwnPropertyNames(K2))
    Acc[K22] = Partial3(K2[K22], Clone5(options));
  return Acc;
}
function FromMappedResult112(R, options) {
  return FromProperties162(R.properties, options);
}
function PartialFromMappedResult3(R, options) {
  const P = FromMappedResult112(R, options);
  return MappedResult3(P);
}
function RecordCreateFromPattern3(pattern, T, options) {
  return CreateType3({ [Kind4]: "Record", type: "object", patternProperties: { [pattern]: T } }, options);
}
function RecordCreateFromKeys3(K2, T, options) {
  const result = {};
  for (const K22 of K2)
    result[K22] = T;
  return Object22(result, { ...options, [Hint4]: "Record" });
}
function FromTemplateLiteralKey3(K2, T, options) {
  return IsTemplateLiteralFinite3(K2) ? RecordCreateFromKeys3(IndexPropertyKeys3(K2), T, options) : RecordCreateFromPattern3(K2.pattern, T, options);
}
function FromUnionKey3(key, type, options) {
  return RecordCreateFromKeys3(IndexPropertyKeys3(Union5(key)), type, options);
}
function FromLiteralKey3(key, type, options) {
  return RecordCreateFromKeys3([key.toString()], type, options);
}
function FromRegExpKey3(key, type, options) {
  return RecordCreateFromPattern3(key.source, type, options);
}
function FromStringKey3(key, type, options) {
  const pattern = IsUndefined9(key.pattern) ? PatternStringExact3 : key.pattern;
  return RecordCreateFromPattern3(pattern, type, options);
}
function FromAnyKey3(_3, type, options) {
  return RecordCreateFromPattern3(PatternStringExact3, type, options);
}
function FromNeverKey3(_key, type, options) {
  return RecordCreateFromPattern3(PatternNeverExact3, type, options);
}
function FromIntegerKey3(_key, type, options) {
  return RecordCreateFromPattern3(PatternNumberExact3, type, options);
}
function FromNumberKey3(_3, type, options) {
  return RecordCreateFromPattern3(PatternNumberExact3, type, options);
}
function Record3(key, type, options = {}) {
  return IsComputed5(type) ? Computed3("Record", [key, Computed3(type.target, type.parameters)], options) : IsComputed5(key) ? Computed3("Record", [Computed3(type.target, type.parameters), type], options) : IsRef5(key) ? Computed3("Record", [Ref3(key.$ref), type]) : IsUnion5(key) ? FromUnionKey3(key.anyOf, type, options) : IsTemplateLiteral5(key) ? FromTemplateLiteralKey3(key, type, options) : IsLiteral5(key) ? FromLiteralKey3(key.const, type, options) : IsInteger7(key) ? FromIntegerKey3(key, type, options) : IsNumber32(key) ? FromNumberKey3(key, type, options) : IsRegExp22(key) ? FromRegExpKey3(key, type, options) : IsString22(key) ? FromStringKey3(key, type, options) : IsAny5(key) ? FromAnyKey3(key, type, options) : IsNever5(key) ? FromNeverKey3(key, type, options) : Never3(options);
}
function FromComputed42(target, parameters) {
  return Computed3("Required", [Computed3(target, parameters)]);
}
function FromRef42($ref) {
  return Computed3("Required", [Ref3($ref)]);
}
function FromProperties172(properties) {
  const requiredProperties = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
    requiredProperties[K2] = Discard3(properties[K2], [OptionalKind4]);
  return requiredProperties;
}
function FromObject52(type) {
  const options = Discard3(type, [TransformKind4, "$id", "required", "properties"]);
  const properties = FromProperties172(type["properties"]);
  return Object22(properties, options);
}
function FromRest72(types2) {
  return types2.map((type) => RequiredResolve3(type));
}
function RequiredResolve3(type) {
  return IsComputed5(type) ? FromComputed42(type.target, type.parameters) : IsRef5(type) ? FromRef42(type.$ref) : IsIntersect5(type) ? Intersect5(FromRest72(type.allOf)) : IsUnion5(type) ? Union5(FromRest72(type.anyOf)) : IsObject32(type) ? FromObject52(type) : Object22({});
}
function Required3(type, options) {
  if (IsMappedResult5(type)) {
    return RequiredFromMappedResult3(type, options);
  } else {
    return CreateType3({ ...RequiredResolve3(type), ...options });
  }
}
function FromProperties182(P, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Required3(P[K2], options);
  return Acc;
}
function FromMappedResult122(R, options) {
  return FromProperties182(R.properties, options);
}
function RequiredFromMappedResult3(R, options) {
  const P = FromMappedResult122(R, options);
  return MappedResult3(P);
}
function DerefParameters3(moduleProperties, types2) {
  return types2.map((type) => {
    return IsRef5(type) ? Deref5(moduleProperties, type.$ref) : FromType3(moduleProperties, type);
  });
}
function Deref5(moduleProperties, ref) {
  return ref in moduleProperties ? IsRef5(moduleProperties[ref]) ? Deref5(moduleProperties, moduleProperties[ref].$ref) : FromType3(moduleProperties, moduleProperties[ref]) : Never3();
}
function FromAwaited3(parameters) {
  return Awaited3(parameters[0]);
}
function FromIndex3(parameters) {
  return Index3(parameters[0], parameters[1]);
}
function FromKeyOf3(parameters) {
  return KeyOf3(parameters[0]);
}
function FromPartial3(parameters) {
  return Partial3(parameters[0]);
}
function FromOmit3(parameters) {
  return Omit3(parameters[0], parameters[1]);
}
function FromPick3(parameters) {
  return Pick3(parameters[0], parameters[1]);
}
function FromRecord26(parameters) {
  return Record3(parameters[0], parameters[1]);
}
function FromRequired3(parameters) {
  return Required3(parameters[0]);
}
function FromComputed52(moduleProperties, target, parameters) {
  const dereferenced = DerefParameters3(moduleProperties, parameters);
  return target === "Awaited" ? FromAwaited3(dereferenced) : target === "Index" ? FromIndex3(dereferenced) : target === "KeyOf" ? FromKeyOf3(dereferenced) : target === "Partial" ? FromPartial3(dereferenced) : target === "Omit" ? FromOmit3(dereferenced) : target === "Pick" ? FromPick3(dereferenced) : target === "Record" ? FromRecord26(dereferenced) : target === "Required" ? FromRequired3(dereferenced) : Never3();
}
function FromObject62(moduleProperties, properties) {
  return Object22(globalThis.Object.keys(properties).reduce((result, key) => {
    return { ...result, [key]: FromType3(moduleProperties, properties[key]) };
  }, {}));
}
function FromConstructor22(moduleProperties, parameters, instanceType) {
  return Constructor3(FromRest82(moduleProperties, parameters), FromType3(moduleProperties, instanceType));
}
function FromFunction22(moduleProperties, parameters, returnType) {
  return Function4(FromRest82(moduleProperties, parameters), FromType3(moduleProperties, returnType));
}
function FromTuple42(moduleProperties, types2) {
  return Tuple3(FromRest82(moduleProperties, types2));
}
function FromIntersect72(moduleProperties, types2) {
  return Intersect5(FromRest82(moduleProperties, types2));
}
function FromUnion92(moduleProperties, types2) {
  return Union5(FromRest82(moduleProperties, types2));
}
function FromArray52(moduleProperties, type) {
  return Array22(FromType3(moduleProperties, type));
}
function FromAsyncIterator22(moduleProperties, type) {
  return AsyncIterator3(FromType3(moduleProperties, type));
}
function FromIterator22(moduleProperties, type) {
  return Iterator3(FromType3(moduleProperties, type));
}
function FromRest82(moduleProperties, types2) {
  return types2.map((type) => FromType3(moduleProperties, type));
}
function FromType3(moduleProperties, type) {
  return IsOptional5(type) ? CreateType3(FromType3(moduleProperties, Discard3(type, [OptionalKind4])), type) : IsReadonly5(type) ? CreateType3(FromType3(moduleProperties, Discard3(type, [ReadonlyKind4])), type) : IsArray32(type) ? CreateType3(FromArray52(moduleProperties, type.items), type) : IsAsyncIterator22(type) ? CreateType3(FromAsyncIterator22(moduleProperties, type.items), type) : IsComputed5(type) ? CreateType3(FromComputed52(moduleProperties, type.target, type.parameters)) : IsConstructor5(type) ? CreateType3(FromConstructor22(moduleProperties, type.parameters, type.returns), type) : IsFunction22(type) ? CreateType3(FromFunction22(moduleProperties, type.parameters, type.returns), type) : IsIntersect5(type) ? CreateType3(FromIntersect72(moduleProperties, type.allOf), type) : IsIterator22(type) ? CreateType3(FromIterator22(moduleProperties, type.items), type) : IsObject32(type) ? CreateType3(FromObject62(moduleProperties, type.properties), type) : IsTuple5(type) ? CreateType3(FromTuple42(moduleProperties, type.items || []), type) : IsUnion5(type) ? CreateType3(FromUnion92(moduleProperties, type.anyOf), type) : type;
}
function ComputeType3(moduleProperties, key) {
  return key in moduleProperties ? FromType3(moduleProperties, moduleProperties[key]) : Never3();
}
function ComputeModuleProperties3(moduleProperties) {
  return globalThis.Object.getOwnPropertyNames(moduleProperties).reduce((result, key) => {
    return { ...result, [key]: ComputeType3(moduleProperties, key) };
  }, {});
}
var TModule3 = class {
  constructor($defs) {
    const computed = ComputeModuleProperties3($defs);
    const identified = this.WithIdentifiers(computed);
    this.$defs = identified;
  }
  Import(key, options) {
    const $defs = { ...this.$defs, [key]: CreateType3(this.$defs[key], options) };
    return CreateType3({ [Kind4]: "Import", $defs, $ref: key });
  }
  WithIdentifiers($defs) {
    return globalThis.Object.getOwnPropertyNames($defs).reduce((result, key) => {
      return { ...result, [key]: { ...$defs[key], $id: key } };
    }, {});
  }
};
function Module3(properties) {
  return new TModule3(properties);
}
function Not5(type, options) {
  return CreateType3({ [Kind4]: "Not", not: type }, options);
}
function Parameters3(schema, options) {
  return Tuple3(schema.parameters, options);
}
function ReadonlyOptional3(schema) {
  return Readonly3(Optional3(schema));
}
var Ordinal3 = 0;
function Recursive3(callback, options = {}) {
  if (IsUndefined9(options.$id))
    options.$id = `T${Ordinal3++}`;
  const thisType = CloneType3(callback({ [Kind4]: "This", $ref: `${options.$id}` }));
  thisType.$id = options.$id;
  return CreateType3({ [Hint4]: "Recursive", ...thisType }, options);
}
function RegExp22(unresolved, options) {
  const expr = IsString9(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;
  return CreateType3({ [Kind4]: "RegExp", type: "RegExp", source: expr.source, flags: expr.flags }, options);
}
function RestResolve3(T) {
  return IsIntersect5(T) ? T.allOf : IsUnion5(T) ? T.anyOf : IsTuple5(T) ? T.items ?? [] : [];
}
function Rest3(T) {
  return RestResolve3(T);
}
function ReturnType3(schema, options) {
  return CreateType3(schema.returns, options);
}
var TransformDecodeBuilder3 = class {
  constructor(schema) {
    this.schema = schema;
  }
  Decode(decode4) {
    return new TransformEncodeBuilder3(this.schema, decode4);
  }
};
var TransformEncodeBuilder3 = class {
  constructor(schema, decode4) {
    this.schema = schema;
    this.decode = decode4;
  }
  EncodeTransform(encode4, schema) {
    const Encode3 = (value) => schema[TransformKind4].Encode(encode4(value));
    const Decode3 = (value) => this.decode(schema[TransformKind4].Decode(value));
    const Codec = { Encode: Encode3, Decode: Decode3 };
    return { ...schema, [TransformKind4]: Codec };
  }
  EncodeSchema(encode4, schema) {
    const Codec = { Decode: this.decode, Encode: encode4 };
    return { ...schema, [TransformKind4]: Codec };
  }
  Encode(encode4) {
    return IsTransform5(this.schema) ? this.EncodeTransform(encode4, this.schema) : this.EncodeSchema(encode4, this.schema);
  }
};
function Transform3(schema) {
  return new TransformDecodeBuilder3(schema);
}
function Unsafe3(options = {}) {
  return CreateType3({ [Kind4]: options[Kind4] ?? "Unsafe" }, options);
}
function Void3(options) {
  return CreateType3({ [Kind4]: "Void", type: "void" }, options);
}
var type_exports2 = {};
__export2(type_exports2, {
  Any: () => Any3,
  Array: () => Array22,
  AsyncIterator: () => AsyncIterator3,
  Awaited: () => Awaited3,
  BigInt: () => BigInt4,
  Boolean: () => Boolean4,
  Capitalize: () => Capitalize3,
  Composite: () => Composite3,
  Const: () => Const3,
  Constructor: () => Constructor3,
  ConstructorParameters: () => ConstructorParameters3,
  Date: () => Date22,
  Enum: () => Enum3,
  Exclude: () => Exclude3,
  Extends: () => Extends3,
  Extract: () => Extract3,
  Function: () => Function4,
  Index: () => Index3,
  InstanceType: () => InstanceType3,
  Integer: () => Integer3,
  Intersect: () => Intersect5,
  Iterator: () => Iterator3,
  KeyOf: () => KeyOf3,
  Literal: () => Literal3,
  Lowercase: () => Lowercase3,
  Mapped: () => Mapped3,
  Module: () => Module3,
  Never: () => Never3,
  Not: () => Not5,
  Null: () => Null3,
  Number: () => Number22,
  Object: () => Object22,
  Omit: () => Omit3,
  Optional: () => Optional3,
  Parameters: () => Parameters3,
  Partial: () => Partial3,
  Pick: () => Pick3,
  Promise: () => Promise22,
  Readonly: () => Readonly3,
  ReadonlyOptional: () => ReadonlyOptional3,
  Record: () => Record3,
  Recursive: () => Recursive3,
  Ref: () => Ref3,
  RegExp: () => RegExp22,
  Required: () => Required3,
  Rest: () => Rest3,
  ReturnType: () => ReturnType3,
  String: () => String4,
  Symbol: () => Symbol22,
  TemplateLiteral: () => TemplateLiteral3,
  Transform: () => Transform3,
  Tuple: () => Tuple3,
  Uint8Array: () => Uint8Array22,
  Uncapitalize: () => Uncapitalize3,
  Undefined: () => Undefined3,
  Union: () => Union5,
  Unknown: () => Unknown3,
  Unsafe: () => Unsafe3,
  Uppercase: () => Uppercase3,
  Void: () => Void3
});
var Type3 = type_exports2;
var jwt = ({
  name = "jwt",
  secret,
  alg = "HS256",
  crit,
  schema,
  nbf,
  exp,
  ...payload
}) => {
  if (!secret)
    throw new Error("Secret can't be empty");
  const key = typeof secret === "string" ? new TextEncoder().encode(secret) : secret;
  const validator = schema ? getSchemaValidator(Type3.Intersect([
    schema,
    Type3.Object({
      iss: Type3.Optional(Type3.String()),
      sub: Type3.Optional(Type3.String()),
      aud: Type3.Optional(Type3.Union([Type3.String(), Type3.Array(Type3.String())])),
      jti: Type3.Optional(Type3.String()),
      nbf: Type3.Optional(Type3.Union([Type3.String(), Type3.Number()])),
      exp: Type3.Optional(Type3.Union([Type3.String(), Type3.Number()])),
      iat: Type3.Optional(Type3.String())
    })
  ]), {}) : undefined;
  return new Elysia({
    name: "@elysiajs/jwt",
    seed: {
      name,
      secret,
      alg,
      crit,
      schema,
      nbf,
      exp,
      ...payload
    }
  }).decorate(name, {
    sign(morePayload) {
      let jwt2 = new SignJWT({
        ...payload,
        ...morePayload,
        nbf: undefined,
        exp: undefined
      }).setProtectedHeader({
        alg,
        crit
      });
      if (nbf)
        jwt2 = jwt2.setNotBefore(nbf);
      if (exp)
        jwt2 = jwt2.setExpirationTime(exp);
      return jwt2.sign(key);
    },
    async verify(jwt2) {
      if (!jwt2)
        return false;
      try {
        const data = (await jwtVerify(jwt2, key)).payload;
        if (validator && !validator.Check(data))
          throw new ValidationError("JWT", validator, data);
        return data;
      } catch (_3) {
        return false;
      }
    }
  });
};
var index_default3 = jwt;

// src/middleware/authPlugin.ts
console.log(Bun.env.JWT_TOKEN, "token");
var authPlugin = (app) => app.use(index_default3({
  secret: Bun.env.JWT_TOKEN
})).derive(async ({ jwt: jwt2, headers, set: set2 }) => {
  const authorization = headers.authorization;
  if (!authorization?.startsWith("Bearer ")) {
    return error2(401, "Unauthorized");
  }
  const token = authorization.slice(7);
  const payload = await jwt2.verify(token);
  if (!payload) {
    return error2(401, "Unauthorized");
  }
  console.log(payload, "payload");
  const user = await prisma.user.findUnique({
    where: {
      id: payload.sub
    }
  });
  if (!user) {
    return error2(401, "Unauthorized User");
  }
  return {
    user: {
      id: user.id,
      name: user.name,
      email: user.email,
      image: user.image
    }
  };
});

// src/routes/productRouter.ts
var productRouter = new Elysia2({ prefix: "/products" }).get("", async ({}) => {
  const products = await prisma.product.findMany({});
  return products;
}).use(authPlugin).get("/:id", async ({ params, ...request }) => {
  try {
    console.log(request, "request");
    const { id } = params;
    console.log({ id });
    const product = await prisma.product.findFirst({
      where: {
        id
      }
    });
    console.log("finding the product....");
    console.log(product, "product");
    return { product };
  } catch (e) {
    return error2(500, e);
  }
}, {
  params: t2.Object({
    id: t2.String({
      minLength: 1
    })
  })
});

// node_modules/@bogeychan/elysia-logger/dist/index.js
var import_pino2 = __toESM(require_pino(), 1);

// node_modules/@bogeychan/elysia-logger/dist/config/serializers.js
var import_pino = __toESM(require_pino(), 1);
var serializers = {
  request: serializeRequest,
  err: import_pino.stdSerializers.err
};
function serializeRequest(request) {
  return {
    method: request.method,
    url: request.url,
    referrer: request.headers.get("Referer")
  };
}

// node_modules/@bogeychan/elysia-logger/dist/config/formatters.js
var formatters = {
  log(object) {
    if (isContext(object)) {
      const log = {
        request: object.request
      };
      if (object.isError) {
        log.code = object.code;
        log.message = object.error.message;
      } else {
        if (object.store.responseTime) {
          log.responseTime = object.store.responseTime;
        }
      }
      return log;
    } else if (isRequest(object)) {
      return serializeRequest(object);
    }
    return object;
  }
};
function isContext(object) {
  const context = object;
  switch (undefined) {
    case context.request:
    case context.store:
    case context.isError:
      return false;
  }
  return true;
}
function isRequest(object) {
  const request = object;
  switch (undefined) {
    case request.url:
    case request.method:
      return false;
  }
  return true;
}
// node_modules/@bogeychan/elysia-logger/dist/index.js
var import_pino3 = __toESM(require_pino(), 1);
function logger(options = {}) {
  return plugin(options);
}
function createPinoLoggerInternal(options) {
  options.level ??= "info";
  options.formatters ??= formatters;
  options.serializers ??= serializers;
  const streamOptions = options;
  if ("file" in options) {
    streamOptions.stream = import_pino2.pino.destination(options.file);
    delete options.file;
  }
  return import_pino2.pino(options, streamOptions.stream);
}
function into(options = {}) {
  const useLevel = options.useLevel ?? "info";
  const autoLogging = options.autoLogging ?? true;
  delete options.autoLogging;
  const getLog = (ctx) => {
    return typeof options.customProps === "function" ? this.child(options.customProps(ctx)) : this;
  };
  let app = new Elysia2({
    name: "@bogeychan/elysia-logger",
    seed: options
  }).derive({ as: "global" }, (ctx) => {
    const loggerCtx = ctx;
    loggerCtx.isError = false;
    return { log: getLog(loggerCtx) };
  });
  if (autoLogging) {
    return app.onRequest((ctx) => {
      ctx.store = { ...ctx.store, startTime: performance.now() };
    }).onAfterResponse((ctx) => {
      const loggerCtx = ctx;
      loggerCtx.isError = false;
      const log = getLog(loggerCtx);
      if (log.level == "silent") {
        return;
      }
      if (typeof autoLogging == "object" && autoLogging.ignore(loggerCtx)) {
        return;
      }
      ctx.store.startTime ??= 0;
      ctx.store.endTime = performance.now();
      ctx.store.responseTime = ctx.store.endTime - ctx.store.startTime;
      log[useLevel](ctx);
    }).onError((ctx) => {
      const loggerCtx = ctx;
      loggerCtx.isError = true;
      const log = getLog(loggerCtx);
      if (log.level == "silent") {
        return;
      }
      if (typeof autoLogging == "object" && autoLogging.ignore(loggerCtx)) {
        return;
      }
      if (ctx.code === "NOT_FOUND") {
        log[useLevel](ctx);
      } else {
        log.error(ctx);
      }
    }).as("global");
  }
  return app;
}
var plugin = (options) => into.bind(createPinoLoggerInternal(options))(options);

// src/routes/authRouter.ts
var authRouter = new Elysia2({ prefix: "/auth" }).use(index_default3({
  secret: Bun.env.JWT_TOKEN
})).post("/login", async ({ body, jwt: jwt2 }) => {
  try {
    const { email, password } = body;
    const user = await prisma.user.findUnique({
      where: {
        email
      }
    });
    if (!user) {
      return error2(401, "User not found");
    }
    const isPasswordCorrect = await Bun.password.verify(password, user?.password);
    if (!isPasswordCorrect) {
      return error2(401, "Invalid password");
    }
    const token = await jwt2.sign({
      sub: user.id
    });
    return {
      token,
      user: {
        name: user.name,
        email: user.email,
        image: user.image
      }
    };
  } catch (e) {
    return error2(500, "Internal Server Error");
  }
}, {
  body: t2.Object({
    email: t2.String({
      minLength: 3,
      maxLength: 30
    }),
    password: t2.String({
      minLength: 3,
      maxLength: 30
    })
  })
});

// node_modules/nanoid/index.js
import { webcrypto as crypto2 } from "crypto";

// node_modules/nanoid/url-alphabet/index.js
var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";

// node_modules/nanoid/index.js
var POOL_SIZE_MULTIPLIER = 128;
var pool;
var poolOffset;
function fillPool(bytes) {
  if (!pool || pool.length < bytes) {
    pool = Buffer.allocUnsafe(bytes * POOL_SIZE_MULTIPLIER);
    crypto2.getRandomValues(pool);
    poolOffset = 0;
  } else if (poolOffset + bytes > pool.length) {
    crypto2.getRandomValues(pool);
    poolOffset = 0;
  }
  poolOffset += bytes;
}
function nanoid(size = 21) {
  fillPool(size |= 0);
  let id = "";
  for (let i = poolOffset - size;i < poolOffset; i++) {
    id += urlAlphabet[pool[i] & 63];
  }
  return id;
}

// node_modules/stripe/esm/net/HttpClient.js
class HttpClient {
  getClientName() {
    throw new Error("getClientName not implemented.");
  }
  makeRequest(host, port, path2, method, headers, requestData, protocol, timeout) {
    throw new Error("makeRequest not implemented.");
  }
  static makeTimeoutError() {
    const timeoutErr = new TypeError(HttpClient.TIMEOUT_ERROR_CODE);
    timeoutErr.code = HttpClient.TIMEOUT_ERROR_CODE;
    return timeoutErr;
  }
}
HttpClient.CONNECTION_CLOSED_ERROR_CODES = ["ECONNRESET", "EPIPE"];
HttpClient.TIMEOUT_ERROR_CODE = "ETIMEDOUT";

class HttpClientResponse {
  constructor(statusCode, headers) {
    this._statusCode = statusCode;
    this._headers = headers;
  }
  getStatusCode() {
    return this._statusCode;
  }
  getHeaders() {
    return this._headers;
  }
  getRawResponse() {
    throw new Error("getRawResponse not implemented.");
  }
  toStream(streamCompleteCallback) {
    throw new Error("toStream not implemented.");
  }
  toJSON() {
    throw new Error("toJSON not implemented.");
  }
}

// node_modules/stripe/esm/net/FetchHttpClient.js
class FetchHttpClient extends HttpClient {
  constructor(fetchFn) {
    super();
    if (!fetchFn) {
      if (!globalThis.fetch) {
        throw new Error("fetch() function not provided and is not defined in the global scope. " + "You must provide a fetch implementation.");
      }
      fetchFn = globalThis.fetch;
    }
    if (globalThis.AbortController) {
      this._fetchFn = FetchHttpClient.makeFetchWithAbortTimeout(fetchFn);
    } else {
      this._fetchFn = FetchHttpClient.makeFetchWithRaceTimeout(fetchFn);
    }
  }
  static makeFetchWithRaceTimeout(fetchFn) {
    return (url, init, timeout) => {
      let pendingTimeoutId;
      const timeoutPromise = new Promise((_3, reject) => {
        pendingTimeoutId = setTimeout(() => {
          pendingTimeoutId = null;
          reject(HttpClient.makeTimeoutError());
        }, timeout);
      });
      const fetchPromise = fetchFn(url, init);
      return Promise.race([fetchPromise, timeoutPromise]).finally(() => {
        if (pendingTimeoutId) {
          clearTimeout(pendingTimeoutId);
        }
      });
    };
  }
  static makeFetchWithAbortTimeout(fetchFn) {
    return async (url, init, timeout) => {
      const abort = new AbortController;
      let timeoutId = setTimeout(() => {
        timeoutId = null;
        abort.abort(HttpClient.makeTimeoutError());
      }, timeout);
      try {
        return await fetchFn(url, Object.assign(Object.assign({}, init), { signal: abort.signal }));
      } catch (err) {
        if (err.name === "AbortError") {
          throw HttpClient.makeTimeoutError();
        } else {
          throw err;
        }
      } finally {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
      }
    };
  }
  getClientName() {
    return "fetch";
  }
  async makeRequest(host, port, path2, method, headers, requestData, protocol, timeout) {
    const isInsecureConnection = protocol === "http";
    const url = new URL(path2, `${isInsecureConnection ? "http" : "https"}://${host}`);
    url.port = port;
    const methodHasPayload = method == "POST" || method == "PUT" || method == "PATCH";
    const body = requestData || (methodHasPayload ? "" : undefined);
    const res = await this._fetchFn(url.toString(), {
      method,
      headers,
      body
    }, timeout);
    return new FetchHttpClientResponse(res);
  }
}

class FetchHttpClientResponse extends HttpClientResponse {
  constructor(res) {
    super(res.status, FetchHttpClientResponse._transformHeadersToObject(res.headers));
    this._res = res;
  }
  getRawResponse() {
    return this._res;
  }
  toStream(streamCompleteCallback) {
    streamCompleteCallback();
    return this._res.body;
  }
  toJSON() {
    return this._res.json();
  }
  static _transformHeadersToObject(headers) {
    const headersObj = {};
    for (const entry of headers) {
      if (!Array.isArray(entry) || entry.length != 2) {
        throw new Error("Response objects produced by the fetch function given to FetchHttpClient do not have an iterable headers map. Response#headers should be an iterable object.");
      }
      headersObj[entry[0]] = entry[1];
    }
    return headersObj;
  }
}

// node_modules/stripe/esm/crypto/CryptoProvider.js
class CryptoProvider {
  computeHMACSignature(payload, secret) {
    throw new Error("computeHMACSignature not implemented.");
  }
  computeHMACSignatureAsync(payload, secret) {
    throw new Error("computeHMACSignatureAsync not implemented.");
  }
  computeSHA256Async(data) {
    throw new Error("computeSHA256 not implemented.");
  }
}

class CryptoProviderOnlySupportsAsyncError extends Error {
}

// node_modules/stripe/esm/crypto/SubtleCryptoProvider.js
class SubtleCryptoProvider extends CryptoProvider {
  constructor(subtleCrypto) {
    super();
    this.subtleCrypto = subtleCrypto || crypto.subtle;
  }
  computeHMACSignature(payload, secret) {
    throw new CryptoProviderOnlySupportsAsyncError("SubtleCryptoProvider cannot be used in a synchronous context.");
  }
  async computeHMACSignatureAsync(payload, secret) {
    const encoder4 = new TextEncoder;
    const key = await this.subtleCrypto.importKey("raw", encoder4.encode(secret), {
      name: "HMAC",
      hash: { name: "SHA-256" }
    }, false, ["sign"]);
    const signatureBuffer = await this.subtleCrypto.sign("hmac", key, encoder4.encode(payload));
    const signatureBytes = new Uint8Array(signatureBuffer);
    const signatureHexCodes = new Array(signatureBytes.length);
    for (let i = 0;i < signatureBytes.length; i++) {
      signatureHexCodes[i] = byteHexMapping[signatureBytes[i]];
    }
    return signatureHexCodes.join("");
  }
  async computeSHA256Async(data) {
    return new Uint8Array(await this.subtleCrypto.digest("SHA-256", data));
  }
}
var byteHexMapping = new Array(256);
for (let i = 0;i < byteHexMapping.length; i++) {
  byteHexMapping[i] = i.toString(16).padStart(2, "0");
}

// node_modules/stripe/esm/platform/PlatformFunctions.js
class PlatformFunctions {
  constructor() {
    this._fetchFn = null;
    this._agent = null;
  }
  getUname() {
    throw new Error("getUname not implemented.");
  }
  uuid4() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c2) => {
      const r2 = Math.random() * 16 | 0;
      const v = c2 === "x" ? r2 : r2 & 3 | 8;
      return v.toString(16);
    });
  }
  secureCompare(a13, b) {
    if (a13.length !== b.length) {
      return false;
    }
    const len = a13.length;
    let result = 0;
    for (let i = 0;i < len; ++i) {
      result |= a13.charCodeAt(i) ^ b.charCodeAt(i);
    }
    return result === 0;
  }
  createEmitter() {
    throw new Error("createEmitter not implemented.");
  }
  tryBufferData(data) {
    throw new Error("tryBufferData not implemented.");
  }
  createNodeHttpClient(agent) {
    throw new Error("createNodeHttpClient not implemented.");
  }
  createFetchHttpClient(fetchFn) {
    return new FetchHttpClient(fetchFn);
  }
  createDefaultHttpClient() {
    throw new Error("createDefaultHttpClient not implemented.");
  }
  createNodeCryptoProvider() {
    throw new Error("createNodeCryptoProvider not implemented.");
  }
  createSubtleCryptoProvider(subtleCrypto) {
    return new SubtleCryptoProvider(subtleCrypto);
  }
  createDefaultCryptoProvider() {
    throw new Error("createDefaultCryptoProvider not implemented.");
  }
}

// node_modules/stripe/esm/StripeEmitter.js
class _StripeEvent extends Event {
  constructor(eventName, data) {
    super(eventName);
    this.data = data;
  }
}

class StripeEmitter {
  constructor() {
    this.eventTarget = new EventTarget;
    this.listenerMapping = new Map;
  }
  on(eventName, listener) {
    const listenerWrapper = (event) => {
      listener(event.data);
    };
    this.listenerMapping.set(listener, listenerWrapper);
    return this.eventTarget.addEventListener(eventName, listenerWrapper);
  }
  removeListener(eventName, listener) {
    const listenerWrapper = this.listenerMapping.get(listener);
    this.listenerMapping.delete(listener);
    return this.eventTarget.removeEventListener(eventName, listenerWrapper);
  }
  once(eventName, listener) {
    const listenerWrapper = (event) => {
      listener(event.data);
    };
    this.listenerMapping.set(listener, listenerWrapper);
    return this.eventTarget.addEventListener(eventName, listenerWrapper, {
      once: true
    });
  }
  emit(eventName, data) {
    return this.eventTarget.dispatchEvent(new _StripeEvent(eventName, data));
  }
}

// node_modules/stripe/esm/platform/WebPlatformFunctions.js
class WebPlatformFunctions extends PlatformFunctions {
  getUname() {
    return Promise.resolve(null);
  }
  createEmitter() {
    return new StripeEmitter;
  }
  tryBufferData(data) {
    if (data.file.data instanceof ReadableStream) {
      throw new Error("Uploading a file as a stream is not supported in non-Node environments. Please open or upvote an issue at github.com/stripe/stripe-node if you use this, detailing your use-case.");
    }
    return Promise.resolve(data);
  }
  createNodeHttpClient() {
    throw new Error("Stripe: `createNodeHttpClient()` is not available in non-Node environments. Please use `createFetchHttpClient()` instead.");
  }
  createDefaultHttpClient() {
    return super.createFetchHttpClient();
  }
  createNodeCryptoProvider() {
    throw new Error("Stripe: `createNodeCryptoProvider()` is not available in non-Node environments. Please use `createSubtleCryptoProvider()` instead.");
  }
  createDefaultCryptoProvider() {
    return this.createSubtleCryptoProvider();
  }
}

// node_modules/stripe/esm/Error.js
var exports_Error = {};
__export(exports_Error, {
  generateV2Error: () => generateV2Error,
  generateV1Error: () => generateV1Error,
  TemporarySessionExpiredError: () => TemporarySessionExpiredError,
  StripeUnknownError: () => StripeUnknownError,
  StripeSignatureVerificationError: () => StripeSignatureVerificationError,
  StripeRateLimitError: () => StripeRateLimitError,
  StripePermissionError: () => StripePermissionError,
  StripeInvalidRequestError: () => StripeInvalidRequestError,
  StripeInvalidGrantError: () => StripeInvalidGrantError,
  StripeIdempotencyError: () => StripeIdempotencyError,
  StripeError: () => StripeError,
  StripeConnectionError: () => StripeConnectionError,
  StripeCardError: () => StripeCardError,
  StripeAuthenticationError: () => StripeAuthenticationError,
  StripeAPIError: () => StripeAPIError
});
var generateV1Error = (rawStripeError) => {
  switch (rawStripeError.type) {
    case "card_error":
      return new StripeCardError(rawStripeError);
    case "invalid_request_error":
      return new StripeInvalidRequestError(rawStripeError);
    case "api_error":
      return new StripeAPIError(rawStripeError);
    case "authentication_error":
      return new StripeAuthenticationError(rawStripeError);
    case "rate_limit_error":
      return new StripeRateLimitError(rawStripeError);
    case "idempotency_error":
      return new StripeIdempotencyError(rawStripeError);
    case "invalid_grant":
      return new StripeInvalidGrantError(rawStripeError);
    default:
      return new StripeUnknownError(rawStripeError);
  }
};
var generateV2Error = (rawStripeError) => {
  switch (rawStripeError.type) {
    case "temporary_session_expired":
      return new TemporarySessionExpiredError(rawStripeError);
  }
  switch (rawStripeError.code) {
    case "invalid_fields":
      return new StripeInvalidRequestError(rawStripeError);
  }
  return generateV1Error(rawStripeError);
};

class StripeError extends Error {
  constructor(raw2 = {}, type = null) {
    super(raw2.message);
    this.type = type || this.constructor.name;
    this.raw = raw2;
    this.rawType = raw2.type;
    this.code = raw2.code;
    this.doc_url = raw2.doc_url;
    this.param = raw2.param;
    this.detail = raw2.detail;
    this.headers = raw2.headers;
    this.requestId = raw2.requestId;
    this.statusCode = raw2.statusCode;
    this.message = raw2.message;
    this.userMessage = raw2.user_message;
    this.charge = raw2.charge;
    this.decline_code = raw2.decline_code;
    this.payment_intent = raw2.payment_intent;
    this.payment_method = raw2.payment_method;
    this.payment_method_type = raw2.payment_method_type;
    this.setup_intent = raw2.setup_intent;
    this.source = raw2.source;
  }
}
StripeError.generate = generateV1Error;

class StripeCardError extends StripeError {
  constructor(raw2 = {}) {
    super(raw2, "StripeCardError");
  }
}

class StripeInvalidRequestError extends StripeError {
  constructor(raw2 = {}) {
    super(raw2, "StripeInvalidRequestError");
  }
}

class StripeAPIError extends StripeError {
  constructor(raw2 = {}) {
    super(raw2, "StripeAPIError");
  }
}

class StripeAuthenticationError extends StripeError {
  constructor(raw2 = {}) {
    super(raw2, "StripeAuthenticationError");
  }
}

class StripePermissionError extends StripeError {
  constructor(raw2 = {}) {
    super(raw2, "StripePermissionError");
  }
}

class StripeRateLimitError extends StripeError {
  constructor(raw2 = {}) {
    super(raw2, "StripeRateLimitError");
  }
}

class StripeConnectionError extends StripeError {
  constructor(raw2 = {}) {
    super(raw2, "StripeConnectionError");
  }
}

class StripeSignatureVerificationError extends StripeError {
  constructor(header, payload, raw2 = {}) {
    super(raw2, "StripeSignatureVerificationError");
    this.header = header;
    this.payload = payload;
  }
}

class StripeIdempotencyError extends StripeError {
  constructor(raw2 = {}) {
    super(raw2, "StripeIdempotencyError");
  }
}

class StripeInvalidGrantError extends StripeError {
  constructor(raw2 = {}) {
    super(raw2, "StripeInvalidGrantError");
  }
}

class StripeUnknownError extends StripeError {
  constructor(raw2 = {}) {
    super(raw2, "StripeUnknownError");
  }
}

class TemporarySessionExpiredError extends StripeError {
  constructor(rawStripeError = {}) {
    super(rawStripeError, "TemporarySessionExpiredError");
  }
}

// node_modules/stripe/esm/utils.js
var qs = __toESM(require_lib(), 1);
var OPTIONS_KEYS = [
  "apiKey",
  "idempotencyKey",
  "stripeAccount",
  "apiVersion",
  "maxNetworkRetries",
  "timeout",
  "host",
  "authenticator",
  "stripeContext",
  "additionalHeaders"
];
function isOptionsHash(o2) {
  return o2 && typeof o2 === "object" && OPTIONS_KEYS.some((prop) => Object.prototype.hasOwnProperty.call(o2, prop));
}
function queryStringifyRequestData(data, apiMode) {
  return qs.stringify(data, {
    serializeDate: (d) => Math.floor(d.getTime() / 1000).toString(),
    arrayFormat: apiMode == "v2" ? "repeat" : "indices"
  }).replace(/%5B/g, "[").replace(/%5D/g, "]");
}
var makeURLInterpolator = (() => {
  const rc = {
    "\n": "\\n",
    '"': "\\\"",
    "\u2028": "\\u2028",
    "\u2029": "\\u2029"
  };
  return (str) => {
    const cleanString = str.replace(/["\n\r\u2028\u2029]/g, ($0) => rc[$0]);
    return (outputs) => {
      return cleanString.replace(/\{([\s\S]+?)\}/g, ($0, $1) => encodeURIComponent(outputs[$1] || ""));
    };
  };
})();
function extractUrlParams(path2) {
  const params = path2.match(/\{\w+\}/g);
  if (!params) {
    return [];
  }
  return params.map((param) => param.replace(/[{}]/g, ""));
}
function getDataFromArgs(args) {
  if (!Array.isArray(args) || !args[0] || typeof args[0] !== "object") {
    return {};
  }
  if (!isOptionsHash(args[0])) {
    return args.shift();
  }
  const argKeys = Object.keys(args[0]);
  const optionKeysInArgs = argKeys.filter((key) => OPTIONS_KEYS.includes(key));
  if (optionKeysInArgs.length > 0 && optionKeysInArgs.length !== argKeys.length) {
    emitWarning(`Options found in arguments (${optionKeysInArgs.join(", ")}). Did you mean to pass an options object? See https://github.com/stripe/stripe-node/wiki/Passing-Options.`);
  }
  return {};
}
function getOptionsFromArgs(args) {
  const opts = {
    host: null,
    headers: {},
    settings: {}
  };
  if (args.length > 0) {
    const arg = args[args.length - 1];
    if (typeof arg === "string") {
      opts.authenticator = createApiKeyAuthenticator(args.pop());
    } else if (isOptionsHash(arg)) {
      const params = Object.assign({}, args.pop());
      const extraKeys = Object.keys(params).filter((key) => !OPTIONS_KEYS.includes(key));
      if (extraKeys.length) {
        emitWarning(`Invalid options found (${extraKeys.join(", ")}); ignoring.`);
      }
      if (params.apiKey) {
        opts.authenticator = createApiKeyAuthenticator(params.apiKey);
      }
      if (params.idempotencyKey) {
        opts.headers["Idempotency-Key"] = params.idempotencyKey;
      }
      if (params.stripeAccount) {
        opts.headers["Stripe-Account"] = params.stripeAccount;
      }
      if (params.stripeContext) {
        if (opts.headers["Stripe-Account"]) {
          throw new Error("Can't specify both stripeAccount and stripeContext.");
        }
        opts.headers["Stripe-Context"] = params.stripeContext;
      }
      if (params.apiVersion) {
        opts.headers["Stripe-Version"] = params.apiVersion;
      }
      if (Number.isInteger(params.maxNetworkRetries)) {
        opts.settings.maxNetworkRetries = params.maxNetworkRetries;
      }
      if (Number.isInteger(params.timeout)) {
        opts.settings.timeout = params.timeout;
      }
      if (params.host) {
        opts.host = params.host;
      }
      if (params.authenticator) {
        if (params.apiKey) {
          throw new Error("Can't specify both apiKey and authenticator.");
        }
        if (typeof params.authenticator !== "function") {
          throw new Error("The authenticator must be a function " + "receiving a request as the first parameter.");
        }
        opts.authenticator = params.authenticator;
      }
      if (params.additionalHeaders) {
        opts.headers = params.additionalHeaders;
      }
    }
  }
  return opts;
}
function protoExtend(sub) {
  const Super = this;
  const Constructor4 = Object.prototype.hasOwnProperty.call(sub, "constructor") ? sub.constructor : function(...args) {
    Super.apply(this, args);
  };
  Object.assign(Constructor4, Super);
  Constructor4.prototype = Object.create(Super.prototype);
  Object.assign(Constructor4.prototype, sub);
  return Constructor4;
}
function removeNullish(obj) {
  if (typeof obj !== "object") {
    throw new Error("Argument must be an object");
  }
  return Object.keys(obj).reduce((result, key) => {
    if (obj[key] != null) {
      result[key] = obj[key];
    }
    return result;
  }, {});
}
function normalizeHeaders(obj) {
  if (!(obj && typeof obj === "object")) {
    return obj;
  }
  return Object.keys(obj).reduce((result, header) => {
    result[normalizeHeader(header)] = obj[header];
    return result;
  }, {});
}
function normalizeHeader(header) {
  return header.split("-").map((text) => text.charAt(0).toUpperCase() + text.substr(1).toLowerCase()).join("-");
}
function callbackifyPromiseWithTimeout(promise, callback) {
  if (callback) {
    return promise.then((res) => {
      setTimeout(() => {
        callback(null, res);
      }, 0);
    }, (err) => {
      setTimeout(() => {
        callback(err, null);
      }, 0);
    });
  }
  return promise;
}
function pascalToCamelCase(name) {
  if (name === "OAuth") {
    return "oauth";
  } else {
    return name[0].toLowerCase() + name.substring(1);
  }
}
function emitWarning(warning) {
  if (typeof process.emitWarning !== "function") {
    return console.warn(`Stripe: ${warning}`);
  }
  return process.emitWarning(warning, "Stripe");
}
function isObject4(obj) {
  const type = typeof obj;
  return (type === "function" || type === "object") && !!obj;
}
function flattenAndStringify(data) {
  const result = {};
  const step = (obj, prevKey) => {
    Object.entries(obj).forEach(([key, value]) => {
      const newKey = prevKey ? `${prevKey}[${key}]` : key;
      if (isObject4(value)) {
        if (!(value instanceof Uint8Array) && !Object.prototype.hasOwnProperty.call(value, "data")) {
          return step(value, newKey);
        } else {
          result[newKey] = value;
        }
      } else {
        result[newKey] = String(value);
      }
    });
  };
  step(data, null);
  return result;
}
function validateInteger(name, n2, defaultVal) {
  if (!Number.isInteger(n2)) {
    if (defaultVal !== undefined) {
      return defaultVal;
    } else {
      throw new Error(`${name} must be an integer`);
    }
  }
  return n2;
}
function determineProcessUserAgentProperties() {
  return typeof process === "undefined" ? {} : {
    lang_version: process.version,
    platform: process.platform
  };
}
function createApiKeyAuthenticator(apiKey) {
  const authenticator = (request) => {
    request.headers.Authorization = "Bearer " + apiKey;
    return Promise.resolve();
  };
  authenticator._apiKey = apiKey;
  return authenticator;
}
function dateTimeReplacer(key, value) {
  if (this[key] instanceof Date) {
    return Math.floor(this[key].getTime() / 1000).toString();
  }
  return value;
}
function jsonStringifyRequestData(data) {
  return JSON.stringify(data, dateTimeReplacer);
}
function getAPIMode(path2) {
  if (!path2) {
    return "v1";
  }
  return path2.startsWith("/v2") ? "v2" : "v1";
}

// node_modules/stripe/esm/RequestSender.js
var MAX_RETRY_AFTER_WAIT = 60;

class RequestSender {
  constructor(stripe, maxBufferedRequestMetric) {
    this._stripe = stripe;
    this._maxBufferedRequestMetric = maxBufferedRequestMetric;
  }
  _addHeadersDirectlyToObject(obj, headers) {
    obj.requestId = headers["request-id"];
    obj.stripeAccount = obj.stripeAccount || headers["stripe-account"];
    obj.apiVersion = obj.apiVersion || headers["stripe-version"];
    obj.idempotencyKey = obj.idempotencyKey || headers["idempotency-key"];
  }
  _makeResponseEvent(requestEvent, statusCode, headers) {
    const requestEndTime = Date.now();
    const requestDurationMs = requestEndTime - requestEvent.request_start_time;
    return removeNullish({
      api_version: headers["stripe-version"],
      account: headers["stripe-account"],
      idempotency_key: headers["idempotency-key"],
      method: requestEvent.method,
      path: requestEvent.path,
      status: statusCode,
      request_id: this._getRequestId(headers),
      elapsed: requestDurationMs,
      request_start_time: requestEvent.request_start_time,
      request_end_time: requestEndTime
    });
  }
  _getRequestId(headers) {
    return headers["request-id"];
  }
  _streamingResponseHandler(requestEvent, usage, callback) {
    return (res) => {
      const headers = res.getHeaders();
      const streamCompleteCallback = () => {
        const responseEvent = this._makeResponseEvent(requestEvent, res.getStatusCode(), headers);
        this._stripe._emitter.emit("response", responseEvent);
        this._recordRequestMetrics(this._getRequestId(headers), responseEvent.elapsed, usage);
      };
      const stream = res.toStream(streamCompleteCallback);
      this._addHeadersDirectlyToObject(stream, headers);
      return callback(null, stream);
    };
  }
  _jsonResponseHandler(requestEvent, apiMode, usage, callback) {
    return (res) => {
      const headers = res.getHeaders();
      const requestId = this._getRequestId(headers);
      const statusCode = res.getStatusCode();
      const responseEvent = this._makeResponseEvent(requestEvent, statusCode, headers);
      this._stripe._emitter.emit("response", responseEvent);
      res.toJSON().then((jsonResponse) => {
        if (jsonResponse.error) {
          let err;
          if (typeof jsonResponse.error === "string") {
            jsonResponse.error = {
              type: jsonResponse.error,
              message: jsonResponse.error_description
            };
          }
          jsonResponse.error.headers = headers;
          jsonResponse.error.statusCode = statusCode;
          jsonResponse.error.requestId = requestId;
          if (statusCode === 401) {
            err = new StripeAuthenticationError(jsonResponse.error);
          } else if (statusCode === 403) {
            err = new StripePermissionError(jsonResponse.error);
          } else if (statusCode === 429) {
            err = new StripeRateLimitError(jsonResponse.error);
          } else if (apiMode === "v2") {
            err = generateV2Error(jsonResponse.error);
          } else {
            err = generateV1Error(jsonResponse.error);
          }
          throw err;
        }
        return jsonResponse;
      }, (e) => {
        throw new StripeAPIError({
          message: "Invalid JSON received from the Stripe API",
          exception: e,
          requestId: headers["request-id"]
        });
      }).then((jsonResponse) => {
        this._recordRequestMetrics(requestId, responseEvent.elapsed, usage);
        const rawResponse = res.getRawResponse();
        this._addHeadersDirectlyToObject(rawResponse, headers);
        Object.defineProperty(jsonResponse, "lastResponse", {
          enumerable: false,
          writable: false,
          value: rawResponse
        });
        callback(null, jsonResponse);
      }, (e) => callback(e, null));
    };
  }
  static _generateConnectionErrorMessage(requestRetries) {
    return `An error occurred with our connection to Stripe.${requestRetries > 0 ? ` Request was retried ${requestRetries} times.` : ""}`;
  }
  static _shouldRetry(res, numRetries, maxRetries, error3) {
    if (error3 && numRetries === 0 && HttpClient.CONNECTION_CLOSED_ERROR_CODES.includes(error3.code)) {
      return true;
    }
    if (numRetries >= maxRetries) {
      return false;
    }
    if (!res) {
      return true;
    }
    if (res.getHeaders()["stripe-should-retry"] === "false") {
      return false;
    }
    if (res.getHeaders()["stripe-should-retry"] === "true") {
      return true;
    }
    if (res.getStatusCode() === 409) {
      return true;
    }
    if (res.getStatusCode() >= 500) {
      return true;
    }
    return false;
  }
  _getSleepTimeInMS(numRetries, retryAfter = null) {
    const initialNetworkRetryDelay = this._stripe.getInitialNetworkRetryDelay();
    const maxNetworkRetryDelay = this._stripe.getMaxNetworkRetryDelay();
    let sleepSeconds = Math.min(initialNetworkRetryDelay * Math.pow(2, numRetries - 1), maxNetworkRetryDelay);
    sleepSeconds *= 0.5 * (1 + Math.random());
    sleepSeconds = Math.max(initialNetworkRetryDelay, sleepSeconds);
    if (Number.isInteger(retryAfter) && retryAfter <= MAX_RETRY_AFTER_WAIT) {
      sleepSeconds = Math.max(sleepSeconds, retryAfter);
    }
    return sleepSeconds * 1000;
  }
  _getMaxNetworkRetries(settings = {}) {
    return settings.maxNetworkRetries !== undefined && Number.isInteger(settings.maxNetworkRetries) ? settings.maxNetworkRetries : this._stripe.getMaxNetworkRetries();
  }
  _defaultIdempotencyKey(method, settings, apiMode) {
    const maxRetries = this._getMaxNetworkRetries(settings);
    const genKey = () => `stripe-node-retry-${this._stripe._platformFunctions.uuid4()}`;
    if (apiMode === "v2") {
      if (method === "POST" || method === "DELETE") {
        return genKey();
      }
    } else if (apiMode === "v1") {
      if (method === "POST" && maxRetries > 0) {
        return genKey();
      }
    }
    return null;
  }
  _makeHeaders({ contentType, contentLength, apiVersion, clientUserAgent, method, userSuppliedHeaders, userSuppliedSettings, stripeAccount, stripeContext, apiMode }) {
    const defaultHeaders = {
      Accept: "application/json",
      "Content-Type": contentType,
      "User-Agent": this._getUserAgentString(apiMode),
      "X-Stripe-Client-User-Agent": clientUserAgent,
      "X-Stripe-Client-Telemetry": this._getTelemetryHeader(),
      "Stripe-Version": apiVersion,
      "Stripe-Account": stripeAccount,
      "Stripe-Context": stripeContext,
      "Idempotency-Key": this._defaultIdempotencyKey(method, userSuppliedSettings, apiMode)
    };
    const methodHasPayload = method == "POST" || method == "PUT" || method == "PATCH";
    if (methodHasPayload || contentLength) {
      if (!methodHasPayload) {
        emitWarning(`${method} method had non-zero contentLength but no payload is expected for this verb`);
      }
      defaultHeaders["Content-Length"] = contentLength;
    }
    return Object.assign(removeNullish(defaultHeaders), normalizeHeaders(userSuppliedHeaders));
  }
  _getUserAgentString(apiMode) {
    const packageVersion = this._stripe.getConstant("PACKAGE_VERSION");
    const appInfo = this._stripe._appInfo ? this._stripe.getAppInfoAsString() : "";
    return `Stripe/${apiMode} NodeBindings/${packageVersion} ${appInfo}`.trim();
  }
  _getTelemetryHeader() {
    if (this._stripe.getTelemetryEnabled() && this._stripe._prevRequestMetrics.length > 0) {
      const metrics = this._stripe._prevRequestMetrics.shift();
      return JSON.stringify({
        last_request_metrics: metrics
      });
    }
  }
  _recordRequestMetrics(requestId, requestDurationMs, usage) {
    if (this._stripe.getTelemetryEnabled() && requestId) {
      if (this._stripe._prevRequestMetrics.length > this._maxBufferedRequestMetric) {
        emitWarning("Request metrics buffer is full, dropping telemetry message.");
      } else {
        const m2 = {
          request_id: requestId,
          request_duration_ms: requestDurationMs
        };
        if (usage && usage.length > 0) {
          m2.usage = usage;
        }
        this._stripe._prevRequestMetrics.push(m2);
      }
    }
  }
  _rawRequest(method, path2, params, options) {
    const requestPromise = new Promise((resolve2, reject) => {
      let opts;
      try {
        const requestMethod = method.toUpperCase();
        if (requestMethod !== "POST" && params && Object.keys(params).length !== 0) {
          throw new Error("rawRequest only supports params on POST requests. Please pass null and add your parameters to path.");
        }
        const args = [].slice.call([params, options]);
        const dataFromArgs = getDataFromArgs(args);
        const data = Object.assign({}, dataFromArgs);
        const calculatedOptions = getOptionsFromArgs(args);
        const headers2 = calculatedOptions.headers;
        const authenticator2 = calculatedOptions.authenticator;
        opts = {
          requestMethod,
          requestPath: path2,
          bodyData: data,
          queryData: {},
          authenticator: authenticator2,
          headers: headers2,
          host: null,
          streaming: false,
          settings: {},
          usage: ["raw_request"]
        };
      } catch (err) {
        reject(err);
        return;
      }
      function requestCallback(err, response) {
        if (err) {
          reject(err);
        } else {
          resolve2(response);
        }
      }
      const { headers, settings } = opts;
      const authenticator = opts.authenticator;
      this._request(opts.requestMethod, opts.host, path2, opts.bodyData, authenticator, { headers, settings, streaming: opts.streaming }, opts.usage, requestCallback);
    });
    return requestPromise;
  }
  _request(method, host, path2, data, authenticator, options, usage = [], callback, requestDataProcessor = null) {
    var _a;
    let requestData;
    authenticator = (_a = authenticator !== null && authenticator !== undefined ? authenticator : this._stripe._authenticator) !== null && _a !== undefined ? _a : null;
    const apiMode = getAPIMode(path2);
    const retryRequest = (requestFn, apiVersion, headers, requestRetries, retryAfter) => {
      return setTimeout(requestFn, this._getSleepTimeInMS(requestRetries, retryAfter), apiVersion, headers, requestRetries + 1);
    };
    const makeRequest = (apiVersion, headers, numRetries) => {
      const timeout = options.settings && options.settings.timeout && Number.isInteger(options.settings.timeout) && options.settings.timeout >= 0 ? options.settings.timeout : this._stripe.getApiField("timeout");
      const request = {
        host: host || this._stripe.getApiField("host"),
        port: this._stripe.getApiField("port"),
        path: path2,
        method,
        headers: Object.assign({}, headers),
        body: requestData,
        protocol: this._stripe.getApiField("protocol")
      };
      authenticator(request).then(() => {
        const req = this._stripe.getApiField("httpClient").makeRequest(request.host, request.port, request.path, request.method, request.headers, request.body, request.protocol, timeout);
        const requestStartTime = Date.now();
        const requestEvent = removeNullish({
          api_version: apiVersion,
          account: headers["Stripe-Account"],
          idempotency_key: headers["Idempotency-Key"],
          method,
          path: path2,
          request_start_time: requestStartTime
        });
        const requestRetries = numRetries || 0;
        const maxRetries = this._getMaxNetworkRetries(options.settings || {});
        this._stripe._emitter.emit("request", requestEvent);
        req.then((res) => {
          if (RequestSender._shouldRetry(res, requestRetries, maxRetries)) {
            return retryRequest(makeRequest, apiVersion, headers, requestRetries, res.getHeaders()["retry-after"]);
          } else if (options.streaming && res.getStatusCode() < 400) {
            return this._streamingResponseHandler(requestEvent, usage, callback)(res);
          } else {
            return this._jsonResponseHandler(requestEvent, apiMode, usage, callback)(res);
          }
        }).catch((error3) => {
          if (RequestSender._shouldRetry(null, requestRetries, maxRetries, error3)) {
            return retryRequest(makeRequest, apiVersion, headers, requestRetries, null);
          } else {
            const isTimeoutError = error3.code && error3.code === HttpClient.TIMEOUT_ERROR_CODE;
            return callback(new StripeConnectionError({
              message: isTimeoutError ? `Request aborted due to timeout being reached (${timeout}ms)` : RequestSender._generateConnectionErrorMessage(requestRetries),
              detail: error3
            }));
          }
        });
      }).catch((e) => {
        throw new StripeError({
          message: "Unable to authenticate the request",
          exception: e
        });
      });
    };
    const prepareAndMakeRequest = (error3, data2) => {
      if (error3) {
        return callback(error3);
      }
      requestData = data2;
      this._stripe.getClientUserAgent((clientUserAgent) => {
        const apiVersion = this._stripe.getApiField("version");
        const headers = this._makeHeaders({
          contentType: apiMode == "v2" ? "application/json" : "application/x-www-form-urlencoded",
          contentLength: requestData.length,
          apiVersion,
          clientUserAgent,
          method,
          userSuppliedHeaders: options.headers,
          userSuppliedSettings: options.settings,
          stripeAccount: apiMode == "v2" ? null : this._stripe.getApiField("stripeAccount"),
          stripeContext: apiMode == "v2" ? this._stripe.getApiField("stripeContext") : null,
          apiMode
        });
        makeRequest(apiVersion, headers, 0);
      });
    };
    if (requestDataProcessor) {
      requestDataProcessor(method, data, options.headers, prepareAndMakeRequest);
    } else {
      let stringifiedData;
      if (apiMode == "v2") {
        stringifiedData = data ? jsonStringifyRequestData(data) : "";
      } else {
        stringifiedData = queryStringifyRequestData(data || {}, apiMode);
      }
      prepareAndMakeRequest(null, stringifiedData);
    }
  }
}

// node_modules/stripe/esm/autoPagination.js
class V1Iterator {
  constructor(firstPagePromise, requestArgs, spec, stripeResource) {
    this.index = 0;
    this.pagePromise = firstPagePromise;
    this.promiseCache = { currentPromise: null };
    this.requestArgs = requestArgs;
    this.spec = spec;
    this.stripeResource = stripeResource;
  }
  async iterate(pageResult) {
    if (!(pageResult && pageResult.data && typeof pageResult.data.length === "number")) {
      throw Error("Unexpected: Stripe API response does not have a well-formed `data` array.");
    }
    const reverseIteration = isReverseIteration(this.requestArgs);
    if (this.index < pageResult.data.length) {
      const idx = reverseIteration ? pageResult.data.length - 1 - this.index : this.index;
      const value = pageResult.data[idx];
      this.index += 1;
      return { value, done: false };
    } else if (pageResult.has_more) {
      this.index = 0;
      this.pagePromise = this.getNextPage(pageResult);
      const nextPageResult = await this.pagePromise;
      return this.iterate(nextPageResult);
    }
    return { done: true, value: undefined };
  }
  getNextPage(_pageResult) {
    throw new Error("Unimplemented");
  }
  async _next() {
    return this.iterate(await this.pagePromise);
  }
  next() {
    if (this.promiseCache.currentPromise) {
      return this.promiseCache.currentPromise;
    }
    const nextPromise = (async () => {
      const ret = await this._next();
      this.promiseCache.currentPromise = null;
      return ret;
    })();
    this.promiseCache.currentPromise = nextPromise;
    return nextPromise;
  }
}

class V1ListIterator extends V1Iterator {
  getNextPage(pageResult) {
    const reverseIteration = isReverseIteration(this.requestArgs);
    const lastId = getLastId(pageResult, reverseIteration);
    return this.stripeResource._makeRequest(this.requestArgs, this.spec, {
      [reverseIteration ? "ending_before" : "starting_after"]: lastId
    });
  }
}

class V1SearchIterator extends V1Iterator {
  getNextPage(pageResult) {
    if (!pageResult.next_page) {
      throw Error("Unexpected: Stripe API response does not have a well-formed `next_page` field, but `has_more` was true.");
    }
    return this.stripeResource._makeRequest(this.requestArgs, this.spec, {
      page: pageResult.next_page
    });
  }
}

class V2ListIterator {
  constructor(firstPagePromise, requestArgs, spec, stripeResource) {
    this.currentPageIterator = (async () => {
      const page = await firstPagePromise;
      return page.data[Symbol.iterator]();
    })();
    this.nextPageUrl = (async () => {
      const page = await firstPagePromise;
      return page.next_page_url || null;
    })();
    this.requestArgs = requestArgs;
    this.spec = spec;
    this.stripeResource = stripeResource;
  }
  async turnPage() {
    const nextPageUrl = await this.nextPageUrl;
    if (!nextPageUrl)
      return null;
    this.spec.fullPath = nextPageUrl;
    const page = await this.stripeResource._makeRequest([], this.spec, {});
    this.nextPageUrl = Promise.resolve(page.next_page_url);
    this.currentPageIterator = Promise.resolve(page.data[Symbol.iterator]());
    return this.currentPageIterator;
  }
  async next() {
    {
      const result2 = (await this.currentPageIterator).next();
      if (!result2.done)
        return { done: false, value: result2.value };
    }
    const nextPageIterator = await this.turnPage();
    if (!nextPageIterator) {
      return { done: true, value: undefined };
    }
    const result = nextPageIterator.next();
    if (!result.done)
      return { done: false, value: result.value };
    return { done: true, value: undefined };
  }
}
var makeAutoPaginationMethods = (stripeResource, requestArgs, spec, firstPagePromise) => {
  const apiMode = getAPIMode(spec.fullPath || spec.path);
  if (apiMode !== "v2" && spec.methodType === "search") {
    return makeAutoPaginationMethodsFromIterator(new V1SearchIterator(firstPagePromise, requestArgs, spec, stripeResource));
  }
  if (apiMode !== "v2" && spec.methodType === "list") {
    return makeAutoPaginationMethodsFromIterator(new V1ListIterator(firstPagePromise, requestArgs, spec, stripeResource));
  }
  if (apiMode === "v2" && spec.methodType === "list") {
    return makeAutoPaginationMethodsFromIterator(new V2ListIterator(firstPagePromise, requestArgs, spec, stripeResource));
  }
  return null;
};
var makeAutoPaginationMethodsFromIterator = (iterator) => {
  const autoPagingEach = makeAutoPagingEach((...args) => iterator.next(...args));
  const autoPagingToArray = makeAutoPagingToArray(autoPagingEach);
  const autoPaginationMethods = {
    autoPagingEach,
    autoPagingToArray,
    next: () => iterator.next(),
    return: () => {
      return {};
    },
    [getAsyncIteratorSymbol()]: () => {
      return autoPaginationMethods;
    }
  };
  return autoPaginationMethods;
};
function getAsyncIteratorSymbol() {
  if (typeof Symbol !== "undefined" && Symbol.asyncIterator) {
    return Symbol.asyncIterator;
  }
  return "@@asyncIterator";
}
function getDoneCallback(args) {
  if (args.length < 2) {
    return null;
  }
  const onDone = args[1];
  if (typeof onDone !== "function") {
    throw Error(`The second argument to autoPagingEach, if present, must be a callback function; received ${typeof onDone}`);
  }
  return onDone;
}
function getItemCallback(args) {
  if (args.length === 0) {
    return;
  }
  const onItem = args[0];
  if (typeof onItem !== "function") {
    throw Error(`The first argument to autoPagingEach, if present, must be a callback function; received ${typeof onItem}`);
  }
  if (onItem.length === 2) {
    return onItem;
  }
  if (onItem.length > 2) {
    throw Error(`The \`onItem\` callback function passed to autoPagingEach must accept at most two arguments; got ${onItem}`);
  }
  return function _onItem(item, next) {
    const shouldContinue = onItem(item);
    next(shouldContinue);
  };
}
function getLastId(listResult, reverseIteration) {
  const lastIdx = reverseIteration ? 0 : listResult.data.length - 1;
  const lastItem = listResult.data[lastIdx];
  const lastId = lastItem && lastItem.id;
  if (!lastId) {
    throw Error("Unexpected: No `id` found on the last item while auto-paging a list.");
  }
  return lastId;
}
function makeAutoPagingEach(asyncIteratorNext) {
  return function autoPagingEach() {
    const args = [].slice.call(arguments);
    const onItem = getItemCallback(args);
    const onDone = getDoneCallback(args);
    if (args.length > 2) {
      throw Error(`autoPagingEach takes up to two arguments; received ${args}`);
    }
    const autoPagePromise = wrapAsyncIteratorWithCallback(asyncIteratorNext, onItem);
    return callbackifyPromiseWithTimeout(autoPagePromise, onDone);
  };
}
function makeAutoPagingToArray(autoPagingEach) {
  return function autoPagingToArray(opts, onDone) {
    const limit = opts && opts.limit;
    if (!limit) {
      throw Error("You must pass a `limit` option to autoPagingToArray, e.g., `autoPagingToArray({limit: 1000});`.");
    }
    if (limit > 1e4) {
      throw Error("You cannot specify a limit of more than 10,000 items to fetch in `autoPagingToArray`; use `autoPagingEach` to iterate through longer lists.");
    }
    const promise = new Promise((resolve2, reject) => {
      const items = [];
      autoPagingEach((item) => {
        items.push(item);
        if (items.length >= limit) {
          return false;
        }
      }).then(() => {
        resolve2(items);
      }).catch(reject);
    });
    return callbackifyPromiseWithTimeout(promise, onDone);
  };
}
function wrapAsyncIteratorWithCallback(asyncIteratorNext, onItem) {
  return new Promise((resolve2, reject) => {
    function handleIteration(iterResult) {
      if (iterResult.done) {
        resolve2();
        return;
      }
      const item = iterResult.value;
      return new Promise((next) => {
        onItem(item, next);
      }).then((shouldContinue) => {
        if (shouldContinue === false) {
          return handleIteration({ done: true, value: undefined });
        } else {
          return asyncIteratorNext().then(handleIteration);
        }
      });
    }
    asyncIteratorNext().then(handleIteration).catch(reject);
  });
}
function isReverseIteration(requestArgs) {
  const args = [].slice.call(requestArgs);
  const dataFromArgs = getDataFromArgs(args);
  return !!dataFromArgs.ending_before;
}

// node_modules/stripe/esm/StripeMethod.js
function stripeMethod(spec) {
  if (spec.path !== undefined && spec.fullPath !== undefined) {
    throw new Error(`Method spec specified both a 'path' (${spec.path}) and a 'fullPath' (${spec.fullPath}).`);
  }
  return function(...args) {
    const callback = typeof args[args.length - 1] == "function" && args.pop();
    spec.urlParams = extractUrlParams(spec.fullPath || this.createResourcePathWithSymbols(spec.path || ""));
    const requestPromise = callbackifyPromiseWithTimeout(this._makeRequest(args, spec, {}), callback);
    Object.assign(requestPromise, makeAutoPaginationMethods(this, args, spec, requestPromise));
    return requestPromise;
  };
}

// node_modules/stripe/esm/StripeResource.js
StripeResource.extend = protoExtend;
StripeResource.method = stripeMethod;
StripeResource.MAX_BUFFERED_REQUEST_METRICS = 100;
function StripeResource(stripe, deprecatedUrlData) {
  this._stripe = stripe;
  if (deprecatedUrlData) {
    throw new Error("Support for curried url params was dropped in stripe-node v7.0.0. Instead, pass two ids.");
  }
  this.basePath = makeURLInterpolator(this.basePath || stripe.getApiField("basePath"));
  this.resourcePath = this.path;
  this.path = makeURLInterpolator(this.path);
  this.initialize(...arguments);
}
StripeResource.prototype = {
  _stripe: null,
  path: "",
  resourcePath: "",
  basePath: null,
  initialize() {
  },
  requestDataProcessor: null,
  validateRequest: null,
  createFullPath(commandPath, urlData) {
    const urlParts = [this.basePath(urlData), this.path(urlData)];
    if (typeof commandPath === "function") {
      const computedCommandPath = commandPath(urlData);
      if (computedCommandPath) {
        urlParts.push(computedCommandPath);
      }
    } else {
      urlParts.push(commandPath);
    }
    return this._joinUrlParts(urlParts);
  },
  createResourcePathWithSymbols(pathWithSymbols) {
    if (pathWithSymbols) {
      return `/${this._joinUrlParts([this.resourcePath, pathWithSymbols])}`;
    } else {
      return `/${this.resourcePath}`;
    }
  },
  _joinUrlParts(parts) {
    return parts.join("/").replace(/\/{2,}/g, "/");
  },
  _getRequestOpts(requestArgs, spec, overrideData) {
    var _a;
    const requestMethod = (spec.method || "GET").toUpperCase();
    const usage = spec.usage || [];
    const urlParams = spec.urlParams || [];
    const encode4 = spec.encode || ((data2) => data2);
    const isUsingFullPath = !!spec.fullPath;
    const commandPath = makeURLInterpolator(isUsingFullPath ? spec.fullPath : spec.path || "");
    const path2 = isUsingFullPath ? spec.fullPath : this.createResourcePathWithSymbols(spec.path);
    const args = [].slice.call(requestArgs);
    const urlData = urlParams.reduce((urlData2, param) => {
      const arg = args.shift();
      if (typeof arg !== "string") {
        throw new Error(`Stripe: Argument "${param}" must be a string, but got: ${arg} (on API request to \`${requestMethod} ${path2}\`)`);
      }
      urlData2[param] = arg;
      return urlData2;
    }, {});
    const dataFromArgs = getDataFromArgs(args);
    const data = encode4(Object.assign({}, dataFromArgs, overrideData));
    const options = getOptionsFromArgs(args);
    const host = options.host || spec.host;
    const streaming = !!spec.streaming;
    if (args.filter((x) => x != null).length) {
      throw new Error(`Stripe: Unknown arguments (${args}). Did you mean to pass an options object? See https://github.com/stripe/stripe-node/wiki/Passing-Options. (on API request to ${requestMethod} \`${path2}\`)`);
    }
    const requestPath = isUsingFullPath ? commandPath(urlData) : this.createFullPath(commandPath, urlData);
    const headers = Object.assign(options.headers, spec.headers);
    if (spec.validator) {
      spec.validator(data, { headers });
    }
    const dataInQuery = spec.method === "GET" || spec.method === "DELETE";
    const bodyData = dataInQuery ? null : data;
    const queryData = dataInQuery ? data : {};
    return {
      requestMethod,
      requestPath,
      bodyData,
      queryData,
      authenticator: (_a = options.authenticator) !== null && _a !== undefined ? _a : null,
      headers,
      host: host !== null && host !== undefined ? host : null,
      streaming,
      settings: options.settings,
      usage
    };
  },
  _makeRequest(requestArgs, spec, overrideData) {
    return new Promise((resolve2, reject) => {
      var _a;
      let opts;
      try {
        opts = this._getRequestOpts(requestArgs, spec, overrideData);
      } catch (err) {
        reject(err);
        return;
      }
      function requestCallback(err, response) {
        if (err) {
          reject(err);
        } else {
          resolve2(spec.transformResponseData ? spec.transformResponseData(response) : response);
        }
      }
      const emptyQuery = Object.keys(opts.queryData).length === 0;
      const path2 = [
        opts.requestPath,
        emptyQuery ? "" : "?",
        queryStringifyRequestData(opts.queryData, getAPIMode(opts.requestPath))
      ].join("");
      const { headers, settings } = opts;
      this._stripe._requestSender._request(opts.requestMethod, opts.host, path2, opts.bodyData, opts.authenticator, {
        headers,
        settings,
        streaming: opts.streaming
      }, opts.usage, requestCallback, (_a = this.requestDataProcessor) === null || _a === undefined ? undefined : _a.bind(this));
    });
  }
};

// node_modules/stripe/esm/Webhooks.js
function createWebhooks(platformFunctions) {
  const Webhook = {
    DEFAULT_TOLERANCE: 300,
    signature: null,
    constructEvent(payload, header, secret, tolerance, cryptoProvider, receivedAt) {
      try {
        this.signature.verifyHeader(payload, header, secret, tolerance || Webhook.DEFAULT_TOLERANCE, cryptoProvider, receivedAt);
      } catch (e) {
        if (e instanceof CryptoProviderOnlySupportsAsyncError) {
          e.message += "\nUse `await constructEventAsync(...)` instead of `constructEvent(...)`";
        }
        throw e;
      }
      const jsonPayload = payload instanceof Uint8Array ? JSON.parse(new TextDecoder("utf8").decode(payload)) : JSON.parse(payload);
      return jsonPayload;
    },
    async constructEventAsync(payload, header, secret, tolerance, cryptoProvider, receivedAt) {
      await this.signature.verifyHeaderAsync(payload, header, secret, tolerance || Webhook.DEFAULT_TOLERANCE, cryptoProvider, receivedAt);
      const jsonPayload = payload instanceof Uint8Array ? JSON.parse(new TextDecoder("utf8").decode(payload)) : JSON.parse(payload);
      return jsonPayload;
    },
    generateTestHeaderString: function(opts) {
      const preparedOpts = prepareOptions(opts);
      const signature2 = preparedOpts.signature || preparedOpts.cryptoProvider.computeHMACSignature(preparedOpts.payloadString, preparedOpts.secret);
      return preparedOpts.generateHeaderString(signature2);
    },
    generateTestHeaderStringAsync: async function(opts) {
      const preparedOpts = prepareOptions(opts);
      const signature2 = preparedOpts.signature || await preparedOpts.cryptoProvider.computeHMACSignatureAsync(preparedOpts.payloadString, preparedOpts.secret);
      return preparedOpts.generateHeaderString(signature2);
    }
  };
  const signature = {
    EXPECTED_SCHEME: "v1",
    verifyHeader(encodedPayload, encodedHeader, secret, tolerance, cryptoProvider, receivedAt) {
      const { decodedHeader: header, decodedPayload: payload, details, suspectPayloadType } = parseEventDetails(encodedPayload, encodedHeader, this.EXPECTED_SCHEME);
      const secretContainsWhitespace = /\s/.test(secret);
      cryptoProvider = cryptoProvider || getCryptoProvider();
      const expectedSignature = cryptoProvider.computeHMACSignature(makeHMACContent(payload, details), secret);
      validateComputedSignature(payload, header, details, expectedSignature, tolerance, suspectPayloadType, secretContainsWhitespace, receivedAt);
      return true;
    },
    async verifyHeaderAsync(encodedPayload, encodedHeader, secret, tolerance, cryptoProvider, receivedAt) {
      const { decodedHeader: header, decodedPayload: payload, details, suspectPayloadType } = parseEventDetails(encodedPayload, encodedHeader, this.EXPECTED_SCHEME);
      const secretContainsWhitespace = /\s/.test(secret);
      cryptoProvider = cryptoProvider || getCryptoProvider();
      const expectedSignature = await cryptoProvider.computeHMACSignatureAsync(makeHMACContent(payload, details), secret);
      return validateComputedSignature(payload, header, details, expectedSignature, tolerance, suspectPayloadType, secretContainsWhitespace, receivedAt);
    }
  };
  function makeHMACContent(payload, details) {
    return `${details.timestamp}.${payload}`;
  }
  function parseEventDetails(encodedPayload, encodedHeader, expectedScheme) {
    if (!encodedPayload) {
      throw new StripeSignatureVerificationError(encodedHeader, encodedPayload, {
        message: "No webhook payload was provided."
      });
    }
    const suspectPayloadType = typeof encodedPayload != "string" && !(encodedPayload instanceof Uint8Array);
    const textDecoder = new TextDecoder("utf8");
    const decodedPayload = encodedPayload instanceof Uint8Array ? textDecoder.decode(encodedPayload) : encodedPayload;
    if (Array.isArray(encodedHeader)) {
      throw new Error("Unexpected: An array was passed as a header, which should not be possible for the stripe-signature header.");
    }
    if (encodedHeader == null || encodedHeader == "") {
      throw new StripeSignatureVerificationError(encodedHeader, encodedPayload, {
        message: "No stripe-signature header value was provided."
      });
    }
    const decodedHeader = encodedHeader instanceof Uint8Array ? textDecoder.decode(encodedHeader) : encodedHeader;
    const details = parseHeader(decodedHeader, expectedScheme);
    if (!details || details.timestamp === -1) {
      throw new StripeSignatureVerificationError(decodedHeader, decodedPayload, {
        message: "Unable to extract timestamp and signatures from header"
      });
    }
    if (!details.signatures.length) {
      throw new StripeSignatureVerificationError(decodedHeader, decodedPayload, {
        message: "No signatures found with expected scheme"
      });
    }
    return {
      decodedPayload,
      decodedHeader,
      details,
      suspectPayloadType
    };
  }
  function validateComputedSignature(payload, header, details, expectedSignature, tolerance, suspectPayloadType, secretContainsWhitespace, receivedAt) {
    const signatureFound = !!details.signatures.filter(platformFunctions.secureCompare.bind(platformFunctions, expectedSignature)).length;
    const docsLocation = `
Learn more about webhook signing and explore webhook integration examples for various frameworks at ` + "https://docs.stripe.com/webhooks/signature";
    const whitespaceMessage = secretContainsWhitespace ? `

Note: The provided signing secret contains whitespace. This often indicates an extra newline or space is in the value` : "";
    if (!signatureFound) {
      if (suspectPayloadType) {
        throw new StripeSignatureVerificationError(header, payload, {
          message: "Webhook payload must be provided as a string or a Buffer (https://nodejs.org/api/buffer.html) instance representing the _raw_ request body." + `Payload was provided as a parsed JavaScript object instead. 
` + `Signature verification is impossible without access to the original signed material. 
` + docsLocation + `
` + whitespaceMessage
        });
      }
      throw new StripeSignatureVerificationError(header, payload, {
        message: "No signatures found matching the expected signature for payload." + ` Are you passing the raw request body you received from Stripe? 
` + " If a webhook request is being forwarded by a third-party tool," + ` ensure that the exact request body, including JSON formatting and new line style, is preserved.
` + docsLocation + `
` + whitespaceMessage
      });
    }
    const timestampAge = Math.floor((typeof receivedAt === "number" ? receivedAt : Date.now()) / 1000) - details.timestamp;
    if (tolerance > 0 && timestampAge > tolerance) {
      throw new StripeSignatureVerificationError(header, payload, {
        message: "Timestamp outside the tolerance zone"
      });
    }
    return true;
  }
  function parseHeader(header, scheme) {
    if (typeof header !== "string") {
      return null;
    }
    return header.split(",").reduce((accum, item) => {
      const kv = item.split("=");
      if (kv[0] === "t") {
        accum.timestamp = parseInt(kv[1], 10);
      }
      if (kv[0] === scheme) {
        accum.signatures.push(kv[1]);
      }
      return accum;
    }, {
      timestamp: -1,
      signatures: []
    });
  }
  let webhooksCryptoProviderInstance = null;
  function getCryptoProvider() {
    if (!webhooksCryptoProviderInstance) {
      webhooksCryptoProviderInstance = platformFunctions.createDefaultCryptoProvider();
    }
    return webhooksCryptoProviderInstance;
  }
  function prepareOptions(opts) {
    if (!opts) {
      throw new StripeError({
        message: "Options are required"
      });
    }
    const timestamp = Math.floor(opts.timestamp) || Math.floor(Date.now() / 1000);
    const scheme = opts.scheme || signature.EXPECTED_SCHEME;
    const cryptoProvider = opts.cryptoProvider || getCryptoProvider();
    const payloadString = `${timestamp}.${opts.payload}`;
    const generateHeaderString = (signature2) => {
      return `t=${timestamp},${scheme}=${signature2}`;
    };
    return Object.assign(Object.assign({}, opts), {
      timestamp,
      scheme,
      cryptoProvider,
      payloadString,
      generateHeaderString
    });
  }
  Webhook.signature = signature;
  return Webhook;
}

// node_modules/stripe/esm/apiVersion.js
var ApiVersion = "2024-12-18.acacia";

// node_modules/stripe/esm/resources.js
var exports_resources = {};
__export(exports_resources, {
  WebhookEndpoints: () => WebhookEndpoints,
  V2: () => V2,
  Treasury: () => Treasury,
  Transfers: () => Transfers,
  Topups: () => Topups,
  Tokens: () => Tokens2,
  TestHelpers: () => TestHelpers,
  Terminal: () => Terminal,
  TaxRates: () => TaxRates,
  TaxIds: () => TaxIds,
  TaxCodes: () => TaxCodes,
  Tax: () => Tax,
  Subscriptions: () => Subscriptions,
  SubscriptionSchedules: () => SubscriptionSchedules,
  SubscriptionItems: () => SubscriptionItems,
  Sources: () => Sources,
  Sigma: () => Sigma,
  ShippingRates: () => ShippingRates,
  SetupIntents: () => SetupIntents,
  SetupAttempts: () => SetupAttempts,
  Reviews: () => Reviews,
  Reporting: () => Reporting,
  Refunds: () => Refunds2,
  Radar: () => Radar,
  Quotes: () => Quotes,
  PromotionCodes: () => PromotionCodes,
  Products: () => Products2,
  Prices: () => Prices,
  Plans: () => Plans,
  Payouts: () => Payouts,
  PaymentMethods: () => PaymentMethods,
  PaymentMethodDomains: () => PaymentMethodDomains,
  PaymentMethodConfigurations: () => PaymentMethodConfigurations,
  PaymentLinks: () => PaymentLinks,
  PaymentIntents: () => PaymentIntents,
  OAuth: () => OAuth,
  Mandates: () => Mandates,
  Issuing: () => Issuing,
  Invoices: () => Invoices,
  InvoiceRenderingTemplates: () => InvoiceRenderingTemplates,
  InvoiceItems: () => InvoiceItems,
  Identity: () => Identity,
  Forwarding: () => Forwarding,
  FinancialConnections: () => FinancialConnections,
  Files: () => Files3,
  FileLinks: () => FileLinks,
  ExchangeRates: () => ExchangeRates,
  Events: () => Events2,
  EphemeralKeys: () => EphemeralKeys,
  Entitlements: () => Entitlements,
  Disputes: () => Disputes2,
  Customers: () => Customers2,
  CustomerSessions: () => CustomerSessions,
  CreditNotes: () => CreditNotes,
  Coupons: () => Coupons,
  CountrySpecs: () => CountrySpecs,
  ConfirmationTokens: () => ConfirmationTokens2,
  Climate: () => Climate,
  Checkout: () => Checkout,
  Charges: () => Charges,
  BillingPortal: () => BillingPortal,
  Billing: () => Billing,
  BalanceTransactions: () => BalanceTransactions,
  Balance: () => Balance,
  Apps: () => Apps,
  ApplicationFees: () => ApplicationFees,
  ApplePayDomains: () => ApplePayDomains,
  Accounts: () => Accounts2,
  AccountSessions: () => AccountSessions,
  AccountLinks: () => AccountLinks,
  Account: () => Accounts2
});

// node_modules/stripe/esm/ResourceNamespace.js
function ResourceNamespace(stripe, resources) {
  for (const name in resources) {
    if (!Object.prototype.hasOwnProperty.call(resources, name)) {
      continue;
    }
    const camelCaseName = name[0].toLowerCase() + name.substring(1);
    const resource = new resources[name](stripe);
    this[camelCaseName] = resource;
  }
}
function resourceNamespace(namespace, resources) {
  return function(stripe) {
    return new ResourceNamespace(stripe, resources);
  };
}

// node_modules/stripe/esm/resources/FinancialConnections/Accounts.js
var stripeMethod2 = StripeResource.method;
var Accounts = StripeResource.extend({
  retrieve: stripeMethod2({
    method: "GET",
    fullPath: "/v1/financial_connections/accounts/{account}"
  }),
  list: stripeMethod2({
    method: "GET",
    fullPath: "/v1/financial_connections/accounts",
    methodType: "list"
  }),
  disconnect: stripeMethod2({
    method: "POST",
    fullPath: "/v1/financial_connections/accounts/{account}/disconnect"
  }),
  listOwners: stripeMethod2({
    method: "GET",
    fullPath: "/v1/financial_connections/accounts/{account}/owners",
    methodType: "list"
  }),
  refresh: stripeMethod2({
    method: "POST",
    fullPath: "/v1/financial_connections/accounts/{account}/refresh"
  }),
  subscribe: stripeMethod2({
    method: "POST",
    fullPath: "/v1/financial_connections/accounts/{account}/subscribe"
  }),
  unsubscribe: stripeMethod2({
    method: "POST",
    fullPath: "/v1/financial_connections/accounts/{account}/unsubscribe"
  })
});

// node_modules/stripe/esm/resources/Entitlements/ActiveEntitlements.js
var stripeMethod3 = StripeResource.method;
var ActiveEntitlements = StripeResource.extend({
  retrieve: stripeMethod3({
    method: "GET",
    fullPath: "/v1/entitlements/active_entitlements/{id}"
  }),
  list: stripeMethod3({
    method: "GET",
    fullPath: "/v1/entitlements/active_entitlements",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/Billing/Alerts.js
var stripeMethod4 = StripeResource.method;
var Alerts = StripeResource.extend({
  create: stripeMethod4({ method: "POST", fullPath: "/v1/billing/alerts" }),
  retrieve: stripeMethod4({ method: "GET", fullPath: "/v1/billing/alerts/{id}" }),
  list: stripeMethod4({
    method: "GET",
    fullPath: "/v1/billing/alerts",
    methodType: "list"
  }),
  activate: stripeMethod4({
    method: "POST",
    fullPath: "/v1/billing/alerts/{id}/activate"
  }),
  archive: stripeMethod4({
    method: "POST",
    fullPath: "/v1/billing/alerts/{id}/archive"
  }),
  deactivate: stripeMethod4({
    method: "POST",
    fullPath: "/v1/billing/alerts/{id}/deactivate"
  })
});

// node_modules/stripe/esm/resources/TestHelpers/Issuing/Authorizations.js
var stripeMethod5 = StripeResource.method;
var Authorizations = StripeResource.extend({
  create: stripeMethod5({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/authorizations"
  }),
  capture: stripeMethod5({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/authorizations/{authorization}/capture"
  }),
  expire: stripeMethod5({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/authorizations/{authorization}/expire"
  }),
  finalizeAmount: stripeMethod5({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/authorizations/{authorization}/finalize_amount"
  }),
  increment: stripeMethod5({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/authorizations/{authorization}/increment"
  }),
  respond: stripeMethod5({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/authorizations/{authorization}/fraud_challenges/respond"
  }),
  reverse: stripeMethod5({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/authorizations/{authorization}/reverse"
  })
});

// node_modules/stripe/esm/resources/Issuing/Authorizations.js
var stripeMethod6 = StripeResource.method;
var Authorizations2 = StripeResource.extend({
  retrieve: stripeMethod6({
    method: "GET",
    fullPath: "/v1/issuing/authorizations/{authorization}"
  }),
  update: stripeMethod6({
    method: "POST",
    fullPath: "/v1/issuing/authorizations/{authorization}"
  }),
  list: stripeMethod6({
    method: "GET",
    fullPath: "/v1/issuing/authorizations",
    methodType: "list"
  }),
  approve: stripeMethod6({
    method: "POST",
    fullPath: "/v1/issuing/authorizations/{authorization}/approve"
  }),
  decline: stripeMethod6({
    method: "POST",
    fullPath: "/v1/issuing/authorizations/{authorization}/decline"
  })
});

// node_modules/stripe/esm/resources/Tax/Calculations.js
var stripeMethod7 = StripeResource.method;
var Calculations = StripeResource.extend({
  create: stripeMethod7({ method: "POST", fullPath: "/v1/tax/calculations" }),
  retrieve: stripeMethod7({
    method: "GET",
    fullPath: "/v1/tax/calculations/{calculation}"
  }),
  listLineItems: stripeMethod7({
    method: "GET",
    fullPath: "/v1/tax/calculations/{calculation}/line_items",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/Issuing/Cardholders.js
var stripeMethod8 = StripeResource.method;
var Cardholders = StripeResource.extend({
  create: stripeMethod8({ method: "POST", fullPath: "/v1/issuing/cardholders" }),
  retrieve: stripeMethod8({
    method: "GET",
    fullPath: "/v1/issuing/cardholders/{cardholder}"
  }),
  update: stripeMethod8({
    method: "POST",
    fullPath: "/v1/issuing/cardholders/{cardholder}"
  }),
  list: stripeMethod8({
    method: "GET",
    fullPath: "/v1/issuing/cardholders",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/TestHelpers/Issuing/Cards.js
var stripeMethod9 = StripeResource.method;
var Cards = StripeResource.extend({
  deliverCard: stripeMethod9({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/cards/{card}/shipping/deliver"
  }),
  failCard: stripeMethod9({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/cards/{card}/shipping/fail"
  }),
  returnCard: stripeMethod9({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/cards/{card}/shipping/return"
  }),
  shipCard: stripeMethod9({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/cards/{card}/shipping/ship"
  }),
  submitCard: stripeMethod9({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/cards/{card}/shipping/submit"
  })
});

// node_modules/stripe/esm/resources/Issuing/Cards.js
var stripeMethod10 = StripeResource.method;
var Cards2 = StripeResource.extend({
  create: stripeMethod10({ method: "POST", fullPath: "/v1/issuing/cards" }),
  retrieve: stripeMethod10({ method: "GET", fullPath: "/v1/issuing/cards/{card}" }),
  update: stripeMethod10({ method: "POST", fullPath: "/v1/issuing/cards/{card}" }),
  list: stripeMethod10({
    method: "GET",
    fullPath: "/v1/issuing/cards",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/BillingPortal/Configurations.js
var stripeMethod11 = StripeResource.method;
var Configurations = StripeResource.extend({
  create: stripeMethod11({
    method: "POST",
    fullPath: "/v1/billing_portal/configurations"
  }),
  retrieve: stripeMethod11({
    method: "GET",
    fullPath: "/v1/billing_portal/configurations/{configuration}"
  }),
  update: stripeMethod11({
    method: "POST",
    fullPath: "/v1/billing_portal/configurations/{configuration}"
  }),
  list: stripeMethod11({
    method: "GET",
    fullPath: "/v1/billing_portal/configurations",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/Terminal/Configurations.js
var stripeMethod12 = StripeResource.method;
var Configurations2 = StripeResource.extend({
  create: stripeMethod12({
    method: "POST",
    fullPath: "/v1/terminal/configurations"
  }),
  retrieve: stripeMethod12({
    method: "GET",
    fullPath: "/v1/terminal/configurations/{configuration}"
  }),
  update: stripeMethod12({
    method: "POST",
    fullPath: "/v1/terminal/configurations/{configuration}"
  }),
  list: stripeMethod12({
    method: "GET",
    fullPath: "/v1/terminal/configurations",
    methodType: "list"
  }),
  del: stripeMethod12({
    method: "DELETE",
    fullPath: "/v1/terminal/configurations/{configuration}"
  })
});

// node_modules/stripe/esm/resources/TestHelpers/ConfirmationTokens.js
var stripeMethod13 = StripeResource.method;
var ConfirmationTokens = StripeResource.extend({
  create: stripeMethod13({
    method: "POST",
    fullPath: "/v1/test_helpers/confirmation_tokens"
  })
});

// node_modules/stripe/esm/resources/Terminal/ConnectionTokens.js
var stripeMethod14 = StripeResource.method;
var ConnectionTokens = StripeResource.extend({
  create: stripeMethod14({
    method: "POST",
    fullPath: "/v1/terminal/connection_tokens"
  })
});

// node_modules/stripe/esm/resources/Billing/CreditBalanceSummary.js
var stripeMethod15 = StripeResource.method;
var CreditBalanceSummary = StripeResource.extend({
  retrieve: stripeMethod15({
    method: "GET",
    fullPath: "/v1/billing/credit_balance_summary"
  })
});

// node_modules/stripe/esm/resources/Billing/CreditBalanceTransactions.js
var stripeMethod16 = StripeResource.method;
var CreditBalanceTransactions = StripeResource.extend({
  retrieve: stripeMethod16({
    method: "GET",
    fullPath: "/v1/billing/credit_balance_transactions/{id}"
  }),
  list: stripeMethod16({
    method: "GET",
    fullPath: "/v1/billing/credit_balance_transactions",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/Billing/CreditGrants.js
var stripeMethod17 = StripeResource.method;
var CreditGrants = StripeResource.extend({
  create: stripeMethod17({ method: "POST", fullPath: "/v1/billing/credit_grants" }),
  retrieve: stripeMethod17({
    method: "GET",
    fullPath: "/v1/billing/credit_grants/{id}"
  }),
  update: stripeMethod17({
    method: "POST",
    fullPath: "/v1/billing/credit_grants/{id}"
  }),
  list: stripeMethod17({
    method: "GET",
    fullPath: "/v1/billing/credit_grants",
    methodType: "list"
  }),
  expire: stripeMethod17({
    method: "POST",
    fullPath: "/v1/billing/credit_grants/{id}/expire"
  }),
  voidGrant: stripeMethod17({
    method: "POST",
    fullPath: "/v1/billing/credit_grants/{id}/void"
  })
});

// node_modules/stripe/esm/resources/Treasury/CreditReversals.js
var stripeMethod18 = StripeResource.method;
var CreditReversals = StripeResource.extend({
  create: stripeMethod18({
    method: "POST",
    fullPath: "/v1/treasury/credit_reversals"
  }),
  retrieve: stripeMethod18({
    method: "GET",
    fullPath: "/v1/treasury/credit_reversals/{credit_reversal}"
  }),
  list: stripeMethod18({
    method: "GET",
    fullPath: "/v1/treasury/credit_reversals",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/TestHelpers/Customers.js
var stripeMethod19 = StripeResource.method;
var Customers = StripeResource.extend({
  fundCashBalance: stripeMethod19({
    method: "POST",
    fullPath: "/v1/test_helpers/customers/{customer}/fund_cash_balance"
  })
});

// node_modules/stripe/esm/resources/Treasury/DebitReversals.js
var stripeMethod20 = StripeResource.method;
var DebitReversals = StripeResource.extend({
  create: stripeMethod20({
    method: "POST",
    fullPath: "/v1/treasury/debit_reversals"
  }),
  retrieve: stripeMethod20({
    method: "GET",
    fullPath: "/v1/treasury/debit_reversals/{debit_reversal}"
  }),
  list: stripeMethod20({
    method: "GET",
    fullPath: "/v1/treasury/debit_reversals",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/Issuing/Disputes.js
var stripeMethod21 = StripeResource.method;
var Disputes = StripeResource.extend({
  create: stripeMethod21({ method: "POST", fullPath: "/v1/issuing/disputes" }),
  retrieve: stripeMethod21({
    method: "GET",
    fullPath: "/v1/issuing/disputes/{dispute}"
  }),
  update: stripeMethod21({
    method: "POST",
    fullPath: "/v1/issuing/disputes/{dispute}"
  }),
  list: stripeMethod21({
    method: "GET",
    fullPath: "/v1/issuing/disputes",
    methodType: "list"
  }),
  submit: stripeMethod21({
    method: "POST",
    fullPath: "/v1/issuing/disputes/{dispute}/submit"
  })
});

// node_modules/stripe/esm/resources/Radar/EarlyFraudWarnings.js
var stripeMethod22 = StripeResource.method;
var EarlyFraudWarnings = StripeResource.extend({
  retrieve: stripeMethod22({
    method: "GET",
    fullPath: "/v1/radar/early_fraud_warnings/{early_fraud_warning}"
  }),
  list: stripeMethod22({
    method: "GET",
    fullPath: "/v1/radar/early_fraud_warnings",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/V2/Core/EventDestinations.js
var stripeMethod23 = StripeResource.method;
var EventDestinations = StripeResource.extend({
  create: stripeMethod23({
    method: "POST",
    fullPath: "/v2/core/event_destinations"
  }),
  retrieve: stripeMethod23({
    method: "GET",
    fullPath: "/v2/core/event_destinations/{id}"
  }),
  update: stripeMethod23({
    method: "POST",
    fullPath: "/v2/core/event_destinations/{id}"
  }),
  list: stripeMethod23({
    method: "GET",
    fullPath: "/v2/core/event_destinations",
    methodType: "list"
  }),
  del: stripeMethod23({
    method: "DELETE",
    fullPath: "/v2/core/event_destinations/{id}"
  }),
  disable: stripeMethod23({
    method: "POST",
    fullPath: "/v2/core/event_destinations/{id}/disable"
  }),
  enable: stripeMethod23({
    method: "POST",
    fullPath: "/v2/core/event_destinations/{id}/enable"
  }),
  ping: stripeMethod23({
    method: "POST",
    fullPath: "/v2/core/event_destinations/{id}/ping"
  })
});

// node_modules/stripe/esm/resources/V2/Core/Events.js
var stripeMethod24 = StripeResource.method;
var Events = StripeResource.extend({
  retrieve(...args) {
    const transformResponseData = (response) => {
      return this.addFetchRelatedObjectIfNeeded(response);
    };
    return stripeMethod24({
      method: "GET",
      fullPath: "/v2/core/events/{id}",
      transformResponseData
    }).apply(this, args);
  },
  list(...args) {
    const transformResponseData = (response) => {
      return Object.assign(Object.assign({}, response), { data: response.data.map(this.addFetchRelatedObjectIfNeeded.bind(this)) });
    };
    return stripeMethod24({
      method: "GET",
      fullPath: "/v2/core/events",
      methodType: "list",
      transformResponseData
    }).apply(this, args);
  },
  addFetchRelatedObjectIfNeeded(pulledEvent) {
    if (!pulledEvent.related_object || !pulledEvent.related_object.url) {
      return pulledEvent;
    }
    return Object.assign(Object.assign({}, pulledEvent), { fetchRelatedObject: () => stripeMethod24({
      method: "GET",
      fullPath: pulledEvent.related_object.url
    }).apply(this, [
      {
        stripeAccount: pulledEvent.context
      }
    ]) });
  }
});

// node_modules/stripe/esm/resources/Entitlements/Features.js
var stripeMethod25 = StripeResource.method;
var Features = StripeResource.extend({
  create: stripeMethod25({ method: "POST", fullPath: "/v1/entitlements/features" }),
  retrieve: stripeMethod25({
    method: "GET",
    fullPath: "/v1/entitlements/features/{id}"
  }),
  update: stripeMethod25({
    method: "POST",
    fullPath: "/v1/entitlements/features/{id}"
  }),
  list: stripeMethod25({
    method: "GET",
    fullPath: "/v1/entitlements/features",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/Treasury/FinancialAccounts.js
var stripeMethod26 = StripeResource.method;
var FinancialAccounts = StripeResource.extend({
  create: stripeMethod26({
    method: "POST",
    fullPath: "/v1/treasury/financial_accounts"
  }),
  retrieve: stripeMethod26({
    method: "GET",
    fullPath: "/v1/treasury/financial_accounts/{financial_account}"
  }),
  update: stripeMethod26({
    method: "POST",
    fullPath: "/v1/treasury/financial_accounts/{financial_account}"
  }),
  list: stripeMethod26({
    method: "GET",
    fullPath: "/v1/treasury/financial_accounts",
    methodType: "list"
  }),
  retrieveFeatures: stripeMethod26({
    method: "GET",
    fullPath: "/v1/treasury/financial_accounts/{financial_account}/features"
  }),
  updateFeatures: stripeMethod26({
    method: "POST",
    fullPath: "/v1/treasury/financial_accounts/{financial_account}/features"
  })
});

// node_modules/stripe/esm/resources/TestHelpers/Treasury/InboundTransfers.js
var stripeMethod27 = StripeResource.method;
var InboundTransfers = StripeResource.extend({
  fail: stripeMethod27({
    method: "POST",
    fullPath: "/v1/test_helpers/treasury/inbound_transfers/{id}/fail"
  }),
  returnInboundTransfer: stripeMethod27({
    method: "POST",
    fullPath: "/v1/test_helpers/treasury/inbound_transfers/{id}/return"
  }),
  succeed: stripeMethod27({
    method: "POST",
    fullPath: "/v1/test_helpers/treasury/inbound_transfers/{id}/succeed"
  })
});

// node_modules/stripe/esm/resources/Treasury/InboundTransfers.js
var stripeMethod28 = StripeResource.method;
var InboundTransfers2 = StripeResource.extend({
  create: stripeMethod28({
    method: "POST",
    fullPath: "/v1/treasury/inbound_transfers"
  }),
  retrieve: stripeMethod28({
    method: "GET",
    fullPath: "/v1/treasury/inbound_transfers/{id}"
  }),
  list: stripeMethod28({
    method: "GET",
    fullPath: "/v1/treasury/inbound_transfers",
    methodType: "list"
  }),
  cancel: stripeMethod28({
    method: "POST",
    fullPath: "/v1/treasury/inbound_transfers/{inbound_transfer}/cancel"
  })
});

// node_modules/stripe/esm/resources/Terminal/Locations.js
var stripeMethod29 = StripeResource.method;
var Locations = StripeResource.extend({
  create: stripeMethod29({ method: "POST", fullPath: "/v1/terminal/locations" }),
  retrieve: stripeMethod29({
    method: "GET",
    fullPath: "/v1/terminal/locations/{location}"
  }),
  update: stripeMethod29({
    method: "POST",
    fullPath: "/v1/terminal/locations/{location}"
  }),
  list: stripeMethod29({
    method: "GET",
    fullPath: "/v1/terminal/locations",
    methodType: "list"
  }),
  del: stripeMethod29({
    method: "DELETE",
    fullPath: "/v1/terminal/locations/{location}"
  })
});

// node_modules/stripe/esm/resources/Billing/MeterEventAdjustments.js
var stripeMethod30 = StripeResource.method;
var MeterEventAdjustments = StripeResource.extend({
  create: stripeMethod30({
    method: "POST",
    fullPath: "/v1/billing/meter_event_adjustments"
  })
});

// node_modules/stripe/esm/resources/V2/Billing/MeterEventAdjustments.js
var stripeMethod31 = StripeResource.method;
var MeterEventAdjustments2 = StripeResource.extend({
  create: stripeMethod31({
    method: "POST",
    fullPath: "/v2/billing/meter_event_adjustments"
  })
});

// node_modules/stripe/esm/resources/V2/Billing/MeterEventSession.js
var stripeMethod32 = StripeResource.method;
var MeterEventSession = StripeResource.extend({
  create: stripeMethod32({
    method: "POST",
    fullPath: "/v2/billing/meter_event_session"
  })
});

// node_modules/stripe/esm/resources/V2/Billing/MeterEventStream.js
var stripeMethod33 = StripeResource.method;
var MeterEventStream = StripeResource.extend({
  create: stripeMethod33({
    method: "POST",
    fullPath: "/v2/billing/meter_event_stream",
    host: "meter-events.stripe.com"
  })
});

// node_modules/stripe/esm/resources/Billing/MeterEvents.js
var stripeMethod34 = StripeResource.method;
var MeterEvents = StripeResource.extend({
  create: stripeMethod34({ method: "POST", fullPath: "/v1/billing/meter_events" })
});

// node_modules/stripe/esm/resources/V2/Billing/MeterEvents.js
var stripeMethod35 = StripeResource.method;
var MeterEvents2 = StripeResource.extend({
  create: stripeMethod35({ method: "POST", fullPath: "/v2/billing/meter_events" })
});

// node_modules/stripe/esm/resources/Billing/Meters.js
var stripeMethod36 = StripeResource.method;
var Meters = StripeResource.extend({
  create: stripeMethod36({ method: "POST", fullPath: "/v1/billing/meters" }),
  retrieve: stripeMethod36({ method: "GET", fullPath: "/v1/billing/meters/{id}" }),
  update: stripeMethod36({ method: "POST", fullPath: "/v1/billing/meters/{id}" }),
  list: stripeMethod36({
    method: "GET",
    fullPath: "/v1/billing/meters",
    methodType: "list"
  }),
  deactivate: stripeMethod36({
    method: "POST",
    fullPath: "/v1/billing/meters/{id}/deactivate"
  }),
  listEventSummaries: stripeMethod36({
    method: "GET",
    fullPath: "/v1/billing/meters/{id}/event_summaries",
    methodType: "list"
  }),
  reactivate: stripeMethod36({
    method: "POST",
    fullPath: "/v1/billing/meters/{id}/reactivate"
  })
});

// node_modules/stripe/esm/resources/Climate/Orders.js
var stripeMethod37 = StripeResource.method;
var Orders = StripeResource.extend({
  create: stripeMethod37({ method: "POST", fullPath: "/v1/climate/orders" }),
  retrieve: stripeMethod37({
    method: "GET",
    fullPath: "/v1/climate/orders/{order}"
  }),
  update: stripeMethod37({
    method: "POST",
    fullPath: "/v1/climate/orders/{order}"
  }),
  list: stripeMethod37({
    method: "GET",
    fullPath: "/v1/climate/orders",
    methodType: "list"
  }),
  cancel: stripeMethod37({
    method: "POST",
    fullPath: "/v1/climate/orders/{order}/cancel"
  })
});

// node_modules/stripe/esm/resources/TestHelpers/Treasury/OutboundPayments.js
var stripeMethod38 = StripeResource.method;
var OutboundPayments = StripeResource.extend({
  update: stripeMethod38({
    method: "POST",
    fullPath: "/v1/test_helpers/treasury/outbound_payments/{id}"
  }),
  fail: stripeMethod38({
    method: "POST",
    fullPath: "/v1/test_helpers/treasury/outbound_payments/{id}/fail"
  }),
  post: stripeMethod38({
    method: "POST",
    fullPath: "/v1/test_helpers/treasury/outbound_payments/{id}/post"
  }),
  returnOutboundPayment: stripeMethod38({
    method: "POST",
    fullPath: "/v1/test_helpers/treasury/outbound_payments/{id}/return"
  })
});

// node_modules/stripe/esm/resources/Treasury/OutboundPayments.js
var stripeMethod39 = StripeResource.method;
var OutboundPayments2 = StripeResource.extend({
  create: stripeMethod39({
    method: "POST",
    fullPath: "/v1/treasury/outbound_payments"
  }),
  retrieve: stripeMethod39({
    method: "GET",
    fullPath: "/v1/treasury/outbound_payments/{id}"
  }),
  list: stripeMethod39({
    method: "GET",
    fullPath: "/v1/treasury/outbound_payments",
    methodType: "list"
  }),
  cancel: stripeMethod39({
    method: "POST",
    fullPath: "/v1/treasury/outbound_payments/{id}/cancel"
  })
});

// node_modules/stripe/esm/resources/TestHelpers/Treasury/OutboundTransfers.js
var stripeMethod40 = StripeResource.method;
var OutboundTransfers = StripeResource.extend({
  update: stripeMethod40({
    method: "POST",
    fullPath: "/v1/test_helpers/treasury/outbound_transfers/{outbound_transfer}"
  }),
  fail: stripeMethod40({
    method: "POST",
    fullPath: "/v1/test_helpers/treasury/outbound_transfers/{outbound_transfer}/fail"
  }),
  post: stripeMethod40({
    method: "POST",
    fullPath: "/v1/test_helpers/treasury/outbound_transfers/{outbound_transfer}/post"
  }),
  returnOutboundTransfer: stripeMethod40({
    method: "POST",
    fullPath: "/v1/test_helpers/treasury/outbound_transfers/{outbound_transfer}/return"
  })
});

// node_modules/stripe/esm/resources/Treasury/OutboundTransfers.js
var stripeMethod41 = StripeResource.method;
var OutboundTransfers2 = StripeResource.extend({
  create: stripeMethod41({
    method: "POST",
    fullPath: "/v1/treasury/outbound_transfers"
  }),
  retrieve: stripeMethod41({
    method: "GET",
    fullPath: "/v1/treasury/outbound_transfers/{outbound_transfer}"
  }),
  list: stripeMethod41({
    method: "GET",
    fullPath: "/v1/treasury/outbound_transfers",
    methodType: "list"
  }),
  cancel: stripeMethod41({
    method: "POST",
    fullPath: "/v1/treasury/outbound_transfers/{outbound_transfer}/cancel"
  })
});

// node_modules/stripe/esm/resources/TestHelpers/Issuing/PersonalizationDesigns.js
var stripeMethod42 = StripeResource.method;
var PersonalizationDesigns = StripeResource.extend({
  activate: stripeMethod42({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/personalization_designs/{personalization_design}/activate"
  }),
  deactivate: stripeMethod42({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/personalization_designs/{personalization_design}/deactivate"
  }),
  reject: stripeMethod42({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/personalization_designs/{personalization_design}/reject"
  })
});

// node_modules/stripe/esm/resources/Issuing/PersonalizationDesigns.js
var stripeMethod43 = StripeResource.method;
var PersonalizationDesigns2 = StripeResource.extend({
  create: stripeMethod43({
    method: "POST",
    fullPath: "/v1/issuing/personalization_designs"
  }),
  retrieve: stripeMethod43({
    method: "GET",
    fullPath: "/v1/issuing/personalization_designs/{personalization_design}"
  }),
  update: stripeMethod43({
    method: "POST",
    fullPath: "/v1/issuing/personalization_designs/{personalization_design}"
  }),
  list: stripeMethod43({
    method: "GET",
    fullPath: "/v1/issuing/personalization_designs",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/Issuing/PhysicalBundles.js
var stripeMethod44 = StripeResource.method;
var PhysicalBundles = StripeResource.extend({
  retrieve: stripeMethod44({
    method: "GET",
    fullPath: "/v1/issuing/physical_bundles/{physical_bundle}"
  }),
  list: stripeMethod44({
    method: "GET",
    fullPath: "/v1/issuing/physical_bundles",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/Climate/Products.js
var stripeMethod45 = StripeResource.method;
var Products = StripeResource.extend({
  retrieve: stripeMethod45({
    method: "GET",
    fullPath: "/v1/climate/products/{product}"
  }),
  list: stripeMethod45({
    method: "GET",
    fullPath: "/v1/climate/products",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/TestHelpers/Terminal/Readers.js
var stripeMethod46 = StripeResource.method;
var Readers = StripeResource.extend({
  presentPaymentMethod: stripeMethod46({
    method: "POST",
    fullPath: "/v1/test_helpers/terminal/readers/{reader}/present_payment_method"
  })
});

// node_modules/stripe/esm/resources/Terminal/Readers.js
var stripeMethod47 = StripeResource.method;
var Readers2 = StripeResource.extend({
  create: stripeMethod47({ method: "POST", fullPath: "/v1/terminal/readers" }),
  retrieve: stripeMethod47({
    method: "GET",
    fullPath: "/v1/terminal/readers/{reader}"
  }),
  update: stripeMethod47({
    method: "POST",
    fullPath: "/v1/terminal/readers/{reader}"
  }),
  list: stripeMethod47({
    method: "GET",
    fullPath: "/v1/terminal/readers",
    methodType: "list"
  }),
  del: stripeMethod47({
    method: "DELETE",
    fullPath: "/v1/terminal/readers/{reader}"
  }),
  cancelAction: stripeMethod47({
    method: "POST",
    fullPath: "/v1/terminal/readers/{reader}/cancel_action"
  }),
  processPaymentIntent: stripeMethod47({
    method: "POST",
    fullPath: "/v1/terminal/readers/{reader}/process_payment_intent"
  }),
  processSetupIntent: stripeMethod47({
    method: "POST",
    fullPath: "/v1/terminal/readers/{reader}/process_setup_intent"
  }),
  refundPayment: stripeMethod47({
    method: "POST",
    fullPath: "/v1/terminal/readers/{reader}/refund_payment"
  }),
  setReaderDisplay: stripeMethod47({
    method: "POST",
    fullPath: "/v1/terminal/readers/{reader}/set_reader_display"
  })
});

// node_modules/stripe/esm/resources/TestHelpers/Treasury/ReceivedCredits.js
var stripeMethod48 = StripeResource.method;
var ReceivedCredits = StripeResource.extend({
  create: stripeMethod48({
    method: "POST",
    fullPath: "/v1/test_helpers/treasury/received_credits"
  })
});

// node_modules/stripe/esm/resources/Treasury/ReceivedCredits.js
var stripeMethod49 = StripeResource.method;
var ReceivedCredits2 = StripeResource.extend({
  retrieve: stripeMethod49({
    method: "GET",
    fullPath: "/v1/treasury/received_credits/{id}"
  }),
  list: stripeMethod49({
    method: "GET",
    fullPath: "/v1/treasury/received_credits",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/TestHelpers/Treasury/ReceivedDebits.js
var stripeMethod50 = StripeResource.method;
var ReceivedDebits = StripeResource.extend({
  create: stripeMethod50({
    method: "POST",
    fullPath: "/v1/test_helpers/treasury/received_debits"
  })
});

// node_modules/stripe/esm/resources/Treasury/ReceivedDebits.js
var stripeMethod51 = StripeResource.method;
var ReceivedDebits2 = StripeResource.extend({
  retrieve: stripeMethod51({
    method: "GET",
    fullPath: "/v1/treasury/received_debits/{id}"
  }),
  list: stripeMethod51({
    method: "GET",
    fullPath: "/v1/treasury/received_debits",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/TestHelpers/Refunds.js
var stripeMethod52 = StripeResource.method;
var Refunds = StripeResource.extend({
  expire: stripeMethod52({
    method: "POST",
    fullPath: "/v1/test_helpers/refunds/{refund}/expire"
  })
});

// node_modules/stripe/esm/resources/Tax/Registrations.js
var stripeMethod53 = StripeResource.method;
var Registrations = StripeResource.extend({
  create: stripeMethod53({ method: "POST", fullPath: "/v1/tax/registrations" }),
  retrieve: stripeMethod53({
    method: "GET",
    fullPath: "/v1/tax/registrations/{id}"
  }),
  update: stripeMethod53({
    method: "POST",
    fullPath: "/v1/tax/registrations/{id}"
  }),
  list: stripeMethod53({
    method: "GET",
    fullPath: "/v1/tax/registrations",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/Reporting/ReportRuns.js
var stripeMethod54 = StripeResource.method;
var ReportRuns = StripeResource.extend({
  create: stripeMethod54({ method: "POST", fullPath: "/v1/reporting/report_runs" }),
  retrieve: stripeMethod54({
    method: "GET",
    fullPath: "/v1/reporting/report_runs/{report_run}"
  }),
  list: stripeMethod54({
    method: "GET",
    fullPath: "/v1/reporting/report_runs",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/Reporting/ReportTypes.js
var stripeMethod55 = StripeResource.method;
var ReportTypes = StripeResource.extend({
  retrieve: stripeMethod55({
    method: "GET",
    fullPath: "/v1/reporting/report_types/{report_type}"
  }),
  list: stripeMethod55({
    method: "GET",
    fullPath: "/v1/reporting/report_types",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/Forwarding/Requests.js
var stripeMethod56 = StripeResource.method;
var Requests = StripeResource.extend({
  create: stripeMethod56({ method: "POST", fullPath: "/v1/forwarding/requests" }),
  retrieve: stripeMethod56({
    method: "GET",
    fullPath: "/v1/forwarding/requests/{id}"
  }),
  list: stripeMethod56({
    method: "GET",
    fullPath: "/v1/forwarding/requests",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/Sigma/ScheduledQueryRuns.js
var stripeMethod57 = StripeResource.method;
var ScheduledQueryRuns = StripeResource.extend({
  retrieve: stripeMethod57({
    method: "GET",
    fullPath: "/v1/sigma/scheduled_query_runs/{scheduled_query_run}"
  }),
  list: stripeMethod57({
    method: "GET",
    fullPath: "/v1/sigma/scheduled_query_runs",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/Apps/Secrets.js
var stripeMethod58 = StripeResource.method;
var Secrets = StripeResource.extend({
  create: stripeMethod58({ method: "POST", fullPath: "/v1/apps/secrets" }),
  list: stripeMethod58({
    method: "GET",
    fullPath: "/v1/apps/secrets",
    methodType: "list"
  }),
  deleteWhere: stripeMethod58({
    method: "POST",
    fullPath: "/v1/apps/secrets/delete"
  }),
  find: stripeMethod58({ method: "GET", fullPath: "/v1/apps/secrets/find" })
});

// node_modules/stripe/esm/resources/BillingPortal/Sessions.js
var stripeMethod59 = StripeResource.method;
var Sessions = StripeResource.extend({
  create: stripeMethod59({
    method: "POST",
    fullPath: "/v1/billing_portal/sessions"
  })
});

// node_modules/stripe/esm/resources/Checkout/Sessions.js
var stripeMethod60 = StripeResource.method;
var Sessions2 = StripeResource.extend({
  create: stripeMethod60({ method: "POST", fullPath: "/v1/checkout/sessions" }),
  retrieve: stripeMethod60({
    method: "GET",
    fullPath: "/v1/checkout/sessions/{session}"
  }),
  update: stripeMethod60({
    method: "POST",
    fullPath: "/v1/checkout/sessions/{session}"
  }),
  list: stripeMethod60({
    method: "GET",
    fullPath: "/v1/checkout/sessions",
    methodType: "list"
  }),
  expire: stripeMethod60({
    method: "POST",
    fullPath: "/v1/checkout/sessions/{session}/expire"
  }),
  listLineItems: stripeMethod60({
    method: "GET",
    fullPath: "/v1/checkout/sessions/{session}/line_items",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/FinancialConnections/Sessions.js
var stripeMethod61 = StripeResource.method;
var Sessions3 = StripeResource.extend({
  create: stripeMethod61({
    method: "POST",
    fullPath: "/v1/financial_connections/sessions"
  }),
  retrieve: stripeMethod61({
    method: "GET",
    fullPath: "/v1/financial_connections/sessions/{session}"
  })
});

// node_modules/stripe/esm/resources/Tax/Settings.js
var stripeMethod62 = StripeResource.method;
var Settings = StripeResource.extend({
  retrieve: stripeMethod62({ method: "GET", fullPath: "/v1/tax/settings" }),
  update: stripeMethod62({ method: "POST", fullPath: "/v1/tax/settings" })
});

// node_modules/stripe/esm/resources/Climate/Suppliers.js
var stripeMethod63 = StripeResource.method;
var Suppliers = StripeResource.extend({
  retrieve: stripeMethod63({
    method: "GET",
    fullPath: "/v1/climate/suppliers/{supplier}"
  }),
  list: stripeMethod63({
    method: "GET",
    fullPath: "/v1/climate/suppliers",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/TestHelpers/TestClocks.js
var stripeMethod64 = StripeResource.method;
var TestClocks = StripeResource.extend({
  create: stripeMethod64({
    method: "POST",
    fullPath: "/v1/test_helpers/test_clocks"
  }),
  retrieve: stripeMethod64({
    method: "GET",
    fullPath: "/v1/test_helpers/test_clocks/{test_clock}"
  }),
  list: stripeMethod64({
    method: "GET",
    fullPath: "/v1/test_helpers/test_clocks",
    methodType: "list"
  }),
  del: stripeMethod64({
    method: "DELETE",
    fullPath: "/v1/test_helpers/test_clocks/{test_clock}"
  }),
  advance: stripeMethod64({
    method: "POST",
    fullPath: "/v1/test_helpers/test_clocks/{test_clock}/advance"
  })
});

// node_modules/stripe/esm/resources/Issuing/Tokens.js
var stripeMethod65 = StripeResource.method;
var Tokens = StripeResource.extend({
  retrieve: stripeMethod65({
    method: "GET",
    fullPath: "/v1/issuing/tokens/{token}"
  }),
  update: stripeMethod65({
    method: "POST",
    fullPath: "/v1/issuing/tokens/{token}"
  }),
  list: stripeMethod65({
    method: "GET",
    fullPath: "/v1/issuing/tokens",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/Treasury/TransactionEntries.js
var stripeMethod66 = StripeResource.method;
var TransactionEntries = StripeResource.extend({
  retrieve: stripeMethod66({
    method: "GET",
    fullPath: "/v1/treasury/transaction_entries/{id}"
  }),
  list: stripeMethod66({
    method: "GET",
    fullPath: "/v1/treasury/transaction_entries",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/TestHelpers/Issuing/Transactions.js
var stripeMethod67 = StripeResource.method;
var Transactions = StripeResource.extend({
  createForceCapture: stripeMethod67({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/transactions/create_force_capture"
  }),
  createUnlinkedRefund: stripeMethod67({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/transactions/create_unlinked_refund"
  }),
  refund: stripeMethod67({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/transactions/{transaction}/refund"
  })
});

// node_modules/stripe/esm/resources/FinancialConnections/Transactions.js
var stripeMethod68 = StripeResource.method;
var Transactions2 = StripeResource.extend({
  retrieve: stripeMethod68({
    method: "GET",
    fullPath: "/v1/financial_connections/transactions/{transaction}"
  }),
  list: stripeMethod68({
    method: "GET",
    fullPath: "/v1/financial_connections/transactions",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/Issuing/Transactions.js
var stripeMethod69 = StripeResource.method;
var Transactions3 = StripeResource.extend({
  retrieve: stripeMethod69({
    method: "GET",
    fullPath: "/v1/issuing/transactions/{transaction}"
  }),
  update: stripeMethod69({
    method: "POST",
    fullPath: "/v1/issuing/transactions/{transaction}"
  }),
  list: stripeMethod69({
    method: "GET",
    fullPath: "/v1/issuing/transactions",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/Tax/Transactions.js
var stripeMethod70 = StripeResource.method;
var Transactions4 = StripeResource.extend({
  retrieve: stripeMethod70({
    method: "GET",
    fullPath: "/v1/tax/transactions/{transaction}"
  }),
  createFromCalculation: stripeMethod70({
    method: "POST",
    fullPath: "/v1/tax/transactions/create_from_calculation"
  }),
  createReversal: stripeMethod70({
    method: "POST",
    fullPath: "/v1/tax/transactions/create_reversal"
  }),
  listLineItems: stripeMethod70({
    method: "GET",
    fullPath: "/v1/tax/transactions/{transaction}/line_items",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/Treasury/Transactions.js
var stripeMethod71 = StripeResource.method;
var Transactions5 = StripeResource.extend({
  retrieve: stripeMethod71({
    method: "GET",
    fullPath: "/v1/treasury/transactions/{id}"
  }),
  list: stripeMethod71({
    method: "GET",
    fullPath: "/v1/treasury/transactions",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/Radar/ValueListItems.js
var stripeMethod72 = StripeResource.method;
var ValueListItems = StripeResource.extend({
  create: stripeMethod72({
    method: "POST",
    fullPath: "/v1/radar/value_list_items"
  }),
  retrieve: stripeMethod72({
    method: "GET",
    fullPath: "/v1/radar/value_list_items/{item}"
  }),
  list: stripeMethod72({
    method: "GET",
    fullPath: "/v1/radar/value_list_items",
    methodType: "list"
  }),
  del: stripeMethod72({
    method: "DELETE",
    fullPath: "/v1/radar/value_list_items/{item}"
  })
});

// node_modules/stripe/esm/resources/Radar/ValueLists.js
var stripeMethod73 = StripeResource.method;
var ValueLists = StripeResource.extend({
  create: stripeMethod73({ method: "POST", fullPath: "/v1/radar/value_lists" }),
  retrieve: stripeMethod73({
    method: "GET",
    fullPath: "/v1/radar/value_lists/{value_list}"
  }),
  update: stripeMethod73({
    method: "POST",
    fullPath: "/v1/radar/value_lists/{value_list}"
  }),
  list: stripeMethod73({
    method: "GET",
    fullPath: "/v1/radar/value_lists",
    methodType: "list"
  }),
  del: stripeMethod73({
    method: "DELETE",
    fullPath: "/v1/radar/value_lists/{value_list}"
  })
});

// node_modules/stripe/esm/resources/Identity/VerificationReports.js
var stripeMethod74 = StripeResource.method;
var VerificationReports = StripeResource.extend({
  retrieve: stripeMethod74({
    method: "GET",
    fullPath: "/v1/identity/verification_reports/{report}"
  }),
  list: stripeMethod74({
    method: "GET",
    fullPath: "/v1/identity/verification_reports",
    methodType: "list"
  })
});

// node_modules/stripe/esm/resources/Identity/VerificationSessions.js
var stripeMethod75 = StripeResource.method;
var VerificationSessions = StripeResource.extend({
  create: stripeMethod75({
    method: "POST",
    fullPath: "/v1/identity/verification_sessions"
  }),
  retrieve: stripeMethod75({
    method: "GET",
    fullPath: "/v1/identity/verification_sessions/{session}"
  }),
  update: stripeMethod75({
    method: "POST",
    fullPath: "/v1/identity/verification_sessions/{session}"
  }),
  list: stripeMethod75({
    method: "GET",
    fullPath: "/v1/identity/verification_sessions",
    methodType: "list"
  }),
  cancel: stripeMethod75({
    method: "POST",
    fullPath: "/v1/identity/verification_sessions/{session}/cancel"
  }),
  redact: stripeMethod75({
    method: "POST",
    fullPath: "/v1/identity/verification_sessions/{session}/redact"
  })
});

// node_modules/stripe/esm/resources/Accounts.js
var stripeMethod76 = StripeResource.method;
var Accounts2 = StripeResource.extend({
  create: stripeMethod76({ method: "POST", fullPath: "/v1/accounts" }),
  retrieve(id, ...args) {
    if (typeof id === "string") {
      return stripeMethod76({
        method: "GET",
        fullPath: "/v1/accounts/{id}"
      }).apply(this, [id, ...args]);
    } else {
      if (id === null || id === undefined) {
        [].shift.apply([id, ...args]);
      }
      return stripeMethod76({
        method: "GET",
        fullPath: "/v1/account"
      }).apply(this, [id, ...args]);
    }
  },
  update: stripeMethod76({ method: "POST", fullPath: "/v1/accounts/{account}" }),
  list: stripeMethod76({
    method: "GET",
    fullPath: "/v1/accounts",
    methodType: "list"
  }),
  del: stripeMethod76({ method: "DELETE", fullPath: "/v1/accounts/{account}" }),
  createExternalAccount: stripeMethod76({
    method: "POST",
    fullPath: "/v1/accounts/{account}/external_accounts"
  }),
  createLoginLink: stripeMethod76({
    method: "POST",
    fullPath: "/v1/accounts/{account}/login_links"
  }),
  createPerson: stripeMethod76({
    method: "POST",
    fullPath: "/v1/accounts/{account}/persons"
  }),
  deleteExternalAccount: stripeMethod76({
    method: "DELETE",
    fullPath: "/v1/accounts/{account}/external_accounts/{id}"
  }),
  deletePerson: stripeMethod76({
    method: "DELETE",
    fullPath: "/v1/accounts/{account}/persons/{person}"
  }),
  listCapabilities: stripeMethod76({
    method: "GET",
    fullPath: "/v1/accounts/{account}/capabilities",
    methodType: "list"
  }),
  listExternalAccounts: stripeMethod76({
    method: "GET",
    fullPath: "/v1/accounts/{account}/external_accounts",
    methodType: "list"
  }),
  listPersons: stripeMethod76({
    method: "GET",
    fullPath: "/v1/accounts/{account}/persons",
    methodType: "list"
  }),
  reject: stripeMethod76({
    method: "POST",
    fullPath: "/v1/accounts/{account}/reject"
  }),
  retrieveCurrent: stripeMethod76({ method: "GET", fullPath: "/v1/account" }),
  retrieveCapability: stripeMethod76({
    method: "GET",
    fullPath: "/v1/accounts/{account}/capabilities/{capability}"
  }),
  retrieveExternalAccount: stripeMethod76({
    method: "GET",
    fullPath: "/v1/accounts/{account}/external_accounts/{id}"
  }),
  retrievePerson: stripeMethod76({
    method: "GET",
    fullPath: "/v1/accounts/{account}/persons/{person}"
  }),
  updateCapability: stripeMethod76({
    method: "POST",
    fullPath: "/v1/accounts/{account}/capabilities/{capability}"
  }),
  updateExternalAccount: stripeMethod76({
    method: "POST",
    fullPath: "/v1/accounts/{account}/external_accounts/{id}"
  }),
  updatePerson: stripeMethod76({
    method: "POST",
    fullPath: "/v1/accounts/{account}/persons/{person}"
  })
});
// node_modules/stripe/esm/resources/AccountLinks.js
var stripeMethod77 = StripeResource.method;
var AccountLinks = StripeResource.extend({
  create: stripeMethod77({ method: "POST", fullPath: "/v1/account_links" })
});
// node_modules/stripe/esm/resources/AccountSessions.js
var stripeMethod78 = StripeResource.method;
var AccountSessions = StripeResource.extend({
  create: stripeMethod78({ method: "POST", fullPath: "/v1/account_sessions" })
});
// node_modules/stripe/esm/resources/ApplePayDomains.js
var stripeMethod79 = StripeResource.method;
var ApplePayDomains = StripeResource.extend({
  create: stripeMethod79({ method: "POST", fullPath: "/v1/apple_pay/domains" }),
  retrieve: stripeMethod79({
    method: "GET",
    fullPath: "/v1/apple_pay/domains/{domain}"
  }),
  list: stripeMethod79({
    method: "GET",
    fullPath: "/v1/apple_pay/domains",
    methodType: "list"
  }),
  del: stripeMethod79({
    method: "DELETE",
    fullPath: "/v1/apple_pay/domains/{domain}"
  })
});
// node_modules/stripe/esm/resources/ApplicationFees.js
var stripeMethod80 = StripeResource.method;
var ApplicationFees = StripeResource.extend({
  retrieve: stripeMethod80({
    method: "GET",
    fullPath: "/v1/application_fees/{id}"
  }),
  list: stripeMethod80({
    method: "GET",
    fullPath: "/v1/application_fees",
    methodType: "list"
  }),
  createRefund: stripeMethod80({
    method: "POST",
    fullPath: "/v1/application_fees/{id}/refunds"
  }),
  listRefunds: stripeMethod80({
    method: "GET",
    fullPath: "/v1/application_fees/{id}/refunds",
    methodType: "list"
  }),
  retrieveRefund: stripeMethod80({
    method: "GET",
    fullPath: "/v1/application_fees/{fee}/refunds/{id}"
  }),
  updateRefund: stripeMethod80({
    method: "POST",
    fullPath: "/v1/application_fees/{fee}/refunds/{id}"
  })
});
// node_modules/stripe/esm/resources/Balance.js
var stripeMethod81 = StripeResource.method;
var Balance = StripeResource.extend({
  retrieve: stripeMethod81({ method: "GET", fullPath: "/v1/balance" })
});
// node_modules/stripe/esm/resources/BalanceTransactions.js
var stripeMethod82 = StripeResource.method;
var BalanceTransactions = StripeResource.extend({
  retrieve: stripeMethod82({
    method: "GET",
    fullPath: "/v1/balance_transactions/{id}"
  }),
  list: stripeMethod82({
    method: "GET",
    fullPath: "/v1/balance_transactions",
    methodType: "list"
  })
});
// node_modules/stripe/esm/resources/Charges.js
var stripeMethod83 = StripeResource.method;
var Charges = StripeResource.extend({
  create: stripeMethod83({ method: "POST", fullPath: "/v1/charges" }),
  retrieve: stripeMethod83({ method: "GET", fullPath: "/v1/charges/{charge}" }),
  update: stripeMethod83({ method: "POST", fullPath: "/v1/charges/{charge}" }),
  list: stripeMethod83({
    method: "GET",
    fullPath: "/v1/charges",
    methodType: "list"
  }),
  capture: stripeMethod83({
    method: "POST",
    fullPath: "/v1/charges/{charge}/capture"
  }),
  search: stripeMethod83({
    method: "GET",
    fullPath: "/v1/charges/search",
    methodType: "search"
  })
});
// node_modules/stripe/esm/resources/ConfirmationTokens.js
var stripeMethod84 = StripeResource.method;
var ConfirmationTokens2 = StripeResource.extend({
  retrieve: stripeMethod84({
    method: "GET",
    fullPath: "/v1/confirmation_tokens/{confirmation_token}"
  })
});
// node_modules/stripe/esm/resources/CountrySpecs.js
var stripeMethod85 = StripeResource.method;
var CountrySpecs = StripeResource.extend({
  retrieve: stripeMethod85({
    method: "GET",
    fullPath: "/v1/country_specs/{country}"
  }),
  list: stripeMethod85({
    method: "GET",
    fullPath: "/v1/country_specs",
    methodType: "list"
  })
});
// node_modules/stripe/esm/resources/Coupons.js
var stripeMethod86 = StripeResource.method;
var Coupons = StripeResource.extend({
  create: stripeMethod86({ method: "POST", fullPath: "/v1/coupons" }),
  retrieve: stripeMethod86({ method: "GET", fullPath: "/v1/coupons/{coupon}" }),
  update: stripeMethod86({ method: "POST", fullPath: "/v1/coupons/{coupon}" }),
  list: stripeMethod86({
    method: "GET",
    fullPath: "/v1/coupons",
    methodType: "list"
  }),
  del: stripeMethod86({ method: "DELETE", fullPath: "/v1/coupons/{coupon}" })
});
// node_modules/stripe/esm/resources/CreditNotes.js
var stripeMethod87 = StripeResource.method;
var CreditNotes = StripeResource.extend({
  create: stripeMethod87({ method: "POST", fullPath: "/v1/credit_notes" }),
  retrieve: stripeMethod87({ method: "GET", fullPath: "/v1/credit_notes/{id}" }),
  update: stripeMethod87({ method: "POST", fullPath: "/v1/credit_notes/{id}" }),
  list: stripeMethod87({
    method: "GET",
    fullPath: "/v1/credit_notes",
    methodType: "list"
  }),
  listLineItems: stripeMethod87({
    method: "GET",
    fullPath: "/v1/credit_notes/{credit_note}/lines",
    methodType: "list"
  }),
  listPreviewLineItems: stripeMethod87({
    method: "GET",
    fullPath: "/v1/credit_notes/preview/lines",
    methodType: "list"
  }),
  preview: stripeMethod87({ method: "GET", fullPath: "/v1/credit_notes/preview" }),
  voidCreditNote: stripeMethod87({
    method: "POST",
    fullPath: "/v1/credit_notes/{id}/void"
  })
});
// node_modules/stripe/esm/resources/CustomerSessions.js
var stripeMethod88 = StripeResource.method;
var CustomerSessions = StripeResource.extend({
  create: stripeMethod88({ method: "POST", fullPath: "/v1/customer_sessions" })
});
// node_modules/stripe/esm/resources/Customers.js
var stripeMethod89 = StripeResource.method;
var Customers2 = StripeResource.extend({
  create: stripeMethod89({ method: "POST", fullPath: "/v1/customers" }),
  retrieve: stripeMethod89({ method: "GET", fullPath: "/v1/customers/{customer}" }),
  update: stripeMethod89({ method: "POST", fullPath: "/v1/customers/{customer}" }),
  list: stripeMethod89({
    method: "GET",
    fullPath: "/v1/customers",
    methodType: "list"
  }),
  del: stripeMethod89({ method: "DELETE", fullPath: "/v1/customers/{customer}" }),
  createBalanceTransaction: stripeMethod89({
    method: "POST",
    fullPath: "/v1/customers/{customer}/balance_transactions"
  }),
  createFundingInstructions: stripeMethod89({
    method: "POST",
    fullPath: "/v1/customers/{customer}/funding_instructions"
  }),
  createSource: stripeMethod89({
    method: "POST",
    fullPath: "/v1/customers/{customer}/sources"
  }),
  createTaxId: stripeMethod89({
    method: "POST",
    fullPath: "/v1/customers/{customer}/tax_ids"
  }),
  deleteDiscount: stripeMethod89({
    method: "DELETE",
    fullPath: "/v1/customers/{customer}/discount"
  }),
  deleteSource: stripeMethod89({
    method: "DELETE",
    fullPath: "/v1/customers/{customer}/sources/{id}"
  }),
  deleteTaxId: stripeMethod89({
    method: "DELETE",
    fullPath: "/v1/customers/{customer}/tax_ids/{id}"
  }),
  listBalanceTransactions: stripeMethod89({
    method: "GET",
    fullPath: "/v1/customers/{customer}/balance_transactions",
    methodType: "list"
  }),
  listCashBalanceTransactions: stripeMethod89({
    method: "GET",
    fullPath: "/v1/customers/{customer}/cash_balance_transactions",
    methodType: "list"
  }),
  listPaymentMethods: stripeMethod89({
    method: "GET",
    fullPath: "/v1/customers/{customer}/payment_methods",
    methodType: "list"
  }),
  listSources: stripeMethod89({
    method: "GET",
    fullPath: "/v1/customers/{customer}/sources",
    methodType: "list"
  }),
  listTaxIds: stripeMethod89({
    method: "GET",
    fullPath: "/v1/customers/{customer}/tax_ids",
    methodType: "list"
  }),
  retrieveBalanceTransaction: stripeMethod89({
    method: "GET",
    fullPath: "/v1/customers/{customer}/balance_transactions/{transaction}"
  }),
  retrieveCashBalance: stripeMethod89({
    method: "GET",
    fullPath: "/v1/customers/{customer}/cash_balance"
  }),
  retrieveCashBalanceTransaction: stripeMethod89({
    method: "GET",
    fullPath: "/v1/customers/{customer}/cash_balance_transactions/{transaction}"
  }),
  retrievePaymentMethod: stripeMethod89({
    method: "GET",
    fullPath: "/v1/customers/{customer}/payment_methods/{payment_method}"
  }),
  retrieveSource: stripeMethod89({
    method: "GET",
    fullPath: "/v1/customers/{customer}/sources/{id}"
  }),
  retrieveTaxId: stripeMethod89({
    method: "GET",
    fullPath: "/v1/customers/{customer}/tax_ids/{id}"
  }),
  search: stripeMethod89({
    method: "GET",
    fullPath: "/v1/customers/search",
    methodType: "search"
  }),
  updateBalanceTransaction: stripeMethod89({
    method: "POST",
    fullPath: "/v1/customers/{customer}/balance_transactions/{transaction}"
  }),
  updateCashBalance: stripeMethod89({
    method: "POST",
    fullPath: "/v1/customers/{customer}/cash_balance"
  }),
  updateSource: stripeMethod89({
    method: "POST",
    fullPath: "/v1/customers/{customer}/sources/{id}"
  }),
  verifySource: stripeMethod89({
    method: "POST",
    fullPath: "/v1/customers/{customer}/sources/{id}/verify"
  })
});
// node_modules/stripe/esm/resources/Disputes.js
var stripeMethod90 = StripeResource.method;
var Disputes2 = StripeResource.extend({
  retrieve: stripeMethod90({ method: "GET", fullPath: "/v1/disputes/{dispute}" }),
  update: stripeMethod90({ method: "POST", fullPath: "/v1/disputes/{dispute}" }),
  list: stripeMethod90({
    method: "GET",
    fullPath: "/v1/disputes",
    methodType: "list"
  }),
  close: stripeMethod90({
    method: "POST",
    fullPath: "/v1/disputes/{dispute}/close"
  })
});
// node_modules/stripe/esm/resources/EphemeralKeys.js
var stripeMethod91 = StripeResource.method;
var EphemeralKeys = StripeResource.extend({
  create: stripeMethod91({
    method: "POST",
    fullPath: "/v1/ephemeral_keys",
    validator: (data, options) => {
      if (!options.headers || !options.headers["Stripe-Version"]) {
        throw new Error("Passing apiVersion in a separate options hash is required to create an ephemeral key. See https://stripe.com/docs/api/versioning?lang=node");
      }
    }
  }),
  del: stripeMethod91({ method: "DELETE", fullPath: "/v1/ephemeral_keys/{key}" })
});
// node_modules/stripe/esm/resources/Events.js
var stripeMethod92 = StripeResource.method;
var Events2 = StripeResource.extend({
  retrieve: stripeMethod92({ method: "GET", fullPath: "/v1/events/{id}" }),
  list: stripeMethod92({
    method: "GET",
    fullPath: "/v1/events",
    methodType: "list"
  })
});
// node_modules/stripe/esm/resources/ExchangeRates.js
var stripeMethod93 = StripeResource.method;
var ExchangeRates = StripeResource.extend({
  retrieve: stripeMethod93({
    method: "GET",
    fullPath: "/v1/exchange_rates/{rate_id}"
  }),
  list: stripeMethod93({
    method: "GET",
    fullPath: "/v1/exchange_rates",
    methodType: "list"
  })
});
// node_modules/stripe/esm/resources/FileLinks.js
var stripeMethod94 = StripeResource.method;
var FileLinks = StripeResource.extend({
  create: stripeMethod94({ method: "POST", fullPath: "/v1/file_links" }),
  retrieve: stripeMethod94({ method: "GET", fullPath: "/v1/file_links/{link}" }),
  update: stripeMethod94({ method: "POST", fullPath: "/v1/file_links/{link}" }),
  list: stripeMethod94({
    method: "GET",
    fullPath: "/v1/file_links",
    methodType: "list"
  })
});
// node_modules/stripe/esm/multipart.js
var multipartDataGenerator = (method, data, headers) => {
  const segno = (Math.round(Math.random() * 10000000000000000) + Math.round(Math.random() * 10000000000000000)).toString();
  headers["Content-Type"] = `multipart/form-data; boundary=${segno}`;
  const textEncoder = new TextEncoder;
  let buffer = new Uint8Array(0);
  const endBuffer = textEncoder.encode(`\r
`);
  function push(l2) {
    const prevBuffer = buffer;
    const newBuffer = l2 instanceof Uint8Array ? l2 : new Uint8Array(textEncoder.encode(l2));
    buffer = new Uint8Array(prevBuffer.length + newBuffer.length + 2);
    buffer.set(prevBuffer);
    buffer.set(newBuffer, prevBuffer.length);
    buffer.set(endBuffer, buffer.length - 2);
  }
  function q(s) {
    return `"${s.replace(/"|"/g, "%22").replace(/\r\n|\r|\n/g, " ")}"`;
  }
  const flattenedData = flattenAndStringify(data);
  for (const k in flattenedData) {
    if (!Object.prototype.hasOwnProperty.call(flattenedData, k)) {
      continue;
    }
    const v = flattenedData[k];
    push(`--${segno}`);
    if (Object.prototype.hasOwnProperty.call(v, "data")) {
      const typedEntry = v;
      push(`Content-Disposition: form-data; name=${q(k)}; filename=${q(typedEntry.name || "blob")}`);
      push(`Content-Type: ${typedEntry.type || "application/octet-stream"}`);
      push("");
      push(typedEntry.data);
    } else {
      push(`Content-Disposition: form-data; name=${q(k)}`);
      push("");
      push(v);
    }
  }
  push(`--${segno}--`);
  return buffer;
};
function multipartRequestDataProcessor(method, data, headers, callback) {
  data = data || {};
  if (method !== "POST") {
    return callback(null, queryStringifyRequestData(data));
  }
  this._stripe._platformFunctions.tryBufferData(data).then((bufferedData) => {
    const buffer = multipartDataGenerator(method, bufferedData, headers);
    return callback(null, buffer);
  }).catch((err) => callback(err, null));
}

// node_modules/stripe/esm/resources/Files.js
var stripeMethod95 = StripeResource.method;
var Files3 = StripeResource.extend({
  create: stripeMethod95({
    method: "POST",
    fullPath: "/v1/files",
    headers: {
      "Content-Type": "multipart/form-data"
    },
    host: "files.stripe.com"
  }),
  retrieve: stripeMethod95({ method: "GET", fullPath: "/v1/files/{file}" }),
  list: stripeMethod95({
    method: "GET",
    fullPath: "/v1/files",
    methodType: "list"
  }),
  requestDataProcessor: multipartRequestDataProcessor
});
// node_modules/stripe/esm/resources/InvoiceItems.js
var stripeMethod96 = StripeResource.method;
var InvoiceItems = StripeResource.extend({
  create: stripeMethod96({ method: "POST", fullPath: "/v1/invoiceitems" }),
  retrieve: stripeMethod96({
    method: "GET",
    fullPath: "/v1/invoiceitems/{invoiceitem}"
  }),
  update: stripeMethod96({
    method: "POST",
    fullPath: "/v1/invoiceitems/{invoiceitem}"
  }),
  list: stripeMethod96({
    method: "GET",
    fullPath: "/v1/invoiceitems",
    methodType: "list"
  }),
  del: stripeMethod96({
    method: "DELETE",
    fullPath: "/v1/invoiceitems/{invoiceitem}"
  })
});
// node_modules/stripe/esm/resources/InvoiceRenderingTemplates.js
var stripeMethod97 = StripeResource.method;
var InvoiceRenderingTemplates = StripeResource.extend({
  retrieve: stripeMethod97({
    method: "GET",
    fullPath: "/v1/invoice_rendering_templates/{template}"
  }),
  list: stripeMethod97({
    method: "GET",
    fullPath: "/v1/invoice_rendering_templates",
    methodType: "list"
  }),
  archive: stripeMethod97({
    method: "POST",
    fullPath: "/v1/invoice_rendering_templates/{template}/archive"
  }),
  unarchive: stripeMethod97({
    method: "POST",
    fullPath: "/v1/invoice_rendering_templates/{template}/unarchive"
  })
});
// node_modules/stripe/esm/resources/Invoices.js
var stripeMethod98 = StripeResource.method;
var Invoices = StripeResource.extend({
  create: stripeMethod98({ method: "POST", fullPath: "/v1/invoices" }),
  retrieve: stripeMethod98({ method: "GET", fullPath: "/v1/invoices/{invoice}" }),
  update: stripeMethod98({ method: "POST", fullPath: "/v1/invoices/{invoice}" }),
  list: stripeMethod98({
    method: "GET",
    fullPath: "/v1/invoices",
    methodType: "list"
  }),
  del: stripeMethod98({ method: "DELETE", fullPath: "/v1/invoices/{invoice}" }),
  addLines: stripeMethod98({
    method: "POST",
    fullPath: "/v1/invoices/{invoice}/add_lines"
  }),
  createPreview: stripeMethod98({
    method: "POST",
    fullPath: "/v1/invoices/create_preview"
  }),
  finalizeInvoice: stripeMethod98({
    method: "POST",
    fullPath: "/v1/invoices/{invoice}/finalize"
  }),
  listLineItems: stripeMethod98({
    method: "GET",
    fullPath: "/v1/invoices/{invoice}/lines",
    methodType: "list"
  }),
  listUpcomingLines: stripeMethod98({
    method: "GET",
    fullPath: "/v1/invoices/upcoming/lines",
    methodType: "list"
  }),
  markUncollectible: stripeMethod98({
    method: "POST",
    fullPath: "/v1/invoices/{invoice}/mark_uncollectible"
  }),
  pay: stripeMethod98({ method: "POST", fullPath: "/v1/invoices/{invoice}/pay" }),
  removeLines: stripeMethod98({
    method: "POST",
    fullPath: "/v1/invoices/{invoice}/remove_lines"
  }),
  retrieveUpcoming: stripeMethod98({
    method: "GET",
    fullPath: "/v1/invoices/upcoming"
  }),
  search: stripeMethod98({
    method: "GET",
    fullPath: "/v1/invoices/search",
    methodType: "search"
  }),
  sendInvoice: stripeMethod98({
    method: "POST",
    fullPath: "/v1/invoices/{invoice}/send"
  }),
  updateLines: stripeMethod98({
    method: "POST",
    fullPath: "/v1/invoices/{invoice}/update_lines"
  }),
  updateLineItem: stripeMethod98({
    method: "POST",
    fullPath: "/v1/invoices/{invoice}/lines/{line_item_id}"
  }),
  voidInvoice: stripeMethod98({
    method: "POST",
    fullPath: "/v1/invoices/{invoice}/void"
  })
});
// node_modules/stripe/esm/resources/Mandates.js
var stripeMethod99 = StripeResource.method;
var Mandates = StripeResource.extend({
  retrieve: stripeMethod99({ method: "GET", fullPath: "/v1/mandates/{mandate}" })
});
// node_modules/stripe/esm/resources/OAuth.js
var stripeMethod100 = StripeResource.method;
var oAuthHost = "connect.stripe.com";
var OAuth = StripeResource.extend({
  basePath: "/",
  authorizeUrl(params, options) {
    params = params || {};
    options = options || {};
    let path2 = "oauth/authorize";
    if (options.express) {
      path2 = `express/${path2}`;
    }
    if (!params.response_type) {
      params.response_type = "code";
    }
    if (!params.client_id) {
      params.client_id = this._stripe.getClientId();
    }
    if (!params.scope) {
      params.scope = "read_write";
    }
    return `https://${oAuthHost}/${path2}?${queryStringifyRequestData(params)}`;
  },
  token: stripeMethod100({
    method: "POST",
    path: "oauth/token",
    host: oAuthHost
  }),
  deauthorize(spec, ...args) {
    if (!spec.client_id) {
      spec.client_id = this._stripe.getClientId();
    }
    return stripeMethod100({
      method: "POST",
      path: "oauth/deauthorize",
      host: oAuthHost
    }).apply(this, [spec, ...args]);
  }
});
// node_modules/stripe/esm/resources/PaymentIntents.js
var stripeMethod101 = StripeResource.method;
var PaymentIntents = StripeResource.extend({
  create: stripeMethod101({ method: "POST", fullPath: "/v1/payment_intents" }),
  retrieve: stripeMethod101({
    method: "GET",
    fullPath: "/v1/payment_intents/{intent}"
  }),
  update: stripeMethod101({
    method: "POST",
    fullPath: "/v1/payment_intents/{intent}"
  }),
  list: stripeMethod101({
    method: "GET",
    fullPath: "/v1/payment_intents",
    methodType: "list"
  }),
  applyCustomerBalance: stripeMethod101({
    method: "POST",
    fullPath: "/v1/payment_intents/{intent}/apply_customer_balance"
  }),
  cancel: stripeMethod101({
    method: "POST",
    fullPath: "/v1/payment_intents/{intent}/cancel"
  }),
  capture: stripeMethod101({
    method: "POST",
    fullPath: "/v1/payment_intents/{intent}/capture"
  }),
  confirm: stripeMethod101({
    method: "POST",
    fullPath: "/v1/payment_intents/{intent}/confirm"
  }),
  incrementAuthorization: stripeMethod101({
    method: "POST",
    fullPath: "/v1/payment_intents/{intent}/increment_authorization"
  }),
  search: stripeMethod101({
    method: "GET",
    fullPath: "/v1/payment_intents/search",
    methodType: "search"
  }),
  verifyMicrodeposits: stripeMethod101({
    method: "POST",
    fullPath: "/v1/payment_intents/{intent}/verify_microdeposits"
  })
});
// node_modules/stripe/esm/resources/PaymentLinks.js
var stripeMethod102 = StripeResource.method;
var PaymentLinks = StripeResource.extend({
  create: stripeMethod102({ method: "POST", fullPath: "/v1/payment_links" }),
  retrieve: stripeMethod102({
    method: "GET",
    fullPath: "/v1/payment_links/{payment_link}"
  }),
  update: stripeMethod102({
    method: "POST",
    fullPath: "/v1/payment_links/{payment_link}"
  }),
  list: stripeMethod102({
    method: "GET",
    fullPath: "/v1/payment_links",
    methodType: "list"
  }),
  listLineItems: stripeMethod102({
    method: "GET",
    fullPath: "/v1/payment_links/{payment_link}/line_items",
    methodType: "list"
  })
});
// node_modules/stripe/esm/resources/PaymentMethodConfigurations.js
var stripeMethod103 = StripeResource.method;
var PaymentMethodConfigurations = StripeResource.extend({
  create: stripeMethod103({
    method: "POST",
    fullPath: "/v1/payment_method_configurations"
  }),
  retrieve: stripeMethod103({
    method: "GET",
    fullPath: "/v1/payment_method_configurations/{configuration}"
  }),
  update: stripeMethod103({
    method: "POST",
    fullPath: "/v1/payment_method_configurations/{configuration}"
  }),
  list: stripeMethod103({
    method: "GET",
    fullPath: "/v1/payment_method_configurations",
    methodType: "list"
  })
});
// node_modules/stripe/esm/resources/PaymentMethodDomains.js
var stripeMethod104 = StripeResource.method;
var PaymentMethodDomains = StripeResource.extend({
  create: stripeMethod104({
    method: "POST",
    fullPath: "/v1/payment_method_domains"
  }),
  retrieve: stripeMethod104({
    method: "GET",
    fullPath: "/v1/payment_method_domains/{payment_method_domain}"
  }),
  update: stripeMethod104({
    method: "POST",
    fullPath: "/v1/payment_method_domains/{payment_method_domain}"
  }),
  list: stripeMethod104({
    method: "GET",
    fullPath: "/v1/payment_method_domains",
    methodType: "list"
  }),
  validate: stripeMethod104({
    method: "POST",
    fullPath: "/v1/payment_method_domains/{payment_method_domain}/validate"
  })
});
// node_modules/stripe/esm/resources/PaymentMethods.js
var stripeMethod105 = StripeResource.method;
var PaymentMethods = StripeResource.extend({
  create: stripeMethod105({ method: "POST", fullPath: "/v1/payment_methods" }),
  retrieve: stripeMethod105({
    method: "GET",
    fullPath: "/v1/payment_methods/{payment_method}"
  }),
  update: stripeMethod105({
    method: "POST",
    fullPath: "/v1/payment_methods/{payment_method}"
  }),
  list: stripeMethod105({
    method: "GET",
    fullPath: "/v1/payment_methods",
    methodType: "list"
  }),
  attach: stripeMethod105({
    method: "POST",
    fullPath: "/v1/payment_methods/{payment_method}/attach"
  }),
  detach: stripeMethod105({
    method: "POST",
    fullPath: "/v1/payment_methods/{payment_method}/detach"
  })
});
// node_modules/stripe/esm/resources/Payouts.js
var stripeMethod106 = StripeResource.method;
var Payouts = StripeResource.extend({
  create: stripeMethod106({ method: "POST", fullPath: "/v1/payouts" }),
  retrieve: stripeMethod106({ method: "GET", fullPath: "/v1/payouts/{payout}" }),
  update: stripeMethod106({ method: "POST", fullPath: "/v1/payouts/{payout}" }),
  list: stripeMethod106({
    method: "GET",
    fullPath: "/v1/payouts",
    methodType: "list"
  }),
  cancel: stripeMethod106({
    method: "POST",
    fullPath: "/v1/payouts/{payout}/cancel"
  }),
  reverse: stripeMethod106({
    method: "POST",
    fullPath: "/v1/payouts/{payout}/reverse"
  })
});
// node_modules/stripe/esm/resources/Plans.js
var stripeMethod107 = StripeResource.method;
var Plans = StripeResource.extend({
  create: stripeMethod107({ method: "POST", fullPath: "/v1/plans" }),
  retrieve: stripeMethod107({ method: "GET", fullPath: "/v1/plans/{plan}" }),
  update: stripeMethod107({ method: "POST", fullPath: "/v1/plans/{plan}" }),
  list: stripeMethod107({
    method: "GET",
    fullPath: "/v1/plans",
    methodType: "list"
  }),
  del: stripeMethod107({ method: "DELETE", fullPath: "/v1/plans/{plan}" })
});
// node_modules/stripe/esm/resources/Prices.js
var stripeMethod108 = StripeResource.method;
var Prices = StripeResource.extend({
  create: stripeMethod108({ method: "POST", fullPath: "/v1/prices" }),
  retrieve: stripeMethod108({ method: "GET", fullPath: "/v1/prices/{price}" }),
  update: stripeMethod108({ method: "POST", fullPath: "/v1/prices/{price}" }),
  list: stripeMethod108({
    method: "GET",
    fullPath: "/v1/prices",
    methodType: "list"
  }),
  search: stripeMethod108({
    method: "GET",
    fullPath: "/v1/prices/search",
    methodType: "search"
  })
});
// node_modules/stripe/esm/resources/Products.js
var stripeMethod109 = StripeResource.method;
var Products2 = StripeResource.extend({
  create: stripeMethod109({ method: "POST", fullPath: "/v1/products" }),
  retrieve: stripeMethod109({ method: "GET", fullPath: "/v1/products/{id}" }),
  update: stripeMethod109({ method: "POST", fullPath: "/v1/products/{id}" }),
  list: stripeMethod109({
    method: "GET",
    fullPath: "/v1/products",
    methodType: "list"
  }),
  del: stripeMethod109({ method: "DELETE", fullPath: "/v1/products/{id}" }),
  createFeature: stripeMethod109({
    method: "POST",
    fullPath: "/v1/products/{product}/features"
  }),
  deleteFeature: stripeMethod109({
    method: "DELETE",
    fullPath: "/v1/products/{product}/features/{id}"
  }),
  listFeatures: stripeMethod109({
    method: "GET",
    fullPath: "/v1/products/{product}/features",
    methodType: "list"
  }),
  retrieveFeature: stripeMethod109({
    method: "GET",
    fullPath: "/v1/products/{product}/features/{id}"
  }),
  search: stripeMethod109({
    method: "GET",
    fullPath: "/v1/products/search",
    methodType: "search"
  })
});
// node_modules/stripe/esm/resources/PromotionCodes.js
var stripeMethod110 = StripeResource.method;
var PromotionCodes = StripeResource.extend({
  create: stripeMethod110({ method: "POST", fullPath: "/v1/promotion_codes" }),
  retrieve: stripeMethod110({
    method: "GET",
    fullPath: "/v1/promotion_codes/{promotion_code}"
  }),
  update: stripeMethod110({
    method: "POST",
    fullPath: "/v1/promotion_codes/{promotion_code}"
  }),
  list: stripeMethod110({
    method: "GET",
    fullPath: "/v1/promotion_codes",
    methodType: "list"
  })
});
// node_modules/stripe/esm/resources/Quotes.js
var stripeMethod111 = StripeResource.method;
var Quotes = StripeResource.extend({
  create: stripeMethod111({ method: "POST", fullPath: "/v1/quotes" }),
  retrieve: stripeMethod111({ method: "GET", fullPath: "/v1/quotes/{quote}" }),
  update: stripeMethod111({ method: "POST", fullPath: "/v1/quotes/{quote}" }),
  list: stripeMethod111({
    method: "GET",
    fullPath: "/v1/quotes",
    methodType: "list"
  }),
  accept: stripeMethod111({ method: "POST", fullPath: "/v1/quotes/{quote}/accept" }),
  cancel: stripeMethod111({ method: "POST", fullPath: "/v1/quotes/{quote}/cancel" }),
  finalizeQuote: stripeMethod111({
    method: "POST",
    fullPath: "/v1/quotes/{quote}/finalize"
  }),
  listComputedUpfrontLineItems: stripeMethod111({
    method: "GET",
    fullPath: "/v1/quotes/{quote}/computed_upfront_line_items",
    methodType: "list"
  }),
  listLineItems: stripeMethod111({
    method: "GET",
    fullPath: "/v1/quotes/{quote}/line_items",
    methodType: "list"
  }),
  pdf: stripeMethod111({
    method: "GET",
    fullPath: "/v1/quotes/{quote}/pdf",
    host: "files.stripe.com",
    streaming: true
  })
});
// node_modules/stripe/esm/resources/Refunds.js
var stripeMethod112 = StripeResource.method;
var Refunds2 = StripeResource.extend({
  create: stripeMethod112({ method: "POST", fullPath: "/v1/refunds" }),
  retrieve: stripeMethod112({ method: "GET", fullPath: "/v1/refunds/{refund}" }),
  update: stripeMethod112({ method: "POST", fullPath: "/v1/refunds/{refund}" }),
  list: stripeMethod112({
    method: "GET",
    fullPath: "/v1/refunds",
    methodType: "list"
  }),
  cancel: stripeMethod112({
    method: "POST",
    fullPath: "/v1/refunds/{refund}/cancel"
  })
});
// node_modules/stripe/esm/resources/Reviews.js
var stripeMethod113 = StripeResource.method;
var Reviews = StripeResource.extend({
  retrieve: stripeMethod113({ method: "GET", fullPath: "/v1/reviews/{review}" }),
  list: stripeMethod113({
    method: "GET",
    fullPath: "/v1/reviews",
    methodType: "list"
  }),
  approve: stripeMethod113({
    method: "POST",
    fullPath: "/v1/reviews/{review}/approve"
  })
});
// node_modules/stripe/esm/resources/SetupAttempts.js
var stripeMethod114 = StripeResource.method;
var SetupAttempts = StripeResource.extend({
  list: stripeMethod114({
    method: "GET",
    fullPath: "/v1/setup_attempts",
    methodType: "list"
  })
});
// node_modules/stripe/esm/resources/SetupIntents.js
var stripeMethod115 = StripeResource.method;
var SetupIntents = StripeResource.extend({
  create: stripeMethod115({ method: "POST", fullPath: "/v1/setup_intents" }),
  retrieve: stripeMethod115({
    method: "GET",
    fullPath: "/v1/setup_intents/{intent}"
  }),
  update: stripeMethod115({
    method: "POST",
    fullPath: "/v1/setup_intents/{intent}"
  }),
  list: stripeMethod115({
    method: "GET",
    fullPath: "/v1/setup_intents",
    methodType: "list"
  }),
  cancel: stripeMethod115({
    method: "POST",
    fullPath: "/v1/setup_intents/{intent}/cancel"
  }),
  confirm: stripeMethod115({
    method: "POST",
    fullPath: "/v1/setup_intents/{intent}/confirm"
  }),
  verifyMicrodeposits: stripeMethod115({
    method: "POST",
    fullPath: "/v1/setup_intents/{intent}/verify_microdeposits"
  })
});
// node_modules/stripe/esm/resources/ShippingRates.js
var stripeMethod116 = StripeResource.method;
var ShippingRates = StripeResource.extend({
  create: stripeMethod116({ method: "POST", fullPath: "/v1/shipping_rates" }),
  retrieve: stripeMethod116({
    method: "GET",
    fullPath: "/v1/shipping_rates/{shipping_rate_token}"
  }),
  update: stripeMethod116({
    method: "POST",
    fullPath: "/v1/shipping_rates/{shipping_rate_token}"
  }),
  list: stripeMethod116({
    method: "GET",
    fullPath: "/v1/shipping_rates",
    methodType: "list"
  })
});
// node_modules/stripe/esm/resources/Sources.js
var stripeMethod117 = StripeResource.method;
var Sources = StripeResource.extend({
  create: stripeMethod117({ method: "POST", fullPath: "/v1/sources" }),
  retrieve: stripeMethod117({ method: "GET", fullPath: "/v1/sources/{source}" }),
  update: stripeMethod117({ method: "POST", fullPath: "/v1/sources/{source}" }),
  listSourceTransactions: stripeMethod117({
    method: "GET",
    fullPath: "/v1/sources/{source}/source_transactions",
    methodType: "list"
  }),
  verify: stripeMethod117({
    method: "POST",
    fullPath: "/v1/sources/{source}/verify"
  })
});
// node_modules/stripe/esm/resources/SubscriptionItems.js
var stripeMethod118 = StripeResource.method;
var SubscriptionItems = StripeResource.extend({
  create: stripeMethod118({ method: "POST", fullPath: "/v1/subscription_items" }),
  retrieve: stripeMethod118({
    method: "GET",
    fullPath: "/v1/subscription_items/{item}"
  }),
  update: stripeMethod118({
    method: "POST",
    fullPath: "/v1/subscription_items/{item}"
  }),
  list: stripeMethod118({
    method: "GET",
    fullPath: "/v1/subscription_items",
    methodType: "list"
  }),
  del: stripeMethod118({
    method: "DELETE",
    fullPath: "/v1/subscription_items/{item}"
  }),
  createUsageRecord: stripeMethod118({
    method: "POST",
    fullPath: "/v1/subscription_items/{subscription_item}/usage_records"
  }),
  listUsageRecordSummaries: stripeMethod118({
    method: "GET",
    fullPath: "/v1/subscription_items/{subscription_item}/usage_record_summaries",
    methodType: "list"
  })
});
// node_modules/stripe/esm/resources/SubscriptionSchedules.js
var stripeMethod119 = StripeResource.method;
var SubscriptionSchedules = StripeResource.extend({
  create: stripeMethod119({
    method: "POST",
    fullPath: "/v1/subscription_schedules"
  }),
  retrieve: stripeMethod119({
    method: "GET",
    fullPath: "/v1/subscription_schedules/{schedule}"
  }),
  update: stripeMethod119({
    method: "POST",
    fullPath: "/v1/subscription_schedules/{schedule}"
  }),
  list: stripeMethod119({
    method: "GET",
    fullPath: "/v1/subscription_schedules",
    methodType: "list"
  }),
  cancel: stripeMethod119({
    method: "POST",
    fullPath: "/v1/subscription_schedules/{schedule}/cancel"
  }),
  release: stripeMethod119({
    method: "POST",
    fullPath: "/v1/subscription_schedules/{schedule}/release"
  })
});
// node_modules/stripe/esm/resources/Subscriptions.js
var stripeMethod120 = StripeResource.method;
var Subscriptions = StripeResource.extend({
  create: stripeMethod120({ method: "POST", fullPath: "/v1/subscriptions" }),
  retrieve: stripeMethod120({
    method: "GET",
    fullPath: "/v1/subscriptions/{subscription_exposed_id}"
  }),
  update: stripeMethod120({
    method: "POST",
    fullPath: "/v1/subscriptions/{subscription_exposed_id}"
  }),
  list: stripeMethod120({
    method: "GET",
    fullPath: "/v1/subscriptions",
    methodType: "list"
  }),
  cancel: stripeMethod120({
    method: "DELETE",
    fullPath: "/v1/subscriptions/{subscription_exposed_id}"
  }),
  deleteDiscount: stripeMethod120({
    method: "DELETE",
    fullPath: "/v1/subscriptions/{subscription_exposed_id}/discount"
  }),
  resume: stripeMethod120({
    method: "POST",
    fullPath: "/v1/subscriptions/{subscription}/resume"
  }),
  search: stripeMethod120({
    method: "GET",
    fullPath: "/v1/subscriptions/search",
    methodType: "search"
  })
});
// node_modules/stripe/esm/resources/TaxCodes.js
var stripeMethod121 = StripeResource.method;
var TaxCodes = StripeResource.extend({
  retrieve: stripeMethod121({ method: "GET", fullPath: "/v1/tax_codes/{id}" }),
  list: stripeMethod121({
    method: "GET",
    fullPath: "/v1/tax_codes",
    methodType: "list"
  })
});
// node_modules/stripe/esm/resources/TaxIds.js
var stripeMethod122 = StripeResource.method;
var TaxIds = StripeResource.extend({
  create: stripeMethod122({ method: "POST", fullPath: "/v1/tax_ids" }),
  retrieve: stripeMethod122({ method: "GET", fullPath: "/v1/tax_ids/{id}" }),
  list: stripeMethod122({
    method: "GET",
    fullPath: "/v1/tax_ids",
    methodType: "list"
  }),
  del: stripeMethod122({ method: "DELETE", fullPath: "/v1/tax_ids/{id}" })
});
// node_modules/stripe/esm/resources/TaxRates.js
var stripeMethod123 = StripeResource.method;
var TaxRates = StripeResource.extend({
  create: stripeMethod123({ method: "POST", fullPath: "/v1/tax_rates" }),
  retrieve: stripeMethod123({ method: "GET", fullPath: "/v1/tax_rates/{tax_rate}" }),
  update: stripeMethod123({ method: "POST", fullPath: "/v1/tax_rates/{tax_rate}" }),
  list: stripeMethod123({
    method: "GET",
    fullPath: "/v1/tax_rates",
    methodType: "list"
  })
});
// node_modules/stripe/esm/resources/Tokens.js
var stripeMethod124 = StripeResource.method;
var Tokens2 = StripeResource.extend({
  create: stripeMethod124({ method: "POST", fullPath: "/v1/tokens" }),
  retrieve: stripeMethod124({ method: "GET", fullPath: "/v1/tokens/{token}" })
});
// node_modules/stripe/esm/resources/Topups.js
var stripeMethod125 = StripeResource.method;
var Topups = StripeResource.extend({
  create: stripeMethod125({ method: "POST", fullPath: "/v1/topups" }),
  retrieve: stripeMethod125({ method: "GET", fullPath: "/v1/topups/{topup}" }),
  update: stripeMethod125({ method: "POST", fullPath: "/v1/topups/{topup}" }),
  list: stripeMethod125({
    method: "GET",
    fullPath: "/v1/topups",
    methodType: "list"
  }),
  cancel: stripeMethod125({ method: "POST", fullPath: "/v1/topups/{topup}/cancel" })
});
// node_modules/stripe/esm/resources/Transfers.js
var stripeMethod126 = StripeResource.method;
var Transfers = StripeResource.extend({
  create: stripeMethod126({ method: "POST", fullPath: "/v1/transfers" }),
  retrieve: stripeMethod126({ method: "GET", fullPath: "/v1/transfers/{transfer}" }),
  update: stripeMethod126({ method: "POST", fullPath: "/v1/transfers/{transfer}" }),
  list: stripeMethod126({
    method: "GET",
    fullPath: "/v1/transfers",
    methodType: "list"
  }),
  createReversal: stripeMethod126({
    method: "POST",
    fullPath: "/v1/transfers/{id}/reversals"
  }),
  listReversals: stripeMethod126({
    method: "GET",
    fullPath: "/v1/transfers/{id}/reversals",
    methodType: "list"
  }),
  retrieveReversal: stripeMethod126({
    method: "GET",
    fullPath: "/v1/transfers/{transfer}/reversals/{id}"
  }),
  updateReversal: stripeMethod126({
    method: "POST",
    fullPath: "/v1/transfers/{transfer}/reversals/{id}"
  })
});
// node_modules/stripe/esm/resources/WebhookEndpoints.js
var stripeMethod127 = StripeResource.method;
var WebhookEndpoints = StripeResource.extend({
  create: stripeMethod127({ method: "POST", fullPath: "/v1/webhook_endpoints" }),
  retrieve: stripeMethod127({
    method: "GET",
    fullPath: "/v1/webhook_endpoints/{webhook_endpoint}"
  }),
  update: stripeMethod127({
    method: "POST",
    fullPath: "/v1/webhook_endpoints/{webhook_endpoint}"
  }),
  list: stripeMethod127({
    method: "GET",
    fullPath: "/v1/webhook_endpoints",
    methodType: "list"
  }),
  del: stripeMethod127({
    method: "DELETE",
    fullPath: "/v1/webhook_endpoints/{webhook_endpoint}"
  })
});

// node_modules/stripe/esm/resources.js
var Apps = resourceNamespace("apps", { Secrets });
var Billing = resourceNamespace("billing", {
  Alerts,
  CreditBalanceSummary,
  CreditBalanceTransactions,
  CreditGrants,
  MeterEventAdjustments,
  MeterEvents,
  Meters
});
var BillingPortal = resourceNamespace("billingPortal", {
  Configurations,
  Sessions
});
var Checkout = resourceNamespace("checkout", {
  Sessions: Sessions2
});
var Climate = resourceNamespace("climate", {
  Orders,
  Products,
  Suppliers
});
var Entitlements = resourceNamespace("entitlements", {
  ActiveEntitlements,
  Features
});
var FinancialConnections = resourceNamespace("financialConnections", {
  Accounts,
  Sessions: Sessions3,
  Transactions: Transactions2
});
var Forwarding = resourceNamespace("forwarding", {
  Requests
});
var Identity = resourceNamespace("identity", {
  VerificationReports,
  VerificationSessions
});
var Issuing = resourceNamespace("issuing", {
  Authorizations: Authorizations2,
  Cardholders,
  Cards: Cards2,
  Disputes,
  PersonalizationDesigns: PersonalizationDesigns2,
  PhysicalBundles,
  Tokens,
  Transactions: Transactions3
});
var Radar = resourceNamespace("radar", {
  EarlyFraudWarnings,
  ValueListItems,
  ValueLists
});
var Reporting = resourceNamespace("reporting", {
  ReportRuns,
  ReportTypes
});
var Sigma = resourceNamespace("sigma", {
  ScheduledQueryRuns
});
var Tax = resourceNamespace("tax", {
  Calculations,
  Registrations,
  Settings,
  Transactions: Transactions4
});
var Terminal = resourceNamespace("terminal", {
  Configurations: Configurations2,
  ConnectionTokens,
  Locations,
  Readers: Readers2
});
var TestHelpers = resourceNamespace("testHelpers", {
  ConfirmationTokens,
  Customers,
  Refunds,
  TestClocks,
  Issuing: resourceNamespace("issuing", {
    Authorizations,
    Cards,
    PersonalizationDesigns,
    Transactions
  }),
  Terminal: resourceNamespace("terminal", {
    Readers
  }),
  Treasury: resourceNamespace("treasury", {
    InboundTransfers,
    OutboundPayments,
    OutboundTransfers,
    ReceivedCredits,
    ReceivedDebits
  })
});
var Treasury = resourceNamespace("treasury", {
  CreditReversals,
  DebitReversals,
  FinancialAccounts,
  InboundTransfers: InboundTransfers2,
  OutboundPayments: OutboundPayments2,
  OutboundTransfers: OutboundTransfers2,
  ReceivedCredits: ReceivedCredits2,
  ReceivedDebits: ReceivedDebits2,
  TransactionEntries,
  Transactions: Transactions5
});
var V2 = resourceNamespace("v2", {
  Billing: resourceNamespace("billing", {
    MeterEventAdjustments: MeterEventAdjustments2,
    MeterEventSession,
    MeterEventStream,
    MeterEvents: MeterEvents2
  }),
  Core: resourceNamespace("core", {
    EventDestinations,
    Events
  })
});

// node_modules/stripe/esm/stripe.core.js
var DEFAULT_HOST = "api.stripe.com";
var DEFAULT_PORT = "443";
var DEFAULT_BASE_PATH = "/v1/";
var DEFAULT_API_VERSION = ApiVersion;
var DEFAULT_TIMEOUT = 80000;
var MAX_NETWORK_RETRY_DELAY_SEC = 5;
var INITIAL_NETWORK_RETRY_DELAY_SEC = 0.5;
var APP_INFO_PROPERTIES = ["name", "version", "url", "partner_id"];
var ALLOWED_CONFIG_PROPERTIES = [
  "authenticator",
  "apiVersion",
  "typescript",
  "maxNetworkRetries",
  "httpAgent",
  "httpClient",
  "timeout",
  "host",
  "port",
  "protocol",
  "telemetry",
  "appInfo",
  "stripeAccount",
  "stripeContext"
];
var defaultRequestSenderFactory = (stripe) => new RequestSender(stripe, StripeResource.MAX_BUFFERED_REQUEST_METRICS);
function createStripe(platformFunctions, requestSender = defaultRequestSenderFactory) {
  Stripe.PACKAGE_VERSION = "17.5.0";
  Stripe.USER_AGENT = Object.assign({ bindings_version: Stripe.PACKAGE_VERSION, lang: "node", publisher: "stripe", uname: null, typescript: false }, determineProcessUserAgentProperties());
  Stripe.StripeResource = StripeResource;
  Stripe.resources = exports_resources;
  Stripe.HttpClient = HttpClient;
  Stripe.HttpClientResponse = HttpClientResponse;
  Stripe.CryptoProvider = CryptoProvider;
  function createWebhooksDefault(fns = platformFunctions) {
    return createWebhooks(fns);
  }
  Stripe.webhooks = Object.assign(createWebhooksDefault, createWebhooks(platformFunctions));
  function Stripe(key, config3 = {}) {
    if (!(this instanceof Stripe)) {
      return new Stripe(key, config3);
    }
    const props = this._getPropsFromConfig(config3);
    this._platformFunctions = platformFunctions;
    Object.defineProperty(this, "_emitter", {
      value: this._platformFunctions.createEmitter(),
      enumerable: false,
      configurable: false,
      writable: false
    });
    this.VERSION = Stripe.PACKAGE_VERSION;
    this.on = this._emitter.on.bind(this._emitter);
    this.once = this._emitter.once.bind(this._emitter);
    this.off = this._emitter.removeListener.bind(this._emitter);
    const agent = props.httpAgent || null;
    this._api = {
      host: props.host || DEFAULT_HOST,
      port: props.port || DEFAULT_PORT,
      protocol: props.protocol || "https",
      basePath: DEFAULT_BASE_PATH,
      version: props.apiVersion || DEFAULT_API_VERSION,
      timeout: validateInteger("timeout", props.timeout, DEFAULT_TIMEOUT),
      maxNetworkRetries: validateInteger("maxNetworkRetries", props.maxNetworkRetries, 2),
      agent,
      httpClient: props.httpClient || (agent ? this._platformFunctions.createNodeHttpClient(agent) : this._platformFunctions.createDefaultHttpClient()),
      dev: false,
      stripeAccount: props.stripeAccount || null,
      stripeContext: props.stripeContext || null
    };
    const typescript = props.typescript || false;
    if (typescript !== Stripe.USER_AGENT.typescript) {
      Stripe.USER_AGENT.typescript = typescript;
    }
    if (props.appInfo) {
      this._setAppInfo(props.appInfo);
    }
    this._prepResources();
    this._setAuthenticator(key, props.authenticator);
    this.errors = exports_Error;
    this.webhooks = createWebhooksDefault();
    this._prevRequestMetrics = [];
    this._enableTelemetry = props.telemetry !== false;
    this._requestSender = requestSender(this);
    this.StripeResource = Stripe.StripeResource;
  }
  Stripe.errors = exports_Error;
  Stripe.createNodeHttpClient = platformFunctions.createNodeHttpClient;
  Stripe.createFetchHttpClient = platformFunctions.createFetchHttpClient;
  Stripe.createNodeCryptoProvider = platformFunctions.createNodeCryptoProvider;
  Stripe.createSubtleCryptoProvider = platformFunctions.createSubtleCryptoProvider;
  Stripe.prototype = {
    _appInfo: undefined,
    on: null,
    off: null,
    once: null,
    VERSION: null,
    StripeResource: null,
    webhooks: null,
    errors: null,
    _api: null,
    _prevRequestMetrics: null,
    _emitter: null,
    _enableTelemetry: null,
    _requestSender: null,
    _platformFunctions: null,
    rawRequest(method, path2, params, options) {
      return this._requestSender._rawRequest(method, path2, params, options);
    },
    _setAuthenticator(key, authenticator) {
      if (key && authenticator) {
        throw new Error("Can't specify both apiKey and authenticator");
      }
      if (!key && !authenticator) {
        throw new Error("Neither apiKey nor config.authenticator provided");
      }
      this._authenticator = key ? createApiKeyAuthenticator(key) : authenticator;
    },
    _setAppInfo(info) {
      if (info && typeof info !== "object") {
        throw new Error("AppInfo must be an object.");
      }
      if (info && !info.name) {
        throw new Error("AppInfo.name is required");
      }
      info = info || {};
      this._appInfo = APP_INFO_PROPERTIES.reduce((accum, prop) => {
        if (typeof info[prop] == "string") {
          accum = accum || {};
          accum[prop] = info[prop];
        }
        return accum;
      }, undefined);
    },
    _setApiField(key, value) {
      this._api[key] = value;
    },
    getApiField(key) {
      return this._api[key];
    },
    setClientId(clientId) {
      this._clientId = clientId;
    },
    getClientId() {
      return this._clientId;
    },
    getConstant: (c2) => {
      switch (c2) {
        case "DEFAULT_HOST":
          return DEFAULT_HOST;
        case "DEFAULT_PORT":
          return DEFAULT_PORT;
        case "DEFAULT_BASE_PATH":
          return DEFAULT_BASE_PATH;
        case "DEFAULT_API_VERSION":
          return DEFAULT_API_VERSION;
        case "DEFAULT_TIMEOUT":
          return DEFAULT_TIMEOUT;
        case "MAX_NETWORK_RETRY_DELAY_SEC":
          return MAX_NETWORK_RETRY_DELAY_SEC;
        case "INITIAL_NETWORK_RETRY_DELAY_SEC":
          return INITIAL_NETWORK_RETRY_DELAY_SEC;
      }
      return Stripe[c2];
    },
    getMaxNetworkRetries() {
      return this.getApiField("maxNetworkRetries");
    },
    _setApiNumberField(prop, n2, defaultVal) {
      const val = validateInteger(prop, n2, defaultVal);
      this._setApiField(prop, val);
    },
    getMaxNetworkRetryDelay() {
      return MAX_NETWORK_RETRY_DELAY_SEC;
    },
    getInitialNetworkRetryDelay() {
      return INITIAL_NETWORK_RETRY_DELAY_SEC;
    },
    getClientUserAgent(cb) {
      return this.getClientUserAgentSeeded(Stripe.USER_AGENT, cb);
    },
    getClientUserAgentSeeded(seed, cb) {
      this._platformFunctions.getUname().then((uname) => {
        var _a;
        const userAgent = {};
        for (const field in seed) {
          if (!Object.prototype.hasOwnProperty.call(seed, field)) {
            continue;
          }
          userAgent[field] = encodeURIComponent((_a = seed[field]) !== null && _a !== undefined ? _a : "null");
        }
        userAgent.uname = encodeURIComponent(uname || "UNKNOWN");
        const client = this.getApiField("httpClient");
        if (client) {
          userAgent.httplib = encodeURIComponent(client.getClientName());
        }
        if (this._appInfo) {
          userAgent.application = this._appInfo;
        }
        cb(JSON.stringify(userAgent));
      });
    },
    getAppInfoAsString() {
      if (!this._appInfo) {
        return "";
      }
      let formatted = this._appInfo.name;
      if (this._appInfo.version) {
        formatted += `/${this._appInfo.version}`;
      }
      if (this._appInfo.url) {
        formatted += ` (${this._appInfo.url})`;
      }
      return formatted;
    },
    getTelemetryEnabled() {
      return this._enableTelemetry;
    },
    _prepResources() {
      for (const name in exports_resources) {
        if (!Object.prototype.hasOwnProperty.call(exports_resources, name)) {
          continue;
        }
        this[pascalToCamelCase(name)] = new exports_resources[name](this);
      }
    },
    _getPropsFromConfig(config3) {
      if (!config3) {
        return {};
      }
      const isString = typeof config3 === "string";
      const isObject5 = config3 === Object(config3) && !Array.isArray(config3);
      if (!isObject5 && !isString) {
        throw new Error("Config must either be an object or a string");
      }
      if (isString) {
        return {
          apiVersion: config3
        };
      }
      const values = Object.keys(config3).filter((value) => !ALLOWED_CONFIG_PROPERTIES.includes(value));
      if (values.length > 0) {
        throw new Error(`Config object may only contain the following: ${ALLOWED_CONFIG_PROPERTIES.join(", ")}`);
      }
      return config3;
    },
    parseThinEvent(payload, header, secret, tolerance, cryptoProvider, receivedAt) {
      return this.webhooks.constructEvent(payload, header, secret, tolerance, cryptoProvider, receivedAt);
    }
  };
  return Stripe;
}

// node_modules/stripe/esm/stripe.esm.worker.js
var Stripe = createStripe(new WebPlatformFunctions);
var stripe_esm_worker_default = Stripe;

// src/routes/orderRouter.ts
var stripeClient = new stripe_esm_worker_default(Bun.env.STRIPE_SECRET_KEY, {
  apiVersion: "2024-12-18.acacia"
});
var orderRouter = new Elysia2({ prefix: "/orders" }).use(authPlugin).post("/", async ({ user, body }) => {
  console.log(body);
  console.log("loggin the body");
  const { orderItems, deliveryAddress, totalPrice } = body;
  const orderId = "order_" + nanoid();
  const paymentIntent = await stripeClient.paymentIntents.create({
    amount: totalPrice * 100,
    currency: "usd"
  });
  const order = await prisma.order.create({
    data: {
      user: {
        connect: {
          id: user.id
        }
      },
      id: orderId,
      deliveryAddress,
      deliveryStatus: "PENDING",
      totalPrice,
      paymentDetails: {
        amount: paymentIntent.amount
      },
      paymentIntentId: paymentIntent.id,
      paymentStatus: "PENDING"
    }
  });
  const __orderItems = await prisma.orderItem.createMany({
    data: orderItems.map((orderItem) => {
      return {
        orderId,
        productId: orderItem.productId,
        quantity: orderItem.quantity,
        price: orderItem.price
      };
    })
  });
  return {
    order,
    clientSecret: paymentIntent.client_secret
  };
}, {
  body: t2.Object({
    deliveryAddress: t2.String(),
    totalPrice: t2.Number(),
    orderItems: t2.Array(t2.Object({
      productId: t2.String(),
      quantity: t2.Number(),
      price: t2.Number()
    }))
  })
}).get("/orders", async ({ user }) => {
  const orders = await prisma.order.findMany({
    where: {
      userId: user.id
    }
  });
  return orders;
});
var orderRouter_default = orderRouter;

// src/routes/webhook.ts
var stripe = new stripe_esm_worker_default(Bun.env.STRIPE_SECRET_KEY, {});
var STRIPE_WEBHOOK_SECRET = Bun.env.STRIPE_WEBHOOK_SECRET;
var webhookRouter = new Elysia2({ prefix: "/webhook" }).onParse(async ({ request }) => {
  const arrayBuffer = await Bun.readableStreamToArrayBuffer(request.body);
  const rawBody = Buffer.from(arrayBuffer);
  return rawBody;
}).post("/", async ({ request, body }) => {
  const signature = request.headers.get("stripe-signature");
  console.log(STRIPE_WEBHOOK_SECRET, "webhook");
  if (!signature) {
    throw new Error("No signature provided");
  }
  let event;
  console.log({ signature });
  try {
    event = await stripe.webhooks.constructEventAsync(body, signature, STRIPE_WEBHOOK_SECRET);
  } catch (error4) {
    console.log("Webhook signature verification failed:", error4);
    throw new Error(`Webhook Error: `);
  }
  try {
    switch (event.type) {
      case "payment_intent.succeeded": {
        const paymentIntent = event.data.object;
        const booking = await prisma.order.findFirst({
          where: {
            paymentIntentId: paymentIntent.id
          }
        });
        if (!booking) {
          throw new Error(`No booking found for payment intent ${paymentIntent.id}`);
        }
        await prisma.order.update({
          where: {
            id: booking.id
          },
          data: {
            paymentStatus: "PAID"
          }
        });
        console.log(`Payment succeeded for booking ${booking.id}`);
        break;
      }
      case "payment_intent.payment_failed": {
        const paymentIntent = event.data.object;
        const booking = await prisma.order.findFirst({
          where: {
            paymentIntentId: paymentIntent.id
          }
        });
        if (!booking) {
          throw new Error(`No booking found for payment intent ${paymentIntent.id}`);
        }
        await prisma.order.update({
          where: {
            id: booking.id
          },
          data: {
            paymentStatus: "FAILED"
          }
        });
        console.log(`Payment failed for booking ${booking.id}`);
        break;
      }
      case "payment_intent.requires_action": {
        const paymentIntent = event.data.object;
        const booking = await prisma.order.findFirst({
          where: {
            paymentIntentId: paymentIntent.id
          }
        });
        if (booking) {
          await prisma.order.update({
            where: {
              id: booking.id
            },
            data: {
              paymentStatus: "PENDING"
            }
          });
        }
        break;
      }
      case "payment_intent.canceled": {
        const paymentIntent = event.data.object;
        const booking = await prisma.order.findFirst({
          where: {
            paymentIntentId: paymentIntent.id
          }
        });
        if (booking) {
          await prisma.order.update({
            where: {
              id: booking.id
            },
            data: {
              paymentStatus: "FAILED"
            }
          });
        }
        break;
      }
      default:
        console.log(`Unhandled event type: ${event.type}`);
    }
    return { received: true };
  } catch (err) {
    console.error("Error processing webhook:", err);
    throw new Error(`Webhook handler failed: ${err.message}`);
  }
});

// src/index.ts
var app = new Elysia2;
app.use(index_default());
app.use(logger()).use(index_default2({
  path: "/swagger"
})).get("/", () => {
  return "Main Route";
}).use(userRouter).use(webhookRouter).use(authRouter).use(productRouter).use(orderRouter_default).listen(3000);
